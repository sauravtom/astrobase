"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@neynar";
exports.ids = ["vendor-chunks/@neynar"];
exports.modules = {

/***/ "(ssr)/./node_modules/@neynar/react/dist/bundle.es.js":
/*!******************************************************!*\
  !*** ./node_modules/@neynar/react/dist/bundle.es.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CastCard: () => (/* binding */ Rs),\n/* harmony export */   MiniAppContext: () => (/* binding */ Xp),\n/* harmony export */   MiniAppProvider: () => (/* binding */ sy),\n/* harmony export */   NeynarAuthButton: () => (/* binding */ fm),\n/* harmony export */   NeynarAutoCompleteUser: () => (/* binding */ fy),\n/* harmony export */   NeynarCastCard: () => (/* binding */ _m),\n/* harmony export */   NeynarContextProvider: () => (/* binding */ oy),\n/* harmony export */   NeynarConversationList: () => (/* binding */ ay),\n/* harmony export */   NeynarFeedList: () => (/* binding */ uy),\n/* harmony export */   NeynarFrameCard: () => (/* binding */ ng),\n/* harmony export */   NeynarProfileCard: () => (/* binding */ cy),\n/* harmony export */   NeynarUserDropdown: () => (/* binding */ ly),\n/* harmony export */   SIWN_variant: () => (/* binding */ wr),\n/* harmony export */   Theme: () => (/* binding */ Sl),\n/* harmony export */   useLocalStorage: () => (/* binding */ _a),\n/* harmony export */   useMiniApp: () => (/* binding */ Qp),\n/* harmony export */   useNeynarContext: () => (/* binding */ lr)\n/* harmony export */ });\n/* harmony import */ var _pigment_css_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pigment-css/react */ \"(ssr)/./node_modules/@pigment-css/react/build/chunk-AFZBAV6Q.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hls.js */ \"(ssr)/./node_modules/hls.js/dist/hls.mjs\");\nvar Jl = Object.defineProperty;\nvar Xl = (t, e, r) => e in t ? Jl(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;\nvar br = (t, e, r) => Xl(t, typeof e != \"symbol\" ? e + \"\" : e, r);\n\n\n\nconst rr = {\n  vars: {\n    colors: {\n      primary: \"var(--colors-primary)\"\n    },\n    typography: {\n      fonts: {\n        base: \"var(--typography-fonts-base)\"\n      },\n      fontWeights: {\n        regular: \"var(--typography-fontWeights-regular)\",\n        bold: \"var(--typography-fontWeights-bold)\"\n      },\n      fontSizes: {\n        large: \"var(--typography-fontSizes-large)\",\n        medium: \"var(--typography-fontSizes-medium)\",\n        small: \"var(--typography-fontSizes-small)\"\n      }\n    },\n    palette: {\n      background: \"var(--palette-background)\",\n      border: \"var(--palette-border)\",\n      text: \"var(--palette-text)\",\n      textMuted: \"var(--palette-textMuted)\"\n    }\n  }\n};\nfunction Qo(t) {\n  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n}\nfunction ea(t) {\n  if (Object.prototype.hasOwnProperty.call(t, \"__esModule\")) return t;\n  var e = t.default;\n  if (typeof e == \"function\") {\n    var r = function n() {\n      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);\n    };\n    r.prototype = e.prototype;\n  } else r = {};\n  return Object.defineProperty(r, \"__esModule\", {\n    value: !0\n  }), Object.keys(t).forEach(function(n) {\n    var o = Object.getOwnPropertyDescriptor(t, n);\n    Object.defineProperty(r, n, o.get ? o : {\n      enumerable: !0,\n      get: function() {\n        return t[n];\n      }\n    });\n  }), r;\n}\nvar Vs = { exports: {} }, Qn = {};\n/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ca;\nfunction tf() {\n  if (Ca) return Qn;\n  Ca = 1;\n  var t = Symbol.for(\"react.transitional.element\"), e = Symbol.for(\"react.fragment\");\n  function r(n, o, i) {\n    var c = null;\n    if (i !== void 0 && (c = \"\" + i), o.key !== void 0 && (c = \"\" + o.key), \"key\" in o) {\n      i = {};\n      for (var f in o)\n        f !== \"key\" && (i[f] = o[f]);\n    } else i = o;\n    return o = i.ref, {\n      $$typeof: t,\n      type: n,\n      key: c,\n      ref: o !== void 0 ? o : null,\n      props: i\n    };\n  }\n  return Qn.Fragment = e, Qn.jsx = r, Qn.jsxs = r, Qn;\n}\nvar Sa;\nfunction rf() {\n  return Sa || (Sa = 1, Vs.exports = tf()), Vs.exports;\n}\nvar U = rf();\nlet ta = class extends Error {\n  constructor(r, n = {}) {\n    super(r, n.cause ? { cause: n.cause } : void 0);\n    br(this, \"name\", \"BaseError\");\n    br(this, \"cause\");\n    this.cause = n.cause;\n  }\n};\nclass nf extends ta {\n  constructor() {\n    super(\"Invalid domain manifest\");\n    br(this, \"name\", \"AddMiniApp.InvalidDomainManifest\");\n  }\n}\nlet sf = class extends ta {\n  constructor() {\n    super(\"Add frame rejected by user\");\n    br(this, \"name\", \"AddMiniApp.RejectedByUser\");\n  }\n};\nclass Hu extends ta {\n  constructor() {\n    super(\"Sign in rejected by user\");\n    br(this, \"name\", \"SignIn.RejectedByUser\");\n  }\n}\nconst Aa = [\n  \"wallet.getEthereumProvider\",\n  \"wallet.getSolanaProvider\",\n  \"actions.ready\",\n  \"actions.openUrl\",\n  \"actions.close\",\n  \"actions.setPrimaryButton\",\n  \"actions.addMiniApp\",\n  \"actions.signIn\",\n  \"actions.viewCast\",\n  \"actions.viewProfile\",\n  \"actions.composeCast\",\n  \"actions.viewToken\",\n  \"actions.sendToken\",\n  \"actions.swapToken\",\n  \"haptics.impactOccurred\",\n  \"haptics.notificationOccurred\",\n  \"haptics.selectionChanged\",\n  \"back\"\n];\nvar nt;\n(function(t) {\n  t.assertEqual = (o) => o;\n  function e(o) {\n  }\n  t.assertIs = e;\n  function r(o) {\n    throw new Error();\n  }\n  t.assertNever = r, t.arrayToEnum = (o) => {\n    const i = {};\n    for (const c of o)\n      i[c] = c;\n    return i;\n  }, t.getValidEnumValues = (o) => {\n    const i = t.objectKeys(o).filter((f) => typeof o[o[f]] != \"number\"), c = {};\n    for (const f of i)\n      c[f] = o[f];\n    return t.objectValues(c);\n  }, t.objectValues = (o) => t.objectKeys(o).map(function(i) {\n    return o[i];\n  }), t.objectKeys = typeof Object.keys == \"function\" ? (o) => Object.keys(o) : (o) => {\n    const i = [];\n    for (const c in o)\n      Object.prototype.hasOwnProperty.call(o, c) && i.push(c);\n    return i;\n  }, t.find = (o, i) => {\n    for (const c of o)\n      if (i(c))\n        return c;\n  }, t.isInteger = typeof Number.isInteger == \"function\" ? (o) => Number.isInteger(o) : (o) => typeof o == \"number\" && isFinite(o) && Math.floor(o) === o;\n  function n(o, i = \" | \") {\n    return o.map((c) => typeof c == \"string\" ? `'${c}'` : c).join(i);\n  }\n  t.joinValues = n, t.jsonStringifyReplacer = (o, i) => typeof i == \"bigint\" ? i.toString() : i;\n})(nt || (nt = {}));\nvar ko;\n(function(t) {\n  t.mergeShapes = (e, r) => ({\n    ...e,\n    ...r\n    // second overwrites first\n  });\n})(ko || (ko = {}));\nconst le = nt.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]), pr = (t) => {\n  switch (typeof t) {\n    case \"undefined\":\n      return le.undefined;\n    case \"string\":\n      return le.string;\n    case \"number\":\n      return isNaN(t) ? le.nan : le.number;\n    case \"boolean\":\n      return le.boolean;\n    case \"function\":\n      return le.function;\n    case \"bigint\":\n      return le.bigint;\n    case \"symbol\":\n      return le.symbol;\n    case \"object\":\n      return Array.isArray(t) ? le.array : t === null ? le.null : t.then && typeof t.then == \"function\" && t.catch && typeof t.catch == \"function\" ? le.promise : typeof Map < \"u\" && t instanceof Map ? le.map : typeof Set < \"u\" && t instanceof Set ? le.set : typeof Date < \"u\" && t instanceof Date ? le.date : le.object;\n    default:\n      return le.unknown;\n  }\n}, ne = nt.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\"\n]), of = (t) => JSON.stringify(t, null, 2).replace(/\"([^\"]+)\":/g, \"$1:\");\nclass Zt extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(e) {\n    super(), this.issues = [], this.addIssue = (n) => {\n      this.issues = [...this.issues, n];\n    }, this.addIssues = (n = []) => {\n      this.issues = [...this.issues, ...n];\n    };\n    const r = new.target.prototype;\n    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = \"ZodError\", this.issues = e;\n  }\n  format(e) {\n    const r = e || function(i) {\n      return i.message;\n    }, n = { _errors: [] }, o = (i) => {\n      for (const c of i.issues)\n        if (c.code === \"invalid_union\")\n          c.unionErrors.map(o);\n        else if (c.code === \"invalid_return_type\")\n          o(c.returnTypeError);\n        else if (c.code === \"invalid_arguments\")\n          o(c.argumentsError);\n        else if (c.path.length === 0)\n          n._errors.push(r(c));\n        else {\n          let f = n, v = 0;\n          for (; v < c.path.length; ) {\n            const x = c.path[v];\n            v === c.path.length - 1 ? (f[x] = f[x] || { _errors: [] }, f[x]._errors.push(r(c))) : f[x] = f[x] || { _errors: [] }, f = f[x], v++;\n          }\n        }\n    };\n    return o(this), n;\n  }\n  static assert(e) {\n    if (!(e instanceof Zt))\n      throw new Error(`Not a ZodError: ${e}`);\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, nt.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(e = (r) => r.message) {\n    const r = {}, n = [];\n    for (const o of this.issues)\n      o.path.length > 0 ? (r[o.path[0]] = r[o.path[0]] || [], r[o.path[0]].push(e(o))) : n.push(e(o));\n    return { formErrors: n, fieldErrors: r };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n}\nZt.create = (t) => new Zt(t);\nconst Rn = (t, e) => {\n  let r;\n  switch (t.code) {\n    case ne.invalid_type:\n      t.received === le.undefined ? r = \"Required\" : r = `Expected ${t.expected}, received ${t.received}`;\n      break;\n    case ne.invalid_literal:\n      r = `Invalid literal value, expected ${JSON.stringify(t.expected, nt.jsonStringifyReplacer)}`;\n      break;\n    case ne.unrecognized_keys:\n      r = `Unrecognized key(s) in object: ${nt.joinValues(t.keys, \", \")}`;\n      break;\n    case ne.invalid_union:\n      r = \"Invalid input\";\n      break;\n    case ne.invalid_union_discriminator:\n      r = `Invalid discriminator value. Expected ${nt.joinValues(t.options)}`;\n      break;\n    case ne.invalid_enum_value:\n      r = `Invalid enum value. Expected ${nt.joinValues(t.options)}, received '${t.received}'`;\n      break;\n    case ne.invalid_arguments:\n      r = \"Invalid function arguments\";\n      break;\n    case ne.invalid_return_type:\n      r = \"Invalid function return type\";\n      break;\n    case ne.invalid_date:\n      r = \"Invalid date\";\n      break;\n    case ne.invalid_string:\n      typeof t.validation == \"object\" ? \"includes\" in t.validation ? (r = `Invalid input: must include \"${t.validation.includes}\"`, typeof t.validation.position == \"number\" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : \"startsWith\" in t.validation ? r = `Invalid input: must start with \"${t.validation.startsWith}\"` : \"endsWith\" in t.validation ? r = `Invalid input: must end with \"${t.validation.endsWith}\"` : nt.assertNever(t.validation) : t.validation !== \"regex\" ? r = `Invalid ${t.validation}` : r = \"Invalid\";\n      break;\n    case ne.too_small:\n      t.type === \"array\" ? r = `Array must contain ${t.exact ? \"exactly\" : t.inclusive ? \"at least\" : \"more than\"} ${t.minimum} element(s)` : t.type === \"string\" ? r = `String must contain ${t.exact ? \"exactly\" : t.inclusive ? \"at least\" : \"over\"} ${t.minimum} character(s)` : t.type === \"number\" ? r = `Number must be ${t.exact ? \"exactly equal to \" : t.inclusive ? \"greater than or equal to \" : \"greater than \"}${t.minimum}` : t.type === \"date\" ? r = `Date must be ${t.exact ? \"exactly equal to \" : t.inclusive ? \"greater than or equal to \" : \"greater than \"}${new Date(Number(t.minimum))}` : r = \"Invalid input\";\n      break;\n    case ne.too_big:\n      t.type === \"array\" ? r = `Array must contain ${t.exact ? \"exactly\" : t.inclusive ? \"at most\" : \"less than\"} ${t.maximum} element(s)` : t.type === \"string\" ? r = `String must contain ${t.exact ? \"exactly\" : t.inclusive ? \"at most\" : \"under\"} ${t.maximum} character(s)` : t.type === \"number\" ? r = `Number must be ${t.exact ? \"exactly\" : t.inclusive ? \"less than or equal to\" : \"less than\"} ${t.maximum}` : t.type === \"bigint\" ? r = `BigInt must be ${t.exact ? \"exactly\" : t.inclusive ? \"less than or equal to\" : \"less than\"} ${t.maximum}` : t.type === \"date\" ? r = `Date must be ${t.exact ? \"exactly\" : t.inclusive ? \"smaller than or equal to\" : \"smaller than\"} ${new Date(Number(t.maximum))}` : r = \"Invalid input\";\n      break;\n    case ne.custom:\n      r = \"Invalid input\";\n      break;\n    case ne.invalid_intersection_types:\n      r = \"Intersection results could not be merged\";\n      break;\n    case ne.not_multiple_of:\n      r = `Number must be a multiple of ${t.multipleOf}`;\n      break;\n    case ne.not_finite:\n      r = \"Number must be finite\";\n      break;\n    default:\n      r = e.defaultError, nt.assertNever(t);\n  }\n  return { message: r };\n};\nlet Ku = Rn;\nfunction af(t) {\n  Ku = t;\n}\nfunction as() {\n  return Ku;\n}\nconst us = (t) => {\n  const { data: e, path: r, errorMaps: n, issueData: o } = t, i = [...r, ...o.path || []], c = {\n    ...o,\n    path: i\n  };\n  if (o.message !== void 0)\n    return {\n      ...o,\n      path: i,\n      message: o.message\n    };\n  let f = \"\";\n  const v = n.filter((x) => !!x).slice().reverse();\n  for (const x of v)\n    f = x(c, { data: e, defaultError: f }).message;\n  return {\n    ...o,\n    path: i,\n    message: f\n  };\n}, uf = [];\nfunction oe(t, e) {\n  const r = as(), n = us({\n    issueData: e,\n    data: t.data,\n    path: t.path,\n    errorMaps: [\n      t.common.contextualErrorMap,\n      // contextual error map is first priority\n      t.schemaErrorMap,\n      // then schema-bound map if available\n      r,\n      // then global override map\n      r === Rn ? void 0 : Rn\n      // then global default map\n    ].filter((o) => !!o)\n  });\n  t.common.issues.push(n);\n}\nclass Lt {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    this.value === \"valid\" && (this.value = \"dirty\");\n  }\n  abort() {\n    this.value !== \"aborted\" && (this.value = \"aborted\");\n  }\n  static mergeArray(e, r) {\n    const n = [];\n    for (const o of r) {\n      if (o.status === \"aborted\")\n        return Ae;\n      o.status === \"dirty\" && e.dirty(), n.push(o.value);\n    }\n    return { status: e.value, value: n };\n  }\n  static async mergeObjectAsync(e, r) {\n    const n = [];\n    for (const o of r) {\n      const i = await o.key, c = await o.value;\n      n.push({\n        key: i,\n        value: c\n      });\n    }\n    return Lt.mergeObjectSync(e, n);\n  }\n  static mergeObjectSync(e, r) {\n    const n = {};\n    for (const o of r) {\n      const { key: i, value: c } = o;\n      if (i.status === \"aborted\" || c.status === \"aborted\")\n        return Ae;\n      i.status === \"dirty\" && e.dirty(), c.status === \"dirty\" && e.dirty(), i.value !== \"__proto__\" && (typeof c.value < \"u\" || o.alwaysSet) && (n[i.value] = c.value);\n    }\n    return { status: e.value, value: n };\n  }\n}\nconst Ae = Object.freeze({\n  status: \"aborted\"\n}), Cn = (t) => ({ status: \"dirty\", value: t }), jt = (t) => ({ status: \"valid\", value: t }), Io = (t) => t.status === \"aborted\", Bo = (t) => t.status === \"dirty\", un = (t) => t.status === \"valid\", oi = (t) => typeof Promise < \"u\" && t instanceof Promise;\nfunction cs(t, e, r, n) {\n  if (typeof e == \"function\" ? t !== e || !0 : !e.has(t)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return e.get(t);\n}\nfunction Wu(t, e, r, n, o) {\n  if (typeof e == \"function\" ? t !== e || !0 : !e.has(t)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return e.set(t, r), r;\n}\nvar ve;\n(function(t) {\n  t.errToObj = (e) => typeof e == \"string\" ? { message: e } : e || {}, t.toString = (e) => typeof e == \"string\" ? e : e == null ? void 0 : e.message;\n})(ve || (ve = {}));\nvar ti, ri;\nclass sr {\n  constructor(e, r, n, o) {\n    this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = o;\n  }\n  get path() {\n    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;\n  }\n}\nconst ka = (t, e) => {\n  if (un(e))\n    return { success: !0, data: e.value };\n  if (!t.common.issues.length)\n    throw new Error(\"Validation failed but no issues detected.\");\n  return {\n    success: !1,\n    get error() {\n      if (this._error)\n        return this._error;\n      const r = new Zt(t.common.issues);\n      return this._error = r, this._error;\n    }\n  };\n};\nfunction Te(t) {\n  if (!t)\n    return {};\n  const { errorMap: e, invalid_type_error: r, required_error: n, description: o } = t;\n  if (e && (r || n))\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  return e ? { errorMap: e, description: o } : { errorMap: (c, f) => {\n    var v, x;\n    const { message: b } = t;\n    return c.code === \"invalid_enum_value\" ? { message: b ?? f.defaultError } : typeof f.data > \"u\" ? { message: (v = b ?? n) !== null && v !== void 0 ? v : f.defaultError } : c.code !== \"invalid_type\" ? { message: f.defaultError } : { message: (x = b ?? r) !== null && x !== void 0 ? x : f.defaultError };\n  }, description: o };\n}\nclass Je {\n  get description() {\n    return this._def.description;\n  }\n  _getType(e) {\n    return pr(e.data);\n  }\n  _getOrReturnCtx(e, r) {\n    return r || {\n      common: e.parent.common,\n      data: e.data,\n      parsedType: pr(e.data),\n      schemaErrorMap: this._def.errorMap,\n      path: e.path,\n      parent: e.parent\n    };\n  }\n  _processInputParams(e) {\n    return {\n      status: new Lt(),\n      ctx: {\n        common: e.parent.common,\n        data: e.data,\n        parsedType: pr(e.data),\n        schemaErrorMap: this._def.errorMap,\n        path: e.path,\n        parent: e.parent\n      }\n    };\n  }\n  _parseSync(e) {\n    const r = this._parse(e);\n    if (oi(r))\n      throw new Error(\"Synchronous parse encountered promise.\");\n    return r;\n  }\n  _parseAsync(e) {\n    const r = this._parse(e);\n    return Promise.resolve(r);\n  }\n  parse(e, r) {\n    const n = this.safeParse(e, r);\n    if (n.success)\n      return n.data;\n    throw n.error;\n  }\n  safeParse(e, r) {\n    var n;\n    const o = {\n      common: {\n        issues: [],\n        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,\n        contextualErrorMap: r == null ? void 0 : r.errorMap\n      },\n      path: (r == null ? void 0 : r.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: pr(e)\n    }, i = this._parseSync({ data: e, path: o.path, parent: o });\n    return ka(o, i);\n  }\n  \"~validate\"(e) {\n    var r, n;\n    const o = {\n      common: {\n        issues: [],\n        async: !!this[\"~standard\"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: pr(e)\n    };\n    if (!this[\"~standard\"].async)\n      try {\n        const i = this._parseSync({ data: e, path: [], parent: o });\n        return un(i) ? {\n          value: i.value\n        } : {\n          issues: o.common.issues\n        };\n      } catch (i) {\n        !((n = (r = i == null ? void 0 : i.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes(\"encountered\") && (this[\"~standard\"].async = !0), o.common = {\n          issues: [],\n          async: !0\n        };\n      }\n    return this._parseAsync({ data: e, path: [], parent: o }).then((i) => un(i) ? {\n      value: i.value\n    } : {\n      issues: o.common.issues\n    });\n  }\n  async parseAsync(e, r) {\n    const n = await this.safeParseAsync(e, r);\n    if (n.success)\n      return n.data;\n    throw n.error;\n  }\n  async safeParseAsync(e, r) {\n    const n = {\n      common: {\n        issues: [],\n        contextualErrorMap: r == null ? void 0 : r.errorMap,\n        async: !0\n      },\n      path: (r == null ? void 0 : r.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: pr(e)\n    }, o = this._parse({ data: e, path: n.path, parent: n }), i = await (oi(o) ? o : Promise.resolve(o));\n    return ka(n, i);\n  }\n  refine(e, r) {\n    const n = (o) => typeof r == \"string\" || typeof r > \"u\" ? { message: r } : typeof r == \"function\" ? r(o) : r;\n    return this._refinement((o, i) => {\n      const c = e(o), f = () => i.addIssue({\n        code: ne.custom,\n        ...n(o)\n      });\n      return typeof Promise < \"u\" && c instanceof Promise ? c.then((v) => v ? !0 : (f(), !1)) : c ? !0 : (f(), !1);\n    });\n  }\n  refinement(e, r) {\n    return this._refinement((n, o) => e(n) ? !0 : (o.addIssue(typeof r == \"function\" ? r(n, o) : r), !1));\n  }\n  _refinement(e) {\n    return new Yt({\n      schema: this,\n      typeName: Ce.ZodEffects,\n      effect: { type: \"refinement\", refinement: e }\n    });\n  }\n  superRefine(e) {\n    return this._refinement(e);\n  }\n  constructor(e) {\n    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this[\"~standard\"] = {\n      version: 1,\n      vendor: \"zod\",\n      validate: (r) => this[\"~validate\"](r)\n    };\n  }\n  optional() {\n    return ir.create(this, this._def);\n  }\n  nullable() {\n    return jr.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return Gt.create(this);\n  }\n  promise() {\n    return Ln.create(this, this._def);\n  }\n  or(e) {\n    return li.create([this, e], this._def);\n  }\n  and(e) {\n    return fi.create(this, e, this._def);\n  }\n  transform(e) {\n    return new Yt({\n      ...Te(this._def),\n      schema: this,\n      typeName: Ce.ZodEffects,\n      effect: { type: \"transform\", transform: e }\n    });\n  }\n  default(e) {\n    const r = typeof e == \"function\" ? e : () => e;\n    return new gi({\n      ...Te(this._def),\n      innerType: this,\n      defaultValue: r,\n      typeName: Ce.ZodDefault\n    });\n  }\n  brand() {\n    return new ra({\n      typeName: Ce.ZodBranded,\n      type: this,\n      ...Te(this._def)\n    });\n  }\n  catch(e) {\n    const r = typeof e == \"function\" ? e : () => e;\n    return new yi({\n      ...Te(this._def),\n      innerType: this,\n      catchValue: r,\n      typeName: Ce.ZodCatch\n    });\n  }\n  describe(e) {\n    const r = this.constructor;\n    return new r({\n      ...this._def,\n      description: e\n    });\n  }\n  pipe(e) {\n    return ji.create(this, e);\n  }\n  readonly() {\n    return vi.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n}\nconst cf = /^c[^\\s-]{8,}$/i, lf = /^[0-9a-z]+$/, ff = /^[0-9A-HJKMNP-TV-Z]{26}$/i, hf = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i, df = /^[a-z0-9_-]{21}$/i, pf = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/, mf = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/, gf = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i, yf = \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\";\nlet Hs;\nconst vf = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, wf = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/, xf = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, bf = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, _f = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Ef = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Gu = \"((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))\", Mf = new RegExp(`^${Gu}$`);\nfunction Yu(t) {\n  let e = \"([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d\";\n  return t.precision ? e = `${e}\\\\.\\\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\\\.\\\\d+)?`), e;\n}\nfunction Cf(t) {\n  return new RegExp(`^${Yu(t)}$`);\n}\nfunction Ju(t) {\n  let e = `${Gu}T${Yu(t)}`;\n  const r = [];\n  return r.push(t.local ? \"Z?\" : \"Z\"), t.offset && r.push(\"([+-]\\\\d{2}:?\\\\d{2})\"), e = `${e}(${r.join(\"|\")})`, new RegExp(`^${e}$`);\n}\nfunction Sf(t, e) {\n  return !!((e === \"v4\" || !e) && vf.test(t) || (e === \"v6\" || !e) && xf.test(t));\n}\nfunction Af(t, e) {\n  if (!pf.test(t))\n    return !1;\n  try {\n    const [r] = t.split(\".\"), n = r.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(r.length + (4 - r.length % 4) % 4, \"=\"), o = JSON.parse(atob(n));\n    return !(typeof o != \"object\" || o === null || !o.typ || !o.alg || e && o.alg !== e);\n  } catch {\n    return !1;\n  }\n}\nfunction kf(t, e) {\n  return !!((e === \"v4\" || !e) && wf.test(t) || (e === \"v6\" || !e) && bf.test(t));\n}\nclass Wt extends Je {\n  _parse(e) {\n    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== le.string) {\n      const i = this._getOrReturnCtx(e);\n      return oe(i, {\n        code: ne.invalid_type,\n        expected: le.string,\n        received: i.parsedType\n      }), Ae;\n    }\n    const n = new Lt();\n    let o;\n    for (const i of this._def.checks)\n      if (i.kind === \"min\")\n        e.data.length < i.value && (o = this._getOrReturnCtx(e, o), oe(o, {\n          code: ne.too_small,\n          minimum: i.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !1,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"max\")\n        e.data.length > i.value && (o = this._getOrReturnCtx(e, o), oe(o, {\n          code: ne.too_big,\n          maximum: i.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !1,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"length\") {\n        const c = e.data.length > i.value, f = e.data.length < i.value;\n        (c || f) && (o = this._getOrReturnCtx(e, o), c ? oe(o, {\n          code: ne.too_big,\n          maximum: i.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !0,\n          message: i.message\n        }) : f && oe(o, {\n          code: ne.too_small,\n          minimum: i.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !0,\n          message: i.message\n        }), n.dirty());\n      } else if (i.kind === \"email\")\n        gf.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n          validation: \"email\",\n          code: ne.invalid_string,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"emoji\")\n        Hs || (Hs = new RegExp(yf, \"u\")), Hs.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n          validation: \"emoji\",\n          code: ne.invalid_string,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"uuid\")\n        hf.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n          validation: \"uuid\",\n          code: ne.invalid_string,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"nanoid\")\n        df.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n          validation: \"nanoid\",\n          code: ne.invalid_string,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"cuid\")\n        cf.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n          validation: \"cuid\",\n          code: ne.invalid_string,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"cuid2\")\n        lf.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n          validation: \"cuid2\",\n          code: ne.invalid_string,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"ulid\")\n        ff.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n          validation: \"ulid\",\n          code: ne.invalid_string,\n          message: i.message\n        }), n.dirty());\n      else if (i.kind === \"url\")\n        try {\n          new URL(e.data);\n        } catch {\n          o = this._getOrReturnCtx(e, o), oe(o, {\n            validation: \"url\",\n            code: ne.invalid_string,\n            message: i.message\n          }), n.dirty();\n        }\n      else i.kind === \"regex\" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        validation: \"regex\",\n        code: ne.invalid_string,\n        message: i.message\n      }), n.dirty())) : i.kind === \"trim\" ? e.data = e.data.trim() : i.kind === \"includes\" ? e.data.includes(i.value, i.position) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        code: ne.invalid_string,\n        validation: { includes: i.value, position: i.position },\n        message: i.message\n      }), n.dirty()) : i.kind === \"toLowerCase\" ? e.data = e.data.toLowerCase() : i.kind === \"toUpperCase\" ? e.data = e.data.toUpperCase() : i.kind === \"startsWith\" ? e.data.startsWith(i.value) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        code: ne.invalid_string,\n        validation: { startsWith: i.value },\n        message: i.message\n      }), n.dirty()) : i.kind === \"endsWith\" ? e.data.endsWith(i.value) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        code: ne.invalid_string,\n        validation: { endsWith: i.value },\n        message: i.message\n      }), n.dirty()) : i.kind === \"datetime\" ? Ju(i).test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        code: ne.invalid_string,\n        validation: \"datetime\",\n        message: i.message\n      }), n.dirty()) : i.kind === \"date\" ? Mf.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        code: ne.invalid_string,\n        validation: \"date\",\n        message: i.message\n      }), n.dirty()) : i.kind === \"time\" ? Cf(i).test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        code: ne.invalid_string,\n        validation: \"time\",\n        message: i.message\n      }), n.dirty()) : i.kind === \"duration\" ? mf.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        validation: \"duration\",\n        code: ne.invalid_string,\n        message: i.message\n      }), n.dirty()) : i.kind === \"ip\" ? Sf(e.data, i.version) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        validation: \"ip\",\n        code: ne.invalid_string,\n        message: i.message\n      }), n.dirty()) : i.kind === \"jwt\" ? Af(e.data, i.alg) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        validation: \"jwt\",\n        code: ne.invalid_string,\n        message: i.message\n      }), n.dirty()) : i.kind === \"cidr\" ? kf(e.data, i.version) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        validation: \"cidr\",\n        code: ne.invalid_string,\n        message: i.message\n      }), n.dirty()) : i.kind === \"base64\" ? _f.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        validation: \"base64\",\n        code: ne.invalid_string,\n        message: i.message\n      }), n.dirty()) : i.kind === \"base64url\" ? Ef.test(e.data) || (o = this._getOrReturnCtx(e, o), oe(o, {\n        validation: \"base64url\",\n        code: ne.invalid_string,\n        message: i.message\n      }), n.dirty()) : nt.assertNever(i);\n    return { status: n.value, value: e.data };\n  }\n  _regex(e, r, n) {\n    return this.refinement((o) => e.test(o), {\n      validation: r,\n      code: ne.invalid_string,\n      ...ve.errToObj(n)\n    });\n  }\n  _addCheck(e) {\n    return new Wt({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  email(e) {\n    return this._addCheck({ kind: \"email\", ...ve.errToObj(e) });\n  }\n  url(e) {\n    return this._addCheck({ kind: \"url\", ...ve.errToObj(e) });\n  }\n  emoji(e) {\n    return this._addCheck({ kind: \"emoji\", ...ve.errToObj(e) });\n  }\n  uuid(e) {\n    return this._addCheck({ kind: \"uuid\", ...ve.errToObj(e) });\n  }\n  nanoid(e) {\n    return this._addCheck({ kind: \"nanoid\", ...ve.errToObj(e) });\n  }\n  cuid(e) {\n    return this._addCheck({ kind: \"cuid\", ...ve.errToObj(e) });\n  }\n  cuid2(e) {\n    return this._addCheck({ kind: \"cuid2\", ...ve.errToObj(e) });\n  }\n  ulid(e) {\n    return this._addCheck({ kind: \"ulid\", ...ve.errToObj(e) });\n  }\n  base64(e) {\n    return this._addCheck({ kind: \"base64\", ...ve.errToObj(e) });\n  }\n  base64url(e) {\n    return this._addCheck({\n      kind: \"base64url\",\n      ...ve.errToObj(e)\n    });\n  }\n  jwt(e) {\n    return this._addCheck({ kind: \"jwt\", ...ve.errToObj(e) });\n  }\n  ip(e) {\n    return this._addCheck({ kind: \"ip\", ...ve.errToObj(e) });\n  }\n  cidr(e) {\n    return this._addCheck({ kind: \"cidr\", ...ve.errToObj(e) });\n  }\n  datetime(e) {\n    var r, n;\n    return typeof e == \"string\" ? this._addCheck({\n      kind: \"datetime\",\n      precision: null,\n      offset: !1,\n      local: !1,\n      message: e\n    }) : this._addCheck({\n      kind: \"datetime\",\n      precision: typeof (e == null ? void 0 : e.precision) > \"u\" ? null : e == null ? void 0 : e.precision,\n      offset: (r = e == null ? void 0 : e.offset) !== null && r !== void 0 ? r : !1,\n      local: (n = e == null ? void 0 : e.local) !== null && n !== void 0 ? n : !1,\n      ...ve.errToObj(e == null ? void 0 : e.message)\n    });\n  }\n  date(e) {\n    return this._addCheck({ kind: \"date\", message: e });\n  }\n  time(e) {\n    return typeof e == \"string\" ? this._addCheck({\n      kind: \"time\",\n      precision: null,\n      message: e\n    }) : this._addCheck({\n      kind: \"time\",\n      precision: typeof (e == null ? void 0 : e.precision) > \"u\" ? null : e == null ? void 0 : e.precision,\n      ...ve.errToObj(e == null ? void 0 : e.message)\n    });\n  }\n  duration(e) {\n    return this._addCheck({ kind: \"duration\", ...ve.errToObj(e) });\n  }\n  regex(e, r) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex: e,\n      ...ve.errToObj(r)\n    });\n  }\n  includes(e, r) {\n    return this._addCheck({\n      kind: \"includes\",\n      value: e,\n      position: r == null ? void 0 : r.position,\n      ...ve.errToObj(r == null ? void 0 : r.message)\n    });\n  }\n  startsWith(e, r) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value: e,\n      ...ve.errToObj(r)\n    });\n  }\n  endsWith(e, r) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value: e,\n      ...ve.errToObj(r)\n    });\n  }\n  min(e, r) {\n    return this._addCheck({\n      kind: \"min\",\n      value: e,\n      ...ve.errToObj(r)\n    });\n  }\n  max(e, r) {\n    return this._addCheck({\n      kind: \"max\",\n      value: e,\n      ...ve.errToObj(r)\n    });\n  }\n  length(e, r) {\n    return this._addCheck({\n      kind: \"length\",\n      value: e,\n      ...ve.errToObj(r)\n    });\n  }\n  /**\n   * Equivalent to `.min(1)`\n   */\n  nonempty(e) {\n    return this.min(1, ve.errToObj(e));\n  }\n  trim() {\n    return new Wt({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  toLowerCase() {\n    return new Wt({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n    });\n  }\n  toUpperCase() {\n    return new Wt({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((e) => e.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find((e) => e.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find((e) => e.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((e) => e.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((e) => e.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((e) => e.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((e) => e.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((e) => e.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((e) => e.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((e) => e.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((e) => e.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((e) => e.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((e) => e.kind === \"ip\");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((e) => e.kind === \"cidr\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((e) => e.kind === \"base64\");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find((e) => e.kind === \"base64url\");\n  }\n  get minLength() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"min\" && (e === null || r.value > e) && (e = r.value);\n    return e;\n  }\n  get maxLength() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"max\" && (e === null || r.value < e) && (e = r.value);\n    return e;\n  }\n}\nWt.create = (t) => {\n  var e;\n  return new Wt({\n    checks: [],\n    typeName: Ce.ZodString,\n    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,\n    ...Te(t)\n  });\n};\nfunction If(t, e) {\n  const r = (t.toString().split(\".\")[1] || \"\").length, n = (e.toString().split(\".\")[1] || \"\").length, o = r > n ? r : n, i = parseInt(t.toFixed(o).replace(\".\", \"\")), c = parseInt(e.toFixed(o).replace(\".\", \"\"));\n  return i % c / Math.pow(10, o);\n}\nclass Lr extends Je {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;\n  }\n  _parse(e) {\n    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== le.number) {\n      const i = this._getOrReturnCtx(e);\n      return oe(i, {\n        code: ne.invalid_type,\n        expected: le.number,\n        received: i.parsedType\n      }), Ae;\n    }\n    let n;\n    const o = new Lt();\n    for (const i of this._def.checks)\n      i.kind === \"int\" ? nt.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), oe(n, {\n        code: ne.invalid_type,\n        expected: \"integer\",\n        received: \"float\",\n        message: i.message\n      }), o.dirty()) : i.kind === \"min\" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), oe(n, {\n        code: ne.too_small,\n        minimum: i.value,\n        type: \"number\",\n        inclusive: i.inclusive,\n        exact: !1,\n        message: i.message\n      }), o.dirty()) : i.kind === \"max\" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), oe(n, {\n        code: ne.too_big,\n        maximum: i.value,\n        type: \"number\",\n        inclusive: i.inclusive,\n        exact: !1,\n        message: i.message\n      }), o.dirty()) : i.kind === \"multipleOf\" ? If(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n), oe(n, {\n        code: ne.not_multiple_of,\n        multipleOf: i.value,\n        message: i.message\n      }), o.dirty()) : i.kind === \"finite\" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), oe(n, {\n        code: ne.not_finite,\n        message: i.message\n      }), o.dirty()) : nt.assertNever(i);\n    return { status: o.value, value: e.data };\n  }\n  gte(e, r) {\n    return this.setLimit(\"min\", e, !0, ve.toString(r));\n  }\n  gt(e, r) {\n    return this.setLimit(\"min\", e, !1, ve.toString(r));\n  }\n  lte(e, r) {\n    return this.setLimit(\"max\", e, !0, ve.toString(r));\n  }\n  lt(e, r) {\n    return this.setLimit(\"max\", e, !1, ve.toString(r));\n  }\n  setLimit(e, r, n, o) {\n    return new Lr({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind: e,\n          value: r,\n          inclusive: n,\n          message: ve.toString(o)\n        }\n      ]\n    });\n  }\n  _addCheck(e) {\n    return new Lr({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  int(e) {\n    return this._addCheck({\n      kind: \"int\",\n      message: ve.toString(e)\n    });\n  }\n  positive(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: !1,\n      message: ve.toString(e)\n    });\n  }\n  negative(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: !1,\n      message: ve.toString(e)\n    });\n  }\n  nonpositive(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: !0,\n      message: ve.toString(e)\n    });\n  }\n  nonnegative(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: !0,\n      message: ve.toString(e)\n    });\n  }\n  multipleOf(e, r) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: e,\n      message: ve.toString(r)\n    });\n  }\n  finite(e) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: ve.toString(e)\n    });\n  }\n  safe(e) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: !0,\n      value: Number.MIN_SAFE_INTEGER,\n      message: ve.toString(e)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: !0,\n      value: Number.MAX_SAFE_INTEGER,\n      message: ve.toString(e)\n    });\n  }\n  get minValue() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"min\" && (e === null || r.value > e) && (e = r.value);\n    return e;\n  }\n  get maxValue() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"max\" && (e === null || r.value < e) && (e = r.value);\n    return e;\n  }\n  get isInt() {\n    return !!this._def.checks.find((e) => e.kind === \"int\" || e.kind === \"multipleOf\" && nt.isInteger(e.value));\n  }\n  get isFinite() {\n    let e = null, r = null;\n    for (const n of this._def.checks) {\n      if (n.kind === \"finite\" || n.kind === \"int\" || n.kind === \"multipleOf\")\n        return !0;\n      n.kind === \"min\" ? (r === null || n.value > r) && (r = n.value) : n.kind === \"max\" && (e === null || n.value < e) && (e = n.value);\n    }\n    return Number.isFinite(r) && Number.isFinite(e);\n  }\n}\nLr.create = (t) => new Lr({\n  checks: [],\n  typeName: Ce.ZodNumber,\n  coerce: (t == null ? void 0 : t.coerce) || !1,\n  ...Te(t)\n});\nclass Or extends Je {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte;\n  }\n  _parse(e) {\n    if (this._def.coerce)\n      try {\n        e.data = BigInt(e.data);\n      } catch {\n        return this._getInvalidInput(e);\n      }\n    if (this._getType(e) !== le.bigint)\n      return this._getInvalidInput(e);\n    let n;\n    const o = new Lt();\n    for (const i of this._def.checks)\n      i.kind === \"min\" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), oe(n, {\n        code: ne.too_small,\n        type: \"bigint\",\n        minimum: i.value,\n        inclusive: i.inclusive,\n        message: i.message\n      }), o.dirty()) : i.kind === \"max\" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), oe(n, {\n        code: ne.too_big,\n        type: \"bigint\",\n        maximum: i.value,\n        inclusive: i.inclusive,\n        message: i.message\n      }), o.dirty()) : i.kind === \"multipleOf\" ? e.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), oe(n, {\n        code: ne.not_multiple_of,\n        multipleOf: i.value,\n        message: i.message\n      }), o.dirty()) : nt.assertNever(i);\n    return { status: o.value, value: e.data };\n  }\n  _getInvalidInput(e) {\n    const r = this._getOrReturnCtx(e);\n    return oe(r, {\n      code: ne.invalid_type,\n      expected: le.bigint,\n      received: r.parsedType\n    }), Ae;\n  }\n  gte(e, r) {\n    return this.setLimit(\"min\", e, !0, ve.toString(r));\n  }\n  gt(e, r) {\n    return this.setLimit(\"min\", e, !1, ve.toString(r));\n  }\n  lte(e, r) {\n    return this.setLimit(\"max\", e, !0, ve.toString(r));\n  }\n  lt(e, r) {\n    return this.setLimit(\"max\", e, !1, ve.toString(r));\n  }\n  setLimit(e, r, n, o) {\n    return new Or({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind: e,\n          value: r,\n          inclusive: n,\n          message: ve.toString(o)\n        }\n      ]\n    });\n  }\n  _addCheck(e) {\n    return new Or({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  positive(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: !1,\n      message: ve.toString(e)\n    });\n  }\n  negative(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: !1,\n      message: ve.toString(e)\n    });\n  }\n  nonpositive(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: !0,\n      message: ve.toString(e)\n    });\n  }\n  nonnegative(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: !0,\n      message: ve.toString(e)\n    });\n  }\n  multipleOf(e, r) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: e,\n      message: ve.toString(r)\n    });\n  }\n  get minValue() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"min\" && (e === null || r.value > e) && (e = r.value);\n    return e;\n  }\n  get maxValue() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"max\" && (e === null || r.value < e) && (e = r.value);\n    return e;\n  }\n}\nOr.create = (t) => {\n  var e;\n  return new Or({\n    checks: [],\n    typeName: Ce.ZodBigInt,\n    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,\n    ...Te(t)\n  });\n};\nclass ai extends Je {\n  _parse(e) {\n    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== le.boolean) {\n      const n = this._getOrReturnCtx(e);\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.boolean,\n        received: n.parsedType\n      }), Ae;\n    }\n    return jt(e.data);\n  }\n}\nai.create = (t) => new ai({\n  typeName: Ce.ZodBoolean,\n  coerce: (t == null ? void 0 : t.coerce) || !1,\n  ...Te(t)\n});\nclass cn extends Je {\n  _parse(e) {\n    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== le.date) {\n      const i = this._getOrReturnCtx(e);\n      return oe(i, {\n        code: ne.invalid_type,\n        expected: le.date,\n        received: i.parsedType\n      }), Ae;\n    }\n    if (isNaN(e.data.getTime())) {\n      const i = this._getOrReturnCtx(e);\n      return oe(i, {\n        code: ne.invalid_date\n      }), Ae;\n    }\n    const n = new Lt();\n    let o;\n    for (const i of this._def.checks)\n      i.kind === \"min\" ? e.data.getTime() < i.value && (o = this._getOrReturnCtx(e, o), oe(o, {\n        code: ne.too_small,\n        message: i.message,\n        inclusive: !0,\n        exact: !1,\n        minimum: i.value,\n        type: \"date\"\n      }), n.dirty()) : i.kind === \"max\" ? e.data.getTime() > i.value && (o = this._getOrReturnCtx(e, o), oe(o, {\n        code: ne.too_big,\n        message: i.message,\n        inclusive: !0,\n        exact: !1,\n        maximum: i.value,\n        type: \"date\"\n      }), n.dirty()) : nt.assertNever(i);\n    return {\n      status: n.value,\n      value: new Date(e.data.getTime())\n    };\n  }\n  _addCheck(e) {\n    return new cn({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  min(e, r) {\n    return this._addCheck({\n      kind: \"min\",\n      value: e.getTime(),\n      message: ve.toString(r)\n    });\n  }\n  max(e, r) {\n    return this._addCheck({\n      kind: \"max\",\n      value: e.getTime(),\n      message: ve.toString(r)\n    });\n  }\n  get minDate() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"min\" && (e === null || r.value > e) && (e = r.value);\n    return e != null ? new Date(e) : null;\n  }\n  get maxDate() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"max\" && (e === null || r.value < e) && (e = r.value);\n    return e != null ? new Date(e) : null;\n  }\n}\ncn.create = (t) => new cn({\n  checks: [],\n  coerce: (t == null ? void 0 : t.coerce) || !1,\n  typeName: Ce.ZodDate,\n  ...Te(t)\n});\nclass ls extends Je {\n  _parse(e) {\n    if (this._getType(e) !== le.symbol) {\n      const n = this._getOrReturnCtx(e);\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.symbol,\n        received: n.parsedType\n      }), Ae;\n    }\n    return jt(e.data);\n  }\n}\nls.create = (t) => new ls({\n  typeName: Ce.ZodSymbol,\n  ...Te(t)\n});\nclass ui extends Je {\n  _parse(e) {\n    if (this._getType(e) !== le.undefined) {\n      const n = this._getOrReturnCtx(e);\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.undefined,\n        received: n.parsedType\n      }), Ae;\n    }\n    return jt(e.data);\n  }\n}\nui.create = (t) => new ui({\n  typeName: Ce.ZodUndefined,\n  ...Te(t)\n});\nclass ci extends Je {\n  _parse(e) {\n    if (this._getType(e) !== le.null) {\n      const n = this._getOrReturnCtx(e);\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.null,\n        received: n.parsedType\n      }), Ae;\n    }\n    return jt(e.data);\n  }\n}\nci.create = (t) => new ci({\n  typeName: Ce.ZodNull,\n  ...Te(t)\n});\nclass Tn extends Je {\n  constructor() {\n    super(...arguments), this._any = !0;\n  }\n  _parse(e) {\n    return jt(e.data);\n  }\n}\nTn.create = (t) => new Tn({\n  typeName: Ce.ZodAny,\n  ...Te(t)\n});\nclass an extends Je {\n  constructor() {\n    super(...arguments), this._unknown = !0;\n  }\n  _parse(e) {\n    return jt(e.data);\n  }\n}\nan.create = (t) => new an({\n  typeName: Ce.ZodUnknown,\n  ...Te(t)\n});\nclass xr extends Je {\n  _parse(e) {\n    const r = this._getOrReturnCtx(e);\n    return oe(r, {\n      code: ne.invalid_type,\n      expected: le.never,\n      received: r.parsedType\n    }), Ae;\n  }\n}\nxr.create = (t) => new xr({\n  typeName: Ce.ZodNever,\n  ...Te(t)\n});\nclass fs extends Je {\n  _parse(e) {\n    if (this._getType(e) !== le.undefined) {\n      const n = this._getOrReturnCtx(e);\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.void,\n        received: n.parsedType\n      }), Ae;\n    }\n    return jt(e.data);\n  }\n}\nfs.create = (t) => new fs({\n  typeName: Ce.ZodVoid,\n  ...Te(t)\n});\nclass Gt extends Je {\n  _parse(e) {\n    const { ctx: r, status: n } = this._processInputParams(e), o = this._def;\n    if (r.parsedType !== le.array)\n      return oe(r, {\n        code: ne.invalid_type,\n        expected: le.array,\n        received: r.parsedType\n      }), Ae;\n    if (o.exactLength !== null) {\n      const c = r.data.length > o.exactLength.value, f = r.data.length < o.exactLength.value;\n      (c || f) && (oe(r, {\n        code: c ? ne.too_big : ne.too_small,\n        minimum: f ? o.exactLength.value : void 0,\n        maximum: c ? o.exactLength.value : void 0,\n        type: \"array\",\n        inclusive: !0,\n        exact: !0,\n        message: o.exactLength.message\n      }), n.dirty());\n    }\n    if (o.minLength !== null && r.data.length < o.minLength.value && (oe(r, {\n      code: ne.too_small,\n      minimum: o.minLength.value,\n      type: \"array\",\n      inclusive: !0,\n      exact: !1,\n      message: o.minLength.message\n    }), n.dirty()), o.maxLength !== null && r.data.length > o.maxLength.value && (oe(r, {\n      code: ne.too_big,\n      maximum: o.maxLength.value,\n      type: \"array\",\n      inclusive: !0,\n      exact: !1,\n      message: o.maxLength.message\n    }), n.dirty()), r.common.async)\n      return Promise.all([...r.data].map((c, f) => o.type._parseAsync(new sr(r, c, r.path, f)))).then((c) => Lt.mergeArray(n, c));\n    const i = [...r.data].map((c, f) => o.type._parseSync(new sr(r, c, r.path, f)));\n    return Lt.mergeArray(n, i);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(e, r) {\n    return new Gt({\n      ...this._def,\n      minLength: { value: e, message: ve.toString(r) }\n    });\n  }\n  max(e, r) {\n    return new Gt({\n      ...this._def,\n      maxLength: { value: e, message: ve.toString(r) }\n    });\n  }\n  length(e, r) {\n    return new Gt({\n      ...this._def,\n      exactLength: { value: e, message: ve.toString(r) }\n    });\n  }\n  nonempty(e) {\n    return this.min(1, e);\n  }\n}\nGt.create = (t, e) => new Gt({\n  type: t,\n  minLength: null,\n  maxLength: null,\n  exactLength: null,\n  typeName: Ce.ZodArray,\n  ...Te(e)\n});\nfunction En(t) {\n  if (t instanceof ht) {\n    const e = {};\n    for (const r in t.shape) {\n      const n = t.shape[r];\n      e[r] = ir.create(En(n));\n    }\n    return new ht({\n      ...t._def,\n      shape: () => e\n    });\n  } else return t instanceof Gt ? new Gt({\n    ...t._def,\n    type: En(t.element)\n  }) : t instanceof ir ? ir.create(En(t.unwrap())) : t instanceof jr ? jr.create(En(t.unwrap())) : t instanceof or ? or.create(t.items.map((e) => En(e))) : t;\n}\nclass ht extends Je {\n  constructor() {\n    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const e = this._def.shape(), r = nt.objectKeys(e);\n    return this._cached = { shape: e, keys: r };\n  }\n  _parse(e) {\n    if (this._getType(e) !== le.object) {\n      const x = this._getOrReturnCtx(e);\n      return oe(x, {\n        code: ne.invalid_type,\n        expected: le.object,\n        received: x.parsedType\n      }), Ae;\n    }\n    const { status: n, ctx: o } = this._processInputParams(e), { shape: i, keys: c } = this._getCached(), f = [];\n    if (!(this._def.catchall instanceof xr && this._def.unknownKeys === \"strip\"))\n      for (const x in o.data)\n        c.includes(x) || f.push(x);\n    const v = [];\n    for (const x of c) {\n      const b = i[x], S = o.data[x];\n      v.push({\n        key: { status: \"valid\", value: x },\n        value: b._parse(new sr(o, S, o.path, x)),\n        alwaysSet: x in o.data\n      });\n    }\n    if (this._def.catchall instanceof xr) {\n      const x = this._def.unknownKeys;\n      if (x === \"passthrough\")\n        for (const b of f)\n          v.push({\n            key: { status: \"valid\", value: b },\n            value: { status: \"valid\", value: o.data[b] }\n          });\n      else if (x === \"strict\")\n        f.length > 0 && (oe(o, {\n          code: ne.unrecognized_keys,\n          keys: f\n        }), n.dirty());\n      else if (x !== \"strip\") throw new Error(\"Internal ZodObject error: invalid unknownKeys value.\");\n    } else {\n      const x = this._def.catchall;\n      for (const b of f) {\n        const S = o.data[b];\n        v.push({\n          key: { status: \"valid\", value: b },\n          value: x._parse(\n            new sr(o, S, o.path, b)\n            //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: b in o.data\n        });\n      }\n    }\n    return o.common.async ? Promise.resolve().then(async () => {\n      const x = [];\n      for (const b of v) {\n        const S = await b.key, T = await b.value;\n        x.push({\n          key: S,\n          value: T,\n          alwaysSet: b.alwaysSet\n        });\n      }\n      return x;\n    }).then((x) => Lt.mergeObjectSync(n, x)) : Lt.mergeObjectSync(n, v);\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(e) {\n    return ve.errToObj, new ht({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...e !== void 0 ? {\n        errorMap: (r, n) => {\n          var o, i, c, f;\n          const v = (c = (i = (o = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(o, r, n).message) !== null && c !== void 0 ? c : n.defaultError;\n          return r.code === \"unrecognized_keys\" ? {\n            message: (f = ve.errToObj(e).message) !== null && f !== void 0 ? f : v\n          } : {\n            message: v\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new ht({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new ht({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(e) {\n    return new ht({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...e\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(e) {\n    return new ht({\n      unknownKeys: e._def.unknownKeys,\n      catchall: e._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...e._def.shape()\n      }),\n      typeName: Ce.ZodObject\n    });\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(e, r) {\n    return this.augment({ [e]: r });\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(e) {\n    return new ht({\n      ...this._def,\n      catchall: e\n    });\n  }\n  pick(e) {\n    const r = {};\n    return nt.objectKeys(e).forEach((n) => {\n      e[n] && this.shape[n] && (r[n] = this.shape[n]);\n    }), new ht({\n      ...this._def,\n      shape: () => r\n    });\n  }\n  omit(e) {\n    const r = {};\n    return nt.objectKeys(this.shape).forEach((n) => {\n      e[n] || (r[n] = this.shape[n]);\n    }), new ht({\n      ...this._def,\n      shape: () => r\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return En(this);\n  }\n  partial(e) {\n    const r = {};\n    return nt.objectKeys(this.shape).forEach((n) => {\n      const o = this.shape[n];\n      e && !e[n] ? r[n] = o : r[n] = o.optional();\n    }), new ht({\n      ...this._def,\n      shape: () => r\n    });\n  }\n  required(e) {\n    const r = {};\n    return nt.objectKeys(this.shape).forEach((n) => {\n      if (e && !e[n])\n        r[n] = this.shape[n];\n      else {\n        let i = this.shape[n];\n        for (; i instanceof ir; )\n          i = i._def.innerType;\n        r[n] = i;\n      }\n    }), new ht({\n      ...this._def,\n      shape: () => r\n    });\n  }\n  keyof() {\n    return Xu(nt.objectKeys(this.shape));\n  }\n}\nht.create = (t, e) => new ht({\n  shape: () => t,\n  unknownKeys: \"strip\",\n  catchall: xr.create(),\n  typeName: Ce.ZodObject,\n  ...Te(e)\n});\nht.strictCreate = (t, e) => new ht({\n  shape: () => t,\n  unknownKeys: \"strict\",\n  catchall: xr.create(),\n  typeName: Ce.ZodObject,\n  ...Te(e)\n});\nht.lazycreate = (t, e) => new ht({\n  shape: t,\n  unknownKeys: \"strip\",\n  catchall: xr.create(),\n  typeName: Ce.ZodObject,\n  ...Te(e)\n});\nclass li extends Je {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e), n = this._def.options;\n    function o(i) {\n      for (const f of i)\n        if (f.result.status === \"valid\")\n          return f.result;\n      for (const f of i)\n        if (f.result.status === \"dirty\")\n          return r.common.issues.push(...f.ctx.common.issues), f.result;\n      const c = i.map((f) => new Zt(f.ctx.common.issues));\n      return oe(r, {\n        code: ne.invalid_union,\n        unionErrors: c\n      }), Ae;\n    }\n    if (r.common.async)\n      return Promise.all(n.map(async (i) => {\n        const c = {\n          ...r,\n          common: {\n            ...r.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await i._parseAsync({\n            data: r.data,\n            path: r.path,\n            parent: c\n          }),\n          ctx: c\n        };\n      })).then(o);\n    {\n      let i;\n      const c = [];\n      for (const v of n) {\n        const x = {\n          ...r,\n          common: {\n            ...r.common,\n            issues: []\n          },\n          parent: null\n        }, b = v._parseSync({\n          data: r.data,\n          path: r.path,\n          parent: x\n        });\n        if (b.status === \"valid\")\n          return b;\n        b.status === \"dirty\" && !i && (i = { result: b, ctx: x }), x.common.issues.length && c.push(x.common.issues);\n      }\n      if (i)\n        return r.common.issues.push(...i.ctx.common.issues), i.result;\n      const f = c.map((v) => new Zt(v));\n      return oe(r, {\n        code: ne.invalid_union,\n        unionErrors: f\n      }), Ae;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n}\nli.create = (t, e) => new li({\n  options: t,\n  typeName: Ce.ZodUnion,\n  ...Te(e)\n});\nconst dr = (t) => t instanceof di ? dr(t.schema) : t instanceof Yt ? dr(t.innerType()) : t instanceof pi ? [t.value] : t instanceof Nr ? t.options : t instanceof mi ? nt.objectValues(t.enum) : t instanceof gi ? dr(t._def.innerType) : t instanceof ui ? [void 0] : t instanceof ci ? [null] : t instanceof ir ? [void 0, ...dr(t.unwrap())] : t instanceof jr ? [null, ...dr(t.unwrap())] : t instanceof ra || t instanceof vi ? dr(t.unwrap()) : t instanceof yi ? dr(t._def.innerType) : [];\nclass Ts extends Je {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== le.object)\n      return oe(r, {\n        code: ne.invalid_type,\n        expected: le.object,\n        received: r.parsedType\n      }), Ae;\n    const n = this.discriminator, o = r.data[n], i = this.optionsMap.get(o);\n    return i ? r.common.async ? i._parseAsync({\n      data: r.data,\n      path: r.path,\n      parent: r\n    }) : i._parseSync({\n      data: r.data,\n      path: r.path,\n      parent: r\n    }) : (oe(r, {\n      code: ne.invalid_union_discriminator,\n      options: Array.from(this.optionsMap.keys()),\n      path: [n]\n    }), Ae);\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(e, r, n) {\n    const o = /* @__PURE__ */ new Map();\n    for (const i of r) {\n      const c = dr(i.shape[e]);\n      if (!c.length)\n        throw new Error(`A discriminator value for key \\`${e}\\` could not be extracted from all schema options`);\n      for (const f of c) {\n        if (o.has(f))\n          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(f)}`);\n        o.set(f, i);\n      }\n    }\n    return new Ts({\n      typeName: Ce.ZodDiscriminatedUnion,\n      discriminator: e,\n      options: r,\n      optionsMap: o,\n      ...Te(n)\n    });\n  }\n}\nfunction Ro(t, e) {\n  const r = pr(t), n = pr(e);\n  if (t === e)\n    return { valid: !0, data: t };\n  if (r === le.object && n === le.object) {\n    const o = nt.objectKeys(e), i = nt.objectKeys(t).filter((f) => o.indexOf(f) !== -1), c = { ...t, ...e };\n    for (const f of i) {\n      const v = Ro(t[f], e[f]);\n      if (!v.valid)\n        return { valid: !1 };\n      c[f] = v.data;\n    }\n    return { valid: !0, data: c };\n  } else if (r === le.array && n === le.array) {\n    if (t.length !== e.length)\n      return { valid: !1 };\n    const o = [];\n    for (let i = 0; i < t.length; i++) {\n      const c = t[i], f = e[i], v = Ro(c, f);\n      if (!v.valid)\n        return { valid: !1 };\n      o.push(v.data);\n    }\n    return { valid: !0, data: o };\n  } else return r === le.date && n === le.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };\n}\nclass fi extends Je {\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e), o = (i, c) => {\n      if (Io(i) || Io(c))\n        return Ae;\n      const f = Ro(i.value, c.value);\n      return f.valid ? ((Bo(i) || Bo(c)) && r.dirty(), { status: r.value, value: f.data }) : (oe(n, {\n        code: ne.invalid_intersection_types\n      }), Ae);\n    };\n    return n.common.async ? Promise.all([\n      this._def.left._parseAsync({\n        data: n.data,\n        path: n.path,\n        parent: n\n      }),\n      this._def.right._parseAsync({\n        data: n.data,\n        path: n.path,\n        parent: n\n      })\n    ]).then(([i, c]) => o(i, c)) : o(this._def.left._parseSync({\n      data: n.data,\n      path: n.path,\n      parent: n\n    }), this._def.right._parseSync({\n      data: n.data,\n      path: n.path,\n      parent: n\n    }));\n  }\n}\nfi.create = (t, e, r) => new fi({\n  left: t,\n  right: e,\n  typeName: Ce.ZodIntersection,\n  ...Te(r)\n});\nclass or extends Je {\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== le.array)\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.array,\n        received: n.parsedType\n      }), Ae;\n    if (n.data.length < this._def.items.length)\n      return oe(n, {\n        code: ne.too_small,\n        minimum: this._def.items.length,\n        inclusive: !0,\n        exact: !1,\n        type: \"array\"\n      }), Ae;\n    !this._def.rest && n.data.length > this._def.items.length && (oe(n, {\n      code: ne.too_big,\n      maximum: this._def.items.length,\n      inclusive: !0,\n      exact: !1,\n      type: \"array\"\n    }), r.dirty());\n    const i = [...n.data].map((c, f) => {\n      const v = this._def.items[f] || this._def.rest;\n      return v ? v._parse(new sr(n, c, n.path, f)) : null;\n    }).filter((c) => !!c);\n    return n.common.async ? Promise.all(i).then((c) => Lt.mergeArray(r, c)) : Lt.mergeArray(r, i);\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(e) {\n    return new or({\n      ...this._def,\n      rest: e\n    });\n  }\n}\nor.create = (t, e) => {\n  if (!Array.isArray(t))\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  return new or({\n    items: t,\n    typeName: Ce.ZodTuple,\n    rest: null,\n    ...Te(e)\n  });\n};\nclass hi extends Je {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== le.object)\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.object,\n        received: n.parsedType\n      }), Ae;\n    const o = [], i = this._def.keyType, c = this._def.valueType;\n    for (const f in n.data)\n      o.push({\n        key: i._parse(new sr(n, f, n.path, f)),\n        value: c._parse(new sr(n, n.data[f], n.path, f)),\n        alwaysSet: f in n.data\n      });\n    return n.common.async ? Lt.mergeObjectAsync(r, o) : Lt.mergeObjectSync(r, o);\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(e, r, n) {\n    return r instanceof Je ? new hi({\n      keyType: e,\n      valueType: r,\n      typeName: Ce.ZodRecord,\n      ...Te(n)\n    }) : new hi({\n      keyType: Wt.create(),\n      valueType: e,\n      typeName: Ce.ZodRecord,\n      ...Te(r)\n    });\n  }\n}\nclass hs extends Je {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== le.map)\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.map,\n        received: n.parsedType\n      }), Ae;\n    const o = this._def.keyType, i = this._def.valueType, c = [...n.data.entries()].map(([f, v], x) => ({\n      key: o._parse(new sr(n, f, n.path, [x, \"key\"])),\n      value: i._parse(new sr(n, v, n.path, [x, \"value\"]))\n    }));\n    if (n.common.async) {\n      const f = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const v of c) {\n          const x = await v.key, b = await v.value;\n          if (x.status === \"aborted\" || b.status === \"aborted\")\n            return Ae;\n          (x.status === \"dirty\" || b.status === \"dirty\") && r.dirty(), f.set(x.value, b.value);\n        }\n        return { status: r.value, value: f };\n      });\n    } else {\n      const f = /* @__PURE__ */ new Map();\n      for (const v of c) {\n        const x = v.key, b = v.value;\n        if (x.status === \"aborted\" || b.status === \"aborted\")\n          return Ae;\n        (x.status === \"dirty\" || b.status === \"dirty\") && r.dirty(), f.set(x.value, b.value);\n      }\n      return { status: r.value, value: f };\n    }\n  }\n}\nhs.create = (t, e, r) => new hs({\n  valueType: e,\n  keyType: t,\n  typeName: Ce.ZodMap,\n  ...Te(r)\n});\nclass ln extends Je {\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== le.set)\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.set,\n        received: n.parsedType\n      }), Ae;\n    const o = this._def;\n    o.minSize !== null && n.data.size < o.minSize.value && (oe(n, {\n      code: ne.too_small,\n      minimum: o.minSize.value,\n      type: \"set\",\n      inclusive: !0,\n      exact: !1,\n      message: o.minSize.message\n    }), r.dirty()), o.maxSize !== null && n.data.size > o.maxSize.value && (oe(n, {\n      code: ne.too_big,\n      maximum: o.maxSize.value,\n      type: \"set\",\n      inclusive: !0,\n      exact: !1,\n      message: o.maxSize.message\n    }), r.dirty());\n    const i = this._def.valueType;\n    function c(v) {\n      const x = /* @__PURE__ */ new Set();\n      for (const b of v) {\n        if (b.status === \"aborted\")\n          return Ae;\n        b.status === \"dirty\" && r.dirty(), x.add(b.value);\n      }\n      return { status: r.value, value: x };\n    }\n    const f = [...n.data.values()].map((v, x) => i._parse(new sr(n, v, n.path, x)));\n    return n.common.async ? Promise.all(f).then((v) => c(v)) : c(f);\n  }\n  min(e, r) {\n    return new ln({\n      ...this._def,\n      minSize: { value: e, message: ve.toString(r) }\n    });\n  }\n  max(e, r) {\n    return new ln({\n      ...this._def,\n      maxSize: { value: e, message: ve.toString(r) }\n    });\n  }\n  size(e, r) {\n    return this.min(e, r).max(e, r);\n  }\n  nonempty(e) {\n    return this.min(1, e);\n  }\n}\nln.create = (t, e) => new ln({\n  valueType: t,\n  minSize: null,\n  maxSize: null,\n  typeName: Ce.ZodSet,\n  ...Te(e)\n});\nclass kn extends Je {\n  constructor() {\n    super(...arguments), this.validate = this.implement;\n  }\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== le.function)\n      return oe(r, {\n        code: ne.invalid_type,\n        expected: le.function,\n        received: r.parsedType\n      }), Ae;\n    function n(f, v) {\n      return us({\n        data: f,\n        path: r.path,\n        errorMaps: [\n          r.common.contextualErrorMap,\n          r.schemaErrorMap,\n          as(),\n          Rn\n        ].filter((x) => !!x),\n        issueData: {\n          code: ne.invalid_arguments,\n          argumentsError: v\n        }\n      });\n    }\n    function o(f, v) {\n      return us({\n        data: f,\n        path: r.path,\n        errorMaps: [\n          r.common.contextualErrorMap,\n          r.schemaErrorMap,\n          as(),\n          Rn\n        ].filter((x) => !!x),\n        issueData: {\n          code: ne.invalid_return_type,\n          returnTypeError: v\n        }\n      });\n    }\n    const i = { errorMap: r.common.contextualErrorMap }, c = r.data;\n    if (this._def.returns instanceof Ln) {\n      const f = this;\n      return jt(async function(...v) {\n        const x = new Zt([]), b = await f._def.args.parseAsync(v, i).catch((C) => {\n          throw x.addIssue(n(v, C)), x;\n        }), S = await Reflect.apply(c, this, b);\n        return await f._def.returns._def.type.parseAsync(S, i).catch((C) => {\n          throw x.addIssue(o(S, C)), x;\n        });\n      });\n    } else {\n      const f = this;\n      return jt(function(...v) {\n        const x = f._def.args.safeParse(v, i);\n        if (!x.success)\n          throw new Zt([n(v, x.error)]);\n        const b = Reflect.apply(c, this, x.data), S = f._def.returns.safeParse(b, i);\n        if (!S.success)\n          throw new Zt([o(b, S.error)]);\n        return S.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...e) {\n    return new kn({\n      ...this._def,\n      args: or.create(e).rest(an.create())\n    });\n  }\n  returns(e) {\n    return new kn({\n      ...this._def,\n      returns: e\n    });\n  }\n  implement(e) {\n    return this.parse(e);\n  }\n  strictImplement(e) {\n    return this.parse(e);\n  }\n  static create(e, r, n) {\n    return new kn({\n      args: e || or.create([]).rest(an.create()),\n      returns: r || an.create(),\n      typeName: Ce.ZodFunction,\n      ...Te(n)\n    });\n  }\n}\nclass di extends Je {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });\n  }\n}\ndi.create = (t, e) => new di({\n  getter: t,\n  typeName: Ce.ZodLazy,\n  ...Te(e)\n});\nclass pi extends Je {\n  _parse(e) {\n    if (e.data !== this._def.value) {\n      const r = this._getOrReturnCtx(e);\n      return oe(r, {\n        received: r.data,\n        code: ne.invalid_literal,\n        expected: this._def.value\n      }), Ae;\n    }\n    return { status: \"valid\", value: e.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n}\npi.create = (t, e) => new pi({\n  value: t,\n  typeName: Ce.ZodLiteral,\n  ...Te(e)\n});\nfunction Xu(t, e) {\n  return new Nr({\n    values: t,\n    typeName: Ce.ZodEnum,\n    ...Te(e)\n  });\n}\nclass Nr extends Je {\n  constructor() {\n    super(...arguments), ti.set(this, void 0);\n  }\n  _parse(e) {\n    if (typeof e.data != \"string\") {\n      const r = this._getOrReturnCtx(e), n = this._def.values;\n      return oe(r, {\n        expected: nt.joinValues(n),\n        received: r.parsedType,\n        code: ne.invalid_type\n      }), Ae;\n    }\n    if (cs(this, ti) || Wu(this, ti, new Set(this._def.values)), !cs(this, ti).has(e.data)) {\n      const r = this._getOrReturnCtx(e), n = this._def.values;\n      return oe(r, {\n        received: r.data,\n        code: ne.invalid_enum_value,\n        options: n\n      }), Ae;\n    }\n    return jt(e.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const e = {};\n    for (const r of this._def.values)\n      e[r] = r;\n    return e;\n  }\n  get Values() {\n    const e = {};\n    for (const r of this._def.values)\n      e[r] = r;\n    return e;\n  }\n  get Enum() {\n    const e = {};\n    for (const r of this._def.values)\n      e[r] = r;\n    return e;\n  }\n  extract(e, r = this._def) {\n    return Nr.create(e, {\n      ...this._def,\n      ...r\n    });\n  }\n  exclude(e, r = this._def) {\n    return Nr.create(this.options.filter((n) => !e.includes(n)), {\n      ...this._def,\n      ...r\n    });\n  }\n}\nti = /* @__PURE__ */ new WeakMap();\nNr.create = Xu;\nclass mi extends Je {\n  constructor() {\n    super(...arguments), ri.set(this, void 0);\n  }\n  _parse(e) {\n    const r = nt.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);\n    if (n.parsedType !== le.string && n.parsedType !== le.number) {\n      const o = nt.objectValues(r);\n      return oe(n, {\n        expected: nt.joinValues(o),\n        received: n.parsedType,\n        code: ne.invalid_type\n      }), Ae;\n    }\n    if (cs(this, ri) || Wu(this, ri, new Set(nt.getValidEnumValues(this._def.values))), !cs(this, ri).has(e.data)) {\n      const o = nt.objectValues(r);\n      return oe(n, {\n        received: n.data,\n        code: ne.invalid_enum_value,\n        options: o\n      }), Ae;\n    }\n    return jt(e.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n}\nri = /* @__PURE__ */ new WeakMap();\nmi.create = (t, e) => new mi({\n  values: t,\n  typeName: Ce.ZodNativeEnum,\n  ...Te(e)\n});\nclass Ln extends Je {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== le.promise && r.common.async === !1)\n      return oe(r, {\n        code: ne.invalid_type,\n        expected: le.promise,\n        received: r.parsedType\n      }), Ae;\n    const n = r.parsedType === le.promise ? r.data : Promise.resolve(r.data);\n    return jt(n.then((o) => this._def.type.parseAsync(o, {\n      path: r.path,\n      errorMap: r.common.contextualErrorMap\n    })));\n  }\n}\nLn.create = (t, e) => new Ln({\n  type: t,\n  typeName: Ce.ZodPromise,\n  ...Te(e)\n});\nclass Yt extends Je {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === Ce.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e), o = this._def.effect || null, i = {\n      addIssue: (c) => {\n        oe(n, c), c.fatal ? r.abort() : r.dirty();\n      },\n      get path() {\n        return n.path;\n      }\n    };\n    if (i.addIssue = i.addIssue.bind(i), o.type === \"preprocess\") {\n      const c = o.transform(n.data, i);\n      if (n.common.async)\n        return Promise.resolve(c).then(async (f) => {\n          if (r.value === \"aborted\")\n            return Ae;\n          const v = await this._def.schema._parseAsync({\n            data: f,\n            path: n.path,\n            parent: n\n          });\n          return v.status === \"aborted\" ? Ae : v.status === \"dirty\" || r.value === \"dirty\" ? Cn(v.value) : v;\n        });\n      {\n        if (r.value === \"aborted\")\n          return Ae;\n        const f = this._def.schema._parseSync({\n          data: c,\n          path: n.path,\n          parent: n\n        });\n        return f.status === \"aborted\" ? Ae : f.status === \"dirty\" || r.value === \"dirty\" ? Cn(f.value) : f;\n      }\n    }\n    if (o.type === \"refinement\") {\n      const c = (f) => {\n        const v = o.refinement(f, i);\n        if (n.common.async)\n          return Promise.resolve(v);\n        if (v instanceof Promise)\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return f;\n      };\n      if (n.common.async === !1) {\n        const f = this._def.schema._parseSync({\n          data: n.data,\n          path: n.path,\n          parent: n\n        });\n        return f.status === \"aborted\" ? Ae : (f.status === \"dirty\" && r.dirty(), c(f.value), { status: r.value, value: f.value });\n      } else\n        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((f) => f.status === \"aborted\" ? Ae : (f.status === \"dirty\" && r.dirty(), c(f.value).then(() => ({ status: r.value, value: f.value }))));\n    }\n    if (o.type === \"transform\")\n      if (n.common.async === !1) {\n        const c = this._def.schema._parseSync({\n          data: n.data,\n          path: n.path,\n          parent: n\n        });\n        if (!un(c))\n          return c;\n        const f = o.transform(c.value, i);\n        if (f instanceof Promise)\n          throw new Error(\"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return { status: r.value, value: f };\n      } else\n        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((c) => un(c) ? Promise.resolve(o.transform(c.value, i)).then((f) => ({ status: r.value, value: f })) : c);\n    nt.assertNever(o);\n  }\n}\nYt.create = (t, e, r) => new Yt({\n  schema: t,\n  typeName: Ce.ZodEffects,\n  effect: e,\n  ...Te(r)\n});\nYt.createWithPreprocess = (t, e, r) => new Yt({\n  schema: e,\n  effect: { type: \"preprocess\", transform: t },\n  typeName: Ce.ZodEffects,\n  ...Te(r)\n});\nclass ir extends Je {\n  _parse(e) {\n    return this._getType(e) === le.undefined ? jt(void 0) : this._def.innerType._parse(e);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nir.create = (t, e) => new ir({\n  innerType: t,\n  typeName: Ce.ZodOptional,\n  ...Te(e)\n});\nclass jr extends Je {\n  _parse(e) {\n    return this._getType(e) === le.null ? jt(null) : this._def.innerType._parse(e);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\njr.create = (t, e) => new jr({\n  innerType: t,\n  typeName: Ce.ZodNullable,\n  ...Te(e)\n});\nclass gi extends Je {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    let n = r.data;\n    return r.parsedType === le.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({\n      data: n,\n      path: r.path,\n      parent: r\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n}\ngi.create = (t, e) => new gi({\n  innerType: t,\n  typeName: Ce.ZodDefault,\n  defaultValue: typeof e.default == \"function\" ? e.default : () => e.default,\n  ...Te(e)\n});\nclass yi extends Je {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e), n = {\n      ...r,\n      common: {\n        ...r.common,\n        issues: []\n      }\n    }, o = this._def.innerType._parse({\n      data: n.data,\n      path: n.path,\n      parent: {\n        ...n\n      }\n    });\n    return oi(o) ? o.then((i) => ({\n      status: \"valid\",\n      value: i.status === \"valid\" ? i.value : this._def.catchValue({\n        get error() {\n          return new Zt(n.common.issues);\n        },\n        input: n.data\n      })\n    })) : {\n      status: \"valid\",\n      value: o.status === \"valid\" ? o.value : this._def.catchValue({\n        get error() {\n          return new Zt(n.common.issues);\n        },\n        input: n.data\n      })\n    };\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n}\nyi.create = (t, e) => new yi({\n  innerType: t,\n  typeName: Ce.ZodCatch,\n  catchValue: typeof e.catch == \"function\" ? e.catch : () => e.catch,\n  ...Te(e)\n});\nclass ds extends Je {\n  _parse(e) {\n    if (this._getType(e) !== le.nan) {\n      const n = this._getOrReturnCtx(e);\n      return oe(n, {\n        code: ne.invalid_type,\n        expected: le.nan,\n        received: n.parsedType\n      }), Ae;\n    }\n    return { status: \"valid\", value: e.data };\n  }\n}\nds.create = (t) => new ds({\n  typeName: Ce.ZodNaN,\n  ...Te(t)\n});\nconst Bf = Symbol(\"zod_brand\");\nclass ra extends Je {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e), n = r.data;\n    return this._def.type._parse({\n      data: n,\n      path: r.path,\n      parent: r\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n}\nclass ji extends Je {\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.common.async)\n      return (async () => {\n        const i = await this._def.in._parseAsync({\n          data: n.data,\n          path: n.path,\n          parent: n\n        });\n        return i.status === \"aborted\" ? Ae : i.status === \"dirty\" ? (r.dirty(), Cn(i.value)) : this._def.out._parseAsync({\n          data: i.value,\n          path: n.path,\n          parent: n\n        });\n      })();\n    {\n      const o = this._def.in._parseSync({\n        data: n.data,\n        path: n.path,\n        parent: n\n      });\n      return o.status === \"aborted\" ? Ae : o.status === \"dirty\" ? (r.dirty(), {\n        status: \"dirty\",\n        value: o.value\n      }) : this._def.out._parseSync({\n        data: o.value,\n        path: n.path,\n        parent: n\n      });\n    }\n  }\n  static create(e, r) {\n    return new ji({\n      in: e,\n      out: r,\n      typeName: Ce.ZodPipeline\n    });\n  }\n}\nclass vi extends Je {\n  _parse(e) {\n    const r = this._def.innerType._parse(e), n = (o) => (un(o) && (o.value = Object.freeze(o.value)), o);\n    return oi(r) ? r.then((o) => n(o)) : n(r);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nvi.create = (t, e) => new vi({\n  innerType: t,\n  typeName: Ce.ZodReadonly,\n  ...Te(e)\n});\nfunction Ia(t, e) {\n  const r = typeof t == \"function\" ? t(e) : typeof t == \"string\" ? { message: t } : t;\n  return typeof r == \"string\" ? { message: r } : r;\n}\nfunction Qu(t, e = {}, r) {\n  return t ? Tn.create().superRefine((n, o) => {\n    var i, c;\n    const f = t(n);\n    if (f instanceof Promise)\n      return f.then((v) => {\n        var x, b;\n        if (!v) {\n          const S = Ia(e, n), T = (b = (x = S.fatal) !== null && x !== void 0 ? x : r) !== null && b !== void 0 ? b : !0;\n          o.addIssue({ code: \"custom\", ...S, fatal: T });\n        }\n      });\n    if (!f) {\n      const v = Ia(e, n), x = (c = (i = v.fatal) !== null && i !== void 0 ? i : r) !== null && c !== void 0 ? c : !0;\n      o.addIssue({ code: \"custom\", ...v, fatal: x });\n    }\n  }) : Tn.create();\n}\nconst Rf = {\n  object: ht.lazycreate\n};\nvar Ce;\n(function(t) {\n  t.ZodString = \"ZodString\", t.ZodNumber = \"ZodNumber\", t.ZodNaN = \"ZodNaN\", t.ZodBigInt = \"ZodBigInt\", t.ZodBoolean = \"ZodBoolean\", t.ZodDate = \"ZodDate\", t.ZodSymbol = \"ZodSymbol\", t.ZodUndefined = \"ZodUndefined\", t.ZodNull = \"ZodNull\", t.ZodAny = \"ZodAny\", t.ZodUnknown = \"ZodUnknown\", t.ZodNever = \"ZodNever\", t.ZodVoid = \"ZodVoid\", t.ZodArray = \"ZodArray\", t.ZodObject = \"ZodObject\", t.ZodUnion = \"ZodUnion\", t.ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\", t.ZodIntersection = \"ZodIntersection\", t.ZodTuple = \"ZodTuple\", t.ZodRecord = \"ZodRecord\", t.ZodMap = \"ZodMap\", t.ZodSet = \"ZodSet\", t.ZodFunction = \"ZodFunction\", t.ZodLazy = \"ZodLazy\", t.ZodLiteral = \"ZodLiteral\", t.ZodEnum = \"ZodEnum\", t.ZodEffects = \"ZodEffects\", t.ZodNativeEnum = \"ZodNativeEnum\", t.ZodOptional = \"ZodOptional\", t.ZodNullable = \"ZodNullable\", t.ZodDefault = \"ZodDefault\", t.ZodCatch = \"ZodCatch\", t.ZodPromise = \"ZodPromise\", t.ZodBranded = \"ZodBranded\", t.ZodPipeline = \"ZodPipeline\", t.ZodReadonly = \"ZodReadonly\";\n})(Ce || (Ce = {}));\nconst Tf = (t, e = {\n  message: `Input not instance of ${t.name}`\n}) => Qu((r) => r instanceof t, e), ec = Wt.create, tc = Lr.create, Lf = ds.create, Of = Or.create, rc = ai.create, Nf = cn.create, jf = ls.create, Uf = ui.create, Ff = ci.create, Pf = Tn.create, Df = an.create, $f = xr.create, zf = fs.create, qf = Gt.create, Zf = ht.create, Vf = ht.strictCreate, Hf = li.create, Kf = Ts.create, Wf = fi.create, Gf = or.create, Yf = hi.create, Jf = hs.create, Xf = ln.create, Qf = kn.create, e0 = di.create, t0 = pi.create, r0 = Nr.create, n0 = mi.create, i0 = Ln.create, Ba = Yt.create, s0 = ir.create, o0 = jr.create, a0 = Yt.createWithPreprocess, u0 = ji.create, c0 = () => ec().optional(), l0 = () => tc().optional(), f0 = () => rc().optional(), h0 = {\n  string: (t) => Wt.create({ ...t, coerce: !0 }),\n  number: (t) => Lr.create({ ...t, coerce: !0 }),\n  boolean: (t) => ai.create({\n    ...t,\n    coerce: !0\n  }),\n  bigint: (t) => Or.create({ ...t, coerce: !0 }),\n  date: (t) => cn.create({ ...t, coerce: !0 })\n}, d0 = Ae;\nvar pe = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  defaultErrorMap: Rn,\n  setErrorMap: af,\n  getErrorMap: as,\n  makeIssue: us,\n  EMPTY_PATH: uf,\n  addIssueToContext: oe,\n  ParseStatus: Lt,\n  INVALID: Ae,\n  DIRTY: Cn,\n  OK: jt,\n  isAborted: Io,\n  isDirty: Bo,\n  isValid: un,\n  isAsync: oi,\n  get util() {\n    return nt;\n  },\n  get objectUtil() {\n    return ko;\n  },\n  ZodParsedType: le,\n  getParsedType: pr,\n  ZodType: Je,\n  datetimeRegex: Ju,\n  ZodString: Wt,\n  ZodNumber: Lr,\n  ZodBigInt: Or,\n  ZodBoolean: ai,\n  ZodDate: cn,\n  ZodSymbol: ls,\n  ZodUndefined: ui,\n  ZodNull: ci,\n  ZodAny: Tn,\n  ZodUnknown: an,\n  ZodNever: xr,\n  ZodVoid: fs,\n  ZodArray: Gt,\n  ZodObject: ht,\n  ZodUnion: li,\n  ZodDiscriminatedUnion: Ts,\n  ZodIntersection: fi,\n  ZodTuple: or,\n  ZodRecord: hi,\n  ZodMap: hs,\n  ZodSet: ln,\n  ZodFunction: kn,\n  ZodLazy: di,\n  ZodLiteral: pi,\n  ZodEnum: Nr,\n  ZodNativeEnum: mi,\n  ZodPromise: Ln,\n  ZodEffects: Yt,\n  ZodTransformer: Yt,\n  ZodOptional: ir,\n  ZodNullable: jr,\n  ZodDefault: gi,\n  ZodCatch: yi,\n  ZodNaN: ds,\n  BRAND: Bf,\n  ZodBranded: ra,\n  ZodPipeline: ji,\n  ZodReadonly: vi,\n  custom: Qu,\n  Schema: Je,\n  ZodSchema: Je,\n  late: Rf,\n  get ZodFirstPartyTypeKind() {\n    return Ce;\n  },\n  coerce: h0,\n  any: Pf,\n  array: qf,\n  bigint: Of,\n  boolean: rc,\n  date: Nf,\n  discriminatedUnion: Kf,\n  effect: Ba,\n  enum: r0,\n  function: Qf,\n  instanceof: Tf,\n  intersection: Wf,\n  lazy: e0,\n  literal: t0,\n  map: Jf,\n  nan: Lf,\n  nativeEnum: n0,\n  never: $f,\n  null: Ff,\n  nullable: o0,\n  number: tc,\n  object: Zf,\n  oboolean: f0,\n  onumber: l0,\n  optional: s0,\n  ostring: c0,\n  pipeline: u0,\n  preprocess: a0,\n  promise: i0,\n  record: Yf,\n  set: Xf,\n  strictObject: Vf,\n  string: ec,\n  symbol: jf,\n  transformer: Ba,\n  tuple: Gf,\n  undefined: Uf,\n  union: Hf,\n  unknown: Df,\n  void: zf,\n  NEVER: d0,\n  ZodIssueCode: ne,\n  quotelessJson: of,\n  ZodError: Zt\n});\nconst p0 = /[@#$%^&*+=\\/\\\\|~«»]/, m0 = /(!{2,}|\\?{2,}|-{2,})/, g0 = /[\\u{1F300}-\\u{1F9FF}]|[\\u{2702}-\\u{27B0}]|[\\u{2600}-\\u{26FF}]|[\\u{2B00}-\\u{2BFF}]/u, vn = ({ max: t, noSpaces: e } = {}) => (e ? pe.string().max(t ?? Number.POSITIVE_INFINITY).regex(/^\\S*$/, \"Spaces are not allowed\") : pe.string().max(t ?? Number.POSITIVE_INFINITY)).refine((n) => !g0.test(n), {\n  message: \"Emojis and symbols are not allowed\"\n}).refine((n) => !p0.test(n), {\n  message: \"Special characters (@, #, $, %, ^, &, *, +, =, /, \\\\, |, ~, «, ») are not allowed\"\n}).refine((n) => !m0.test(n), {\n  message: \"Repeated punctuations (!!, ??, --) are not allowed\"\n}), Dt = pe.string().url().startsWith(\"https://\", { message: \"Must be an https url\" }).max(1024), nc = pe.string().max(32), ic = pe.string().max(32), y0 = /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}\\/(?:[-a-z0-9]{3,8}:[-.%a-zA-Z0-9]{1,128}(?:\\/[-.%a-zA-Z0-9]{1,78})?|native)$/, v0 = pe.string().regex(y0, { message: \"Invalid CAIP-19 asset ID\" }), sc = pe.string().regex(/^#([0-9A-F]{3}|[0-9A-F]{6})$/i, {\n  message: \"Invalid hex color code. It should be in the format #RRGGBB or #RGB.\"\n}), w0 = pe.union([pe.literal(\"1:1\"), pe.literal(\"3:2\")]), x0 = pe.object({\n  header: pe.string(),\n  payload: pe.string(),\n  signature: pe.string()\n});\npe.object({\n  fid: pe.number(),\n  type: pe.literal(\"app_key\"),\n  key: pe.string().startsWith(\"0x\")\n});\nconst b0 = pe.object({\n  type: pe.literal(\"launch_frame\"),\n  name: nc,\n  url: Dt.optional(),\n  splashImageUrl: Dt.optional(),\n  splashBackgroundColor: sc.optional()\n}), _0 = pe.object({\n  type: pe.literal(\"view_token\"),\n  token: v0\n}), E0 = pe.discriminatedUnion(\"type\", [\n  b0,\n  _0\n]), M0 = pe.object({\n  title: ic,\n  action: E0\n});\npe.object({\n  version: pe.literal(\"next\"),\n  imageUrl: Dt,\n  aspectRatio: w0.optional(),\n  button: M0\n});\nconst oc = pe.object({\n  url: pe.string(),\n  token: pe.string()\n});\npe.object({\n  notificationId: pe.string().max(128),\n  title: pe.string().max(32),\n  body: pe.string().max(128),\n  targetUrl: Dt,\n  tokens: pe.string().array().max(100)\n});\npe.object({\n  result: pe.object({\n    successfulTokens: pe.array(pe.string()),\n    invalidTokens: pe.array(pe.string()),\n    rateLimitedTokens: pe.array(pe.string())\n  })\n});\nconst C0 = pe.object({\n  event: pe.literal(\"frame_added\"),\n  notificationDetails: oc.optional()\n}), S0 = pe.object({\n  event: pe.literal(\"frame_removed\")\n}), A0 = pe.object({\n  event: pe.literal(\"notifications_enabled\"),\n  notificationDetails: oc.required()\n}), k0 = pe.object({\n  event: pe.literal(\"notifications_disabled\")\n});\npe.discriminatedUnion(\"event\", [\n  C0,\n  S0,\n  A0,\n  k0\n]);\nconst I0 = pe.enum([\n  \"games\",\n  \"social\",\n  \"finance\",\n  \"utility\",\n  \"productivity\",\n  \"health-fitness\",\n  \"news-media\",\n  \"music\",\n  \"shopping\",\n  \"education\",\n  \"developer-tools\",\n  \"entertainment\",\n  \"art-creativity\"\n]), Ra = [\n  \"eip155:1\",\n  // Ethereum mainnet\n  \"eip155:8453\",\n  // Base mainnet\n  \"eip155:42161\",\n  // Arbitrum One\n  \"eip155:421614\",\n  // Arbitrum Sepolia\n  \"eip155:84532\",\n  // Base Sepolia\n  \"eip155:666666666\",\n  // Degen\n  \"eip155:100\",\n  // Gnosis\n  \"eip155:10\",\n  // Optimism\n  \"eip155:11155420\",\n  // Optimism Sepolia\n  \"eip155:137\",\n  // Polygon\n  \"eip155:11155111\",\n  // Ethereum Sepolia\n  \"eip155:7777777\",\n  // Zora\n  \"eip155:130\",\n  // Unichain\n  \"eip155:10143\",\n  // Monad testnet\n  \"eip155:42220\",\n  // Celo\n  \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\"\n  // Solana\n], B0 = pe.object({\n  // 0.0.0 and 0.0.1 are not technically part of the spec but kept for\n  // backwards compatibility. next should always resolve to the most recent\n  // schema version.\n  version: pe.union([\n    pe.literal(\"0.0.0\"),\n    pe.literal(\"0.0.1\"),\n    pe.literal(\"1\"),\n    pe.literal(\"next\")\n  ]),\n  name: nc,\n  iconUrl: Dt,\n  homeUrl: Dt,\n  /** deprecated, set ogImageUrl instead */\n  imageUrl: Dt.optional(),\n  /** deprecated, will rely on fc:frame meta tag */\n  buttonTitle: ic.optional(),\n  splashImageUrl: Dt.optional(),\n  splashBackgroundColor: sc.optional(),\n  webhookUrl: Dt.optional(),\n  /** see: https://github.com/farcasterxyz/miniapps/discussions/191 */\n  subtitle: vn({ max: 30 }).optional(),\n  description: vn({ max: 170 }).optional(),\n  screenshotUrls: pe.array(Dt).max(3).optional(),\n  primaryCategory: I0.optional(),\n  tags: pe.array(vn({ max: 20, noSpaces: !0 })).max(5).optional(),\n  heroImageUrl: Dt.optional(),\n  tagline: vn({ max: 30 }).optional(),\n  ogTitle: vn({ max: 30 }).optional(),\n  ogDescription: vn({ max: 100 }).optional(),\n  ogImageUrl: Dt.optional(),\n  /** see: https://github.com/farcasterxyz/miniapps/discussions/204 */\n  noindex: pe.boolean().optional(),\n  /** see https://github.com/farcasterxyz/miniapps/discussions/256 */\n  requiredChains: pe.array(pe.enum(Ra)).max(Ra.length).optional(),\n  requiredCapabilities: pe.array(pe.enum(Aa)).max(Aa.length).optional(),\n  /** see https://github.com/farcasterxyz/miniapps/discussions/158 */\n  /** Documentation will be added once this feature is finalized. */\n  castShareUrl: Dt.optional()\n}).refine((t) => {\n  if (t.castShareUrl === void 0)\n    return !0;\n  try {\n    const e = new URL(t.homeUrl).hostname, r = new URL(t.castShareUrl).hostname;\n    return e === r;\n  } catch {\n    return !1;\n  }\n}, {\n  message: \"castShareUrl must have the same domain as homeUrl\",\n  path: [\"castShareUrl\"]\n});\npe.object({\n  accountAssociation: x0,\n  frame: B0.optional()\n});\nvar Ks = {}, ei = {}, Ta;\nfunction R0() {\n  if (Ta) return ei;\n  Ta = 1, ei.byteLength = f, ei.toByteArray = x, ei.fromByteArray = T;\n  for (var t = [], e = [], r = typeof Uint8Array < \"u\" ? Uint8Array : Array, n = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", o = 0, i = n.length; o < i; ++o)\n    t[o] = n[o], e[n.charCodeAt(o)] = o;\n  e[45] = 62, e[95] = 63;\n  function c(C) {\n    var P = C.length;\n    if (P % 4 > 0)\n      throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    var B = C.indexOf(\"=\");\n    B === -1 && (B = P);\n    var R = B === P ? 0 : 4 - B % 4;\n    return [B, R];\n  }\n  function f(C) {\n    var P = c(C), B = P[0], R = P[1];\n    return (B + R) * 3 / 4 - R;\n  }\n  function v(C, P, B) {\n    return (P + B) * 3 / 4 - B;\n  }\n  function x(C) {\n    var P, B = c(C), R = B[0], z = B[1], K = new r(v(C, R, z)), Z = 0, Q = z > 0 ? R - 4 : R, j;\n    for (j = 0; j < Q; j += 4)\n      P = e[C.charCodeAt(j)] << 18 | e[C.charCodeAt(j + 1)] << 12 | e[C.charCodeAt(j + 2)] << 6 | e[C.charCodeAt(j + 3)], K[Z++] = P >> 16 & 255, K[Z++] = P >> 8 & 255, K[Z++] = P & 255;\n    return z === 2 && (P = e[C.charCodeAt(j)] << 2 | e[C.charCodeAt(j + 1)] >> 4, K[Z++] = P & 255), z === 1 && (P = e[C.charCodeAt(j)] << 10 | e[C.charCodeAt(j + 1)] << 4 | e[C.charCodeAt(j + 2)] >> 2, K[Z++] = P >> 8 & 255, K[Z++] = P & 255), K;\n  }\n  function b(C) {\n    return t[C >> 18 & 63] + t[C >> 12 & 63] + t[C >> 6 & 63] + t[C & 63];\n  }\n  function S(C, P, B) {\n    for (var R, z = [], K = P; K < B; K += 3)\n      R = (C[K] << 16 & 16711680) + (C[K + 1] << 8 & 65280) + (C[K + 2] & 255), z.push(b(R));\n    return z.join(\"\");\n  }\n  function T(C) {\n    for (var P, B = C.length, R = B % 3, z = [], K = 16383, Z = 0, Q = B - R; Z < Q; Z += K)\n      z.push(S(C, Z, Z + K > Q ? Q : Z + K));\n    return R === 1 ? (P = C[B - 1], z.push(\n      t[P >> 2] + t[P << 4 & 63] + \"==\"\n    )) : R === 2 && (P = (C[B - 2] << 8) + C[B - 1], z.push(\n      t[P >> 10] + t[P >> 4 & 63] + t[P << 2 & 63] + \"=\"\n    )), z.join(\"\");\n  }\n  return ei;\n}\nvar qi = {};\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nvar La;\nfunction T0() {\n  return La || (La = 1, qi.read = function(t, e, r, n, o) {\n    var i, c, f = o * 8 - n - 1, v = (1 << f) - 1, x = v >> 1, b = -7, S = r ? o - 1 : 0, T = r ? -1 : 1, C = t[e + S];\n    for (S += T, i = C & (1 << -b) - 1, C >>= -b, b += f; b > 0; i = i * 256 + t[e + S], S += T, b -= 8)\n      ;\n    for (c = i & (1 << -b) - 1, i >>= -b, b += n; b > 0; c = c * 256 + t[e + S], S += T, b -= 8)\n      ;\n    if (i === 0)\n      i = 1 - x;\n    else {\n      if (i === v)\n        return c ? NaN : (C ? -1 : 1) * (1 / 0);\n      c = c + Math.pow(2, n), i = i - x;\n    }\n    return (C ? -1 : 1) * c * Math.pow(2, i - n);\n  }, qi.write = function(t, e, r, n, o, i) {\n    var c, f, v, x = i * 8 - o - 1, b = (1 << x) - 1, S = b >> 1, T = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, C = n ? 0 : i - 1, P = n ? 1 : -1, B = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;\n    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (f = isNaN(e) ? 1 : 0, c = b) : (c = Math.floor(Math.log(e) / Math.LN2), e * (v = Math.pow(2, -c)) < 1 && (c--, v *= 2), c + S >= 1 ? e += T / v : e += T * Math.pow(2, 1 - S), e * v >= 2 && (c++, v /= 2), c + S >= b ? (f = 0, c = b) : c + S >= 1 ? (f = (e * v - 1) * Math.pow(2, o), c = c + S) : (f = e * Math.pow(2, S - 1) * Math.pow(2, o), c = 0)); o >= 8; t[r + C] = f & 255, C += P, f /= 256, o -= 8)\n      ;\n    for (c = c << o | f, x += o; x > 0; t[r + C] = c & 255, C += P, c /= 256, x -= 8)\n      ;\n    t[r + C - P] |= B * 128;\n  }), qi;\n}\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\nvar Oa;\nfunction na() {\n  return Oa || (Oa = 1, function(t) {\n    const e = R0(), r = T0(), n = typeof Symbol == \"function\" && typeof Symbol.for == \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n    t.Buffer = f, t.SlowBuffer = K, t.INSPECT_MAX_BYTES = 50;\n    const o = 2147483647;\n    t.kMaxLength = o, f.TYPED_ARRAY_SUPPORT = i(), !f.TYPED_ARRAY_SUPPORT && typeof console < \"u\" && typeof console.error == \"function\" && console.error(\n      \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n    );\n    function i() {\n      try {\n        const E = new Uint8Array(1), m = { foo: function() {\n          return 42;\n        } };\n        return Object.setPrototypeOf(m, Uint8Array.prototype), Object.setPrototypeOf(E, m), E.foo() === 42;\n      } catch {\n        return !1;\n      }\n    }\n    Object.defineProperty(f.prototype, \"parent\", {\n      enumerable: !0,\n      get: function() {\n        if (f.isBuffer(this))\n          return this.buffer;\n      }\n    }), Object.defineProperty(f.prototype, \"offset\", {\n      enumerable: !0,\n      get: function() {\n        if (f.isBuffer(this))\n          return this.byteOffset;\n      }\n    });\n    function c(E) {\n      if (E > o)\n        throw new RangeError('The value \"' + E + '\" is invalid for option \"size\"');\n      const m = new Uint8Array(E);\n      return Object.setPrototypeOf(m, f.prototype), m;\n    }\n    function f(E, m, y) {\n      if (typeof E == \"number\") {\n        if (typeof m == \"string\")\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        return S(E);\n      }\n      return v(E, m, y);\n    }\n    f.poolSize = 8192;\n    function v(E, m, y) {\n      if (typeof E == \"string\")\n        return T(E, m);\n      if (ArrayBuffer.isView(E))\n        return P(E);\n      if (E == null)\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof E\n        );\n      if (xt(E, ArrayBuffer) || E && xt(E.buffer, ArrayBuffer) || typeof SharedArrayBuffer < \"u\" && (xt(E, SharedArrayBuffer) || E && xt(E.buffer, SharedArrayBuffer)))\n        return B(E, m, y);\n      if (typeof E == \"number\")\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      const I = E.valueOf && E.valueOf();\n      if (I != null && I !== E)\n        return f.from(I, m, y);\n      const q = R(E);\n      if (q) return q;\n      if (typeof Symbol < \"u\" && Symbol.toPrimitive != null && typeof E[Symbol.toPrimitive] == \"function\")\n        return f.from(E[Symbol.toPrimitive](\"string\"), m, y);\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof E\n      );\n    }\n    f.from = function(E, m, y) {\n      return v(E, m, y);\n    }, Object.setPrototypeOf(f.prototype, Uint8Array.prototype), Object.setPrototypeOf(f, Uint8Array);\n    function x(E) {\n      if (typeof E != \"number\")\n        throw new TypeError('\"size\" argument must be of type number');\n      if (E < 0)\n        throw new RangeError('The value \"' + E + '\" is invalid for option \"size\"');\n    }\n    function b(E, m, y) {\n      return x(E), E <= 0 ? c(E) : m !== void 0 ? typeof y == \"string\" ? c(E).fill(m, y) : c(E).fill(m) : c(E);\n    }\n    f.alloc = function(E, m, y) {\n      return b(E, m, y);\n    };\n    function S(E) {\n      return x(E), c(E < 0 ? 0 : z(E) | 0);\n    }\n    f.allocUnsafe = function(E) {\n      return S(E);\n    }, f.allocUnsafeSlow = function(E) {\n      return S(E);\n    };\n    function T(E, m) {\n      if ((typeof m != \"string\" || m === \"\") && (m = \"utf8\"), !f.isEncoding(m))\n        throw new TypeError(\"Unknown encoding: \" + m);\n      const y = Z(E, m) | 0;\n      let I = c(y);\n      const q = I.write(E, m);\n      return q !== y && (I = I.slice(0, q)), I;\n    }\n    function C(E) {\n      const m = E.length < 0 ? 0 : z(E.length) | 0, y = c(m);\n      for (let I = 0; I < m; I += 1)\n        y[I] = E[I] & 255;\n      return y;\n    }\n    function P(E) {\n      if (xt(E, Uint8Array)) {\n        const m = new Uint8Array(E);\n        return B(m.buffer, m.byteOffset, m.byteLength);\n      }\n      return C(E);\n    }\n    function B(E, m, y) {\n      if (m < 0 || E.byteLength < m)\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      if (E.byteLength < m + (y || 0))\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      let I;\n      return m === void 0 && y === void 0 ? I = new Uint8Array(E) : y === void 0 ? I = new Uint8Array(E, m) : I = new Uint8Array(E, m, y), Object.setPrototypeOf(I, f.prototype), I;\n    }\n    function R(E) {\n      if (f.isBuffer(E)) {\n        const m = z(E.length) | 0, y = c(m);\n        return y.length === 0 || E.copy(y, 0, 0, m), y;\n      }\n      if (E.length !== void 0)\n        return typeof E.length != \"number\" || Se(E.length) ? c(0) : C(E);\n      if (E.type === \"Buffer\" && Array.isArray(E.data))\n        return C(E.data);\n    }\n    function z(E) {\n      if (E >= o)\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + o.toString(16) + \" bytes\");\n      return E | 0;\n    }\n    function K(E) {\n      return +E != E && (E = 0), f.alloc(+E);\n    }\n    f.isBuffer = function(m) {\n      return m != null && m._isBuffer === !0 && m !== f.prototype;\n    }, f.compare = function(m, y) {\n      if (xt(m, Uint8Array) && (m = f.from(m, m.offset, m.byteLength)), xt(y, Uint8Array) && (y = f.from(y, y.offset, y.byteLength)), !f.isBuffer(m) || !f.isBuffer(y))\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      if (m === y) return 0;\n      let I = m.length, q = y.length;\n      for (let H = 0, W = Math.min(I, q); H < W; ++H)\n        if (m[H] !== y[H]) {\n          I = m[H], q = y[H];\n          break;\n        }\n      return I < q ? -1 : q < I ? 1 : 0;\n    }, f.isEncoding = function(m) {\n      switch (String(m).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return !0;\n        default:\n          return !1;\n      }\n    }, f.concat = function(m, y) {\n      if (!Array.isArray(m))\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      if (m.length === 0)\n        return f.alloc(0);\n      let I;\n      if (y === void 0)\n        for (y = 0, I = 0; I < m.length; ++I)\n          y += m[I].length;\n      const q = f.allocUnsafe(y);\n      let H = 0;\n      for (I = 0; I < m.length; ++I) {\n        let W = m[I];\n        if (xt(W, Uint8Array))\n          H + W.length > q.length ? (f.isBuffer(W) || (W = f.from(W)), W.copy(q, H)) : Uint8Array.prototype.set.call(\n            q,\n            W,\n            H\n          );\n        else if (f.isBuffer(W))\n          W.copy(q, H);\n        else\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        H += W.length;\n      }\n      return q;\n    };\n    function Z(E, m) {\n      if (f.isBuffer(E))\n        return E.length;\n      if (ArrayBuffer.isView(E) || xt(E, ArrayBuffer))\n        return E.byteLength;\n      if (typeof E != \"string\")\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof E\n        );\n      const y = E.length, I = arguments.length > 2 && arguments[2] === !0;\n      if (!I && y === 0) return 0;\n      let q = !1;\n      for (; ; )\n        switch (m) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return y;\n          case \"utf8\":\n          case \"utf-8\":\n            return we(E).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return y * 2;\n          case \"hex\":\n            return y >>> 1;\n          case \"base64\":\n            return ye(E).length;\n          default:\n            if (q)\n              return I ? -1 : we(E).length;\n            m = (\"\" + m).toLowerCase(), q = !0;\n        }\n    }\n    f.byteLength = Z;\n    function Q(E, m, y) {\n      let I = !1;\n      if ((m === void 0 || m < 0) && (m = 0), m > this.length || ((y === void 0 || y > this.length) && (y = this.length), y <= 0) || (y >>>= 0, m >>>= 0, y <= m))\n        return \"\";\n      for (E || (E = \"utf8\"); ; )\n        switch (E) {\n          case \"hex\":\n            return _(this, m, y);\n          case \"utf8\":\n          case \"utf-8\":\n            return s(this, m, y);\n          case \"ascii\":\n            return g(this, m, y);\n          case \"latin1\":\n          case \"binary\":\n            return w(this, m, y);\n          case \"base64\":\n            return d(this, m, y);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return A(this, m, y);\n          default:\n            if (I) throw new TypeError(\"Unknown encoding: \" + E);\n            E = (E + \"\").toLowerCase(), I = !0;\n        }\n    }\n    f.prototype._isBuffer = !0;\n    function j(E, m, y) {\n      const I = E[m];\n      E[m] = E[y], E[y] = I;\n    }\n    f.prototype.swap16 = function() {\n      const m = this.length;\n      if (m % 2 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      for (let y = 0; y < m; y += 2)\n        j(this, y, y + 1);\n      return this;\n    }, f.prototype.swap32 = function() {\n      const m = this.length;\n      if (m % 4 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      for (let y = 0; y < m; y += 4)\n        j(this, y, y + 3), j(this, y + 1, y + 2);\n      return this;\n    }, f.prototype.swap64 = function() {\n      const m = this.length;\n      if (m % 8 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      for (let y = 0; y < m; y += 8)\n        j(this, y, y + 7), j(this, y + 1, y + 6), j(this, y + 2, y + 5), j(this, y + 3, y + 4);\n      return this;\n    }, f.prototype.toString = function() {\n      const m = this.length;\n      return m === 0 ? \"\" : arguments.length === 0 ? s(this, 0, m) : Q.apply(this, arguments);\n    }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(m) {\n      if (!f.isBuffer(m)) throw new TypeError(\"Argument must be a Buffer\");\n      return this === m ? !0 : f.compare(this, m) === 0;\n    }, f.prototype.inspect = function() {\n      let m = \"\";\n      const y = t.INSPECT_MAX_BYTES;\n      return m = this.toString(\"hex\", 0, y).replace(/(.{2})/g, \"$1 \").trim(), this.length > y && (m += \" ... \"), \"<Buffer \" + m + \">\";\n    }, n && (f.prototype[n] = f.prototype.inspect), f.prototype.compare = function(m, y, I, q, H) {\n      if (xt(m, Uint8Array) && (m = f.from(m, m.offset, m.byteLength)), !f.isBuffer(m))\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof m\n        );\n      if (y === void 0 && (y = 0), I === void 0 && (I = m ? m.length : 0), q === void 0 && (q = 0), H === void 0 && (H = this.length), y < 0 || I > m.length || q < 0 || H > this.length)\n        throw new RangeError(\"out of range index\");\n      if (q >= H && y >= I)\n        return 0;\n      if (q >= H)\n        return -1;\n      if (y >= I)\n        return 1;\n      if (y >>>= 0, I >>>= 0, q >>>= 0, H >>>= 0, this === m) return 0;\n      let W = H - q, Be = I - y;\n      const me = Math.min(W, Be), de = this.slice(q, H), ot = m.slice(y, I);\n      for (let ce = 0; ce < me; ++ce)\n        if (de[ce] !== ot[ce]) {\n          W = de[ce], Be = ot[ce];\n          break;\n        }\n      return W < Be ? -1 : Be < W ? 1 : 0;\n    };\n    function V(E, m, y, I, q) {\n      if (E.length === 0) return -1;\n      if (typeof y == \"string\" ? (I = y, y = 0) : y > 2147483647 ? y = 2147483647 : y < -2147483648 && (y = -2147483648), y = +y, Se(y) && (y = q ? 0 : E.length - 1), y < 0 && (y = E.length + y), y >= E.length) {\n        if (q) return -1;\n        y = E.length - 1;\n      } else if (y < 0)\n        if (q) y = 0;\n        else return -1;\n      if (typeof m == \"string\" && (m = f.from(m, I)), f.isBuffer(m))\n        return m.length === 0 ? -1 : ee(E, m, y, I, q);\n      if (typeof m == \"number\")\n        return m = m & 255, typeof Uint8Array.prototype.indexOf == \"function\" ? q ? Uint8Array.prototype.indexOf.call(E, m, y) : Uint8Array.prototype.lastIndexOf.call(E, m, y) : ee(E, [m], y, I, q);\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function ee(E, m, y, I, q) {\n      let H = 1, W = E.length, Be = m.length;\n      if (I !== void 0 && (I = String(I).toLowerCase(), I === \"ucs2\" || I === \"ucs-2\" || I === \"utf16le\" || I === \"utf-16le\")) {\n        if (E.length < 2 || m.length < 2)\n          return -1;\n        H = 2, W /= 2, Be /= 2, y /= 2;\n      }\n      function me(ot, ce) {\n        return H === 1 ? ot[ce] : ot.readUInt16BE(ce * H);\n      }\n      let de;\n      if (q) {\n        let ot = -1;\n        for (de = y; de < W; de++)\n          if (me(E, de) === me(m, ot === -1 ? 0 : de - ot)) {\n            if (ot === -1 && (ot = de), de - ot + 1 === Be) return ot * H;\n          } else\n            ot !== -1 && (de -= de - ot), ot = -1;\n      } else\n        for (y + Be > W && (y = W - Be), de = y; de >= 0; de--) {\n          let ot = !0;\n          for (let ce = 0; ce < Be; ce++)\n            if (me(E, de + ce) !== me(m, ce)) {\n              ot = !1;\n              break;\n            }\n          if (ot) return de;\n        }\n      return -1;\n    }\n    f.prototype.includes = function(m, y, I) {\n      return this.indexOf(m, y, I) !== -1;\n    }, f.prototype.indexOf = function(m, y, I) {\n      return V(this, m, y, I, !0);\n    }, f.prototype.lastIndexOf = function(m, y, I) {\n      return V(this, m, y, I, !1);\n    };\n    function G(E, m, y, I) {\n      y = Number(y) || 0;\n      const q = E.length - y;\n      I ? (I = Number(I), I > q && (I = q)) : I = q;\n      const H = m.length;\n      I > H / 2 && (I = H / 2);\n      let W;\n      for (W = 0; W < I; ++W) {\n        const Be = parseInt(m.substr(W * 2, 2), 16);\n        if (Se(Be)) return W;\n        E[y + W] = Be;\n      }\n      return W;\n    }\n    function N(E, m, y, I) {\n      return be(we(m, E.length - y), E, y, I);\n    }\n    function O(E, m, y, I) {\n      return be(Me(m), E, y, I);\n    }\n    function L(E, m, y, I) {\n      return be(ye(m), E, y, I);\n    }\n    function F(E, m, y, I) {\n      return be(ft(m, E.length - y), E, y, I);\n    }\n    f.prototype.write = function(m, y, I, q) {\n      if (y === void 0)\n        q = \"utf8\", I = this.length, y = 0;\n      else if (I === void 0 && typeof y == \"string\")\n        q = y, I = this.length, y = 0;\n      else if (isFinite(y))\n        y = y >>> 0, isFinite(I) ? (I = I >>> 0, q === void 0 && (q = \"utf8\")) : (q = I, I = void 0);\n      else\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      const H = this.length - y;\n      if ((I === void 0 || I > H) && (I = H), m.length > 0 && (I < 0 || y < 0) || y > this.length)\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      q || (q = \"utf8\");\n      let W = !1;\n      for (; ; )\n        switch (q) {\n          case \"hex\":\n            return G(this, m, y, I);\n          case \"utf8\":\n          case \"utf-8\":\n            return N(this, m, y, I);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return O(this, m, y, I);\n          case \"base64\":\n            return L(this, m, y, I);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return F(this, m, y, I);\n          default:\n            if (W) throw new TypeError(\"Unknown encoding: \" + q);\n            q = (\"\" + q).toLowerCase(), W = !0;\n        }\n    }, f.prototype.toJSON = function() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function d(E, m, y) {\n      return m === 0 && y === E.length ? e.fromByteArray(E) : e.fromByteArray(E.slice(m, y));\n    }\n    function s(E, m, y) {\n      y = Math.min(E.length, y);\n      const I = [];\n      let q = m;\n      for (; q < y; ) {\n        const H = E[q];\n        let W = null, Be = H > 239 ? 4 : H > 223 ? 3 : H > 191 ? 2 : 1;\n        if (q + Be <= y) {\n          let me, de, ot, ce;\n          switch (Be) {\n            case 1:\n              H < 128 && (W = H);\n              break;\n            case 2:\n              me = E[q + 1], (me & 192) === 128 && (ce = (H & 31) << 6 | me & 63, ce > 127 && (W = ce));\n              break;\n            case 3:\n              me = E[q + 1], de = E[q + 2], (me & 192) === 128 && (de & 192) === 128 && (ce = (H & 15) << 12 | (me & 63) << 6 | de & 63, ce > 2047 && (ce < 55296 || ce > 57343) && (W = ce));\n              break;\n            case 4:\n              me = E[q + 1], de = E[q + 2], ot = E[q + 3], (me & 192) === 128 && (de & 192) === 128 && (ot & 192) === 128 && (ce = (H & 15) << 18 | (me & 63) << 12 | (de & 63) << 6 | ot & 63, ce > 65535 && ce < 1114112 && (W = ce));\n          }\n        }\n        W === null ? (W = 65533, Be = 1) : W > 65535 && (W -= 65536, I.push(W >>> 10 & 1023 | 55296), W = 56320 | W & 1023), I.push(W), q += Be;\n      }\n      return h(I);\n    }\n    const u = 4096;\n    function h(E) {\n      const m = E.length;\n      if (m <= u)\n        return String.fromCharCode.apply(String, E);\n      let y = \"\", I = 0;\n      for (; I < m; )\n        y += String.fromCharCode.apply(\n          String,\n          E.slice(I, I += u)\n        );\n      return y;\n    }\n    function g(E, m, y) {\n      let I = \"\";\n      y = Math.min(E.length, y);\n      for (let q = m; q < y; ++q)\n        I += String.fromCharCode(E[q] & 127);\n      return I;\n    }\n    function w(E, m, y) {\n      let I = \"\";\n      y = Math.min(E.length, y);\n      for (let q = m; q < y; ++q)\n        I += String.fromCharCode(E[q]);\n      return I;\n    }\n    function _(E, m, y) {\n      const I = E.length;\n      (!m || m < 0) && (m = 0), (!y || y < 0 || y > I) && (y = I);\n      let q = \"\";\n      for (let H = m; H < y; ++H)\n        q += ke[E[H]];\n      return q;\n    }\n    function A(E, m, y) {\n      const I = E.slice(m, y);\n      let q = \"\";\n      for (let H = 0; H < I.length - 1; H += 2)\n        q += String.fromCharCode(I[H] + I[H + 1] * 256);\n      return q;\n    }\n    f.prototype.slice = function(m, y) {\n      const I = this.length;\n      m = ~~m, y = y === void 0 ? I : ~~y, m < 0 ? (m += I, m < 0 && (m = 0)) : m > I && (m = I), y < 0 ? (y += I, y < 0 && (y = 0)) : y > I && (y = I), y < m && (y = m);\n      const q = this.subarray(m, y);\n      return Object.setPrototypeOf(q, f.prototype), q;\n    };\n    function p(E, m, y) {\n      if (E % 1 !== 0 || E < 0) throw new RangeError(\"offset is not uint\");\n      if (E + m > y) throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    f.prototype.readUintLE = f.prototype.readUIntLE = function(m, y, I) {\n      m = m >>> 0, y = y >>> 0, I || p(m, y, this.length);\n      let q = this[m], H = 1, W = 0;\n      for (; ++W < y && (H *= 256); )\n        q += this[m + W] * H;\n      return q;\n    }, f.prototype.readUintBE = f.prototype.readUIntBE = function(m, y, I) {\n      m = m >>> 0, y = y >>> 0, I || p(m, y, this.length);\n      let q = this[m + --y], H = 1;\n      for (; y > 0 && (H *= 256); )\n        q += this[m + --y] * H;\n      return q;\n    }, f.prototype.readUint8 = f.prototype.readUInt8 = function(m, y) {\n      return m = m >>> 0, y || p(m, 1, this.length), this[m];\n    }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(m, y) {\n      return m = m >>> 0, y || p(m, 2, this.length), this[m] | this[m + 1] << 8;\n    }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(m, y) {\n      return m = m >>> 0, y || p(m, 2, this.length), this[m] << 8 | this[m + 1];\n    }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(m, y) {\n      return m = m >>> 0, y || p(m, 4, this.length), (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + this[m + 3] * 16777216;\n    }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(m, y) {\n      return m = m >>> 0, y || p(m, 4, this.length), this[m] * 16777216 + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]);\n    }, f.prototype.readBigUInt64LE = ct(function(m) {\n      m = m >>> 0, Xe(m, \"offset\");\n      const y = this[m], I = this[m + 7];\n      (y === void 0 || I === void 0) && ae(m, this.length - 8);\n      const q = y + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24, H = this[++m] + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + I * 2 ** 24;\n      return BigInt(q) + (BigInt(H) << BigInt(32));\n    }), f.prototype.readBigUInt64BE = ct(function(m) {\n      m = m >>> 0, Xe(m, \"offset\");\n      const y = this[m], I = this[m + 7];\n      (y === void 0 || I === void 0) && ae(m, this.length - 8);\n      const q = y * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m], H = this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + I;\n      return (BigInt(q) << BigInt(32)) + BigInt(H);\n    }), f.prototype.readIntLE = function(m, y, I) {\n      m = m >>> 0, y = y >>> 0, I || p(m, y, this.length);\n      let q = this[m], H = 1, W = 0;\n      for (; ++W < y && (H *= 256); )\n        q += this[m + W] * H;\n      return H *= 128, q >= H && (q -= Math.pow(2, 8 * y)), q;\n    }, f.prototype.readIntBE = function(m, y, I) {\n      m = m >>> 0, y = y >>> 0, I || p(m, y, this.length);\n      let q = y, H = 1, W = this[m + --q];\n      for (; q > 0 && (H *= 256); )\n        W += this[m + --q] * H;\n      return H *= 128, W >= H && (W -= Math.pow(2, 8 * y)), W;\n    }, f.prototype.readInt8 = function(m, y) {\n      return m = m >>> 0, y || p(m, 1, this.length), this[m] & 128 ? (255 - this[m] + 1) * -1 : this[m];\n    }, f.prototype.readInt16LE = function(m, y) {\n      m = m >>> 0, y || p(m, 2, this.length);\n      const I = this[m] | this[m + 1] << 8;\n      return I & 32768 ? I | 4294901760 : I;\n    }, f.prototype.readInt16BE = function(m, y) {\n      m = m >>> 0, y || p(m, 2, this.length);\n      const I = this[m + 1] | this[m] << 8;\n      return I & 32768 ? I | 4294901760 : I;\n    }, f.prototype.readInt32LE = function(m, y) {\n      return m = m >>> 0, y || p(m, 4, this.length), this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24;\n    }, f.prototype.readInt32BE = function(m, y) {\n      return m = m >>> 0, y || p(m, 4, this.length), this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3];\n    }, f.prototype.readBigInt64LE = ct(function(m) {\n      m = m >>> 0, Xe(m, \"offset\");\n      const y = this[m], I = this[m + 7];\n      (y === void 0 || I === void 0) && ae(m, this.length - 8);\n      const q = this[m + 4] + this[m + 5] * 2 ** 8 + this[m + 6] * 2 ** 16 + (I << 24);\n      return (BigInt(q) << BigInt(32)) + BigInt(y + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24);\n    }), f.prototype.readBigInt64BE = ct(function(m) {\n      m = m >>> 0, Xe(m, \"offset\");\n      const y = this[m], I = this[m + 7];\n      (y === void 0 || I === void 0) && ae(m, this.length - 8);\n      const q = (y << 24) + // Overflow\n      this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m];\n      return (BigInt(q) << BigInt(32)) + BigInt(this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + I);\n    }), f.prototype.readFloatLE = function(m, y) {\n      return m = m >>> 0, y || p(m, 4, this.length), r.read(this, m, !0, 23, 4);\n    }, f.prototype.readFloatBE = function(m, y) {\n      return m = m >>> 0, y || p(m, 4, this.length), r.read(this, m, !1, 23, 4);\n    }, f.prototype.readDoubleLE = function(m, y) {\n      return m = m >>> 0, y || p(m, 8, this.length), r.read(this, m, !0, 52, 8);\n    }, f.prototype.readDoubleBE = function(m, y) {\n      return m = m >>> 0, y || p(m, 8, this.length), r.read(this, m, !1, 52, 8);\n    };\n    function a(E, m, y, I, q, H) {\n      if (!f.isBuffer(E)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (m > q || m < H) throw new RangeError('\"value\" argument is out of bounds');\n      if (y + I > E.length) throw new RangeError(\"Index out of range\");\n    }\n    f.prototype.writeUintLE = f.prototype.writeUIntLE = function(m, y, I, q) {\n      if (m = +m, y = y >>> 0, I = I >>> 0, !q) {\n        const Be = Math.pow(2, 8 * I) - 1;\n        a(this, m, y, I, Be, 0);\n      }\n      let H = 1, W = 0;\n      for (this[y] = m & 255; ++W < I && (H *= 256); )\n        this[y + W] = m / H & 255;\n      return y + I;\n    }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(m, y, I, q) {\n      if (m = +m, y = y >>> 0, I = I >>> 0, !q) {\n        const Be = Math.pow(2, 8 * I) - 1;\n        a(this, m, y, I, Be, 0);\n      }\n      let H = I - 1, W = 1;\n      for (this[y + H] = m & 255; --H >= 0 && (W *= 256); )\n        this[y + H] = m / W & 255;\n      return y + I;\n    }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 1, 255, 0), this[y] = m & 255, y + 1;\n    }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 2, 65535, 0), this[y] = m & 255, this[y + 1] = m >>> 8, y + 2;\n    }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 2, 65535, 0), this[y] = m >>> 8, this[y + 1] = m & 255, y + 2;\n    }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 4, 4294967295, 0), this[y + 3] = m >>> 24, this[y + 2] = m >>> 16, this[y + 1] = m >>> 8, this[y] = m & 255, y + 4;\n    }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 4, 4294967295, 0), this[y] = m >>> 24, this[y + 1] = m >>> 16, this[y + 2] = m >>> 8, this[y + 3] = m & 255, y + 4;\n    };\n    function l(E, m, y, I, q) {\n      Ie(m, I, q, E, y, 7);\n      let H = Number(m & BigInt(4294967295));\n      E[y++] = H, H = H >> 8, E[y++] = H, H = H >> 8, E[y++] = H, H = H >> 8, E[y++] = H;\n      let W = Number(m >> BigInt(32) & BigInt(4294967295));\n      return E[y++] = W, W = W >> 8, E[y++] = W, W = W >> 8, E[y++] = W, W = W >> 8, E[y++] = W, y;\n    }\n    function M(E, m, y, I, q) {\n      Ie(m, I, q, E, y, 7);\n      let H = Number(m & BigInt(4294967295));\n      E[y + 7] = H, H = H >> 8, E[y + 6] = H, H = H >> 8, E[y + 5] = H, H = H >> 8, E[y + 4] = H;\n      let W = Number(m >> BigInt(32) & BigInt(4294967295));\n      return E[y + 3] = W, W = W >> 8, E[y + 2] = W, W = W >> 8, E[y + 1] = W, W = W >> 8, E[y] = W, y + 8;\n    }\n    f.prototype.writeBigUInt64LE = ct(function(m, y = 0) {\n      return l(this, m, y, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    }), f.prototype.writeBigUInt64BE = ct(function(m, y = 0) {\n      return M(this, m, y, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    }), f.prototype.writeIntLE = function(m, y, I, q) {\n      if (m = +m, y = y >>> 0, !q) {\n        const me = Math.pow(2, 8 * I - 1);\n        a(this, m, y, I, me - 1, -me);\n      }\n      let H = 0, W = 1, Be = 0;\n      for (this[y] = m & 255; ++H < I && (W *= 256); )\n        m < 0 && Be === 0 && this[y + H - 1] !== 0 && (Be = 1), this[y + H] = (m / W >> 0) - Be & 255;\n      return y + I;\n    }, f.prototype.writeIntBE = function(m, y, I, q) {\n      if (m = +m, y = y >>> 0, !q) {\n        const me = Math.pow(2, 8 * I - 1);\n        a(this, m, y, I, me - 1, -me);\n      }\n      let H = I - 1, W = 1, Be = 0;\n      for (this[y + H] = m & 255; --H >= 0 && (W *= 256); )\n        m < 0 && Be === 0 && this[y + H + 1] !== 0 && (Be = 1), this[y + H] = (m / W >> 0) - Be & 255;\n      return y + I;\n    }, f.prototype.writeInt8 = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 1, 127, -128), m < 0 && (m = 255 + m + 1), this[y] = m & 255, y + 1;\n    }, f.prototype.writeInt16LE = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 2, 32767, -32768), this[y] = m & 255, this[y + 1] = m >>> 8, y + 2;\n    }, f.prototype.writeInt16BE = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 2, 32767, -32768), this[y] = m >>> 8, this[y + 1] = m & 255, y + 2;\n    }, f.prototype.writeInt32LE = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 4, 2147483647, -2147483648), this[y] = m & 255, this[y + 1] = m >>> 8, this[y + 2] = m >>> 16, this[y + 3] = m >>> 24, y + 4;\n    }, f.prototype.writeInt32BE = function(m, y, I) {\n      return m = +m, y = y >>> 0, I || a(this, m, y, 4, 2147483647, -2147483648), m < 0 && (m = 4294967295 + m + 1), this[y] = m >>> 24, this[y + 1] = m >>> 16, this[y + 2] = m >>> 8, this[y + 3] = m & 255, y + 4;\n    }, f.prototype.writeBigInt64LE = ct(function(m, y = 0) {\n      return l(this, m, y, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    }), f.prototype.writeBigInt64BE = ct(function(m, y = 0) {\n      return M(this, m, y, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function k(E, m, y, I, q, H) {\n      if (y + I > E.length) throw new RangeError(\"Index out of range\");\n      if (y < 0) throw new RangeError(\"Index out of range\");\n    }\n    function $(E, m, y, I, q) {\n      return m = +m, y = y >>> 0, q || k(E, m, y, 4), r.write(E, m, y, I, 23, 4), y + 4;\n    }\n    f.prototype.writeFloatLE = function(m, y, I) {\n      return $(this, m, y, !0, I);\n    }, f.prototype.writeFloatBE = function(m, y, I) {\n      return $(this, m, y, !1, I);\n    };\n    function X(E, m, y, I, q) {\n      return m = +m, y = y >>> 0, q || k(E, m, y, 8), r.write(E, m, y, I, 52, 8), y + 8;\n    }\n    f.prototype.writeDoubleLE = function(m, y, I) {\n      return X(this, m, y, !0, I);\n    }, f.prototype.writeDoubleBE = function(m, y, I) {\n      return X(this, m, y, !1, I);\n    }, f.prototype.copy = function(m, y, I, q) {\n      if (!f.isBuffer(m)) throw new TypeError(\"argument should be a Buffer\");\n      if (I || (I = 0), !q && q !== 0 && (q = this.length), y >= m.length && (y = m.length), y || (y = 0), q > 0 && q < I && (q = I), q === I || m.length === 0 || this.length === 0) return 0;\n      if (y < 0)\n        throw new RangeError(\"targetStart out of bounds\");\n      if (I < 0 || I >= this.length) throw new RangeError(\"Index out of range\");\n      if (q < 0) throw new RangeError(\"sourceEnd out of bounds\");\n      q > this.length && (q = this.length), m.length - y < q - I && (q = m.length - y + I);\n      const H = q - I;\n      return this === m && typeof Uint8Array.prototype.copyWithin == \"function\" ? this.copyWithin(y, I, q) : Uint8Array.prototype.set.call(\n        m,\n        this.subarray(I, q),\n        y\n      ), H;\n    }, f.prototype.fill = function(m, y, I, q) {\n      if (typeof m == \"string\") {\n        if (typeof y == \"string\" ? (q = y, y = 0, I = this.length) : typeof I == \"string\" && (q = I, I = this.length), q !== void 0 && typeof q != \"string\")\n          throw new TypeError(\"encoding must be a string\");\n        if (typeof q == \"string\" && !f.isEncoding(q))\n          throw new TypeError(\"Unknown encoding: \" + q);\n        if (m.length === 1) {\n          const W = m.charCodeAt(0);\n          (q === \"utf8\" && W < 128 || q === \"latin1\") && (m = W);\n        }\n      } else typeof m == \"number\" ? m = m & 255 : typeof m == \"boolean\" && (m = Number(m));\n      if (y < 0 || this.length < y || this.length < I)\n        throw new RangeError(\"Out of range index\");\n      if (I <= y)\n        return this;\n      y = y >>> 0, I = I === void 0 ? this.length : I >>> 0, m || (m = 0);\n      let H;\n      if (typeof m == \"number\")\n        for (H = y; H < I; ++H)\n          this[H] = m;\n      else {\n        const W = f.isBuffer(m) ? m : f.from(m, q), Be = W.length;\n        if (Be === 0)\n          throw new TypeError('The value \"' + m + '\" is invalid for argument \"value\"');\n        for (H = 0; H < I - y; ++H)\n          this[H + y] = W[H % Be];\n      }\n      return this;\n    };\n    const re = {};\n    function se(E, m, y) {\n      re[E] = class extends y {\n        constructor() {\n          super(), Object.defineProperty(this, \"message\", {\n            value: m.apply(this, arguments),\n            writable: !0,\n            configurable: !0\n          }), this.name = `${this.name} [${E}]`, this.stack, delete this.name;\n        }\n        get code() {\n          return E;\n        }\n        set code(q) {\n          Object.defineProperty(this, \"code\", {\n            configurable: !0,\n            enumerable: !0,\n            value: q,\n            writable: !0\n          });\n        }\n        toString() {\n          return `${this.name} [${E}]: ${this.message}`;\n        }\n      };\n    }\n    se(\n      \"ERR_BUFFER_OUT_OF_BOUNDS\",\n      function(E) {\n        return E ? `${E} is outside of buffer bounds` : \"Attempt to access memory outside buffer bounds\";\n      },\n      RangeError\n    ), se(\n      \"ERR_INVALID_ARG_TYPE\",\n      function(E, m) {\n        return `The \"${E}\" argument must be of type number. Received type ${typeof m}`;\n      },\n      TypeError\n    ), se(\n      \"ERR_OUT_OF_RANGE\",\n      function(E, m, y) {\n        let I = `The value of \"${E}\" is out of range.`, q = y;\n        return Number.isInteger(y) && Math.abs(y) > 2 ** 32 ? q = ut(String(y)) : typeof y == \"bigint\" && (q = String(y), (y > BigInt(2) ** BigInt(32) || y < -(BigInt(2) ** BigInt(32))) && (q = ut(q)), q += \"n\"), I += ` It must be ${m}. Received ${q}`, I;\n      },\n      RangeError\n    );\n    function ut(E) {\n      let m = \"\", y = E.length;\n      const I = E[0] === \"-\" ? 1 : 0;\n      for (; y >= I + 4; y -= 3)\n        m = `_${E.slice(y - 3, y)}${m}`;\n      return `${E.slice(0, y)}${m}`;\n    }\n    function xe(E, m, y) {\n      Xe(m, \"offset\"), (E[m] === void 0 || E[m + y] === void 0) && ae(m, E.length - (y + 1));\n    }\n    function Ie(E, m, y, I, q, H) {\n      if (E > y || E < m) {\n        const W = typeof m == \"bigint\" ? \"n\" : \"\";\n        let Be;\n        throw m === 0 || m === BigInt(0) ? Be = `>= 0${W} and < 2${W} ** ${(H + 1) * 8}${W}` : Be = `>= -(2${W} ** ${(H + 1) * 8 - 1}${W}) and < 2 ** ${(H + 1) * 8 - 1}${W}`, new re.ERR_OUT_OF_RANGE(\"value\", Be, E);\n      }\n      xe(I, q, H);\n    }\n    function Xe(E, m) {\n      if (typeof E != \"number\")\n        throw new re.ERR_INVALID_ARG_TYPE(m, \"number\", E);\n    }\n    function ae(E, m, y) {\n      throw Math.floor(E) !== E ? (Xe(E, y), new re.ERR_OUT_OF_RANGE(\"offset\", \"an integer\", E)) : m < 0 ? new re.ERR_BUFFER_OUT_OF_BOUNDS() : new re.ERR_OUT_OF_RANGE(\n        \"offset\",\n        `>= 0 and <= ${m}`,\n        E\n      );\n    }\n    const ge = /[^+/0-9A-Za-z-_]/g;\n    function it(E) {\n      if (E = E.split(\"=\")[0], E = E.trim().replace(ge, \"\"), E.length < 2) return \"\";\n      for (; E.length % 4 !== 0; )\n        E = E + \"=\";\n      return E;\n    }\n    function we(E, m) {\n      m = m || 1 / 0;\n      let y;\n      const I = E.length;\n      let q = null;\n      const H = [];\n      for (let W = 0; W < I; ++W) {\n        if (y = E.charCodeAt(W), y > 55295 && y < 57344) {\n          if (!q) {\n            if (y > 56319) {\n              (m -= 3) > -1 && H.push(239, 191, 189);\n              continue;\n            } else if (W + 1 === I) {\n              (m -= 3) > -1 && H.push(239, 191, 189);\n              continue;\n            }\n            q = y;\n            continue;\n          }\n          if (y < 56320) {\n            (m -= 3) > -1 && H.push(239, 191, 189), q = y;\n            continue;\n          }\n          y = (q - 55296 << 10 | y - 56320) + 65536;\n        } else q && (m -= 3) > -1 && H.push(239, 191, 189);\n        if (q = null, y < 128) {\n          if ((m -= 1) < 0) break;\n          H.push(y);\n        } else if (y < 2048) {\n          if ((m -= 2) < 0) break;\n          H.push(\n            y >> 6 | 192,\n            y & 63 | 128\n          );\n        } else if (y < 65536) {\n          if ((m -= 3) < 0) break;\n          H.push(\n            y >> 12 | 224,\n            y >> 6 & 63 | 128,\n            y & 63 | 128\n          );\n        } else if (y < 1114112) {\n          if ((m -= 4) < 0) break;\n          H.push(\n            y >> 18 | 240,\n            y >> 12 & 63 | 128,\n            y >> 6 & 63 | 128,\n            y & 63 | 128\n          );\n        } else\n          throw new Error(\"Invalid code point\");\n      }\n      return H;\n    }\n    function Me(E) {\n      const m = [];\n      for (let y = 0; y < E.length; ++y)\n        m.push(E.charCodeAt(y) & 255);\n      return m;\n    }\n    function ft(E, m) {\n      let y, I, q;\n      const H = [];\n      for (let W = 0; W < E.length && !((m -= 2) < 0); ++W)\n        y = E.charCodeAt(W), I = y >> 8, q = y % 256, H.push(q), H.push(I);\n      return H;\n    }\n    function ye(E) {\n      return e.toByteArray(it(E));\n    }\n    function be(E, m, y, I) {\n      let q;\n      for (q = 0; q < I && !(q + y >= m.length || q >= E.length); ++q)\n        m[q + y] = E[q];\n      return q;\n    }\n    function xt(E, m) {\n      return E instanceof m || E != null && E.constructor != null && E.constructor.name != null && E.constructor.name === m.name;\n    }\n    function Se(E) {\n      return E !== E;\n    }\n    const ke = function() {\n      const E = \"0123456789abcdef\", m = new Array(256);\n      for (let y = 0; y < 16; ++y) {\n        const I = y * 16;\n        for (let q = 0; q < 16; ++q)\n          m[I + q] = E[y] + E[q];\n      }\n      return m;\n    }();\n    function ct(E) {\n      return typeof BigInt > \"u\" ? _e : E;\n    }\n    function _e() {\n      throw new Error(\"BigInt not supported\");\n    }\n  }(Ks)), Ks;\n}\nvar et = na();\nconst wn = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction ia(t) {\n  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === \"Uint8Array\";\n}\nfunction To(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(\"positive integer expected, got \" + t);\n}\nfunction ar(t, ...e) {\n  if (!ia(t))\n    throw new Error(\"Uint8Array expected\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new Error(\"Uint8Array expected of length \" + e + \", got length=\" + t.length);\n}\nfunction L0(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.createHasher\");\n  To(t.outputLen), To(t.blockLen);\n}\nfunction ps(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction O0(t, e) {\n  ar(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(\"digestInto() expects output buffer of length at least \" + r);\n}\nfunction On(...t) {\n  for (let e = 0; e < t.length; e++)\n    t[e].fill(0);\n}\nfunction Ws(t) {\n  return new DataView(t.buffer, t.byteOffset, t.byteLength);\n}\nfunction Qt(t, e) {\n  return t << 32 - e | t >>> e;\n}\nconst ac = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == \"function\" && typeof Uint8Array.fromHex == \"function\", N0 = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction Nn(t) {\n  if (ar(t), ac)\n    return t.toHex();\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += N0[t[r]];\n  return e;\n}\nconst fr = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction Na(t) {\n  if (t >= fr._0 && t <= fr._9)\n    return t - fr._0;\n  if (t >= fr.A && t <= fr.F)\n    return t - (fr.A - 10);\n  if (t >= fr.a && t <= fr.f)\n    return t - (fr.a - 10);\n}\nfunction sa(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  if (ac)\n    return Uint8Array.fromHex(t);\n  const e = t.length, r = e / 2;\n  if (e % 2)\n    throw new Error(\"hex string expected, got unpadded hex of length \" + e);\n  const n = new Uint8Array(r);\n  for (let o = 0, i = 0; o < r; o++, i += 2) {\n    const c = Na(t.charCodeAt(i)), f = Na(t.charCodeAt(i + 1));\n    if (c === void 0 || f === void 0) {\n      const v = t[i] + t[i + 1];\n      throw new Error('hex string expected, got non-hex character \"' + v + '\" at index ' + i);\n    }\n    n[o] = c * 16 + f;\n  }\n  return n;\n}\nfunction j0(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"string expected\");\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nfunction oa(t) {\n  return typeof t == \"string\" && (t = j0(t)), ar(t), t;\n}\nfunction vr(...t) {\n  let e = 0;\n  for (let n = 0; n < t.length; n++) {\n    const o = t[n];\n    ar(o), e += o.length;\n  }\n  const r = new Uint8Array(e);\n  for (let n = 0, o = 0; n < t.length; n++) {\n    const i = t[n];\n    r.set(i, o), o += i.length;\n  }\n  return r;\n}\nlet uc = class {\n};\nfunction cc(t) {\n  const e = (n) => t().update(oa(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction lc(t = 32) {\n  if (wn && typeof wn.getRandomValues == \"function\")\n    return wn.getRandomValues(new Uint8Array(t));\n  if (wn && typeof wn.randomBytes == \"function\")\n    return Uint8Array.from(wn.randomBytes(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction U0(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const o = BigInt(32), i = BigInt(4294967295), c = Number(r >> o & i), f = Number(r & i), v = n ? 4 : 0, x = n ? 0 : 4;\n  t.setUint32(e + v, c, n), t.setUint32(e + x, f, n);\n}\nfunction F0(t, e, r) {\n  return t & e ^ ~t & r;\n}\nfunction P0(t, e, r) {\n  return t & e ^ t & r ^ e & r;\n}\nlet fc = class extends uc {\n  constructor(e, r, n, o) {\n    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = o, this.buffer = new Uint8Array(e), this.view = Ws(this.buffer);\n  }\n  update(e) {\n    ps(this), e = oa(e), ar(e);\n    const { view: r, buffer: n, blockLen: o } = this, i = e.length;\n    for (let c = 0; c < i; ) {\n      const f = Math.min(o - this.pos, i - c);\n      if (f === o) {\n        const v = Ws(e);\n        for (; o <= i - c; c += o)\n          this.process(v, c);\n        continue;\n      }\n      n.set(e.subarray(c, c + f), this.pos), this.pos += f, c += f, this.pos === o && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    ps(this), O0(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: o, isLE: i } = this;\n    let { pos: c } = this;\n    r[c++] = 128, On(this.buffer.subarray(c)), this.padOffset > o - c && (this.process(n, 0), c = 0);\n    for (let S = c; S < o; S++)\n      r[S] = 0;\n    U0(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);\n    const f = Ws(e), v = this.outputLen;\n    if (v % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const x = v / 4, b = this.get();\n    if (x > b.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let S = 0; S < x; S++)\n      f.setUint32(4 * S, b[S], i);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: c, pos: f } = this;\n    return e.destroyed = c, e.finished = i, e.length = o, e.pos = f, o % r && e.buffer.set(n), e;\n  }\n  clone() {\n    return this._cloneInto();\n  }\n};\nconst _r = /* @__PURE__ */ Uint32Array.from([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), St = /* @__PURE__ */ Uint32Array.from([\n  1779033703,\n  4089235720,\n  3144134277,\n  2227873595,\n  1013904242,\n  4271175723,\n  2773480762,\n  1595750129,\n  1359893119,\n  2917565137,\n  2600822924,\n  725511199,\n  528734635,\n  4215389547,\n  1541459225,\n  327033209\n]), Zi = /* @__PURE__ */ BigInt(2 ** 32 - 1), ja = /* @__PURE__ */ BigInt(32);\nfunction D0(t, e = !1) {\n  return e ? { h: Number(t & Zi), l: Number(t >> ja & Zi) } : { h: Number(t >> ja & Zi) | 0, l: Number(t & Zi) | 0 };\n}\nfunction $0(t, e = !1) {\n  const r = t.length;\n  let n = new Uint32Array(r), o = new Uint32Array(r);\n  for (let i = 0; i < r; i++) {\n    const { h: c, l: f } = D0(t[i], e);\n    [n[i], o[i]] = [c, f];\n  }\n  return [n, o];\n}\nconst Ua = (t, e, r) => t >>> r, Fa = (t, e, r) => t << 32 - r | e >>> r, xn = (t, e, r) => t >>> r | e << 32 - r, bn = (t, e, r) => t << 32 - r | e >>> r, Vi = (t, e, r) => t << 64 - r | e >>> r - 32, Hi = (t, e, r) => t >>> r - 32 | e << 64 - r;\nfunction hr(t, e, r, n) {\n  const o = (e >>> 0) + (n >>> 0);\n  return { h: t + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };\n}\nconst z0 = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0), q0 = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0, Z0 = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0), V0 = (t, e, r, n, o) => e + r + n + o + (t / 2 ** 32 | 0) | 0, H0 = (t, e, r, n, o) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0), K0 = (t, e, r, n, o, i) => e + r + n + o + i + (t / 2 ** 32 | 0) | 0, W0 = /* @__PURE__ */ Uint32Array.from([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), Er = /* @__PURE__ */ new Uint32Array(64);\nlet G0 = class extends fc {\n  constructor(e = 32) {\n    super(64, e, 8, !1), this.A = _r[0] | 0, this.B = _r[1] | 0, this.C = _r[2] | 0, this.D = _r[3] | 0, this.E = _r[4] | 0, this.F = _r[5] | 0, this.G = _r[6] | 0, this.H = _r[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: o, E: i, F: c, G: f, H: v } = this;\n    return [e, r, n, o, i, c, f, v];\n  }\n  // prettier-ignore\n  set(e, r, n, o, i, c, f, v) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = c | 0, this.G = f | 0, this.H = v | 0;\n  }\n  process(e, r) {\n    for (let S = 0; S < 16; S++, r += 4)\n      Er[S] = e.getUint32(r, !1);\n    for (let S = 16; S < 64; S++) {\n      const T = Er[S - 15], C = Er[S - 2], P = Qt(T, 7) ^ Qt(T, 18) ^ T >>> 3, B = Qt(C, 17) ^ Qt(C, 19) ^ C >>> 10;\n      Er[S] = B + Er[S - 7] + P + Er[S - 16] | 0;\n    }\n    let { A: n, B: o, C: i, D: c, E: f, F: v, G: x, H: b } = this;\n    for (let S = 0; S < 64; S++) {\n      const T = Qt(f, 6) ^ Qt(f, 11) ^ Qt(f, 25), C = b + T + F0(f, v, x) + W0[S] + Er[S] | 0, B = (Qt(n, 2) ^ Qt(n, 13) ^ Qt(n, 22)) + P0(n, o, i) | 0;\n      b = x, x = v, v = f, f = c + C | 0, c = i, i = o, o = n, n = C + B | 0;\n    }\n    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, c = c + this.D | 0, f = f + this.E | 0, v = v + this.F | 0, x = x + this.G | 0, b = b + this.H | 0, this.set(n, o, i, c, f, v, x, b);\n  }\n  roundClean() {\n    On(Er);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), On(this.buffer);\n  }\n};\nconst hc = $0([\n  \"0x428a2f98d728ae22\",\n  \"0x7137449123ef65cd\",\n  \"0xb5c0fbcfec4d3b2f\",\n  \"0xe9b5dba58189dbbc\",\n  \"0x3956c25bf348b538\",\n  \"0x59f111f1b605d019\",\n  \"0x923f82a4af194f9b\",\n  \"0xab1c5ed5da6d8118\",\n  \"0xd807aa98a3030242\",\n  \"0x12835b0145706fbe\",\n  \"0x243185be4ee4b28c\",\n  \"0x550c7dc3d5ffb4e2\",\n  \"0x72be5d74f27b896f\",\n  \"0x80deb1fe3b1696b1\",\n  \"0x9bdc06a725c71235\",\n  \"0xc19bf174cf692694\",\n  \"0xe49b69c19ef14ad2\",\n  \"0xefbe4786384f25e3\",\n  \"0x0fc19dc68b8cd5b5\",\n  \"0x240ca1cc77ac9c65\",\n  \"0x2de92c6f592b0275\",\n  \"0x4a7484aa6ea6e483\",\n  \"0x5cb0a9dcbd41fbd4\",\n  \"0x76f988da831153b5\",\n  \"0x983e5152ee66dfab\",\n  \"0xa831c66d2db43210\",\n  \"0xb00327c898fb213f\",\n  \"0xbf597fc7beef0ee4\",\n  \"0xc6e00bf33da88fc2\",\n  \"0xd5a79147930aa725\",\n  \"0x06ca6351e003826f\",\n  \"0x142929670a0e6e70\",\n  \"0x27b70a8546d22ffc\",\n  \"0x2e1b21385c26c926\",\n  \"0x4d2c6dfc5ac42aed\",\n  \"0x53380d139d95b3df\",\n  \"0x650a73548baf63de\",\n  \"0x766a0abb3c77b2a8\",\n  \"0x81c2c92e47edaee6\",\n  \"0x92722c851482353b\",\n  \"0xa2bfe8a14cf10364\",\n  \"0xa81a664bbc423001\",\n  \"0xc24b8b70d0f89791\",\n  \"0xc76c51a30654be30\",\n  \"0xd192e819d6ef5218\",\n  \"0xd69906245565a910\",\n  \"0xf40e35855771202a\",\n  \"0x106aa07032bbd1b8\",\n  \"0x19a4c116b8d2d0c8\",\n  \"0x1e376c085141ab53\",\n  \"0x2748774cdf8eeb99\",\n  \"0x34b0bcb5e19b48a8\",\n  \"0x391c0cb3c5c95a63\",\n  \"0x4ed8aa4ae3418acb\",\n  \"0x5b9cca4f7763e373\",\n  \"0x682e6ff3d6b2b8a3\",\n  \"0x748f82ee5defb2fc\",\n  \"0x78a5636f43172f60\",\n  \"0x84c87814a1f0ab72\",\n  \"0x8cc702081a6439ec\",\n  \"0x90befffa23631e28\",\n  \"0xa4506cebde82bde9\",\n  \"0xbef9a3f7b2c67915\",\n  \"0xc67178f2e372532b\",\n  \"0xca273eceea26619c\",\n  \"0xd186b8c721c0c207\",\n  \"0xeada7dd6cde0eb1e\",\n  \"0xf57d4f7fee6ed178\",\n  \"0x06f067aa72176fba\",\n  \"0x0a637dc5a2c898a6\",\n  \"0x113f9804bef90dae\",\n  \"0x1b710b35131c471b\",\n  \"0x28db77f523047d84\",\n  \"0x32caab7b40c72493\",\n  \"0x3c9ebe0a15c9bebc\",\n  \"0x431d67c49c100d4c\",\n  \"0x4cc5d4becb3e42b6\",\n  \"0x597f299cfc657e2a\",\n  \"0x5fcb6fab3ad6faec\",\n  \"0x6c44198c4a475817\"\n].map((t) => BigInt(t))), Y0 = hc[0], J0 = hc[1], Mr = /* @__PURE__ */ new Uint32Array(80), Cr = /* @__PURE__ */ new Uint32Array(80);\nclass X0 extends fc {\n  constructor(e = 64) {\n    super(128, e, 16, !1), this.Ah = St[0] | 0, this.Al = St[1] | 0, this.Bh = St[2] | 0, this.Bl = St[3] | 0, this.Ch = St[4] | 0, this.Cl = St[5] | 0, this.Dh = St[6] | 0, this.Dl = St[7] | 0, this.Eh = St[8] | 0, this.El = St[9] | 0, this.Fh = St[10] | 0, this.Fl = St[11] | 0, this.Gh = St[12] | 0, this.Gl = St[13] | 0, this.Hh = St[14] | 0, this.Hl = St[15] | 0;\n  }\n  // prettier-ignore\n  get() {\n    const { Ah: e, Al: r, Bh: n, Bl: o, Ch: i, Cl: c, Dh: f, Dl: v, Eh: x, El: b, Fh: S, Fl: T, Gh: C, Gl: P, Hh: B, Hl: R } = this;\n    return [e, r, n, o, i, c, f, v, x, b, S, T, C, P, B, R];\n  }\n  // prettier-ignore\n  set(e, r, n, o, i, c, f, v, x, b, S, T, C, P, B, R) {\n    this.Ah = e | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = i | 0, this.Cl = c | 0, this.Dh = f | 0, this.Dl = v | 0, this.Eh = x | 0, this.El = b | 0, this.Fh = S | 0, this.Fl = T | 0, this.Gh = C | 0, this.Gl = P | 0, this.Hh = B | 0, this.Hl = R | 0;\n  }\n  process(e, r) {\n    for (let Z = 0; Z < 16; Z++, r += 4)\n      Mr[Z] = e.getUint32(r), Cr[Z] = e.getUint32(r += 4);\n    for (let Z = 16; Z < 80; Z++) {\n      const Q = Mr[Z - 15] | 0, j = Cr[Z - 15] | 0, V = xn(Q, j, 1) ^ xn(Q, j, 8) ^ Ua(Q, j, 7), ee = bn(Q, j, 1) ^ bn(Q, j, 8) ^ Fa(Q, j, 7), G = Mr[Z - 2] | 0, N = Cr[Z - 2] | 0, O = xn(G, N, 19) ^ Vi(G, N, 61) ^ Ua(G, N, 6), L = bn(G, N, 19) ^ Hi(G, N, 61) ^ Fa(G, N, 6), F = Z0(ee, L, Cr[Z - 7], Cr[Z - 16]), d = V0(F, V, O, Mr[Z - 7], Mr[Z - 16]);\n      Mr[Z] = d | 0, Cr[Z] = F | 0;\n    }\n    let { Ah: n, Al: o, Bh: i, Bl: c, Ch: f, Cl: v, Dh: x, Dl: b, Eh: S, El: T, Fh: C, Fl: P, Gh: B, Gl: R, Hh: z, Hl: K } = this;\n    for (let Z = 0; Z < 80; Z++) {\n      const Q = xn(S, T, 14) ^ xn(S, T, 18) ^ Vi(S, T, 41), j = bn(S, T, 14) ^ bn(S, T, 18) ^ Hi(S, T, 41), V = S & C ^ ~S & B, ee = T & P ^ ~T & R, G = H0(K, j, ee, J0[Z], Cr[Z]), N = K0(G, z, Q, V, Y0[Z], Mr[Z]), O = G | 0, L = xn(n, o, 28) ^ Vi(n, o, 34) ^ Vi(n, o, 39), F = bn(n, o, 28) ^ Hi(n, o, 34) ^ Hi(n, o, 39), d = n & i ^ n & f ^ i & f, s = o & c ^ o & v ^ c & v;\n      z = B | 0, K = R | 0, B = C | 0, R = P | 0, C = S | 0, P = T | 0, { h: S, l: T } = hr(x | 0, b | 0, N | 0, O | 0), x = f | 0, b = v | 0, f = i | 0, v = c | 0, i = n | 0, c = o | 0;\n      const u = z0(O, F, s);\n      n = q0(u, N, L, d), o = u | 0;\n    }\n    ({ h: n, l: o } = hr(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: i, l: c } = hr(this.Bh | 0, this.Bl | 0, i | 0, c | 0), { h: f, l: v } = hr(this.Ch | 0, this.Cl | 0, f | 0, v | 0), { h: x, l: b } = hr(this.Dh | 0, this.Dl | 0, x | 0, b | 0), { h: S, l: T } = hr(this.Eh | 0, this.El | 0, S | 0, T | 0), { h: C, l: P } = hr(this.Fh | 0, this.Fl | 0, C | 0, P | 0), { h: B, l: R } = hr(this.Gh | 0, this.Gl | 0, B | 0, R | 0), { h: z, l: K } = hr(this.Hh | 0, this.Hl | 0, z | 0, K | 0), this.set(n, o, i, c, f, v, x, b, S, T, C, P, B, R, z, K);\n  }\n  roundClean() {\n    On(Mr, Cr);\n  }\n  destroy() {\n    On(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\nconst Q0 = /* @__PURE__ */ cc(() => new G0()), eh = /* @__PURE__ */ cc(() => new X0());\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst aa = /* @__PURE__ */ BigInt(0), Lo = /* @__PURE__ */ BigInt(1);\nfunction fn(t, e) {\n  if (typeof e != \"boolean\")\n    throw new Error(t + \" boolean expected, got \" + e);\n}\nfunction Ki(t) {\n  const e = t.toString(16);\n  return e.length & 1 ? \"0\" + e : e;\n}\nfunction dc(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  return t === \"\" ? aa : BigInt(\"0x\" + t);\n}\nfunction Ls(t) {\n  return dc(Nn(t));\n}\nfunction wi(t) {\n  return ar(t), dc(Nn(Uint8Array.from(t).reverse()));\n}\nfunction ua(t, e) {\n  return sa(t.toString(16).padStart(e * 2, \"0\"));\n}\nfunction Os(t, e) {\n  return ua(t, e).reverse();\n}\nfunction vt(t, e, r) {\n  let n;\n  if (typeof e == \"string\")\n    try {\n      n = sa(e);\n    } catch (i) {\n      throw new Error(t + \" must be hex string or Uint8Array, cause: \" + i);\n    }\n  else if (ia(e))\n    n = Uint8Array.from(e);\n  else\n    throw new Error(t + \" must be hex string or Uint8Array\");\n  const o = n.length;\n  if (typeof r == \"number\" && o !== r)\n    throw new Error(t + \" of length \" + r + \" expected, got \" + o);\n  return n;\n}\nconst Gs = (t) => typeof t == \"bigint\" && aa <= t;\nfunction th(t, e, r) {\n  return Gs(t) && Gs(e) && Gs(r) && e <= t && t < r;\n}\nfunction Sn(t, e, r, n) {\n  if (!th(e, r, n))\n    throw new Error(\"expected valid \" + t + \": \" + r + \" <= n < \" + n + \", got \" + e);\n}\nfunction rh(t) {\n  let e;\n  for (e = 0; t > aa; t >>= Lo, e += 1)\n    ;\n  return e;\n}\nconst Ns = (t) => (Lo << BigInt(t)) - Lo;\nfunction nh(t, e, r) {\n  if (typeof t != \"number\" || t < 2)\n    throw new Error(\"hashLen must be a number\");\n  if (typeof e != \"number\" || e < 2)\n    throw new Error(\"qByteLen must be a number\");\n  if (typeof r != \"function\")\n    throw new Error(\"hmacFn must be a function\");\n  const n = (C) => new Uint8Array(C), o = (C) => Uint8Array.of(C);\n  let i = n(t), c = n(t), f = 0;\n  const v = () => {\n    i.fill(1), c.fill(0), f = 0;\n  }, x = (...C) => r(c, i, ...C), b = (C = n(0)) => {\n    c = x(o(0), C), i = x(), C.length !== 0 && (c = x(o(1), C), i = x());\n  }, S = () => {\n    if (f++ >= 1e3)\n      throw new Error(\"drbg: tried 1000 values\");\n    let C = 0;\n    const P = [];\n    for (; C < e; ) {\n      i = x();\n      const B = i.slice();\n      P.push(B), C += i.length;\n    }\n    return vr(...P);\n  };\n  return (C, P) => {\n    v(), b(C);\n    let B;\n    for (; !(B = P(S())); )\n      b();\n    return v(), B;\n  };\n}\nfunction Ui(t, e, r = {}) {\n  if (!t || typeof t != \"object\")\n    throw new Error(\"expected valid options object\");\n  function n(o, i, c) {\n    const f = t[o];\n    if (c && f === void 0)\n      return;\n    const v = typeof f;\n    if (v !== i || f === null)\n      throw new Error(`param \"${o}\" is invalid: expected ${i}, got ${v}`);\n  }\n  Object.entries(e).forEach(([o, i]) => n(o, i, !1)), Object.entries(r).forEach(([o, i]) => n(o, i, !0));\n}\nfunction ms(t) {\n  const e = /* @__PURE__ */ new WeakMap();\n  return (r, ...n) => {\n    const o = e.get(r);\n    if (o !== void 0)\n      return o;\n    const i = t(r, ...n);\n    return e.set(r, i), i;\n  };\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Ft = BigInt(0), Ct = BigInt(1), sn = /* @__PURE__ */ BigInt(2), ih = /* @__PURE__ */ BigInt(3), pc = /* @__PURE__ */ BigInt(4), mc = /* @__PURE__ */ BigInt(5), gc = /* @__PURE__ */ BigInt(8);\nfunction wt(t, e) {\n  const r = t % e;\n  return r >= Ft ? r : e + r;\n}\nfunction pt(t, e, r) {\n  let n = t;\n  for (; e-- > Ft; )\n    n *= n, n %= r;\n  return n;\n}\nfunction Pa(t, e) {\n  if (t === Ft)\n    throw new Error(\"invert: expected non-zero number\");\n  if (e <= Ft)\n    throw new Error(\"invert: expected positive modulus, got \" + e);\n  let r = wt(t, e), n = e, o = Ft, i = Ct;\n  for (; r !== Ft; ) {\n    const f = n / r, v = n % r, x = o - i * f;\n    n = r, r = v, o = i, i = x;\n  }\n  if (n !== Ct)\n    throw new Error(\"invert: does not exist\");\n  return wt(o, e);\n}\nfunction yc(t, e) {\n  const r = (t.ORDER + Ct) / pc, n = t.pow(e, r);\n  if (!t.eql(t.sqr(n), e))\n    throw new Error(\"Cannot find square root\");\n  return n;\n}\nfunction sh(t, e) {\n  const r = (t.ORDER - mc) / gc, n = t.mul(e, sn), o = t.pow(n, r), i = t.mul(e, o), c = t.mul(t.mul(i, sn), o), f = t.mul(i, t.sub(c, t.ONE));\n  if (!t.eql(t.sqr(f), e))\n    throw new Error(\"Cannot find square root\");\n  return f;\n}\nfunction oh(t) {\n  if (t < BigInt(3))\n    throw new Error(\"sqrt is not defined for small field\");\n  let e = t - Ct, r = 0;\n  for (; e % sn === Ft; )\n    e /= sn, r++;\n  let n = sn;\n  const o = $n(t);\n  for (; Da(o, n) === 1; )\n    if (n++ > 1e3)\n      throw new Error(\"Cannot find square root: probably non-prime P\");\n  if (r === 1)\n    return yc;\n  let i = o.pow(n, e);\n  const c = (e + Ct) / sn;\n  return function(v, x) {\n    if (v.is0(x))\n      return x;\n    if (Da(v, x) !== 1)\n      throw new Error(\"Cannot find square root\");\n    let b = r, S = v.mul(v.ONE, i), T = v.pow(x, e), C = v.pow(x, c);\n    for (; !v.eql(T, v.ONE); ) {\n      if (v.is0(T))\n        return v.ZERO;\n      let P = 1, B = v.sqr(T);\n      for (; !v.eql(B, v.ONE); )\n        if (P++, B = v.sqr(B), P === b)\n          throw new Error(\"Cannot find square root\");\n      const R = Ct << BigInt(b - P - 1), z = v.pow(S, R);\n      b = P, S = v.sqr(z), T = v.mul(T, S), C = v.mul(C, z);\n    }\n    return C;\n  };\n}\nfunction ah(t) {\n  return t % pc === ih ? yc : t % gc === mc ? sh : oh(t);\n}\nconst uh = (t, e) => (wt(t, e) & Ct) === Ct, ch = [\n  \"create\",\n  \"isValid\",\n  \"is0\",\n  \"neg\",\n  \"inv\",\n  \"sqrt\",\n  \"sqr\",\n  \"eql\",\n  \"add\",\n  \"sub\",\n  \"mul\",\n  \"pow\",\n  \"div\",\n  \"addN\",\n  \"subN\",\n  \"mulN\",\n  \"sqrN\"\n];\nfunction lh(t) {\n  const e = {\n    ORDER: \"bigint\",\n    MASK: \"bigint\",\n    BYTES: \"number\",\n    BITS: \"number\"\n  }, r = ch.reduce((n, o) => (n[o] = \"function\", n), e);\n  return Ui(t, r), t;\n}\nfunction fh(t, e, r) {\n  if (r < Ft)\n    throw new Error(\"invalid exponent, negatives unsupported\");\n  if (r === Ft)\n    return t.ONE;\n  if (r === Ct)\n    return e;\n  let n = t.ONE, o = e;\n  for (; r > Ft; )\n    r & Ct && (n = t.mul(n, o)), o = t.sqr(o), r >>= Ct;\n  return n;\n}\nfunction vc(t, e, r = !1) {\n  const n = new Array(e.length).fill(r ? t.ZERO : void 0), o = e.reduce((c, f, v) => t.is0(f) ? c : (n[v] = c, t.mul(c, f)), t.ONE), i = t.inv(o);\n  return e.reduceRight((c, f, v) => t.is0(f) ? c : (n[v] = t.mul(c, n[v]), t.mul(c, f)), i), n;\n}\nfunction Da(t, e) {\n  const r = (t.ORDER - Ct) / sn, n = t.pow(e, r), o = t.eql(n, t.ONE), i = t.eql(n, t.ZERO), c = t.eql(n, t.neg(t.ONE));\n  if (!o && !i && !c)\n    throw new Error(\"invalid Legendre symbol result\");\n  return o ? 1 : i ? 0 : -1;\n}\nfunction hh(t, e) {\n  e !== void 0 && To(e);\n  const r = e !== void 0 ? e : t.toString(2).length, n = Math.ceil(r / 8);\n  return { nBitLength: r, nByteLength: n };\n}\nfunction $n(t, e, r = !1, n = {}) {\n  if (t <= Ft)\n    throw new Error(\"invalid field: expected ORDER > 0, got \" + t);\n  let o, i;\n  if (typeof e == \"object\" && e != null) {\n    if (n.sqrt || r)\n      throw new Error(\"cannot specify opts in two arguments\");\n    const b = e;\n    b.BITS && (o = b.BITS), b.sqrt && (i = b.sqrt), typeof b.isLE == \"boolean\" && (r = b.isLE);\n  } else\n    typeof e == \"number\" && (o = e), n.sqrt && (i = n.sqrt);\n  const { nBitLength: c, nByteLength: f } = hh(t, o);\n  if (f > 2048)\n    throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n  let v;\n  const x = Object.freeze({\n    ORDER: t,\n    isLE: r,\n    BITS: c,\n    BYTES: f,\n    MASK: Ns(c),\n    ZERO: Ft,\n    ONE: Ct,\n    create: (b) => wt(b, t),\n    isValid: (b) => {\n      if (typeof b != \"bigint\")\n        throw new Error(\"invalid field element: expected bigint, got \" + typeof b);\n      return Ft <= b && b < t;\n    },\n    is0: (b) => b === Ft,\n    // is valid and invertible\n    isValidNot0: (b) => !x.is0(b) && x.isValid(b),\n    isOdd: (b) => (b & Ct) === Ct,\n    neg: (b) => wt(-b, t),\n    eql: (b, S) => b === S,\n    sqr: (b) => wt(b * b, t),\n    add: (b, S) => wt(b + S, t),\n    sub: (b, S) => wt(b - S, t),\n    mul: (b, S) => wt(b * S, t),\n    pow: (b, S) => fh(x, b, S),\n    div: (b, S) => wt(b * Pa(S, t), t),\n    // Same as above, but doesn't normalize\n    sqrN: (b) => b * b,\n    addN: (b, S) => b + S,\n    subN: (b, S) => b - S,\n    mulN: (b, S) => b * S,\n    inv: (b) => Pa(b, t),\n    sqrt: i || ((b) => (v || (v = ah(t)), v(x, b))),\n    toBytes: (b) => r ? Os(b, f) : ua(b, f),\n    fromBytes: (b) => {\n      if (b.length !== f)\n        throw new Error(\"Field.fromBytes: expected \" + f + \" bytes, got \" + b.length);\n      return r ? wi(b) : Ls(b);\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: (b) => vc(x, b),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (b, S, T) => T ? S : b\n  });\n  return Object.freeze(x);\n}\nfunction wc(t) {\n  if (typeof t != \"bigint\")\n    throw new Error(\"field order must be bigint\");\n  const e = t.toString(2).length;\n  return Math.ceil(e / 8);\n}\nfunction xc(t) {\n  const e = wc(t);\n  return e + Math.ceil(e / 2);\n}\nfunction dh(t, e, r = !1) {\n  const n = t.length, o = wc(e), i = xc(e);\n  if (n < 16 || n < i || n > 1024)\n    throw new Error(\"expected \" + i + \"-1024 bytes of input, got \" + n);\n  const c = r ? wi(t) : Ls(t), f = wt(c, e - Ct) + Ct;\n  return r ? Os(f, o) : ua(f, o);\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst jn = BigInt(0), on = BigInt(1);\nfunction ni(t, e) {\n  const r = e.negate();\n  return t ? r : e;\n}\nfunction bc(t, e, r) {\n  const n = e === \"pz\" ? (c) => c.pz : (c) => c.ez, o = vc(t.Fp, r.map(n));\n  return r.map((c, f) => c.toAffine(o[f])).map(t.fromAffine);\n}\nfunction _c(t, e) {\n  if (!Number.isSafeInteger(t) || t <= 0 || t > e)\n    throw new Error(\"invalid window size, expected [1..\" + e + \"], got W=\" + t);\n}\nfunction Ys(t, e) {\n  _c(t, e);\n  const r = Math.ceil(e / t) + 1, n = 2 ** (t - 1), o = 2 ** t, i = Ns(t), c = BigInt(t);\n  return { windows: r, windowSize: n, mask: i, maxNumber: o, shiftBy: c };\n}\nfunction $a(t, e, r) {\n  const { windowSize: n, mask: o, maxNumber: i, shiftBy: c } = r;\n  let f = Number(t & o), v = t >> c;\n  f > n && (f -= i, v += on);\n  const x = e * n, b = x + Math.abs(f) - 1, S = f === 0, T = f < 0, C = e % 2 !== 0;\n  return { nextN: v, offset: b, isZero: S, isNeg: T, isNegF: C, offsetF: x };\n}\nfunction ph(t, e) {\n  if (!Array.isArray(t))\n    throw new Error(\"array expected\");\n  t.forEach((r, n) => {\n    if (!(r instanceof e))\n      throw new Error(\"invalid point at index \" + n);\n  });\n}\nfunction mh(t, e) {\n  if (!Array.isArray(t))\n    throw new Error(\"array of scalars expected\");\n  t.forEach((r, n) => {\n    if (!e.isValid(r))\n      throw new Error(\"invalid scalar at index \" + n);\n  });\n}\nconst Js = /* @__PURE__ */ new WeakMap(), Ec = /* @__PURE__ */ new WeakMap();\nfunction Xs(t) {\n  return Ec.get(t) || 1;\n}\nfunction za(t) {\n  if (t !== jn)\n    throw new Error(\"invalid wNAF\");\n}\nfunction Mc(t, e) {\n  return {\n    constTimeNegate: ni,\n    hasPrecomputes(r) {\n      return Xs(r) !== 1;\n    },\n    // non-const time multiplication ladder\n    unsafeLadder(r, n, o = t.ZERO) {\n      let i = r;\n      for (; n > jn; )\n        n & on && (o = o.add(i)), i = i.double(), n >>= on;\n      return o;\n    },\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(r, n) {\n      const { windows: o, windowSize: i } = Ys(n, e), c = [];\n      let f = r, v = f;\n      for (let x = 0; x < o; x++) {\n        v = f, c.push(v);\n        for (let b = 1; b < i; b++)\n          v = v.add(f), c.push(v);\n        f = v.double();\n      }\n      return c;\n    },\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(r, n, o) {\n      let i = t.ZERO, c = t.BASE;\n      const f = Ys(r, e);\n      for (let v = 0; v < f.windows; v++) {\n        const { nextN: x, offset: b, isZero: S, isNeg: T, isNegF: C, offsetF: P } = $a(o, v, f);\n        o = x, S ? c = c.add(ni(C, n[P])) : i = i.add(ni(T, n[b]));\n      }\n      return za(o), { p: i, f: c };\n    },\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(r, n, o, i = t.ZERO) {\n      const c = Ys(r, e);\n      for (let f = 0; f < c.windows && o !== jn; f++) {\n        const { nextN: v, offset: x, isZero: b, isNeg: S } = $a(o, f, c);\n        if (o = v, !b) {\n          const T = n[x];\n          i = i.add(S ? T.negate() : T);\n        }\n      }\n      return za(o), i;\n    },\n    getPrecomputes(r, n, o) {\n      let i = Js.get(n);\n      return i || (i = this.precomputeWindow(n, r), r !== 1 && (typeof o == \"function\" && (i = o(i)), Js.set(n, i))), i;\n    },\n    wNAFCached(r, n, o) {\n      const i = Xs(r);\n      return this.wNAF(i, this.getPrecomputes(i, r, o), n);\n    },\n    wNAFCachedUnsafe(r, n, o, i) {\n      const c = Xs(r);\n      return c === 1 ? this.unsafeLadder(r, n, i) : this.wNAFUnsafe(c, this.getPrecomputes(c, r, o), n, i);\n    },\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    setWindowSize(r, n) {\n      _c(n, e), Ec.set(r, n), Js.delete(r);\n    }\n  };\n}\nfunction gh(t, e, r, n) {\n  let o = e, i = t.ZERO, c = t.ZERO;\n  for (; r > jn || n > jn; )\n    r & on && (i = i.add(o)), n & on && (c = c.add(o)), o = o.double(), r >>= on, n >>= on;\n  return { p1: i, p2: c };\n}\nfunction Cc(t, e, r, n) {\n  ph(r, t), mh(n, e);\n  const o = r.length, i = n.length;\n  if (o !== i)\n    throw new Error(\"arrays of points and scalars must have equal length\");\n  const c = t.ZERO, f = rh(BigInt(o));\n  let v = 1;\n  f > 12 ? v = f - 3 : f > 4 ? v = f - 2 : f > 0 && (v = 2);\n  const x = Ns(v), b = new Array(Number(x) + 1).fill(c), S = Math.floor((e.BITS - 1) / v) * v;\n  let T = c;\n  for (let C = S; C >= 0; C -= v) {\n    b.fill(c);\n    for (let B = 0; B < i; B++) {\n      const R = n[B], z = Number(R >> BigInt(C) & x);\n      b[z] = b[z].add(r[B]);\n    }\n    let P = c;\n    for (let B = b.length - 1, R = c; B > 0; B--)\n      R = R.add(b[B]), P = P.add(R);\n    if (T = T.add(P), C !== 0)\n      for (let B = 0; B < v; B++)\n        T = T.double();\n  }\n  return T;\n}\nfunction qa(t, e) {\n  if (e) {\n    if (e.ORDER !== t)\n      throw new Error(\"Field.ORDER must match order: Fp == p, Fn == n\");\n    return lh(e), e;\n  } else\n    return $n(t);\n}\nfunction Sc(t, e, r = {}) {\n  if (!e || typeof e != \"object\")\n    throw new Error(`expected valid ${t} CURVE object`);\n  for (const f of [\"p\", \"n\", \"h\"]) {\n    const v = e[f];\n    if (!(typeof v == \"bigint\" && v > jn))\n      throw new Error(`CURVE.${f} must be positive bigint`);\n  }\n  const n = qa(e.p, r.Fp), o = qa(e.n, r.Fn), c = [\"Gx\", \"Gy\", \"a\", t === \"weierstrass\" ? \"b\" : \"d\"];\n  for (const f of c)\n    if (!n.isValid(e[f]))\n      throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);\n  return { Fp: n, Fn: o };\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst tr = BigInt(0), Ot = BigInt(1), Qs = BigInt(2), yh = BigInt(8), vh = { zip215: !0 };\nfunction wh(t, e, r, n) {\n  const o = t.sqr(r), i = t.sqr(n), c = t.add(t.mul(e.a, o), i), f = t.add(t.ONE, t.mul(e.d, t.mul(o, i)));\n  return t.eql(c, f);\n}\nfunction xh(t, e = {}) {\n  const { Fp: r, Fn: n } = Sc(\"edwards\", t, e), { h: o, n: i } = t;\n  Ui(e, {}, { uvRatio: \"function\" });\n  const c = Qs << BigInt(n.BYTES * 8) - Ot, f = (B) => r.create(B), v = e.uvRatio || ((B, R) => {\n    try {\n      return { isValid: !0, value: r.sqrt(r.div(B, R)) };\n    } catch {\n      return { isValid: !1, value: tr };\n    }\n  });\n  if (!wh(r, t, t.Gx, t.Gy))\n    throw new Error(\"bad curve params: generator point\");\n  function x(B, R, z = !1) {\n    const K = z ? Ot : tr;\n    return Sn(\"coordinate \" + B, R, K, c), R;\n  }\n  function b(B) {\n    if (!(B instanceof C))\n      throw new Error(\"ExtendedPoint expected\");\n  }\n  const S = ms((B, R) => {\n    const { ex: z, ey: K, ez: Z } = B, Q = B.is0();\n    R == null && (R = Q ? yh : r.inv(Z));\n    const j = f(z * R), V = f(K * R), ee = f(Z * R);\n    if (Q)\n      return { x: tr, y: Ot };\n    if (ee !== Ot)\n      throw new Error(\"invZ was invalid\");\n    return { x: j, y: V };\n  }), T = ms((B) => {\n    const { a: R, d: z } = t;\n    if (B.is0())\n      throw new Error(\"bad point: ZERO\");\n    const { ex: K, ey: Z, ez: Q, et: j } = B, V = f(K * K), ee = f(Z * Z), G = f(Q * Q), N = f(G * G), O = f(V * R), L = f(G * f(O + ee)), F = f(N + f(z * f(V * ee)));\n    if (L !== F)\n      throw new Error(\"bad point: equation left != right (1)\");\n    const d = f(K * Z), s = f(Q * j);\n    if (d !== s)\n      throw new Error(\"bad point: equation left != right (2)\");\n    return !0;\n  });\n  class C {\n    constructor(R, z, K, Z) {\n      this.ex = x(\"x\", R), this.ey = x(\"y\", z), this.ez = x(\"z\", K, !0), this.et = x(\"t\", Z), Object.freeze(this);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static fromAffine(R) {\n      if (R instanceof C)\n        throw new Error(\"extended point not allowed\");\n      const { x: z, y: K } = R || {};\n      return x(\"x\", z), x(\"y\", K), new C(z, K, Ot, f(z * K));\n    }\n    static normalizeZ(R) {\n      return bc(C, \"ez\", R);\n    }\n    // Multiscalar Multiplication\n    static msm(R, z) {\n      return Cc(C, n, R, z);\n    }\n    // \"Private method\", don't use it directly\n    _setWindowSize(R) {\n      this.precompute(R);\n    }\n    precompute(R = 8, z = !0) {\n      return P.setWindowSize(this, R), z || this.multiply(Qs), this;\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity() {\n      T(this);\n    }\n    // Compare one point to another.\n    equals(R) {\n      b(R);\n      const { ex: z, ey: K, ez: Z } = this, { ex: Q, ey: j, ez: V } = R, ee = f(z * V), G = f(Q * Z), N = f(K * V), O = f(j * Z);\n      return ee === G && N === O;\n    }\n    is0() {\n      return this.equals(C.ZERO);\n    }\n    negate() {\n      return new C(f(-this.ex), this.ey, this.ez, f(-this.et));\n    }\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double() {\n      const { a: R } = t, { ex: z, ey: K, ez: Z } = this, Q = f(z * z), j = f(K * K), V = f(Qs * f(Z * Z)), ee = f(R * Q), G = z + K, N = f(f(G * G) - Q - j), O = ee + j, L = O - V, F = ee - j, d = f(N * L), s = f(O * F), u = f(N * F), h = f(L * O);\n      return new C(d, s, h, u);\n    }\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(R) {\n      b(R);\n      const { a: z, d: K } = t, { ex: Z, ey: Q, ez: j, et: V } = this, { ex: ee, ey: G, ez: N, et: O } = R, L = f(Z * ee), F = f(Q * G), d = f(V * K * O), s = f(j * N), u = f((Z + Q) * (ee + G) - L - F), h = s - d, g = s + d, w = f(F - z * L), _ = f(u * h), A = f(g * w), p = f(u * w), a = f(h * g);\n      return new C(_, A, a, p);\n    }\n    subtract(R) {\n      return this.add(R.negate());\n    }\n    // Constant-time multiplication.\n    multiply(R) {\n      const z = R;\n      Sn(\"scalar\", z, Ot, i);\n      const { p: K, f: Z } = P.wNAFCached(this, z, C.normalizeZ);\n      return C.normalizeZ([K, Z])[0];\n    }\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(R, z = C.ZERO) {\n      const K = R;\n      return Sn(\"scalar\", K, tr, i), K === tr ? C.ZERO : this.is0() || K === Ot ? this : P.wNAFCachedUnsafe(this, K, C.normalizeZ, z);\n    }\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder() {\n      return this.multiplyUnsafe(o).is0();\n    }\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree() {\n      return P.wNAFCachedUnsafe(this, i).is0();\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(R) {\n      return S(this, R);\n    }\n    clearCofactor() {\n      return o === Ot ? this : this.multiplyUnsafe(o);\n    }\n    static fromBytes(R, z = !1) {\n      return ar(R), this.fromHex(R, z);\n    }\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(R, z = !1) {\n      const { d: K, a: Z } = t, Q = r.BYTES;\n      R = vt(\"pointHex\", R, Q), fn(\"zip215\", z);\n      const j = R.slice(), V = R[Q - 1];\n      j[Q - 1] = V & -129;\n      const ee = wi(j), G = z ? c : r.ORDER;\n      Sn(\"pointHex.y\", ee, tr, G);\n      const N = f(ee * ee), O = f(N - Ot), L = f(K * N - Z);\n      let { isValid: F, value: d } = v(O, L);\n      if (!F)\n        throw new Error(\"Point.fromHex: invalid y coordinate\");\n      const s = (d & Ot) === Ot, u = (V & 128) !== 0;\n      if (!z && d === tr && u)\n        throw new Error(\"Point.fromHex: x=0 and x_0=1\");\n      return u !== s && (d = f(-d)), C.fromAffine({ x: d, y: ee });\n    }\n    static fromPrivateScalar(R) {\n      return C.BASE.multiply(R);\n    }\n    toBytes() {\n      const { x: R, y: z } = this.toAffine(), K = Os(z, r.BYTES);\n      return K[K.length - 1] |= R & Ot ? 128 : 0, K;\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes() {\n      return this.toBytes();\n    }\n    toHex() {\n      return Nn(this.toBytes());\n    }\n    toString() {\n      return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n    }\n  }\n  C.BASE = new C(t.Gx, t.Gy, Ot, f(t.Gx * t.Gy)), C.ZERO = new C(tr, Ot, Ot, tr), C.Fp = r, C.Fn = n;\n  const P = Mc(C, n.BYTES * 8);\n  return C;\n}\nfunction bh(t, e) {\n  Ui(e, {\n    hash: \"function\"\n  }, {\n    adjustScalarBytes: \"function\",\n    randomBytes: \"function\",\n    domain: \"function\",\n    prehash: \"function\",\n    mapToCurve: \"function\"\n  });\n  const { prehash: r, hash: n } = e, { BASE: o, Fp: i, Fn: c } = t, f = c.ORDER, v = e.randomBytes || lc, x = e.adjustScalarBytes || ((j) => j), b = e.domain || ((j, V, ee) => {\n    if (fn(\"phflag\", ee), V.length || ee)\n      throw new Error(\"Contexts/pre-hash are not supported\");\n    return j;\n  });\n  function S(j) {\n    return c.create(j);\n  }\n  function T(j) {\n    return S(wi(j));\n  }\n  function C(j) {\n    const V = i.BYTES;\n    j = vt(\"private key\", j, V);\n    const ee = vt(\"hashed private key\", n(j), 2 * V), G = x(ee.slice(0, V)), N = ee.slice(V, 2 * V), O = T(G);\n    return { head: G, prefix: N, scalar: O };\n  }\n  function P(j) {\n    const { head: V, prefix: ee, scalar: G } = C(j), N = o.multiply(G), O = N.toBytes();\n    return { head: V, prefix: ee, scalar: G, point: N, pointBytes: O };\n  }\n  function B(j) {\n    return P(j).pointBytes;\n  }\n  function R(j = Uint8Array.of(), ...V) {\n    const ee = vr(...V);\n    return T(n(b(ee, vt(\"context\", j), !!r)));\n  }\n  function z(j, V, ee = {}) {\n    j = vt(\"message\", j), r && (j = r(j));\n    const { prefix: G, scalar: N, pointBytes: O } = P(V), L = R(ee.context, G, j), F = o.multiply(L).toBytes(), d = R(ee.context, F, O, j), s = S(L + d * N);\n    Sn(\"signature.s\", s, tr, f);\n    const u = i.BYTES, h = vr(F, Os(s, u));\n    return vt(\"result\", h, u * 2);\n  }\n  const K = vh;\n  function Z(j, V, ee, G = K) {\n    const { context: N, zip215: O } = G, L = i.BYTES;\n    j = vt(\"signature\", j, 2 * L), V = vt(\"message\", V), ee = vt(\"publicKey\", ee, L), O !== void 0 && fn(\"zip215\", O), r && (V = r(V));\n    const F = wi(j.slice(L, 2 * L));\n    let d, s, u;\n    try {\n      d = t.fromHex(ee, O), s = t.fromHex(j.slice(0, L), O), u = o.multiplyUnsafe(F);\n    } catch {\n      return !1;\n    }\n    if (!O && d.isSmallOrder())\n      return !1;\n    const h = R(N, s.toBytes(), d.toBytes(), V);\n    return s.add(d.multiplyUnsafe(h)).subtract(u).clearCofactor().is0();\n  }\n  return o.precompute(8), { getPublicKey: B, sign: z, verify: Z, utils: {\n    getExtendedPublicKey: P,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: () => v(i.BYTES),\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(j = 8, V = t.BASE) {\n      return V.precompute(j, !1);\n    }\n  }, Point: t };\n}\nfunction _h(t) {\n  const e = {\n    a: t.a,\n    d: t.d,\n    p: t.Fp.ORDER,\n    n: t.n,\n    h: t.h,\n    Gx: t.Gx,\n    Gy: t.Gy\n  }, r = t.Fp, n = $n(e.n, t.nBitLength, !0), o = { Fp: r, Fn: n, uvRatio: t.uvRatio }, i = {\n    hash: t.hash,\n    randomBytes: t.randomBytes,\n    adjustScalarBytes: t.adjustScalarBytes,\n    domain: t.domain,\n    prehash: t.prehash,\n    mapToCurve: t.mapToCurve\n  };\n  return { CURVE: e, curveOpts: o, eddsaOpts: i };\n}\nfunction Eh(t, e) {\n  return Object.assign({}, e, { ExtendedPoint: e.Point, CURVE: t });\n}\nfunction Mh(t) {\n  const { CURVE: e, curveOpts: r, eddsaOpts: n } = _h(t), o = xh(e, r), i = bh(o, n);\n  return Eh(t, i);\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nBigInt(0);\nconst Ch = BigInt(1), Za = BigInt(2);\nBigInt(3);\nconst Sh = BigInt(5), Ah = BigInt(8), js = {\n  p: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\"),\n  n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n  h: Ah,\n  a: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"),\n  d: BigInt(\"0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\"),\n  Gx: BigInt(\"0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\"),\n  Gy: BigInt(\"0x6666666666666666666666666666666666666666666666666666666666666658\")\n};\nfunction kh(t) {\n  const e = BigInt(10), r = BigInt(20), n = BigInt(40), o = BigInt(80), i = js.p, f = t * t % i * t % i, v = pt(f, Za, i) * f % i, x = pt(v, Ch, i) * t % i, b = pt(x, Sh, i) * x % i, S = pt(b, e, i) * b % i, T = pt(S, r, i) * S % i, C = pt(T, n, i) * T % i, P = pt(C, o, i) * C % i, B = pt(P, o, i) * C % i, R = pt(B, e, i) * b % i;\n  return { pow_p_5_8: pt(R, Za, i) * t % i, b2: f };\n}\nfunction Ih(t) {\n  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;\n}\nconst Va = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\nfunction Bh(t, e) {\n  const r = js.p, n = wt(e * e * e, r), o = wt(n * n * e, r), i = kh(t * o).pow_p_5_8;\n  let c = wt(t * n * i, r);\n  const f = wt(e * c * c, r), v = c, x = wt(c * Va, r), b = f === t, S = f === wt(-t, r), T = f === wt(-t * Va, r);\n  return b && (c = v), (S || T) && (c = x), uh(c, r) && (c = wt(-c, r)), { isValid: b || S, value: c };\n}\nconst Rh = $n(js.p, void 0, !0), Th = {\n  ...js,\n  Fp: Rh,\n  hash: eh,\n  adjustScalarBytes: Ih,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/√v\n  uvRatio: Bh\n}, Fi = Mh(Th);\nvar rs = { exports: {} };\nconst Lh = {}, Oh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: Lh\n}, Symbol.toStringTag, { value: \"Module\" })), Ac = /* @__PURE__ */ ea(Oh);\nvar Nh = rs.exports, Ha;\nfunction jh() {\n  return Ha || (Ha = 1, function(t) {\n    (function(e, r) {\n      function n(d, s) {\n        if (!d) throw new Error(s || \"Assertion failed\");\n      }\n      function o(d, s) {\n        d.super_ = s;\n        var u = function() {\n        };\n        u.prototype = s.prototype, d.prototype = new u(), d.prototype.constructor = d;\n      }\n      function i(d, s, u) {\n        if (i.isBN(d))\n          return d;\n        this.negative = 0, this.words = null, this.length = 0, this.red = null, d !== null && ((s === \"le\" || s === \"be\") && (u = s, s = 10), this._init(d || 0, s || 10, u || \"be\"));\n      }\n      typeof e == \"object\" ? e.exports = i : r.BN = i, i.BN = i, i.wordSize = 26;\n      var c;\n      try {\n        typeof window < \"u\" && typeof window.Buffer < \"u\" ? c = window.Buffer : c = Ac.Buffer;\n      } catch {\n      }\n      i.isBN = function(s) {\n        return s instanceof i ? !0 : s !== null && typeof s == \"object\" && s.constructor.wordSize === i.wordSize && Array.isArray(s.words);\n      }, i.max = function(s, u) {\n        return s.cmp(u) > 0 ? s : u;\n      }, i.min = function(s, u) {\n        return s.cmp(u) < 0 ? s : u;\n      }, i.prototype._init = function(s, u, h) {\n        if (typeof s == \"number\")\n          return this._initNumber(s, u, h);\n        if (typeof s == \"object\")\n          return this._initArray(s, u, h);\n        u === \"hex\" && (u = 16), n(u === (u | 0) && u >= 2 && u <= 36), s = s.toString().replace(/\\s+/g, \"\");\n        var g = 0;\n        s[0] === \"-\" && (g++, this.negative = 1), g < s.length && (u === 16 ? this._parseHex(s, g, h) : (this._parseBase(s, u, g), h === \"le\" && this._initArray(this.toArray(), u, h)));\n      }, i.prototype._initNumber = function(s, u, h) {\n        s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [\n          s & 67108863,\n          s / 67108864 & 67108863\n        ], this.length = 2) : (n(s < 9007199254740992), this.words = [\n          s & 67108863,\n          s / 67108864 & 67108863,\n          1\n        ], this.length = 3), h === \"le\" && this._initArray(this.toArray(), u, h);\n      }, i.prototype._initArray = function(s, u, h) {\n        if (n(typeof s.length == \"number\"), s.length <= 0)\n          return this.words = [0], this.length = 1, this;\n        this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);\n        for (var g = 0; g < this.length; g++)\n          this.words[g] = 0;\n        var w, _, A = 0;\n        if (h === \"be\")\n          for (g = s.length - 1, w = 0; g >= 0; g -= 3)\n            _ = s[g] | s[g - 1] << 8 | s[g - 2] << 16, this.words[w] |= _ << A & 67108863, this.words[w + 1] = _ >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, w++);\n        else if (h === \"le\")\n          for (g = 0, w = 0; g < s.length; g += 3)\n            _ = s[g] | s[g + 1] << 8 | s[g + 2] << 16, this.words[w] |= _ << A & 67108863, this.words[w + 1] = _ >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, w++);\n        return this._strip();\n      };\n      function f(d, s) {\n        var u = d.charCodeAt(s);\n        if (u >= 48 && u <= 57)\n          return u - 48;\n        if (u >= 65 && u <= 70)\n          return u - 55;\n        if (u >= 97 && u <= 102)\n          return u - 87;\n        n(!1, \"Invalid character in \" + d);\n      }\n      function v(d, s, u) {\n        var h = f(d, u);\n        return u - 1 >= s && (h |= f(d, u - 1) << 4), h;\n      }\n      i.prototype._parseHex = function(s, u, h) {\n        this.length = Math.ceil((s.length - u) / 6), this.words = new Array(this.length);\n        for (var g = 0; g < this.length; g++)\n          this.words[g] = 0;\n        var w = 0, _ = 0, A;\n        if (h === \"be\")\n          for (g = s.length - 1; g >= u; g -= 2)\n            A = v(s, u, g) << w, this.words[_] |= A & 67108863, w >= 18 ? (w -= 18, _ += 1, this.words[_] |= A >>> 26) : w += 8;\n        else {\n          var p = s.length - u;\n          for (g = p % 2 === 0 ? u + 1 : u; g < s.length; g += 2)\n            A = v(s, u, g) << w, this.words[_] |= A & 67108863, w >= 18 ? (w -= 18, _ += 1, this.words[_] |= A >>> 26) : w += 8;\n        }\n        this._strip();\n      };\n      function x(d, s, u, h) {\n        for (var g = 0, w = 0, _ = Math.min(d.length, u), A = s; A < _; A++) {\n          var p = d.charCodeAt(A) - 48;\n          g *= h, p >= 49 ? w = p - 49 + 10 : p >= 17 ? w = p - 17 + 10 : w = p, n(p >= 0 && w < h, \"Invalid character\"), g += w;\n        }\n        return g;\n      }\n      i.prototype._parseBase = function(s, u, h) {\n        this.words = [0], this.length = 1;\n        for (var g = 0, w = 1; w <= 67108863; w *= u)\n          g++;\n        g--, w = w / u | 0;\n        for (var _ = s.length - h, A = _ % g, p = Math.min(_, _ - A) + h, a = 0, l = h; l < p; l += g)\n          a = x(s, l, l + g, u), this.imuln(w), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a);\n        if (A !== 0) {\n          var M = 1;\n          for (a = x(s, l, s.length, u), l = 0; l < A; l++)\n            M *= u;\n          this.imuln(M), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a);\n        }\n        this._strip();\n      }, i.prototype.copy = function(s) {\n        s.words = new Array(this.length);\n        for (var u = 0; u < this.length; u++)\n          s.words[u] = this.words[u];\n        s.length = this.length, s.negative = this.negative, s.red = this.red;\n      };\n      function b(d, s) {\n        d.words = s.words, d.length = s.length, d.negative = s.negative, d.red = s.red;\n      }\n      if (i.prototype._move = function(s) {\n        b(s, this);\n      }, i.prototype.clone = function() {\n        var s = new i(null);\n        return this.copy(s), s;\n      }, i.prototype._expand = function(s) {\n        for (; this.length < s; )\n          this.words[this.length++] = 0;\n        return this;\n      }, i.prototype._strip = function() {\n        for (; this.length > 1 && this.words[this.length - 1] === 0; )\n          this.length--;\n        return this._normSign();\n      }, i.prototype._normSign = function() {\n        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;\n      }, typeof Symbol < \"u\" && typeof Symbol.for == \"function\")\n        try {\n          i.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = S;\n        } catch {\n          i.prototype.inspect = S;\n        }\n      else\n        i.prototype.inspect = S;\n      function S() {\n        return (this.red ? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n      }\n      var T = [\n        \"\",\n        \"0\",\n        \"00\",\n        \"000\",\n        \"0000\",\n        \"00000\",\n        \"000000\",\n        \"0000000\",\n        \"00000000\",\n        \"000000000\",\n        \"0000000000\",\n        \"00000000000\",\n        \"000000000000\",\n        \"0000000000000\",\n        \"00000000000000\",\n        \"000000000000000\",\n        \"0000000000000000\",\n        \"00000000000000000\",\n        \"000000000000000000\",\n        \"0000000000000000000\",\n        \"00000000000000000000\",\n        \"000000000000000000000\",\n        \"0000000000000000000000\",\n        \"00000000000000000000000\",\n        \"000000000000000000000000\",\n        \"0000000000000000000000000\"\n      ], C = [\n        0,\n        0,\n        25,\n        16,\n        12,\n        11,\n        10,\n        9,\n        8,\n        8,\n        7,\n        7,\n        7,\n        7,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5\n      ], P = [\n        0,\n        0,\n        33554432,\n        43046721,\n        16777216,\n        48828125,\n        60466176,\n        40353607,\n        16777216,\n        43046721,\n        1e7,\n        19487171,\n        35831808,\n        62748517,\n        7529536,\n        11390625,\n        16777216,\n        24137569,\n        34012224,\n        47045881,\n        64e6,\n        4084101,\n        5153632,\n        6436343,\n        7962624,\n        9765625,\n        11881376,\n        14348907,\n        17210368,\n        20511149,\n        243e5,\n        28629151,\n        33554432,\n        39135393,\n        45435424,\n        52521875,\n        60466176\n      ];\n      i.prototype.toString = function(s, u) {\n        s = s || 10, u = u | 0 || 1;\n        var h;\n        if (s === 16 || s === \"hex\") {\n          h = \"\";\n          for (var g = 0, w = 0, _ = 0; _ < this.length; _++) {\n            var A = this.words[_], p = ((A << g | w) & 16777215).toString(16);\n            w = A >>> 24 - g & 16777215, g += 2, g >= 26 && (g -= 26, _--), w !== 0 || _ !== this.length - 1 ? h = T[6 - p.length] + p + h : h = p + h;\n          }\n          for (w !== 0 && (h = w.toString(16) + h); h.length % u !== 0; )\n            h = \"0\" + h;\n          return this.negative !== 0 && (h = \"-\" + h), h;\n        }\n        if (s === (s | 0) && s >= 2 && s <= 36) {\n          var a = C[s], l = P[s];\n          h = \"\";\n          var M = this.clone();\n          for (M.negative = 0; !M.isZero(); ) {\n            var k = M.modrn(l).toString(s);\n            M = M.idivn(l), M.isZero() ? h = k + h : h = T[a - k.length] + k + h;\n          }\n          for (this.isZero() && (h = \"0\" + h); h.length % u !== 0; )\n            h = \"0\" + h;\n          return this.negative !== 0 && (h = \"-\" + h), h;\n        }\n        n(!1, \"Base should be between 2 and 36\");\n      }, i.prototype.toNumber = function() {\n        var s = this.words[0];\n        return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 ? -s : s;\n      }, i.prototype.toJSON = function() {\n        return this.toString(16, 2);\n      }, c && (i.prototype.toBuffer = function(s, u) {\n        return this.toArrayLike(c, s, u);\n      }), i.prototype.toArray = function(s, u) {\n        return this.toArrayLike(Array, s, u);\n      };\n      var B = function(s, u) {\n        return s.allocUnsafe ? s.allocUnsafe(u) : new s(u);\n      };\n      i.prototype.toArrayLike = function(s, u, h) {\n        this._strip();\n        var g = this.byteLength(), w = h || Math.max(1, g);\n        n(g <= w, \"byte array longer than desired length\"), n(w > 0, \"Requested array length <= 0\");\n        var _ = B(s, w), A = u === \"le\" ? \"LE\" : \"BE\";\n        return this[\"_toArrayLike\" + A](_, g), _;\n      }, i.prototype._toArrayLikeLE = function(s, u) {\n        for (var h = 0, g = 0, w = 0, _ = 0; w < this.length; w++) {\n          var A = this.words[w] << _ | g;\n          s[h++] = A & 255, h < s.length && (s[h++] = A >> 8 & 255), h < s.length && (s[h++] = A >> 16 & 255), _ === 6 ? (h < s.length && (s[h++] = A >> 24 & 255), g = 0, _ = 0) : (g = A >>> 24, _ += 2);\n        }\n        if (h < s.length)\n          for (s[h++] = g; h < s.length; )\n            s[h++] = 0;\n      }, i.prototype._toArrayLikeBE = function(s, u) {\n        for (var h = s.length - 1, g = 0, w = 0, _ = 0; w < this.length; w++) {\n          var A = this.words[w] << _ | g;\n          s[h--] = A & 255, h >= 0 && (s[h--] = A >> 8 & 255), h >= 0 && (s[h--] = A >> 16 & 255), _ === 6 ? (h >= 0 && (s[h--] = A >> 24 & 255), g = 0, _ = 0) : (g = A >>> 24, _ += 2);\n        }\n        if (h >= 0)\n          for (s[h--] = g; h >= 0; )\n            s[h--] = 0;\n      }, Math.clz32 ? i.prototype._countBits = function(s) {\n        return 32 - Math.clz32(s);\n      } : i.prototype._countBits = function(s) {\n        var u = s, h = 0;\n        return u >= 4096 && (h += 13, u >>>= 13), u >= 64 && (h += 7, u >>>= 7), u >= 8 && (h += 4, u >>>= 4), u >= 2 && (h += 2, u >>>= 2), h + u;\n      }, i.prototype._zeroBits = function(s) {\n        if (s === 0) return 26;\n        var u = s, h = 0;\n        return (u & 8191) === 0 && (h += 13, u >>>= 13), (u & 127) === 0 && (h += 7, u >>>= 7), (u & 15) === 0 && (h += 4, u >>>= 4), (u & 3) === 0 && (h += 2, u >>>= 2), (u & 1) === 0 && h++, h;\n      }, i.prototype.bitLength = function() {\n        var s = this.words[this.length - 1], u = this._countBits(s);\n        return (this.length - 1) * 26 + u;\n      };\n      function R(d) {\n        for (var s = new Array(d.bitLength()), u = 0; u < s.length; u++) {\n          var h = u / 26 | 0, g = u % 26;\n          s[u] = d.words[h] >>> g & 1;\n        }\n        return s;\n      }\n      i.prototype.zeroBits = function() {\n        if (this.isZero()) return 0;\n        for (var s = 0, u = 0; u < this.length; u++) {\n          var h = this._zeroBits(this.words[u]);\n          if (s += h, h !== 26) break;\n        }\n        return s;\n      }, i.prototype.byteLength = function() {\n        return Math.ceil(this.bitLength() / 8);\n      }, i.prototype.toTwos = function(s) {\n        return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();\n      }, i.prototype.fromTwos = function(s) {\n        return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();\n      }, i.prototype.isNeg = function() {\n        return this.negative !== 0;\n      }, i.prototype.neg = function() {\n        return this.clone().ineg();\n      }, i.prototype.ineg = function() {\n        return this.isZero() || (this.negative ^= 1), this;\n      }, i.prototype.iuor = function(s) {\n        for (; this.length < s.length; )\n          this.words[this.length++] = 0;\n        for (var u = 0; u < s.length; u++)\n          this.words[u] = this.words[u] | s.words[u];\n        return this._strip();\n      }, i.prototype.ior = function(s) {\n        return n((this.negative | s.negative) === 0), this.iuor(s);\n      }, i.prototype.or = function(s) {\n        return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this);\n      }, i.prototype.uor = function(s) {\n        return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this);\n      }, i.prototype.iuand = function(s) {\n        var u;\n        this.length > s.length ? u = s : u = this;\n        for (var h = 0; h < u.length; h++)\n          this.words[h] = this.words[h] & s.words[h];\n        return this.length = u.length, this._strip();\n      }, i.prototype.iand = function(s) {\n        return n((this.negative | s.negative) === 0), this.iuand(s);\n      }, i.prototype.and = function(s) {\n        return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this);\n      }, i.prototype.uand = function(s) {\n        return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this);\n      }, i.prototype.iuxor = function(s) {\n        var u, h;\n        this.length > s.length ? (u = this, h = s) : (u = s, h = this);\n        for (var g = 0; g < h.length; g++)\n          this.words[g] = u.words[g] ^ h.words[g];\n        if (this !== u)\n          for (; g < u.length; g++)\n            this.words[g] = u.words[g];\n        return this.length = u.length, this._strip();\n      }, i.prototype.ixor = function(s) {\n        return n((this.negative | s.negative) === 0), this.iuxor(s);\n      }, i.prototype.xor = function(s) {\n        return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this);\n      }, i.prototype.uxor = function(s) {\n        return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this);\n      }, i.prototype.inotn = function(s) {\n        n(typeof s == \"number\" && s >= 0);\n        var u = Math.ceil(s / 26) | 0, h = s % 26;\n        this._expand(u), h > 0 && u--;\n        for (var g = 0; g < u; g++)\n          this.words[g] = ~this.words[g] & 67108863;\n        return h > 0 && (this.words[g] = ~this.words[g] & 67108863 >> 26 - h), this._strip();\n      }, i.prototype.notn = function(s) {\n        return this.clone().inotn(s);\n      }, i.prototype.setn = function(s, u) {\n        n(typeof s == \"number\" && s >= 0);\n        var h = s / 26 | 0, g = s % 26;\n        return this._expand(h + 1), u ? this.words[h] = this.words[h] | 1 << g : this.words[h] = this.words[h] & ~(1 << g), this._strip();\n      }, i.prototype.iadd = function(s) {\n        var u;\n        if (this.negative !== 0 && s.negative === 0)\n          return this.negative = 0, u = this.isub(s), this.negative ^= 1, this._normSign();\n        if (this.negative === 0 && s.negative !== 0)\n          return s.negative = 0, u = this.isub(s), s.negative = 1, u._normSign();\n        var h, g;\n        this.length > s.length ? (h = this, g = s) : (h = s, g = this);\n        for (var w = 0, _ = 0; _ < g.length; _++)\n          u = (h.words[_] | 0) + (g.words[_] | 0) + w, this.words[_] = u & 67108863, w = u >>> 26;\n        for (; w !== 0 && _ < h.length; _++)\n          u = (h.words[_] | 0) + w, this.words[_] = u & 67108863, w = u >>> 26;\n        if (this.length = h.length, w !== 0)\n          this.words[this.length] = w, this.length++;\n        else if (h !== this)\n          for (; _ < h.length; _++)\n            this.words[_] = h.words[_];\n        return this;\n      }, i.prototype.add = function(s) {\n        var u;\n        return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, u = this.sub(s), s.negative ^= 1, u) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = s.sub(this), this.negative = 1, u) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this);\n      }, i.prototype.isub = function(s) {\n        if (s.negative !== 0) {\n          s.negative = 0;\n          var u = this.iadd(s);\n          return s.negative = 1, u._normSign();\n        } else if (this.negative !== 0)\n          return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();\n        var h = this.cmp(s);\n        if (h === 0)\n          return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n        var g, w;\n        h > 0 ? (g = this, w = s) : (g = s, w = this);\n        for (var _ = 0, A = 0; A < w.length; A++)\n          u = (g.words[A] | 0) - (w.words[A] | 0) + _, _ = u >> 26, this.words[A] = u & 67108863;\n        for (; _ !== 0 && A < g.length; A++)\n          u = (g.words[A] | 0) + _, _ = u >> 26, this.words[A] = u & 67108863;\n        if (_ === 0 && A < g.length && g !== this)\n          for (; A < g.length; A++)\n            this.words[A] = g.words[A];\n        return this.length = Math.max(this.length, A), g !== this && (this.negative = 1), this._strip();\n      }, i.prototype.sub = function(s) {\n        return this.clone().isub(s);\n      };\n      function z(d, s, u) {\n        u.negative = s.negative ^ d.negative;\n        var h = d.length + s.length | 0;\n        u.length = h, h = h - 1 | 0;\n        var g = d.words[0] | 0, w = s.words[0] | 0, _ = g * w, A = _ & 67108863, p = _ / 67108864 | 0;\n        u.words[0] = A;\n        for (var a = 1; a < h; a++) {\n          for (var l = p >>> 26, M = p & 67108863, k = Math.min(a, s.length - 1), $ = Math.max(0, a - d.length + 1); $ <= k; $++) {\n            var X = a - $ | 0;\n            g = d.words[X] | 0, w = s.words[$] | 0, _ = g * w + M, l += _ / 67108864 | 0, M = _ & 67108863;\n          }\n          u.words[a] = M | 0, p = l | 0;\n        }\n        return p !== 0 ? u.words[a] = p | 0 : u.length--, u._strip();\n      }\n      var K = function(s, u, h) {\n        var g = s.words, w = u.words, _ = h.words, A = 0, p, a, l, M = g[0] | 0, k = M & 8191, $ = M >>> 13, X = g[1] | 0, re = X & 8191, se = X >>> 13, ut = g[2] | 0, xe = ut & 8191, Ie = ut >>> 13, Xe = g[3] | 0, ae = Xe & 8191, ge = Xe >>> 13, it = g[4] | 0, we = it & 8191, Me = it >>> 13, ft = g[5] | 0, ye = ft & 8191, be = ft >>> 13, xt = g[6] | 0, Se = xt & 8191, ke = xt >>> 13, ct = g[7] | 0, _e = ct & 8191, E = ct >>> 13, m = g[8] | 0, y = m & 8191, I = m >>> 13, q = g[9] | 0, H = q & 8191, W = q >>> 13, Be = w[0] | 0, me = Be & 8191, de = Be >>> 13, ot = w[1] | 0, ce = ot & 8191, Le = ot >>> 13, Vn = w[2] | 0, Oe = Vn & 8191, Ne = Vn >>> 13, Hn = w[3] | 0, je = Hn & 8191, Ue = Hn >>> 13, Kn = w[4] | 0, Fe = Kn & 8191, Pe = Kn >>> 13, Wn = w[5] | 0, De = Wn & 8191, $e = Wn >>> 13, Gn = w[6] | 0, ze = Gn & 8191, qe = Gn >>> 13, Yn = w[7] | 0, Ze = Yn & 8191, Ve = Yn >>> 13, Jn = w[8] | 0, He = Jn & 8191, Ke = Jn >>> 13, Xn = w[9] | 0, We = Xn & 8191, Ge = Xn >>> 13;\n        h.negative = s.negative ^ u.negative, h.length = 19, p = Math.imul(k, me), a = Math.imul(k, de), a = a + Math.imul($, me) | 0, l = Math.imul($, de);\n        var Fr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, p = Math.imul(re, me), a = Math.imul(re, de), a = a + Math.imul(se, me) | 0, l = Math.imul(se, de), p = p + Math.imul(k, ce) | 0, a = a + Math.imul(k, Le) | 0, a = a + Math.imul($, ce) | 0, l = l + Math.imul($, Le) | 0;\n        var Pr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, p = Math.imul(xe, me), a = Math.imul(xe, de), a = a + Math.imul(Ie, me) | 0, l = Math.imul(Ie, de), p = p + Math.imul(re, ce) | 0, a = a + Math.imul(re, Le) | 0, a = a + Math.imul(se, ce) | 0, l = l + Math.imul(se, Le) | 0, p = p + Math.imul(k, Oe) | 0, a = a + Math.imul(k, Ne) | 0, a = a + Math.imul($, Oe) | 0, l = l + Math.imul($, Ne) | 0;\n        var Dr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, p = Math.imul(ae, me), a = Math.imul(ae, de), a = a + Math.imul(ge, me) | 0, l = Math.imul(ge, de), p = p + Math.imul(xe, ce) | 0, a = a + Math.imul(xe, Le) | 0, a = a + Math.imul(Ie, ce) | 0, l = l + Math.imul(Ie, Le) | 0, p = p + Math.imul(re, Oe) | 0, a = a + Math.imul(re, Ne) | 0, a = a + Math.imul(se, Oe) | 0, l = l + Math.imul(se, Ne) | 0, p = p + Math.imul(k, je) | 0, a = a + Math.imul(k, Ue) | 0, a = a + Math.imul($, je) | 0, l = l + Math.imul($, Ue) | 0;\n        var $r = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, p = Math.imul(we, me), a = Math.imul(we, de), a = a + Math.imul(Me, me) | 0, l = Math.imul(Me, de), p = p + Math.imul(ae, ce) | 0, a = a + Math.imul(ae, Le) | 0, a = a + Math.imul(ge, ce) | 0, l = l + Math.imul(ge, Le) | 0, p = p + Math.imul(xe, Oe) | 0, a = a + Math.imul(xe, Ne) | 0, a = a + Math.imul(Ie, Oe) | 0, l = l + Math.imul(Ie, Ne) | 0, p = p + Math.imul(re, je) | 0, a = a + Math.imul(re, Ue) | 0, a = a + Math.imul(se, je) | 0, l = l + Math.imul(se, Ue) | 0, p = p + Math.imul(k, Fe) | 0, a = a + Math.imul(k, Pe) | 0, a = a + Math.imul($, Fe) | 0, l = l + Math.imul($, Pe) | 0;\n        var zr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, p = Math.imul(ye, me), a = Math.imul(ye, de), a = a + Math.imul(be, me) | 0, l = Math.imul(be, de), p = p + Math.imul(we, ce) | 0, a = a + Math.imul(we, Le) | 0, a = a + Math.imul(Me, ce) | 0, l = l + Math.imul(Me, Le) | 0, p = p + Math.imul(ae, Oe) | 0, a = a + Math.imul(ae, Ne) | 0, a = a + Math.imul(ge, Oe) | 0, l = l + Math.imul(ge, Ne) | 0, p = p + Math.imul(xe, je) | 0, a = a + Math.imul(xe, Ue) | 0, a = a + Math.imul(Ie, je) | 0, l = l + Math.imul(Ie, Ue) | 0, p = p + Math.imul(re, Fe) | 0, a = a + Math.imul(re, Pe) | 0, a = a + Math.imul(se, Fe) | 0, l = l + Math.imul(se, Pe) | 0, p = p + Math.imul(k, De) | 0, a = a + Math.imul(k, $e) | 0, a = a + Math.imul($, De) | 0, l = l + Math.imul($, $e) | 0;\n        var qr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, p = Math.imul(Se, me), a = Math.imul(Se, de), a = a + Math.imul(ke, me) | 0, l = Math.imul(ke, de), p = p + Math.imul(ye, ce) | 0, a = a + Math.imul(ye, Le) | 0, a = a + Math.imul(be, ce) | 0, l = l + Math.imul(be, Le) | 0, p = p + Math.imul(we, Oe) | 0, a = a + Math.imul(we, Ne) | 0, a = a + Math.imul(Me, Oe) | 0, l = l + Math.imul(Me, Ne) | 0, p = p + Math.imul(ae, je) | 0, a = a + Math.imul(ae, Ue) | 0, a = a + Math.imul(ge, je) | 0, l = l + Math.imul(ge, Ue) | 0, p = p + Math.imul(xe, Fe) | 0, a = a + Math.imul(xe, Pe) | 0, a = a + Math.imul(Ie, Fe) | 0, l = l + Math.imul(Ie, Pe) | 0, p = p + Math.imul(re, De) | 0, a = a + Math.imul(re, $e) | 0, a = a + Math.imul(se, De) | 0, l = l + Math.imul(se, $e) | 0, p = p + Math.imul(k, ze) | 0, a = a + Math.imul(k, qe) | 0, a = a + Math.imul($, ze) | 0, l = l + Math.imul($, qe) | 0;\n        var Zr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, p = Math.imul(_e, me), a = Math.imul(_e, de), a = a + Math.imul(E, me) | 0, l = Math.imul(E, de), p = p + Math.imul(Se, ce) | 0, a = a + Math.imul(Se, Le) | 0, a = a + Math.imul(ke, ce) | 0, l = l + Math.imul(ke, Le) | 0, p = p + Math.imul(ye, Oe) | 0, a = a + Math.imul(ye, Ne) | 0, a = a + Math.imul(be, Oe) | 0, l = l + Math.imul(be, Ne) | 0, p = p + Math.imul(we, je) | 0, a = a + Math.imul(we, Ue) | 0, a = a + Math.imul(Me, je) | 0, l = l + Math.imul(Me, Ue) | 0, p = p + Math.imul(ae, Fe) | 0, a = a + Math.imul(ae, Pe) | 0, a = a + Math.imul(ge, Fe) | 0, l = l + Math.imul(ge, Pe) | 0, p = p + Math.imul(xe, De) | 0, a = a + Math.imul(xe, $e) | 0, a = a + Math.imul(Ie, De) | 0, l = l + Math.imul(Ie, $e) | 0, p = p + Math.imul(re, ze) | 0, a = a + Math.imul(re, qe) | 0, a = a + Math.imul(se, ze) | 0, l = l + Math.imul(se, qe) | 0, p = p + Math.imul(k, Ze) | 0, a = a + Math.imul(k, Ve) | 0, a = a + Math.imul($, Ze) | 0, l = l + Math.imul($, Ve) | 0;\n        var Vr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, p = Math.imul(y, me), a = Math.imul(y, de), a = a + Math.imul(I, me) | 0, l = Math.imul(I, de), p = p + Math.imul(_e, ce) | 0, a = a + Math.imul(_e, Le) | 0, a = a + Math.imul(E, ce) | 0, l = l + Math.imul(E, Le) | 0, p = p + Math.imul(Se, Oe) | 0, a = a + Math.imul(Se, Ne) | 0, a = a + Math.imul(ke, Oe) | 0, l = l + Math.imul(ke, Ne) | 0, p = p + Math.imul(ye, je) | 0, a = a + Math.imul(ye, Ue) | 0, a = a + Math.imul(be, je) | 0, l = l + Math.imul(be, Ue) | 0, p = p + Math.imul(we, Fe) | 0, a = a + Math.imul(we, Pe) | 0, a = a + Math.imul(Me, Fe) | 0, l = l + Math.imul(Me, Pe) | 0, p = p + Math.imul(ae, De) | 0, a = a + Math.imul(ae, $e) | 0, a = a + Math.imul(ge, De) | 0, l = l + Math.imul(ge, $e) | 0, p = p + Math.imul(xe, ze) | 0, a = a + Math.imul(xe, qe) | 0, a = a + Math.imul(Ie, ze) | 0, l = l + Math.imul(Ie, qe) | 0, p = p + Math.imul(re, Ze) | 0, a = a + Math.imul(re, Ve) | 0, a = a + Math.imul(se, Ze) | 0, l = l + Math.imul(se, Ve) | 0, p = p + Math.imul(k, He) | 0, a = a + Math.imul(k, Ke) | 0, a = a + Math.imul($, He) | 0, l = l + Math.imul($, Ke) | 0;\n        var Hr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, p = Math.imul(H, me), a = Math.imul(H, de), a = a + Math.imul(W, me) | 0, l = Math.imul(W, de), p = p + Math.imul(y, ce) | 0, a = a + Math.imul(y, Le) | 0, a = a + Math.imul(I, ce) | 0, l = l + Math.imul(I, Le) | 0, p = p + Math.imul(_e, Oe) | 0, a = a + Math.imul(_e, Ne) | 0, a = a + Math.imul(E, Oe) | 0, l = l + Math.imul(E, Ne) | 0, p = p + Math.imul(Se, je) | 0, a = a + Math.imul(Se, Ue) | 0, a = a + Math.imul(ke, je) | 0, l = l + Math.imul(ke, Ue) | 0, p = p + Math.imul(ye, Fe) | 0, a = a + Math.imul(ye, Pe) | 0, a = a + Math.imul(be, Fe) | 0, l = l + Math.imul(be, Pe) | 0, p = p + Math.imul(we, De) | 0, a = a + Math.imul(we, $e) | 0, a = a + Math.imul(Me, De) | 0, l = l + Math.imul(Me, $e) | 0, p = p + Math.imul(ae, ze) | 0, a = a + Math.imul(ae, qe) | 0, a = a + Math.imul(ge, ze) | 0, l = l + Math.imul(ge, qe) | 0, p = p + Math.imul(xe, Ze) | 0, a = a + Math.imul(xe, Ve) | 0, a = a + Math.imul(Ie, Ze) | 0, l = l + Math.imul(Ie, Ve) | 0, p = p + Math.imul(re, He) | 0, a = a + Math.imul(re, Ke) | 0, a = a + Math.imul(se, He) | 0, l = l + Math.imul(se, Ke) | 0, p = p + Math.imul(k, We) | 0, a = a + Math.imul(k, Ge) | 0, a = a + Math.imul($, We) | 0, l = l + Math.imul($, Ge) | 0;\n        var Kr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, p = Math.imul(H, ce), a = Math.imul(H, Le), a = a + Math.imul(W, ce) | 0, l = Math.imul(W, Le), p = p + Math.imul(y, Oe) | 0, a = a + Math.imul(y, Ne) | 0, a = a + Math.imul(I, Oe) | 0, l = l + Math.imul(I, Ne) | 0, p = p + Math.imul(_e, je) | 0, a = a + Math.imul(_e, Ue) | 0, a = a + Math.imul(E, je) | 0, l = l + Math.imul(E, Ue) | 0, p = p + Math.imul(Se, Fe) | 0, a = a + Math.imul(Se, Pe) | 0, a = a + Math.imul(ke, Fe) | 0, l = l + Math.imul(ke, Pe) | 0, p = p + Math.imul(ye, De) | 0, a = a + Math.imul(ye, $e) | 0, a = a + Math.imul(be, De) | 0, l = l + Math.imul(be, $e) | 0, p = p + Math.imul(we, ze) | 0, a = a + Math.imul(we, qe) | 0, a = a + Math.imul(Me, ze) | 0, l = l + Math.imul(Me, qe) | 0, p = p + Math.imul(ae, Ze) | 0, a = a + Math.imul(ae, Ve) | 0, a = a + Math.imul(ge, Ze) | 0, l = l + Math.imul(ge, Ve) | 0, p = p + Math.imul(xe, He) | 0, a = a + Math.imul(xe, Ke) | 0, a = a + Math.imul(Ie, He) | 0, l = l + Math.imul(Ie, Ke) | 0, p = p + Math.imul(re, We) | 0, a = a + Math.imul(re, Ge) | 0, a = a + Math.imul(se, We) | 0, l = l + Math.imul(se, Ge) | 0;\n        var Wr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, p = Math.imul(H, Oe), a = Math.imul(H, Ne), a = a + Math.imul(W, Oe) | 0, l = Math.imul(W, Ne), p = p + Math.imul(y, je) | 0, a = a + Math.imul(y, Ue) | 0, a = a + Math.imul(I, je) | 0, l = l + Math.imul(I, Ue) | 0, p = p + Math.imul(_e, Fe) | 0, a = a + Math.imul(_e, Pe) | 0, a = a + Math.imul(E, Fe) | 0, l = l + Math.imul(E, Pe) | 0, p = p + Math.imul(Se, De) | 0, a = a + Math.imul(Se, $e) | 0, a = a + Math.imul(ke, De) | 0, l = l + Math.imul(ke, $e) | 0, p = p + Math.imul(ye, ze) | 0, a = a + Math.imul(ye, qe) | 0, a = a + Math.imul(be, ze) | 0, l = l + Math.imul(be, qe) | 0, p = p + Math.imul(we, Ze) | 0, a = a + Math.imul(we, Ve) | 0, a = a + Math.imul(Me, Ze) | 0, l = l + Math.imul(Me, Ve) | 0, p = p + Math.imul(ae, He) | 0, a = a + Math.imul(ae, Ke) | 0, a = a + Math.imul(ge, He) | 0, l = l + Math.imul(ge, Ke) | 0, p = p + Math.imul(xe, We) | 0, a = a + Math.imul(xe, Ge) | 0, a = a + Math.imul(Ie, We) | 0, l = l + Math.imul(Ie, Ge) | 0;\n        var Gr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, p = Math.imul(H, je), a = Math.imul(H, Ue), a = a + Math.imul(W, je) | 0, l = Math.imul(W, Ue), p = p + Math.imul(y, Fe) | 0, a = a + Math.imul(y, Pe) | 0, a = a + Math.imul(I, Fe) | 0, l = l + Math.imul(I, Pe) | 0, p = p + Math.imul(_e, De) | 0, a = a + Math.imul(_e, $e) | 0, a = a + Math.imul(E, De) | 0, l = l + Math.imul(E, $e) | 0, p = p + Math.imul(Se, ze) | 0, a = a + Math.imul(Se, qe) | 0, a = a + Math.imul(ke, ze) | 0, l = l + Math.imul(ke, qe) | 0, p = p + Math.imul(ye, Ze) | 0, a = a + Math.imul(ye, Ve) | 0, a = a + Math.imul(be, Ze) | 0, l = l + Math.imul(be, Ve) | 0, p = p + Math.imul(we, He) | 0, a = a + Math.imul(we, Ke) | 0, a = a + Math.imul(Me, He) | 0, l = l + Math.imul(Me, Ke) | 0, p = p + Math.imul(ae, We) | 0, a = a + Math.imul(ae, Ge) | 0, a = a + Math.imul(ge, We) | 0, l = l + Math.imul(ge, Ge) | 0;\n        var Yr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, p = Math.imul(H, Fe), a = Math.imul(H, Pe), a = a + Math.imul(W, Fe) | 0, l = Math.imul(W, Pe), p = p + Math.imul(y, De) | 0, a = a + Math.imul(y, $e) | 0, a = a + Math.imul(I, De) | 0, l = l + Math.imul(I, $e) | 0, p = p + Math.imul(_e, ze) | 0, a = a + Math.imul(_e, qe) | 0, a = a + Math.imul(E, ze) | 0, l = l + Math.imul(E, qe) | 0, p = p + Math.imul(Se, Ze) | 0, a = a + Math.imul(Se, Ve) | 0, a = a + Math.imul(ke, Ze) | 0, l = l + Math.imul(ke, Ve) | 0, p = p + Math.imul(ye, He) | 0, a = a + Math.imul(ye, Ke) | 0, a = a + Math.imul(be, He) | 0, l = l + Math.imul(be, Ke) | 0, p = p + Math.imul(we, We) | 0, a = a + Math.imul(we, Ge) | 0, a = a + Math.imul(Me, We) | 0, l = l + Math.imul(Me, Ge) | 0;\n        var Jr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, p = Math.imul(H, De), a = Math.imul(H, $e), a = a + Math.imul(W, De) | 0, l = Math.imul(W, $e), p = p + Math.imul(y, ze) | 0, a = a + Math.imul(y, qe) | 0, a = a + Math.imul(I, ze) | 0, l = l + Math.imul(I, qe) | 0, p = p + Math.imul(_e, Ze) | 0, a = a + Math.imul(_e, Ve) | 0, a = a + Math.imul(E, Ze) | 0, l = l + Math.imul(E, Ve) | 0, p = p + Math.imul(Se, He) | 0, a = a + Math.imul(Se, Ke) | 0, a = a + Math.imul(ke, He) | 0, l = l + Math.imul(ke, Ke) | 0, p = p + Math.imul(ye, We) | 0, a = a + Math.imul(ye, Ge) | 0, a = a + Math.imul(be, We) | 0, l = l + Math.imul(be, Ge) | 0;\n        var Xr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, p = Math.imul(H, ze), a = Math.imul(H, qe), a = a + Math.imul(W, ze) | 0, l = Math.imul(W, qe), p = p + Math.imul(y, Ze) | 0, a = a + Math.imul(y, Ve) | 0, a = a + Math.imul(I, Ze) | 0, l = l + Math.imul(I, Ve) | 0, p = p + Math.imul(_e, He) | 0, a = a + Math.imul(_e, Ke) | 0, a = a + Math.imul(E, He) | 0, l = l + Math.imul(E, Ke) | 0, p = p + Math.imul(Se, We) | 0, a = a + Math.imul(Se, Ge) | 0, a = a + Math.imul(ke, We) | 0, l = l + Math.imul(ke, Ge) | 0;\n        var Qr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, p = Math.imul(H, Ze), a = Math.imul(H, Ve), a = a + Math.imul(W, Ze) | 0, l = Math.imul(W, Ve), p = p + Math.imul(y, He) | 0, a = a + Math.imul(y, Ke) | 0, a = a + Math.imul(I, He) | 0, l = l + Math.imul(I, Ke) | 0, p = p + Math.imul(_e, We) | 0, a = a + Math.imul(_e, Ge) | 0, a = a + Math.imul(E, We) | 0, l = l + Math.imul(E, Ge) | 0;\n        var en = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, p = Math.imul(H, He), a = Math.imul(H, Ke), a = a + Math.imul(W, He) | 0, l = Math.imul(W, Ke), p = p + Math.imul(y, We) | 0, a = a + Math.imul(y, Ge) | 0, a = a + Math.imul(I, We) | 0, l = l + Math.imul(I, Ge) | 0;\n        var tn = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, p = Math.imul(H, We), a = Math.imul(H, Ge), a = a + Math.imul(W, We) | 0, l = Math.imul(W, Ge);\n        var rn = (A + p | 0) + ((a & 8191) << 13) | 0;\n        return A = (l + (a >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, _[0] = Fr, _[1] = Pr, _[2] = Dr, _[3] = $r, _[4] = zr, _[5] = qr, _[6] = Zr, _[7] = Vr, _[8] = Hr, _[9] = Kr, _[10] = Wr, _[11] = Gr, _[12] = Yr, _[13] = Jr, _[14] = Xr, _[15] = Qr, _[16] = en, _[17] = tn, _[18] = rn, A !== 0 && (_[19] = A, h.length++), h;\n      };\n      Math.imul || (K = z);\n      function Z(d, s, u) {\n        u.negative = s.negative ^ d.negative, u.length = d.length + s.length;\n        for (var h = 0, g = 0, w = 0; w < u.length - 1; w++) {\n          var _ = g;\n          g = 0;\n          for (var A = h & 67108863, p = Math.min(w, s.length - 1), a = Math.max(0, w - d.length + 1); a <= p; a++) {\n            var l = w - a, M = d.words[l] | 0, k = s.words[a] | 0, $ = M * k, X = $ & 67108863;\n            _ = _ + ($ / 67108864 | 0) | 0, X = X + A | 0, A = X & 67108863, _ = _ + (X >>> 26) | 0, g += _ >>> 26, _ &= 67108863;\n          }\n          u.words[w] = A, h = _, _ = g;\n        }\n        return h !== 0 ? u.words[w] = h : u.length--, u._strip();\n      }\n      function Q(d, s, u) {\n        return Z(d, s, u);\n      }\n      i.prototype.mulTo = function(s, u) {\n        var h, g = this.length + s.length;\n        return this.length === 10 && s.length === 10 ? h = K(this, s, u) : g < 63 ? h = z(this, s, u) : g < 1024 ? h = Z(this, s, u) : h = Q(this, s, u), h;\n      }, i.prototype.mul = function(s) {\n        var u = new i(null);\n        return u.words = new Array(this.length + s.length), this.mulTo(s, u);\n      }, i.prototype.mulf = function(s) {\n        var u = new i(null);\n        return u.words = new Array(this.length + s.length), Q(this, s, u);\n      }, i.prototype.imul = function(s) {\n        return this.clone().mulTo(s, this);\n      }, i.prototype.imuln = function(s) {\n        var u = s < 0;\n        u && (s = -s), n(typeof s == \"number\"), n(s < 67108864);\n        for (var h = 0, g = 0; g < this.length; g++) {\n          var w = (this.words[g] | 0) * s, _ = (w & 67108863) + (h & 67108863);\n          h >>= 26, h += w / 67108864 | 0, h += _ >>> 26, this.words[g] = _ & 67108863;\n        }\n        return h !== 0 && (this.words[g] = h, this.length++), u ? this.ineg() : this;\n      }, i.prototype.muln = function(s) {\n        return this.clone().imuln(s);\n      }, i.prototype.sqr = function() {\n        return this.mul(this);\n      }, i.prototype.isqr = function() {\n        return this.imul(this.clone());\n      }, i.prototype.pow = function(s) {\n        var u = R(s);\n        if (u.length === 0) return new i(1);\n        for (var h = this, g = 0; g < u.length && u[g] === 0; g++, h = h.sqr())\n          ;\n        if (++g < u.length)\n          for (var w = h.sqr(); g < u.length; g++, w = w.sqr())\n            u[g] !== 0 && (h = h.mul(w));\n        return h;\n      }, i.prototype.iushln = function(s) {\n        n(typeof s == \"number\" && s >= 0);\n        var u = s % 26, h = (s - u) / 26, g = 67108863 >>> 26 - u << 26 - u, w;\n        if (u !== 0) {\n          var _ = 0;\n          for (w = 0; w < this.length; w++) {\n            var A = this.words[w] & g, p = (this.words[w] | 0) - A << u;\n            this.words[w] = p | _, _ = A >>> 26 - u;\n          }\n          _ && (this.words[w] = _, this.length++);\n        }\n        if (h !== 0) {\n          for (w = this.length - 1; w >= 0; w--)\n            this.words[w + h] = this.words[w];\n          for (w = 0; w < h; w++)\n            this.words[w] = 0;\n          this.length += h;\n        }\n        return this._strip();\n      }, i.prototype.ishln = function(s) {\n        return n(this.negative === 0), this.iushln(s);\n      }, i.prototype.iushrn = function(s, u, h) {\n        n(typeof s == \"number\" && s >= 0);\n        var g;\n        u ? g = (u - u % 26) / 26 : g = 0;\n        var w = s % 26, _ = Math.min((s - w) / 26, this.length), A = 67108863 ^ 67108863 >>> w << w, p = h;\n        if (g -= _, g = Math.max(0, g), p) {\n          for (var a = 0; a < _; a++)\n            p.words[a] = this.words[a];\n          p.length = _;\n        }\n        if (_ !== 0) if (this.length > _)\n          for (this.length -= _, a = 0; a < this.length; a++)\n            this.words[a] = this.words[a + _];\n        else\n          this.words[0] = 0, this.length = 1;\n        var l = 0;\n        for (a = this.length - 1; a >= 0 && (l !== 0 || a >= g); a--) {\n          var M = this.words[a] | 0;\n          this.words[a] = l << 26 - w | M >>> w, l = M & A;\n        }\n        return p && l !== 0 && (p.words[p.length++] = l), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();\n      }, i.prototype.ishrn = function(s, u, h) {\n        return n(this.negative === 0), this.iushrn(s, u, h);\n      }, i.prototype.shln = function(s) {\n        return this.clone().ishln(s);\n      }, i.prototype.ushln = function(s) {\n        return this.clone().iushln(s);\n      }, i.prototype.shrn = function(s) {\n        return this.clone().ishrn(s);\n      }, i.prototype.ushrn = function(s) {\n        return this.clone().iushrn(s);\n      }, i.prototype.testn = function(s) {\n        n(typeof s == \"number\" && s >= 0);\n        var u = s % 26, h = (s - u) / 26, g = 1 << u;\n        if (this.length <= h) return !1;\n        var w = this.words[h];\n        return !!(w & g);\n      }, i.prototype.imaskn = function(s) {\n        n(typeof s == \"number\" && s >= 0);\n        var u = s % 26, h = (s - u) / 26;\n        if (n(this.negative === 0, \"imaskn works only with positive numbers\"), this.length <= h)\n          return this;\n        if (u !== 0 && h++, this.length = Math.min(h, this.length), u !== 0) {\n          var g = 67108863 ^ 67108863 >>> u << u;\n          this.words[this.length - 1] &= g;\n        }\n        return this._strip();\n      }, i.prototype.maskn = function(s) {\n        return this.clone().imaskn(s);\n      }, i.prototype.iaddn = function(s) {\n        return n(typeof s == \"number\"), n(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s);\n      }, i.prototype._iaddn = function(s) {\n        this.words[0] += s;\n        for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)\n          this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;\n        return this.length = Math.max(this.length, u + 1), this;\n      }, i.prototype.isubn = function(s) {\n        if (n(typeof s == \"number\"), n(s < 67108864), s < 0) return this.iaddn(-s);\n        if (this.negative !== 0)\n          return this.negative = 0, this.iaddn(s), this.negative = 1, this;\n        if (this.words[0] -= s, this.length === 1 && this.words[0] < 0)\n          this.words[0] = -this.words[0], this.negative = 1;\n        else\n          for (var u = 0; u < this.length && this.words[u] < 0; u++)\n            this.words[u] += 67108864, this.words[u + 1] -= 1;\n        return this._strip();\n      }, i.prototype.addn = function(s) {\n        return this.clone().iaddn(s);\n      }, i.prototype.subn = function(s) {\n        return this.clone().isubn(s);\n      }, i.prototype.iabs = function() {\n        return this.negative = 0, this;\n      }, i.prototype.abs = function() {\n        return this.clone().iabs();\n      }, i.prototype._ishlnsubmul = function(s, u, h) {\n        var g = s.length + h, w;\n        this._expand(g);\n        var _, A = 0;\n        for (w = 0; w < s.length; w++) {\n          _ = (this.words[w + h] | 0) + A;\n          var p = (s.words[w] | 0) * u;\n          _ -= p & 67108863, A = (_ >> 26) - (p / 67108864 | 0), this.words[w + h] = _ & 67108863;\n        }\n        for (; w < this.length - h; w++)\n          _ = (this.words[w + h] | 0) + A, A = _ >> 26, this.words[w + h] = _ & 67108863;\n        if (A === 0) return this._strip();\n        for (n(A === -1), A = 0, w = 0; w < this.length; w++)\n          _ = -(this.words[w] | 0) + A, A = _ >> 26, this.words[w] = _ & 67108863;\n        return this.negative = 1, this._strip();\n      }, i.prototype._wordDiv = function(s, u) {\n        var h = this.length - s.length, g = this.clone(), w = s, _ = w.words[w.length - 1] | 0, A = this._countBits(_);\n        h = 26 - A, h !== 0 && (w = w.ushln(h), g.iushln(h), _ = w.words[w.length - 1] | 0);\n        var p = g.length - w.length, a;\n        if (u !== \"mod\") {\n          a = new i(null), a.length = p + 1, a.words = new Array(a.length);\n          for (var l = 0; l < a.length; l++)\n            a.words[l] = 0;\n        }\n        var M = g.clone()._ishlnsubmul(w, 1, p);\n        M.negative === 0 && (g = M, a && (a.words[p] = 1));\n        for (var k = p - 1; k >= 0; k--) {\n          var $ = (g.words[w.length + k] | 0) * 67108864 + (g.words[w.length + k - 1] | 0);\n          for ($ = Math.min($ / _ | 0, 67108863), g._ishlnsubmul(w, $, k); g.negative !== 0; )\n            $--, g.negative = 0, g._ishlnsubmul(w, 1, k), g.isZero() || (g.negative ^= 1);\n          a && (a.words[k] = $);\n        }\n        return a && a._strip(), g._strip(), u !== \"div\" && h !== 0 && g.iushrn(h), {\n          div: a || null,\n          mod: g\n        };\n      }, i.prototype.divmod = function(s, u, h) {\n        if (n(!s.isZero()), this.isZero())\n          return {\n            div: new i(0),\n            mod: new i(0)\n          };\n        var g, w, _;\n        return this.negative !== 0 && s.negative === 0 ? (_ = this.neg().divmod(s, u), u !== \"mod\" && (g = _.div.neg()), u !== \"div\" && (w = _.mod.neg(), h && w.negative !== 0 && w.iadd(s)), {\n          div: g,\n          mod: w\n        }) : this.negative === 0 && s.negative !== 0 ? (_ = this.divmod(s.neg(), u), u !== \"mod\" && (g = _.div.neg()), {\n          div: g,\n          mod: _.mod\n        }) : (this.negative & s.negative) !== 0 ? (_ = this.neg().divmod(s.neg(), u), u !== \"div\" && (w = _.mod.neg(), h && w.negative !== 0 && w.isub(s)), {\n          div: _.div,\n          mod: w\n        }) : s.length > this.length || this.cmp(s) < 0 ? {\n          div: new i(0),\n          mod: this\n        } : s.length === 1 ? u === \"div\" ? {\n          div: this.divn(s.words[0]),\n          mod: null\n        } : u === \"mod\" ? {\n          div: null,\n          mod: new i(this.modrn(s.words[0]))\n        } : {\n          div: this.divn(s.words[0]),\n          mod: new i(this.modrn(s.words[0]))\n        } : this._wordDiv(s, u);\n      }, i.prototype.div = function(s) {\n        return this.divmod(s, \"div\", !1).div;\n      }, i.prototype.mod = function(s) {\n        return this.divmod(s, \"mod\", !1).mod;\n      }, i.prototype.umod = function(s) {\n        return this.divmod(s, \"mod\", !0).mod;\n      }, i.prototype.divRound = function(s) {\n        var u = this.divmod(s);\n        if (u.mod.isZero()) return u.div;\n        var h = u.div.negative !== 0 ? u.mod.isub(s) : u.mod, g = s.ushrn(1), w = s.andln(1), _ = h.cmp(g);\n        return _ < 0 || w === 1 && _ === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);\n      }, i.prototype.modrn = function(s) {\n        var u = s < 0;\n        u && (s = -s), n(s <= 67108863);\n        for (var h = (1 << 26) % s, g = 0, w = this.length - 1; w >= 0; w--)\n          g = (h * g + (this.words[w] | 0)) % s;\n        return u ? -g : g;\n      }, i.prototype.modn = function(s) {\n        return this.modrn(s);\n      }, i.prototype.idivn = function(s) {\n        var u = s < 0;\n        u && (s = -s), n(s <= 67108863);\n        for (var h = 0, g = this.length - 1; g >= 0; g--) {\n          var w = (this.words[g] | 0) + h * 67108864;\n          this.words[g] = w / s | 0, h = w % s;\n        }\n        return this._strip(), u ? this.ineg() : this;\n      }, i.prototype.divn = function(s) {\n        return this.clone().idivn(s);\n      }, i.prototype.egcd = function(s) {\n        n(s.negative === 0), n(!s.isZero());\n        var u = this, h = s.clone();\n        u.negative !== 0 ? u = u.umod(s) : u = u.clone();\n        for (var g = new i(1), w = new i(0), _ = new i(0), A = new i(1), p = 0; u.isEven() && h.isEven(); )\n          u.iushrn(1), h.iushrn(1), ++p;\n        for (var a = h.clone(), l = u.clone(); !u.isZero(); ) {\n          for (var M = 0, k = 1; (u.words[0] & k) === 0 && M < 26; ++M, k <<= 1) ;\n          if (M > 0)\n            for (u.iushrn(M); M-- > 0; )\n              (g.isOdd() || w.isOdd()) && (g.iadd(a), w.isub(l)), g.iushrn(1), w.iushrn(1);\n          for (var $ = 0, X = 1; (h.words[0] & X) === 0 && $ < 26; ++$, X <<= 1) ;\n          if ($ > 0)\n            for (h.iushrn($); $-- > 0; )\n              (_.isOdd() || A.isOdd()) && (_.iadd(a), A.isub(l)), _.iushrn(1), A.iushrn(1);\n          u.cmp(h) >= 0 ? (u.isub(h), g.isub(_), w.isub(A)) : (h.isub(u), _.isub(g), A.isub(w));\n        }\n        return {\n          a: _,\n          b: A,\n          gcd: h.iushln(p)\n        };\n      }, i.prototype._invmp = function(s) {\n        n(s.negative === 0), n(!s.isZero());\n        var u = this, h = s.clone();\n        u.negative !== 0 ? u = u.umod(s) : u = u.clone();\n        for (var g = new i(1), w = new i(0), _ = h.clone(); u.cmpn(1) > 0 && h.cmpn(1) > 0; ) {\n          for (var A = 0, p = 1; (u.words[0] & p) === 0 && A < 26; ++A, p <<= 1) ;\n          if (A > 0)\n            for (u.iushrn(A); A-- > 0; )\n              g.isOdd() && g.iadd(_), g.iushrn(1);\n          for (var a = 0, l = 1; (h.words[0] & l) === 0 && a < 26; ++a, l <<= 1) ;\n          if (a > 0)\n            for (h.iushrn(a); a-- > 0; )\n              w.isOdd() && w.iadd(_), w.iushrn(1);\n          u.cmp(h) >= 0 ? (u.isub(h), g.isub(w)) : (h.isub(u), w.isub(g));\n        }\n        var M;\n        return u.cmpn(1) === 0 ? M = g : M = w, M.cmpn(0) < 0 && M.iadd(s), M;\n      }, i.prototype.gcd = function(s) {\n        if (this.isZero()) return s.abs();\n        if (s.isZero()) return this.abs();\n        var u = this.clone(), h = s.clone();\n        u.negative = 0, h.negative = 0;\n        for (var g = 0; u.isEven() && h.isEven(); g++)\n          u.iushrn(1), h.iushrn(1);\n        do {\n          for (; u.isEven(); )\n            u.iushrn(1);\n          for (; h.isEven(); )\n            h.iushrn(1);\n          var w = u.cmp(h);\n          if (w < 0) {\n            var _ = u;\n            u = h, h = _;\n          } else if (w === 0 || h.cmpn(1) === 0)\n            break;\n          u.isub(h);\n        } while (!0);\n        return h.iushln(g);\n      }, i.prototype.invm = function(s) {\n        return this.egcd(s).a.umod(s);\n      }, i.prototype.isEven = function() {\n        return (this.words[0] & 1) === 0;\n      }, i.prototype.isOdd = function() {\n        return (this.words[0] & 1) === 1;\n      }, i.prototype.andln = function(s) {\n        return this.words[0] & s;\n      }, i.prototype.bincn = function(s) {\n        n(typeof s == \"number\");\n        var u = s % 26, h = (s - u) / 26, g = 1 << u;\n        if (this.length <= h)\n          return this._expand(h + 1), this.words[h] |= g, this;\n        for (var w = g, _ = h; w !== 0 && _ < this.length; _++) {\n          var A = this.words[_] | 0;\n          A += w, w = A >>> 26, A &= 67108863, this.words[_] = A;\n        }\n        return w !== 0 && (this.words[_] = w, this.length++), this;\n      }, i.prototype.isZero = function() {\n        return this.length === 1 && this.words[0] === 0;\n      }, i.prototype.cmpn = function(s) {\n        var u = s < 0;\n        if (this.negative !== 0 && !u) return -1;\n        if (this.negative === 0 && u) return 1;\n        this._strip();\n        var h;\n        if (this.length > 1)\n          h = 1;\n        else {\n          u && (s = -s), n(s <= 67108863, \"Number is too big\");\n          var g = this.words[0] | 0;\n          h = g === s ? 0 : g < s ? -1 : 1;\n        }\n        return this.negative !== 0 ? -h | 0 : h;\n      }, i.prototype.cmp = function(s) {\n        if (this.negative !== 0 && s.negative === 0) return -1;\n        if (this.negative === 0 && s.negative !== 0) return 1;\n        var u = this.ucmp(s);\n        return this.negative !== 0 ? -u | 0 : u;\n      }, i.prototype.ucmp = function(s) {\n        if (this.length > s.length) return 1;\n        if (this.length < s.length) return -1;\n        for (var u = 0, h = this.length - 1; h >= 0; h--) {\n          var g = this.words[h] | 0, w = s.words[h] | 0;\n          if (g !== w) {\n            g < w ? u = -1 : g > w && (u = 1);\n            break;\n          }\n        }\n        return u;\n      }, i.prototype.gtn = function(s) {\n        return this.cmpn(s) === 1;\n      }, i.prototype.gt = function(s) {\n        return this.cmp(s) === 1;\n      }, i.prototype.gten = function(s) {\n        return this.cmpn(s) >= 0;\n      }, i.prototype.gte = function(s) {\n        return this.cmp(s) >= 0;\n      }, i.prototype.ltn = function(s) {\n        return this.cmpn(s) === -1;\n      }, i.prototype.lt = function(s) {\n        return this.cmp(s) === -1;\n      }, i.prototype.lten = function(s) {\n        return this.cmpn(s) <= 0;\n      }, i.prototype.lte = function(s) {\n        return this.cmp(s) <= 0;\n      }, i.prototype.eqn = function(s) {\n        return this.cmpn(s) === 0;\n      }, i.prototype.eq = function(s) {\n        return this.cmp(s) === 0;\n      }, i.red = function(s) {\n        return new L(s);\n      }, i.prototype.toRed = function(s) {\n        return n(!this.red, \"Already a number in reduction context\"), n(this.negative === 0, \"red works only with positives\"), s.convertTo(this)._forceRed(s);\n      }, i.prototype.fromRed = function() {\n        return n(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n      }, i.prototype._forceRed = function(s) {\n        return this.red = s, this;\n      }, i.prototype.forceRed = function(s) {\n        return n(!this.red, \"Already a number in reduction context\"), this._forceRed(s);\n      }, i.prototype.redAdd = function(s) {\n        return n(this.red, \"redAdd works only with red numbers\"), this.red.add(this, s);\n      }, i.prototype.redIAdd = function(s) {\n        return n(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, s);\n      }, i.prototype.redSub = function(s) {\n        return n(this.red, \"redSub works only with red numbers\"), this.red.sub(this, s);\n      }, i.prototype.redISub = function(s) {\n        return n(this.red, \"redISub works only with red numbers\"), this.red.isub(this, s);\n      }, i.prototype.redShl = function(s) {\n        return n(this.red, \"redShl works only with red numbers\"), this.red.shl(this, s);\n      }, i.prototype.redMul = function(s) {\n        return n(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, s), this.red.mul(this, s);\n      }, i.prototype.redIMul = function(s) {\n        return n(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, s), this.red.imul(this, s);\n      }, i.prototype.redSqr = function() {\n        return n(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n      }, i.prototype.redISqr = function() {\n        return n(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n      }, i.prototype.redSqrt = function() {\n        return n(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n      }, i.prototype.redInvm = function() {\n        return n(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n      }, i.prototype.redNeg = function() {\n        return n(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n      }, i.prototype.redPow = function(s) {\n        return n(this.red && !s.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, s);\n      };\n      var j = {\n        k256: null,\n        p224: null,\n        p192: null,\n        p25519: null\n      };\n      function V(d, s) {\n        this.name = d, this.p = new i(s, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n      }\n      V.prototype._tmp = function() {\n        var s = new i(null);\n        return s.words = new Array(Math.ceil(this.n / 13)), s;\n      }, V.prototype.ireduce = function(s) {\n        var u = s, h;\n        do\n          this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), h = u.bitLength();\n        while (h > this.n);\n        var g = h < this.n ? -1 : u.ucmp(this.p);\n        return g === 0 ? (u.words[0] = 0, u.length = 1) : g > 0 ? u.isub(this.p) : u.strip !== void 0 ? u.strip() : u._strip(), u;\n      }, V.prototype.split = function(s, u) {\n        s.iushrn(this.n, 0, u);\n      }, V.prototype.imulK = function(s) {\n        return s.imul(this.k);\n      };\n      function ee() {\n        V.call(\n          this,\n          \"k256\",\n          \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\"\n        );\n      }\n      o(ee, V), ee.prototype.split = function(s, u) {\n        for (var h = 4194303, g = Math.min(s.length, 9), w = 0; w < g; w++)\n          u.words[w] = s.words[w];\n        if (u.length = g, s.length <= 9) {\n          s.words[0] = 0, s.length = 1;\n          return;\n        }\n        var _ = s.words[9];\n        for (u.words[u.length++] = _ & h, w = 10; w < s.length; w++) {\n          var A = s.words[w] | 0;\n          s.words[w - 10] = (A & h) << 4 | _ >>> 22, _ = A;\n        }\n        _ >>>= 22, s.words[w - 10] = _, _ === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9;\n      }, ee.prototype.imulK = function(s) {\n        s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;\n        for (var u = 0, h = 0; h < s.length; h++) {\n          var g = s.words[h] | 0;\n          u += g * 977, s.words[h] = u & 67108863, u = g * 64 + (u / 67108864 | 0);\n        }\n        return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s;\n      };\n      function G() {\n        V.call(\n          this,\n          \"p224\",\n          \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\"\n        );\n      }\n      o(G, V);\n      function N() {\n        V.call(\n          this,\n          \"p192\",\n          \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\"\n        );\n      }\n      o(N, V);\n      function O() {\n        V.call(\n          this,\n          \"25519\",\n          \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\"\n        );\n      }\n      o(O, V), O.prototype.imulK = function(s) {\n        for (var u = 0, h = 0; h < s.length; h++) {\n          var g = (s.words[h] | 0) * 19 + u, w = g & 67108863;\n          g >>>= 26, s.words[h] = w, u = g;\n        }\n        return u !== 0 && (s.words[s.length++] = u), s;\n      }, i._prime = function(s) {\n        if (j[s]) return j[s];\n        var u;\n        if (s === \"k256\")\n          u = new ee();\n        else if (s === \"p224\")\n          u = new G();\n        else if (s === \"p192\")\n          u = new N();\n        else if (s === \"p25519\")\n          u = new O();\n        else\n          throw new Error(\"Unknown prime \" + s);\n        return j[s] = u, u;\n      };\n      function L(d) {\n        if (typeof d == \"string\") {\n          var s = i._prime(d);\n          this.m = s.p, this.prime = s;\n        } else\n          n(d.gtn(1), \"modulus must be greater than 1\"), this.m = d, this.prime = null;\n      }\n      L.prototype._verify1 = function(s) {\n        n(s.negative === 0, \"red works only with positives\"), n(s.red, \"red works only with red numbers\");\n      }, L.prototype._verify2 = function(s, u) {\n        n((s.negative | u.negative) === 0, \"red works only with positives\"), n(\n          s.red && s.red === u.red,\n          \"red works only with red numbers\"\n        );\n      }, L.prototype.imod = function(s) {\n        return this.prime ? this.prime.ireduce(s)._forceRed(this) : (b(s, s.umod(this.m)._forceRed(this)), s);\n      }, L.prototype.neg = function(s) {\n        return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this);\n      }, L.prototype.add = function(s, u) {\n        this._verify2(s, u);\n        var h = s.add(u);\n        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);\n      }, L.prototype.iadd = function(s, u) {\n        this._verify2(s, u);\n        var h = s.iadd(u);\n        return h.cmp(this.m) >= 0 && h.isub(this.m), h;\n      }, L.prototype.sub = function(s, u) {\n        this._verify2(s, u);\n        var h = s.sub(u);\n        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);\n      }, L.prototype.isub = function(s, u) {\n        this._verify2(s, u);\n        var h = s.isub(u);\n        return h.cmpn(0) < 0 && h.iadd(this.m), h;\n      }, L.prototype.shl = function(s, u) {\n        return this._verify1(s), this.imod(s.ushln(u));\n      }, L.prototype.imul = function(s, u) {\n        return this._verify2(s, u), this.imod(s.imul(u));\n      }, L.prototype.mul = function(s, u) {\n        return this._verify2(s, u), this.imod(s.mul(u));\n      }, L.prototype.isqr = function(s) {\n        return this.imul(s, s.clone());\n      }, L.prototype.sqr = function(s) {\n        return this.mul(s, s);\n      }, L.prototype.sqrt = function(s) {\n        if (s.isZero()) return s.clone();\n        var u = this.m.andln(3);\n        if (n(u % 2 === 1), u === 3) {\n          var h = this.m.add(new i(1)).iushrn(2);\n          return this.pow(s, h);\n        }\n        for (var g = this.m.subn(1), w = 0; !g.isZero() && g.andln(1) === 0; )\n          w++, g.iushrn(1);\n        n(!g.isZero());\n        var _ = new i(1).toRed(this), A = _.redNeg(), p = this.m.subn(1).iushrn(1), a = this.m.bitLength();\n        for (a = new i(2 * a * a).toRed(this); this.pow(a, p).cmp(A) !== 0; )\n          a.redIAdd(A);\n        for (var l = this.pow(a, g), M = this.pow(s, g.addn(1).iushrn(1)), k = this.pow(s, g), $ = w; k.cmp(_) !== 0; ) {\n          for (var X = k, re = 0; X.cmp(_) !== 0; re++)\n            X = X.redSqr();\n          n(re < $);\n          var se = this.pow(l, new i(1).iushln($ - re - 1));\n          M = M.redMul(se), l = se.redSqr(), k = k.redMul(l), $ = re;\n        }\n        return M;\n      }, L.prototype.invm = function(s) {\n        var u = s._invmp(this.m);\n        return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);\n      }, L.prototype.pow = function(s, u) {\n        if (u.isZero()) return new i(1).toRed(this);\n        if (u.cmpn(1) === 0) return s.clone();\n        var h = 4, g = new Array(1 << h);\n        g[0] = new i(1).toRed(this), g[1] = s;\n        for (var w = 2; w < g.length; w++)\n          g[w] = this.mul(g[w - 1], s);\n        var _ = g[0], A = 0, p = 0, a = u.bitLength() % 26;\n        for (a === 0 && (a = 26), w = u.length - 1; w >= 0; w--) {\n          for (var l = u.words[w], M = a - 1; M >= 0; M--) {\n            var k = l >> M & 1;\n            if (_ !== g[0] && (_ = this.sqr(_)), k === 0 && A === 0) {\n              p = 0;\n              continue;\n            }\n            A <<= 1, A |= k, p++, !(p !== h && (w !== 0 || M !== 0)) && (_ = this.mul(_, g[A]), p = 0, A = 0);\n          }\n          a = 26;\n        }\n        return _;\n      }, L.prototype.convertTo = function(s) {\n        var u = s.umod(this.m);\n        return u === s ? u.clone() : u;\n      }, L.prototype.convertFrom = function(s) {\n        var u = s.clone();\n        return u.red = null, u;\n      }, i.mont = function(s) {\n        return new F(s);\n      };\n      function F(d) {\n        L.call(this, d), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n      }\n      o(F, L), F.prototype.convertTo = function(s) {\n        return this.imod(s.ushln(this.shift));\n      }, F.prototype.convertFrom = function(s) {\n        var u = this.imod(s.mul(this.rinv));\n        return u.red = null, u;\n      }, F.prototype.imul = function(s, u) {\n        if (s.isZero() || u.isZero())\n          return s.words[0] = 0, s.length = 1, s;\n        var h = s.imul(u), g = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = h.isub(g).iushrn(this.shift), _ = w;\n        return w.cmp(this.m) >= 0 ? _ = w.isub(this.m) : w.cmpn(0) < 0 && (_ = w.iadd(this.m)), _._forceRed(this);\n      }, F.prototype.mul = function(s, u) {\n        if (s.isZero() || u.isZero()) return new i(0)._forceRed(this);\n        var h = s.mul(u), g = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = h.isub(g).iushrn(this.shift), _ = w;\n        return w.cmp(this.m) >= 0 ? _ = w.isub(this.m) : w.cmpn(0) < 0 && (_ = w.iadd(this.m)), _._forceRed(this);\n      }, F.prototype.invm = function(s) {\n        var u = this.imod(s._invmp(this.m).mul(this.r2));\n        return u._forceRed(this);\n      };\n    })(t, Nh);\n  }(rs)), rs.exports;\n}\nvar Uh = jh();\nconst Ka = /* @__PURE__ */ Qo(Uh);\nvar Wi = { exports: {} };\n/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nvar Wa;\nfunction kc() {\n  return Wa || (Wa = 1, function(t, e) {\n    var r = na(), n = r.Buffer;\n    function o(c, f) {\n      for (var v in c)\n        f[v] = c[v];\n    }\n    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (o(r, e), e.Buffer = i);\n    function i(c, f, v) {\n      return n(c, f, v);\n    }\n    i.prototype = Object.create(n.prototype), o(n, i), i.from = function(c, f, v) {\n      if (typeof c == \"number\")\n        throw new TypeError(\"Argument must not be a number\");\n      return n(c, f, v);\n    }, i.alloc = function(c, f, v) {\n      if (typeof c != \"number\")\n        throw new TypeError(\"Argument must be a number\");\n      var x = n(c);\n      return f !== void 0 ? typeof v == \"string\" ? x.fill(f, v) : x.fill(f) : x.fill(0), x;\n    }, i.allocUnsafe = function(c) {\n      if (typeof c != \"number\")\n        throw new TypeError(\"Argument must be a number\");\n      return n(c);\n    }, i.allocUnsafeSlow = function(c) {\n      if (typeof c != \"number\")\n        throw new TypeError(\"Argument must be a number\");\n      return r.SlowBuffer(c);\n    };\n  }(Wi, Wi.exports)), Wi.exports;\n}\nvar eo, Ga;\nfunction Fh() {\n  if (Ga) return eo;\n  Ga = 1;\n  var t = kc().Buffer;\n  function e(r) {\n    if (r.length >= 255)\n      throw new TypeError(\"Alphabet too long\");\n    for (var n = new Uint8Array(256), o = 0; o < n.length; o++)\n      n[o] = 255;\n    for (var i = 0; i < r.length; i++) {\n      var c = r.charAt(i), f = c.charCodeAt(0);\n      if (n[f] !== 255)\n        throw new TypeError(c + \" is ambiguous\");\n      n[f] = i;\n    }\n    var v = r.length, x = r.charAt(0), b = Math.log(v) / Math.log(256), S = Math.log(256) / Math.log(v);\n    function T(B) {\n      if ((Array.isArray(B) || B instanceof Uint8Array) && (B = t.from(B)), !t.isBuffer(B))\n        throw new TypeError(\"Expected Buffer\");\n      if (B.length === 0)\n        return \"\";\n      for (var R = 0, z = 0, K = 0, Z = B.length; K !== Z && B[K] === 0; )\n        K++, R++;\n      for (var Q = (Z - K) * S + 1 >>> 0, j = new Uint8Array(Q); K !== Z; ) {\n        for (var V = B[K], ee = 0, G = Q - 1; (V !== 0 || ee < z) && G !== -1; G--, ee++)\n          V += 256 * j[G] >>> 0, j[G] = V % v >>> 0, V = V / v >>> 0;\n        if (V !== 0)\n          throw new Error(\"Non-zero carry\");\n        z = ee, K++;\n      }\n      for (var N = Q - z; N !== Q && j[N] === 0; )\n        N++;\n      for (var O = x.repeat(R); N < Q; ++N)\n        O += r.charAt(j[N]);\n      return O;\n    }\n    function C(B) {\n      if (typeof B != \"string\")\n        throw new TypeError(\"Expected String\");\n      if (B.length === 0)\n        return t.alloc(0);\n      for (var R = 0, z = 0, K = 0; B[R] === x; )\n        z++, R++;\n      for (var Z = (B.length - R) * b + 1 >>> 0, Q = new Uint8Array(Z); R < B.length; ) {\n        var j = B.charCodeAt(R);\n        if (j > 255)\n          return;\n        var V = n[j];\n        if (V === 255)\n          return;\n        for (var ee = 0, G = Z - 1; (V !== 0 || ee < K) && G !== -1; G--, ee++)\n          V += v * Q[G] >>> 0, Q[G] = V % 256 >>> 0, V = V / 256 >>> 0;\n        if (V !== 0)\n          throw new Error(\"Non-zero carry\");\n        K = ee, R++;\n      }\n      for (var N = Z - K; N !== Z && Q[N] === 0; )\n        N++;\n      var O = t.allocUnsafe(z + (Z - N));\n      O.fill(0, 0, z);\n      for (var L = z; N !== Z; )\n        O[L++] = Q[N++];\n      return O;\n    }\n    function P(B) {\n      var R = C(B);\n      if (R)\n        return R;\n      throw new Error(\"Non-base\" + v + \" character\");\n    }\n    return {\n      encode: T,\n      decodeUnsafe: C,\n      decode: P\n    };\n  }\n  return eo = e, eo;\n}\nvar to, Ya;\nfunction Ph() {\n  if (Ya) return to;\n  Ya = 1;\n  var t = Fh(), e = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n  return to = t(e), to;\n}\nvar Dh = Ph();\nconst Nt = /* @__PURE__ */ Qo(Dh);\nfunction $h(t) {\n  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === \"Uint8Array\";\n}\nfunction Ic(t, ...e) {\n  if (!$h(t))\n    throw new Error(\"Uint8Array expected\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new Error(\"Uint8Array expected of length \" + e + \", got length=\" + t.length);\n}\nfunction Ja(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction zh(t, e) {\n  Ic(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(\"digestInto() expects output buffer of length at least \" + r);\n}\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction ro(t) {\n  return new DataView(t.buffer, t.byteOffset, t.byteLength);\n}\nfunction er(t, e) {\n  return t << 32 - e | t >>> e;\n}\nfunction qh(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"utf8ToBytes expected string, got \" + typeof t);\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nfunction Bc(t) {\n  return typeof t == \"string\" && (t = qh(t)), Ic(t), t;\n}\nclass Zh {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction Vh(t) {\n  const e = (n) => t().update(Bc(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction Hh(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const o = BigInt(32), i = BigInt(4294967295), c = Number(r >> o & i), f = Number(r & i), v = n ? 4 : 0, x = n ? 0 : 4;\n  t.setUint32(e + v, c, n), t.setUint32(e + x, f, n);\n}\nfunction Kh(t, e, r) {\n  return t & e ^ ~t & r;\n}\nfunction Wh(t, e, r) {\n  return t & e ^ t & r ^ e & r;\n}\nclass Gh extends Zh {\n  constructor(e, r, n, o) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = ro(this.buffer);\n  }\n  update(e) {\n    Ja(this);\n    const { view: r, buffer: n, blockLen: o } = this;\n    e = Bc(e);\n    const i = e.length;\n    for (let c = 0; c < i; ) {\n      const f = Math.min(o - this.pos, i - c);\n      if (f === o) {\n        const v = ro(e);\n        for (; o <= i - c; c += o)\n          this.process(v, c);\n        continue;\n      }\n      n.set(e.subarray(c, c + f), this.pos), this.pos += f, c += f, this.pos === o && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    Ja(this), zh(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: o, isLE: i } = this;\n    let { pos: c } = this;\n    r[c++] = 128, this.buffer.subarray(c).fill(0), this.padOffset > o - c && (this.process(n, 0), c = 0);\n    for (let S = c; S < o; S++)\n      r[S] = 0;\n    Hh(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);\n    const f = ro(e), v = this.outputLen;\n    if (v % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const x = v / 4, b = this.get();\n    if (x > b.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let S = 0; S < x; S++)\n      f.setUint32(4 * S, b[S], i);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: c, pos: f } = this;\n    return e.length = o, e.pos = f, e.finished = i, e.destroyed = c, o % r && e.buffer.set(n), e;\n  }\n}\nconst Yh = /* @__PURE__ */ new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), Sr = /* @__PURE__ */ new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), Ar = /* @__PURE__ */ new Uint32Array(64);\nclass Jh extends Gh {\n  constructor() {\n    super(64, 32, 8, !1), this.A = Sr[0] | 0, this.B = Sr[1] | 0, this.C = Sr[2] | 0, this.D = Sr[3] | 0, this.E = Sr[4] | 0, this.F = Sr[5] | 0, this.G = Sr[6] | 0, this.H = Sr[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: o, E: i, F: c, G: f, H: v } = this;\n    return [e, r, n, o, i, c, f, v];\n  }\n  // prettier-ignore\n  set(e, r, n, o, i, c, f, v) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = c | 0, this.G = f | 0, this.H = v | 0;\n  }\n  process(e, r) {\n    for (let S = 0; S < 16; S++, r += 4)\n      Ar[S] = e.getUint32(r, !1);\n    for (let S = 16; S < 64; S++) {\n      const T = Ar[S - 15], C = Ar[S - 2], P = er(T, 7) ^ er(T, 18) ^ T >>> 3, B = er(C, 17) ^ er(C, 19) ^ C >>> 10;\n      Ar[S] = B + Ar[S - 7] + P + Ar[S - 16] | 0;\n    }\n    let { A: n, B: o, C: i, D: c, E: f, F: v, G: x, H: b } = this;\n    for (let S = 0; S < 64; S++) {\n      const T = er(f, 6) ^ er(f, 11) ^ er(f, 25), C = b + T + Kh(f, v, x) + Yh[S] + Ar[S] | 0, B = (er(n, 2) ^ er(n, 13) ^ er(n, 22)) + Wh(n, o, i) | 0;\n      b = x, x = v, v = f, f = c + C | 0, c = i, i = o, o = n, n = C + B | 0;\n    }\n    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, c = c + this.D | 0, f = f + this.E | 0, v = v + this.F | 0, x = x + this.G | 0, b = b + this.H | 0, this.set(n, o, i, c, f, v, x, b);\n  }\n  roundClean() {\n    Ar.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nconst Xa = /* @__PURE__ */ Vh(() => new Jh());\nvar st = {}, ns = { exports: {} }, Xh = ns.exports, Qa;\nfunction Qh() {\n  return Qa || (Qa = 1, function(t) {\n    (function(e, r) {\n      function n(d, s) {\n        if (!d) throw new Error(s || \"Assertion failed\");\n      }\n      function o(d, s) {\n        d.super_ = s;\n        var u = function() {\n        };\n        u.prototype = s.prototype, d.prototype = new u(), d.prototype.constructor = d;\n      }\n      function i(d, s, u) {\n        if (i.isBN(d))\n          return d;\n        this.negative = 0, this.words = null, this.length = 0, this.red = null, d !== null && ((s === \"le\" || s === \"be\") && (u = s, s = 10), this._init(d || 0, s || 10, u || \"be\"));\n      }\n      typeof e == \"object\" ? e.exports = i : r.BN = i, i.BN = i, i.wordSize = 26;\n      var c;\n      try {\n        typeof window < \"u\" && typeof window.Buffer < \"u\" ? c = window.Buffer : c = Ac.Buffer;\n      } catch {\n      }\n      i.isBN = function(s) {\n        return s instanceof i ? !0 : s !== null && typeof s == \"object\" && s.constructor.wordSize === i.wordSize && Array.isArray(s.words);\n      }, i.max = function(s, u) {\n        return s.cmp(u) > 0 ? s : u;\n      }, i.min = function(s, u) {\n        return s.cmp(u) < 0 ? s : u;\n      }, i.prototype._init = function(s, u, h) {\n        if (typeof s == \"number\")\n          return this._initNumber(s, u, h);\n        if (typeof s == \"object\")\n          return this._initArray(s, u, h);\n        u === \"hex\" && (u = 16), n(u === (u | 0) && u >= 2 && u <= 36), s = s.toString().replace(/\\s+/g, \"\");\n        var g = 0;\n        s[0] === \"-\" && (g++, this.negative = 1), g < s.length && (u === 16 ? this._parseHex(s, g, h) : (this._parseBase(s, u, g), h === \"le\" && this._initArray(this.toArray(), u, h)));\n      }, i.prototype._initNumber = function(s, u, h) {\n        s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [\n          s & 67108863,\n          s / 67108864 & 67108863\n        ], this.length = 2) : (n(s < 9007199254740992), this.words = [\n          s & 67108863,\n          s / 67108864 & 67108863,\n          1\n        ], this.length = 3), h === \"le\" && this._initArray(this.toArray(), u, h);\n      }, i.prototype._initArray = function(s, u, h) {\n        if (n(typeof s.length == \"number\"), s.length <= 0)\n          return this.words = [0], this.length = 1, this;\n        this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);\n        for (var g = 0; g < this.length; g++)\n          this.words[g] = 0;\n        var w, _, A = 0;\n        if (h === \"be\")\n          for (g = s.length - 1, w = 0; g >= 0; g -= 3)\n            _ = s[g] | s[g - 1] << 8 | s[g - 2] << 16, this.words[w] |= _ << A & 67108863, this.words[w + 1] = _ >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, w++);\n        else if (h === \"le\")\n          for (g = 0, w = 0; g < s.length; g += 3)\n            _ = s[g] | s[g + 1] << 8 | s[g + 2] << 16, this.words[w] |= _ << A & 67108863, this.words[w + 1] = _ >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, w++);\n        return this._strip();\n      };\n      function f(d, s) {\n        var u = d.charCodeAt(s);\n        if (u >= 48 && u <= 57)\n          return u - 48;\n        if (u >= 65 && u <= 70)\n          return u - 55;\n        if (u >= 97 && u <= 102)\n          return u - 87;\n        n(!1, \"Invalid character in \" + d);\n      }\n      function v(d, s, u) {\n        var h = f(d, u);\n        return u - 1 >= s && (h |= f(d, u - 1) << 4), h;\n      }\n      i.prototype._parseHex = function(s, u, h) {\n        this.length = Math.ceil((s.length - u) / 6), this.words = new Array(this.length);\n        for (var g = 0; g < this.length; g++)\n          this.words[g] = 0;\n        var w = 0, _ = 0, A;\n        if (h === \"be\")\n          for (g = s.length - 1; g >= u; g -= 2)\n            A = v(s, u, g) << w, this.words[_] |= A & 67108863, w >= 18 ? (w -= 18, _ += 1, this.words[_] |= A >>> 26) : w += 8;\n        else {\n          var p = s.length - u;\n          for (g = p % 2 === 0 ? u + 1 : u; g < s.length; g += 2)\n            A = v(s, u, g) << w, this.words[_] |= A & 67108863, w >= 18 ? (w -= 18, _ += 1, this.words[_] |= A >>> 26) : w += 8;\n        }\n        this._strip();\n      };\n      function x(d, s, u, h) {\n        for (var g = 0, w = 0, _ = Math.min(d.length, u), A = s; A < _; A++) {\n          var p = d.charCodeAt(A) - 48;\n          g *= h, p >= 49 ? w = p - 49 + 10 : p >= 17 ? w = p - 17 + 10 : w = p, n(p >= 0 && w < h, \"Invalid character\"), g += w;\n        }\n        return g;\n      }\n      i.prototype._parseBase = function(s, u, h) {\n        this.words = [0], this.length = 1;\n        for (var g = 0, w = 1; w <= 67108863; w *= u)\n          g++;\n        g--, w = w / u | 0;\n        for (var _ = s.length - h, A = _ % g, p = Math.min(_, _ - A) + h, a = 0, l = h; l < p; l += g)\n          a = x(s, l, l + g, u), this.imuln(w), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a);\n        if (A !== 0) {\n          var M = 1;\n          for (a = x(s, l, s.length, u), l = 0; l < A; l++)\n            M *= u;\n          this.imuln(M), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a);\n        }\n        this._strip();\n      }, i.prototype.copy = function(s) {\n        s.words = new Array(this.length);\n        for (var u = 0; u < this.length; u++)\n          s.words[u] = this.words[u];\n        s.length = this.length, s.negative = this.negative, s.red = this.red;\n      };\n      function b(d, s) {\n        d.words = s.words, d.length = s.length, d.negative = s.negative, d.red = s.red;\n      }\n      if (i.prototype._move = function(s) {\n        b(s, this);\n      }, i.prototype.clone = function() {\n        var s = new i(null);\n        return this.copy(s), s;\n      }, i.prototype._expand = function(s) {\n        for (; this.length < s; )\n          this.words[this.length++] = 0;\n        return this;\n      }, i.prototype._strip = function() {\n        for (; this.length > 1 && this.words[this.length - 1] === 0; )\n          this.length--;\n        return this._normSign();\n      }, i.prototype._normSign = function() {\n        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;\n      }, typeof Symbol < \"u\" && typeof Symbol.for == \"function\")\n        try {\n          i.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = S;\n        } catch {\n          i.prototype.inspect = S;\n        }\n      else\n        i.prototype.inspect = S;\n      function S() {\n        return (this.red ? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n      }\n      var T = [\n        \"\",\n        \"0\",\n        \"00\",\n        \"000\",\n        \"0000\",\n        \"00000\",\n        \"000000\",\n        \"0000000\",\n        \"00000000\",\n        \"000000000\",\n        \"0000000000\",\n        \"00000000000\",\n        \"000000000000\",\n        \"0000000000000\",\n        \"00000000000000\",\n        \"000000000000000\",\n        \"0000000000000000\",\n        \"00000000000000000\",\n        \"000000000000000000\",\n        \"0000000000000000000\",\n        \"00000000000000000000\",\n        \"000000000000000000000\",\n        \"0000000000000000000000\",\n        \"00000000000000000000000\",\n        \"000000000000000000000000\",\n        \"0000000000000000000000000\"\n      ], C = [\n        0,\n        0,\n        25,\n        16,\n        12,\n        11,\n        10,\n        9,\n        8,\n        8,\n        7,\n        7,\n        7,\n        7,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5\n      ], P = [\n        0,\n        0,\n        33554432,\n        43046721,\n        16777216,\n        48828125,\n        60466176,\n        40353607,\n        16777216,\n        43046721,\n        1e7,\n        19487171,\n        35831808,\n        62748517,\n        7529536,\n        11390625,\n        16777216,\n        24137569,\n        34012224,\n        47045881,\n        64e6,\n        4084101,\n        5153632,\n        6436343,\n        7962624,\n        9765625,\n        11881376,\n        14348907,\n        17210368,\n        20511149,\n        243e5,\n        28629151,\n        33554432,\n        39135393,\n        45435424,\n        52521875,\n        60466176\n      ];\n      i.prototype.toString = function(s, u) {\n        s = s || 10, u = u | 0 || 1;\n        var h;\n        if (s === 16 || s === \"hex\") {\n          h = \"\";\n          for (var g = 0, w = 0, _ = 0; _ < this.length; _++) {\n            var A = this.words[_], p = ((A << g | w) & 16777215).toString(16);\n            w = A >>> 24 - g & 16777215, g += 2, g >= 26 && (g -= 26, _--), w !== 0 || _ !== this.length - 1 ? h = T[6 - p.length] + p + h : h = p + h;\n          }\n          for (w !== 0 && (h = w.toString(16) + h); h.length % u !== 0; )\n            h = \"0\" + h;\n          return this.negative !== 0 && (h = \"-\" + h), h;\n        }\n        if (s === (s | 0) && s >= 2 && s <= 36) {\n          var a = C[s], l = P[s];\n          h = \"\";\n          var M = this.clone();\n          for (M.negative = 0; !M.isZero(); ) {\n            var k = M.modrn(l).toString(s);\n            M = M.idivn(l), M.isZero() ? h = k + h : h = T[a - k.length] + k + h;\n          }\n          for (this.isZero() && (h = \"0\" + h); h.length % u !== 0; )\n            h = \"0\" + h;\n          return this.negative !== 0 && (h = \"-\" + h), h;\n        }\n        n(!1, \"Base should be between 2 and 36\");\n      }, i.prototype.toNumber = function() {\n        var s = this.words[0];\n        return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 ? -s : s;\n      }, i.prototype.toJSON = function() {\n        return this.toString(16, 2);\n      }, c && (i.prototype.toBuffer = function(s, u) {\n        return this.toArrayLike(c, s, u);\n      }), i.prototype.toArray = function(s, u) {\n        return this.toArrayLike(Array, s, u);\n      };\n      var B = function(s, u) {\n        return s.allocUnsafe ? s.allocUnsafe(u) : new s(u);\n      };\n      i.prototype.toArrayLike = function(s, u, h) {\n        this._strip();\n        var g = this.byteLength(), w = h || Math.max(1, g);\n        n(g <= w, \"byte array longer than desired length\"), n(w > 0, \"Requested array length <= 0\");\n        var _ = B(s, w), A = u === \"le\" ? \"LE\" : \"BE\";\n        return this[\"_toArrayLike\" + A](_, g), _;\n      }, i.prototype._toArrayLikeLE = function(s, u) {\n        for (var h = 0, g = 0, w = 0, _ = 0; w < this.length; w++) {\n          var A = this.words[w] << _ | g;\n          s[h++] = A & 255, h < s.length && (s[h++] = A >> 8 & 255), h < s.length && (s[h++] = A >> 16 & 255), _ === 6 ? (h < s.length && (s[h++] = A >> 24 & 255), g = 0, _ = 0) : (g = A >>> 24, _ += 2);\n        }\n        if (h < s.length)\n          for (s[h++] = g; h < s.length; )\n            s[h++] = 0;\n      }, i.prototype._toArrayLikeBE = function(s, u) {\n        for (var h = s.length - 1, g = 0, w = 0, _ = 0; w < this.length; w++) {\n          var A = this.words[w] << _ | g;\n          s[h--] = A & 255, h >= 0 && (s[h--] = A >> 8 & 255), h >= 0 && (s[h--] = A >> 16 & 255), _ === 6 ? (h >= 0 && (s[h--] = A >> 24 & 255), g = 0, _ = 0) : (g = A >>> 24, _ += 2);\n        }\n        if (h >= 0)\n          for (s[h--] = g; h >= 0; )\n            s[h--] = 0;\n      }, Math.clz32 ? i.prototype._countBits = function(s) {\n        return 32 - Math.clz32(s);\n      } : i.prototype._countBits = function(s) {\n        var u = s, h = 0;\n        return u >= 4096 && (h += 13, u >>>= 13), u >= 64 && (h += 7, u >>>= 7), u >= 8 && (h += 4, u >>>= 4), u >= 2 && (h += 2, u >>>= 2), h + u;\n      }, i.prototype._zeroBits = function(s) {\n        if (s === 0) return 26;\n        var u = s, h = 0;\n        return (u & 8191) === 0 && (h += 13, u >>>= 13), (u & 127) === 0 && (h += 7, u >>>= 7), (u & 15) === 0 && (h += 4, u >>>= 4), (u & 3) === 0 && (h += 2, u >>>= 2), (u & 1) === 0 && h++, h;\n      }, i.prototype.bitLength = function() {\n        var s = this.words[this.length - 1], u = this._countBits(s);\n        return (this.length - 1) * 26 + u;\n      };\n      function R(d) {\n        for (var s = new Array(d.bitLength()), u = 0; u < s.length; u++) {\n          var h = u / 26 | 0, g = u % 26;\n          s[u] = d.words[h] >>> g & 1;\n        }\n        return s;\n      }\n      i.prototype.zeroBits = function() {\n        if (this.isZero()) return 0;\n        for (var s = 0, u = 0; u < this.length; u++) {\n          var h = this._zeroBits(this.words[u]);\n          if (s += h, h !== 26) break;\n        }\n        return s;\n      }, i.prototype.byteLength = function() {\n        return Math.ceil(this.bitLength() / 8);\n      }, i.prototype.toTwos = function(s) {\n        return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();\n      }, i.prototype.fromTwos = function(s) {\n        return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();\n      }, i.prototype.isNeg = function() {\n        return this.negative !== 0;\n      }, i.prototype.neg = function() {\n        return this.clone().ineg();\n      }, i.prototype.ineg = function() {\n        return this.isZero() || (this.negative ^= 1), this;\n      }, i.prototype.iuor = function(s) {\n        for (; this.length < s.length; )\n          this.words[this.length++] = 0;\n        for (var u = 0; u < s.length; u++)\n          this.words[u] = this.words[u] | s.words[u];\n        return this._strip();\n      }, i.prototype.ior = function(s) {\n        return n((this.negative | s.negative) === 0), this.iuor(s);\n      }, i.prototype.or = function(s) {\n        return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this);\n      }, i.prototype.uor = function(s) {\n        return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this);\n      }, i.prototype.iuand = function(s) {\n        var u;\n        this.length > s.length ? u = s : u = this;\n        for (var h = 0; h < u.length; h++)\n          this.words[h] = this.words[h] & s.words[h];\n        return this.length = u.length, this._strip();\n      }, i.prototype.iand = function(s) {\n        return n((this.negative | s.negative) === 0), this.iuand(s);\n      }, i.prototype.and = function(s) {\n        return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this);\n      }, i.prototype.uand = function(s) {\n        return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this);\n      }, i.prototype.iuxor = function(s) {\n        var u, h;\n        this.length > s.length ? (u = this, h = s) : (u = s, h = this);\n        for (var g = 0; g < h.length; g++)\n          this.words[g] = u.words[g] ^ h.words[g];\n        if (this !== u)\n          for (; g < u.length; g++)\n            this.words[g] = u.words[g];\n        return this.length = u.length, this._strip();\n      }, i.prototype.ixor = function(s) {\n        return n((this.negative | s.negative) === 0), this.iuxor(s);\n      }, i.prototype.xor = function(s) {\n        return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this);\n      }, i.prototype.uxor = function(s) {\n        return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this);\n      }, i.prototype.inotn = function(s) {\n        n(typeof s == \"number\" && s >= 0);\n        var u = Math.ceil(s / 26) | 0, h = s % 26;\n        this._expand(u), h > 0 && u--;\n        for (var g = 0; g < u; g++)\n          this.words[g] = ~this.words[g] & 67108863;\n        return h > 0 && (this.words[g] = ~this.words[g] & 67108863 >> 26 - h), this._strip();\n      }, i.prototype.notn = function(s) {\n        return this.clone().inotn(s);\n      }, i.prototype.setn = function(s, u) {\n        n(typeof s == \"number\" && s >= 0);\n        var h = s / 26 | 0, g = s % 26;\n        return this._expand(h + 1), u ? this.words[h] = this.words[h] | 1 << g : this.words[h] = this.words[h] & ~(1 << g), this._strip();\n      }, i.prototype.iadd = function(s) {\n        var u;\n        if (this.negative !== 0 && s.negative === 0)\n          return this.negative = 0, u = this.isub(s), this.negative ^= 1, this._normSign();\n        if (this.negative === 0 && s.negative !== 0)\n          return s.negative = 0, u = this.isub(s), s.negative = 1, u._normSign();\n        var h, g;\n        this.length > s.length ? (h = this, g = s) : (h = s, g = this);\n        for (var w = 0, _ = 0; _ < g.length; _++)\n          u = (h.words[_] | 0) + (g.words[_] | 0) + w, this.words[_] = u & 67108863, w = u >>> 26;\n        for (; w !== 0 && _ < h.length; _++)\n          u = (h.words[_] | 0) + w, this.words[_] = u & 67108863, w = u >>> 26;\n        if (this.length = h.length, w !== 0)\n          this.words[this.length] = w, this.length++;\n        else if (h !== this)\n          for (; _ < h.length; _++)\n            this.words[_] = h.words[_];\n        return this;\n      }, i.prototype.add = function(s) {\n        var u;\n        return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, u = this.sub(s), s.negative ^= 1, u) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = s.sub(this), this.negative = 1, u) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this);\n      }, i.prototype.isub = function(s) {\n        if (s.negative !== 0) {\n          s.negative = 0;\n          var u = this.iadd(s);\n          return s.negative = 1, u._normSign();\n        } else if (this.negative !== 0)\n          return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();\n        var h = this.cmp(s);\n        if (h === 0)\n          return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n        var g, w;\n        h > 0 ? (g = this, w = s) : (g = s, w = this);\n        for (var _ = 0, A = 0; A < w.length; A++)\n          u = (g.words[A] | 0) - (w.words[A] | 0) + _, _ = u >> 26, this.words[A] = u & 67108863;\n        for (; _ !== 0 && A < g.length; A++)\n          u = (g.words[A] | 0) + _, _ = u >> 26, this.words[A] = u & 67108863;\n        if (_ === 0 && A < g.length && g !== this)\n          for (; A < g.length; A++)\n            this.words[A] = g.words[A];\n        return this.length = Math.max(this.length, A), g !== this && (this.negative = 1), this._strip();\n      }, i.prototype.sub = function(s) {\n        return this.clone().isub(s);\n      };\n      function z(d, s, u) {\n        u.negative = s.negative ^ d.negative;\n        var h = d.length + s.length | 0;\n        u.length = h, h = h - 1 | 0;\n        var g = d.words[0] | 0, w = s.words[0] | 0, _ = g * w, A = _ & 67108863, p = _ / 67108864 | 0;\n        u.words[0] = A;\n        for (var a = 1; a < h; a++) {\n          for (var l = p >>> 26, M = p & 67108863, k = Math.min(a, s.length - 1), $ = Math.max(0, a - d.length + 1); $ <= k; $++) {\n            var X = a - $ | 0;\n            g = d.words[X] | 0, w = s.words[$] | 0, _ = g * w + M, l += _ / 67108864 | 0, M = _ & 67108863;\n          }\n          u.words[a] = M | 0, p = l | 0;\n        }\n        return p !== 0 ? u.words[a] = p | 0 : u.length--, u._strip();\n      }\n      var K = function(s, u, h) {\n        var g = s.words, w = u.words, _ = h.words, A = 0, p, a, l, M = g[0] | 0, k = M & 8191, $ = M >>> 13, X = g[1] | 0, re = X & 8191, se = X >>> 13, ut = g[2] | 0, xe = ut & 8191, Ie = ut >>> 13, Xe = g[3] | 0, ae = Xe & 8191, ge = Xe >>> 13, it = g[4] | 0, we = it & 8191, Me = it >>> 13, ft = g[5] | 0, ye = ft & 8191, be = ft >>> 13, xt = g[6] | 0, Se = xt & 8191, ke = xt >>> 13, ct = g[7] | 0, _e = ct & 8191, E = ct >>> 13, m = g[8] | 0, y = m & 8191, I = m >>> 13, q = g[9] | 0, H = q & 8191, W = q >>> 13, Be = w[0] | 0, me = Be & 8191, de = Be >>> 13, ot = w[1] | 0, ce = ot & 8191, Le = ot >>> 13, Vn = w[2] | 0, Oe = Vn & 8191, Ne = Vn >>> 13, Hn = w[3] | 0, je = Hn & 8191, Ue = Hn >>> 13, Kn = w[4] | 0, Fe = Kn & 8191, Pe = Kn >>> 13, Wn = w[5] | 0, De = Wn & 8191, $e = Wn >>> 13, Gn = w[6] | 0, ze = Gn & 8191, qe = Gn >>> 13, Yn = w[7] | 0, Ze = Yn & 8191, Ve = Yn >>> 13, Jn = w[8] | 0, He = Jn & 8191, Ke = Jn >>> 13, Xn = w[9] | 0, We = Xn & 8191, Ge = Xn >>> 13;\n        h.negative = s.negative ^ u.negative, h.length = 19, p = Math.imul(k, me), a = Math.imul(k, de), a = a + Math.imul($, me) | 0, l = Math.imul($, de);\n        var Fr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, p = Math.imul(re, me), a = Math.imul(re, de), a = a + Math.imul(se, me) | 0, l = Math.imul(se, de), p = p + Math.imul(k, ce) | 0, a = a + Math.imul(k, Le) | 0, a = a + Math.imul($, ce) | 0, l = l + Math.imul($, Le) | 0;\n        var Pr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, p = Math.imul(xe, me), a = Math.imul(xe, de), a = a + Math.imul(Ie, me) | 0, l = Math.imul(Ie, de), p = p + Math.imul(re, ce) | 0, a = a + Math.imul(re, Le) | 0, a = a + Math.imul(se, ce) | 0, l = l + Math.imul(se, Le) | 0, p = p + Math.imul(k, Oe) | 0, a = a + Math.imul(k, Ne) | 0, a = a + Math.imul($, Oe) | 0, l = l + Math.imul($, Ne) | 0;\n        var Dr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, p = Math.imul(ae, me), a = Math.imul(ae, de), a = a + Math.imul(ge, me) | 0, l = Math.imul(ge, de), p = p + Math.imul(xe, ce) | 0, a = a + Math.imul(xe, Le) | 0, a = a + Math.imul(Ie, ce) | 0, l = l + Math.imul(Ie, Le) | 0, p = p + Math.imul(re, Oe) | 0, a = a + Math.imul(re, Ne) | 0, a = a + Math.imul(se, Oe) | 0, l = l + Math.imul(se, Ne) | 0, p = p + Math.imul(k, je) | 0, a = a + Math.imul(k, Ue) | 0, a = a + Math.imul($, je) | 0, l = l + Math.imul($, Ue) | 0;\n        var $r = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, p = Math.imul(we, me), a = Math.imul(we, de), a = a + Math.imul(Me, me) | 0, l = Math.imul(Me, de), p = p + Math.imul(ae, ce) | 0, a = a + Math.imul(ae, Le) | 0, a = a + Math.imul(ge, ce) | 0, l = l + Math.imul(ge, Le) | 0, p = p + Math.imul(xe, Oe) | 0, a = a + Math.imul(xe, Ne) | 0, a = a + Math.imul(Ie, Oe) | 0, l = l + Math.imul(Ie, Ne) | 0, p = p + Math.imul(re, je) | 0, a = a + Math.imul(re, Ue) | 0, a = a + Math.imul(se, je) | 0, l = l + Math.imul(se, Ue) | 0, p = p + Math.imul(k, Fe) | 0, a = a + Math.imul(k, Pe) | 0, a = a + Math.imul($, Fe) | 0, l = l + Math.imul($, Pe) | 0;\n        var zr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, p = Math.imul(ye, me), a = Math.imul(ye, de), a = a + Math.imul(be, me) | 0, l = Math.imul(be, de), p = p + Math.imul(we, ce) | 0, a = a + Math.imul(we, Le) | 0, a = a + Math.imul(Me, ce) | 0, l = l + Math.imul(Me, Le) | 0, p = p + Math.imul(ae, Oe) | 0, a = a + Math.imul(ae, Ne) | 0, a = a + Math.imul(ge, Oe) | 0, l = l + Math.imul(ge, Ne) | 0, p = p + Math.imul(xe, je) | 0, a = a + Math.imul(xe, Ue) | 0, a = a + Math.imul(Ie, je) | 0, l = l + Math.imul(Ie, Ue) | 0, p = p + Math.imul(re, Fe) | 0, a = a + Math.imul(re, Pe) | 0, a = a + Math.imul(se, Fe) | 0, l = l + Math.imul(se, Pe) | 0, p = p + Math.imul(k, De) | 0, a = a + Math.imul(k, $e) | 0, a = a + Math.imul($, De) | 0, l = l + Math.imul($, $e) | 0;\n        var qr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, p = Math.imul(Se, me), a = Math.imul(Se, de), a = a + Math.imul(ke, me) | 0, l = Math.imul(ke, de), p = p + Math.imul(ye, ce) | 0, a = a + Math.imul(ye, Le) | 0, a = a + Math.imul(be, ce) | 0, l = l + Math.imul(be, Le) | 0, p = p + Math.imul(we, Oe) | 0, a = a + Math.imul(we, Ne) | 0, a = a + Math.imul(Me, Oe) | 0, l = l + Math.imul(Me, Ne) | 0, p = p + Math.imul(ae, je) | 0, a = a + Math.imul(ae, Ue) | 0, a = a + Math.imul(ge, je) | 0, l = l + Math.imul(ge, Ue) | 0, p = p + Math.imul(xe, Fe) | 0, a = a + Math.imul(xe, Pe) | 0, a = a + Math.imul(Ie, Fe) | 0, l = l + Math.imul(Ie, Pe) | 0, p = p + Math.imul(re, De) | 0, a = a + Math.imul(re, $e) | 0, a = a + Math.imul(se, De) | 0, l = l + Math.imul(se, $e) | 0, p = p + Math.imul(k, ze) | 0, a = a + Math.imul(k, qe) | 0, a = a + Math.imul($, ze) | 0, l = l + Math.imul($, qe) | 0;\n        var Zr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, p = Math.imul(_e, me), a = Math.imul(_e, de), a = a + Math.imul(E, me) | 0, l = Math.imul(E, de), p = p + Math.imul(Se, ce) | 0, a = a + Math.imul(Se, Le) | 0, a = a + Math.imul(ke, ce) | 0, l = l + Math.imul(ke, Le) | 0, p = p + Math.imul(ye, Oe) | 0, a = a + Math.imul(ye, Ne) | 0, a = a + Math.imul(be, Oe) | 0, l = l + Math.imul(be, Ne) | 0, p = p + Math.imul(we, je) | 0, a = a + Math.imul(we, Ue) | 0, a = a + Math.imul(Me, je) | 0, l = l + Math.imul(Me, Ue) | 0, p = p + Math.imul(ae, Fe) | 0, a = a + Math.imul(ae, Pe) | 0, a = a + Math.imul(ge, Fe) | 0, l = l + Math.imul(ge, Pe) | 0, p = p + Math.imul(xe, De) | 0, a = a + Math.imul(xe, $e) | 0, a = a + Math.imul(Ie, De) | 0, l = l + Math.imul(Ie, $e) | 0, p = p + Math.imul(re, ze) | 0, a = a + Math.imul(re, qe) | 0, a = a + Math.imul(se, ze) | 0, l = l + Math.imul(se, qe) | 0, p = p + Math.imul(k, Ze) | 0, a = a + Math.imul(k, Ve) | 0, a = a + Math.imul($, Ze) | 0, l = l + Math.imul($, Ve) | 0;\n        var Vr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, p = Math.imul(y, me), a = Math.imul(y, de), a = a + Math.imul(I, me) | 0, l = Math.imul(I, de), p = p + Math.imul(_e, ce) | 0, a = a + Math.imul(_e, Le) | 0, a = a + Math.imul(E, ce) | 0, l = l + Math.imul(E, Le) | 0, p = p + Math.imul(Se, Oe) | 0, a = a + Math.imul(Se, Ne) | 0, a = a + Math.imul(ke, Oe) | 0, l = l + Math.imul(ke, Ne) | 0, p = p + Math.imul(ye, je) | 0, a = a + Math.imul(ye, Ue) | 0, a = a + Math.imul(be, je) | 0, l = l + Math.imul(be, Ue) | 0, p = p + Math.imul(we, Fe) | 0, a = a + Math.imul(we, Pe) | 0, a = a + Math.imul(Me, Fe) | 0, l = l + Math.imul(Me, Pe) | 0, p = p + Math.imul(ae, De) | 0, a = a + Math.imul(ae, $e) | 0, a = a + Math.imul(ge, De) | 0, l = l + Math.imul(ge, $e) | 0, p = p + Math.imul(xe, ze) | 0, a = a + Math.imul(xe, qe) | 0, a = a + Math.imul(Ie, ze) | 0, l = l + Math.imul(Ie, qe) | 0, p = p + Math.imul(re, Ze) | 0, a = a + Math.imul(re, Ve) | 0, a = a + Math.imul(se, Ze) | 0, l = l + Math.imul(se, Ve) | 0, p = p + Math.imul(k, He) | 0, a = a + Math.imul(k, Ke) | 0, a = a + Math.imul($, He) | 0, l = l + Math.imul($, Ke) | 0;\n        var Hr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, p = Math.imul(H, me), a = Math.imul(H, de), a = a + Math.imul(W, me) | 0, l = Math.imul(W, de), p = p + Math.imul(y, ce) | 0, a = a + Math.imul(y, Le) | 0, a = a + Math.imul(I, ce) | 0, l = l + Math.imul(I, Le) | 0, p = p + Math.imul(_e, Oe) | 0, a = a + Math.imul(_e, Ne) | 0, a = a + Math.imul(E, Oe) | 0, l = l + Math.imul(E, Ne) | 0, p = p + Math.imul(Se, je) | 0, a = a + Math.imul(Se, Ue) | 0, a = a + Math.imul(ke, je) | 0, l = l + Math.imul(ke, Ue) | 0, p = p + Math.imul(ye, Fe) | 0, a = a + Math.imul(ye, Pe) | 0, a = a + Math.imul(be, Fe) | 0, l = l + Math.imul(be, Pe) | 0, p = p + Math.imul(we, De) | 0, a = a + Math.imul(we, $e) | 0, a = a + Math.imul(Me, De) | 0, l = l + Math.imul(Me, $e) | 0, p = p + Math.imul(ae, ze) | 0, a = a + Math.imul(ae, qe) | 0, a = a + Math.imul(ge, ze) | 0, l = l + Math.imul(ge, qe) | 0, p = p + Math.imul(xe, Ze) | 0, a = a + Math.imul(xe, Ve) | 0, a = a + Math.imul(Ie, Ze) | 0, l = l + Math.imul(Ie, Ve) | 0, p = p + Math.imul(re, He) | 0, a = a + Math.imul(re, Ke) | 0, a = a + Math.imul(se, He) | 0, l = l + Math.imul(se, Ke) | 0, p = p + Math.imul(k, We) | 0, a = a + Math.imul(k, Ge) | 0, a = a + Math.imul($, We) | 0, l = l + Math.imul($, Ge) | 0;\n        var Kr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, p = Math.imul(H, ce), a = Math.imul(H, Le), a = a + Math.imul(W, ce) | 0, l = Math.imul(W, Le), p = p + Math.imul(y, Oe) | 0, a = a + Math.imul(y, Ne) | 0, a = a + Math.imul(I, Oe) | 0, l = l + Math.imul(I, Ne) | 0, p = p + Math.imul(_e, je) | 0, a = a + Math.imul(_e, Ue) | 0, a = a + Math.imul(E, je) | 0, l = l + Math.imul(E, Ue) | 0, p = p + Math.imul(Se, Fe) | 0, a = a + Math.imul(Se, Pe) | 0, a = a + Math.imul(ke, Fe) | 0, l = l + Math.imul(ke, Pe) | 0, p = p + Math.imul(ye, De) | 0, a = a + Math.imul(ye, $e) | 0, a = a + Math.imul(be, De) | 0, l = l + Math.imul(be, $e) | 0, p = p + Math.imul(we, ze) | 0, a = a + Math.imul(we, qe) | 0, a = a + Math.imul(Me, ze) | 0, l = l + Math.imul(Me, qe) | 0, p = p + Math.imul(ae, Ze) | 0, a = a + Math.imul(ae, Ve) | 0, a = a + Math.imul(ge, Ze) | 0, l = l + Math.imul(ge, Ve) | 0, p = p + Math.imul(xe, He) | 0, a = a + Math.imul(xe, Ke) | 0, a = a + Math.imul(Ie, He) | 0, l = l + Math.imul(Ie, Ke) | 0, p = p + Math.imul(re, We) | 0, a = a + Math.imul(re, Ge) | 0, a = a + Math.imul(se, We) | 0, l = l + Math.imul(se, Ge) | 0;\n        var Wr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, p = Math.imul(H, Oe), a = Math.imul(H, Ne), a = a + Math.imul(W, Oe) | 0, l = Math.imul(W, Ne), p = p + Math.imul(y, je) | 0, a = a + Math.imul(y, Ue) | 0, a = a + Math.imul(I, je) | 0, l = l + Math.imul(I, Ue) | 0, p = p + Math.imul(_e, Fe) | 0, a = a + Math.imul(_e, Pe) | 0, a = a + Math.imul(E, Fe) | 0, l = l + Math.imul(E, Pe) | 0, p = p + Math.imul(Se, De) | 0, a = a + Math.imul(Se, $e) | 0, a = a + Math.imul(ke, De) | 0, l = l + Math.imul(ke, $e) | 0, p = p + Math.imul(ye, ze) | 0, a = a + Math.imul(ye, qe) | 0, a = a + Math.imul(be, ze) | 0, l = l + Math.imul(be, qe) | 0, p = p + Math.imul(we, Ze) | 0, a = a + Math.imul(we, Ve) | 0, a = a + Math.imul(Me, Ze) | 0, l = l + Math.imul(Me, Ve) | 0, p = p + Math.imul(ae, He) | 0, a = a + Math.imul(ae, Ke) | 0, a = a + Math.imul(ge, He) | 0, l = l + Math.imul(ge, Ke) | 0, p = p + Math.imul(xe, We) | 0, a = a + Math.imul(xe, Ge) | 0, a = a + Math.imul(Ie, We) | 0, l = l + Math.imul(Ie, Ge) | 0;\n        var Gr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, p = Math.imul(H, je), a = Math.imul(H, Ue), a = a + Math.imul(W, je) | 0, l = Math.imul(W, Ue), p = p + Math.imul(y, Fe) | 0, a = a + Math.imul(y, Pe) | 0, a = a + Math.imul(I, Fe) | 0, l = l + Math.imul(I, Pe) | 0, p = p + Math.imul(_e, De) | 0, a = a + Math.imul(_e, $e) | 0, a = a + Math.imul(E, De) | 0, l = l + Math.imul(E, $e) | 0, p = p + Math.imul(Se, ze) | 0, a = a + Math.imul(Se, qe) | 0, a = a + Math.imul(ke, ze) | 0, l = l + Math.imul(ke, qe) | 0, p = p + Math.imul(ye, Ze) | 0, a = a + Math.imul(ye, Ve) | 0, a = a + Math.imul(be, Ze) | 0, l = l + Math.imul(be, Ve) | 0, p = p + Math.imul(we, He) | 0, a = a + Math.imul(we, Ke) | 0, a = a + Math.imul(Me, He) | 0, l = l + Math.imul(Me, Ke) | 0, p = p + Math.imul(ae, We) | 0, a = a + Math.imul(ae, Ge) | 0, a = a + Math.imul(ge, We) | 0, l = l + Math.imul(ge, Ge) | 0;\n        var Yr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, p = Math.imul(H, Fe), a = Math.imul(H, Pe), a = a + Math.imul(W, Fe) | 0, l = Math.imul(W, Pe), p = p + Math.imul(y, De) | 0, a = a + Math.imul(y, $e) | 0, a = a + Math.imul(I, De) | 0, l = l + Math.imul(I, $e) | 0, p = p + Math.imul(_e, ze) | 0, a = a + Math.imul(_e, qe) | 0, a = a + Math.imul(E, ze) | 0, l = l + Math.imul(E, qe) | 0, p = p + Math.imul(Se, Ze) | 0, a = a + Math.imul(Se, Ve) | 0, a = a + Math.imul(ke, Ze) | 0, l = l + Math.imul(ke, Ve) | 0, p = p + Math.imul(ye, He) | 0, a = a + Math.imul(ye, Ke) | 0, a = a + Math.imul(be, He) | 0, l = l + Math.imul(be, Ke) | 0, p = p + Math.imul(we, We) | 0, a = a + Math.imul(we, Ge) | 0, a = a + Math.imul(Me, We) | 0, l = l + Math.imul(Me, Ge) | 0;\n        var Jr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, p = Math.imul(H, De), a = Math.imul(H, $e), a = a + Math.imul(W, De) | 0, l = Math.imul(W, $e), p = p + Math.imul(y, ze) | 0, a = a + Math.imul(y, qe) | 0, a = a + Math.imul(I, ze) | 0, l = l + Math.imul(I, qe) | 0, p = p + Math.imul(_e, Ze) | 0, a = a + Math.imul(_e, Ve) | 0, a = a + Math.imul(E, Ze) | 0, l = l + Math.imul(E, Ve) | 0, p = p + Math.imul(Se, He) | 0, a = a + Math.imul(Se, Ke) | 0, a = a + Math.imul(ke, He) | 0, l = l + Math.imul(ke, Ke) | 0, p = p + Math.imul(ye, We) | 0, a = a + Math.imul(ye, Ge) | 0, a = a + Math.imul(be, We) | 0, l = l + Math.imul(be, Ge) | 0;\n        var Xr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, p = Math.imul(H, ze), a = Math.imul(H, qe), a = a + Math.imul(W, ze) | 0, l = Math.imul(W, qe), p = p + Math.imul(y, Ze) | 0, a = a + Math.imul(y, Ve) | 0, a = a + Math.imul(I, Ze) | 0, l = l + Math.imul(I, Ve) | 0, p = p + Math.imul(_e, He) | 0, a = a + Math.imul(_e, Ke) | 0, a = a + Math.imul(E, He) | 0, l = l + Math.imul(E, Ke) | 0, p = p + Math.imul(Se, We) | 0, a = a + Math.imul(Se, Ge) | 0, a = a + Math.imul(ke, We) | 0, l = l + Math.imul(ke, Ge) | 0;\n        var Qr = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, p = Math.imul(H, Ze), a = Math.imul(H, Ve), a = a + Math.imul(W, Ze) | 0, l = Math.imul(W, Ve), p = p + Math.imul(y, He) | 0, a = a + Math.imul(y, Ke) | 0, a = a + Math.imul(I, He) | 0, l = l + Math.imul(I, Ke) | 0, p = p + Math.imul(_e, We) | 0, a = a + Math.imul(_e, Ge) | 0, a = a + Math.imul(E, We) | 0, l = l + Math.imul(E, Ge) | 0;\n        var en = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, p = Math.imul(H, He), a = Math.imul(H, Ke), a = a + Math.imul(W, He) | 0, l = Math.imul(W, Ke), p = p + Math.imul(y, We) | 0, a = a + Math.imul(y, Ge) | 0, a = a + Math.imul(I, We) | 0, l = l + Math.imul(I, Ge) | 0;\n        var tn = (A + p | 0) + ((a & 8191) << 13) | 0;\n        A = (l + (a >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, p = Math.imul(H, We), a = Math.imul(H, Ge), a = a + Math.imul(W, We) | 0, l = Math.imul(W, Ge);\n        var rn = (A + p | 0) + ((a & 8191) << 13) | 0;\n        return A = (l + (a >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, _[0] = Fr, _[1] = Pr, _[2] = Dr, _[3] = $r, _[4] = zr, _[5] = qr, _[6] = Zr, _[7] = Vr, _[8] = Hr, _[9] = Kr, _[10] = Wr, _[11] = Gr, _[12] = Yr, _[13] = Jr, _[14] = Xr, _[15] = Qr, _[16] = en, _[17] = tn, _[18] = rn, A !== 0 && (_[19] = A, h.length++), h;\n      };\n      Math.imul || (K = z);\n      function Z(d, s, u) {\n        u.negative = s.negative ^ d.negative, u.length = d.length + s.length;\n        for (var h = 0, g = 0, w = 0; w < u.length - 1; w++) {\n          var _ = g;\n          g = 0;\n          for (var A = h & 67108863, p = Math.min(w, s.length - 1), a = Math.max(0, w - d.length + 1); a <= p; a++) {\n            var l = w - a, M = d.words[l] | 0, k = s.words[a] | 0, $ = M * k, X = $ & 67108863;\n            _ = _ + ($ / 67108864 | 0) | 0, X = X + A | 0, A = X & 67108863, _ = _ + (X >>> 26) | 0, g += _ >>> 26, _ &= 67108863;\n          }\n          u.words[w] = A, h = _, _ = g;\n        }\n        return h !== 0 ? u.words[w] = h : u.length--, u._strip();\n      }\n      function Q(d, s, u) {\n        return Z(d, s, u);\n      }\n      i.prototype.mulTo = function(s, u) {\n        var h, g = this.length + s.length;\n        return this.length === 10 && s.length === 10 ? h = K(this, s, u) : g < 63 ? h = z(this, s, u) : g < 1024 ? h = Z(this, s, u) : h = Q(this, s, u), h;\n      }, i.prototype.mul = function(s) {\n        var u = new i(null);\n        return u.words = new Array(this.length + s.length), this.mulTo(s, u);\n      }, i.prototype.mulf = function(s) {\n        var u = new i(null);\n        return u.words = new Array(this.length + s.length), Q(this, s, u);\n      }, i.prototype.imul = function(s) {\n        return this.clone().mulTo(s, this);\n      }, i.prototype.imuln = function(s) {\n        var u = s < 0;\n        u && (s = -s), n(typeof s == \"number\"), n(s < 67108864);\n        for (var h = 0, g = 0; g < this.length; g++) {\n          var w = (this.words[g] | 0) * s, _ = (w & 67108863) + (h & 67108863);\n          h >>= 26, h += w / 67108864 | 0, h += _ >>> 26, this.words[g] = _ & 67108863;\n        }\n        return h !== 0 && (this.words[g] = h, this.length++), this.length = s === 0 ? 1 : this.length, u ? this.ineg() : this;\n      }, i.prototype.muln = function(s) {\n        return this.clone().imuln(s);\n      }, i.prototype.sqr = function() {\n        return this.mul(this);\n      }, i.prototype.isqr = function() {\n        return this.imul(this.clone());\n      }, i.prototype.pow = function(s) {\n        var u = R(s);\n        if (u.length === 0) return new i(1);\n        for (var h = this, g = 0; g < u.length && u[g] === 0; g++, h = h.sqr())\n          ;\n        if (++g < u.length)\n          for (var w = h.sqr(); g < u.length; g++, w = w.sqr())\n            u[g] !== 0 && (h = h.mul(w));\n        return h;\n      }, i.prototype.iushln = function(s) {\n        n(typeof s == \"number\" && s >= 0);\n        var u = s % 26, h = (s - u) / 26, g = 67108863 >>> 26 - u << 26 - u, w;\n        if (u !== 0) {\n          var _ = 0;\n          for (w = 0; w < this.length; w++) {\n            var A = this.words[w] & g, p = (this.words[w] | 0) - A << u;\n            this.words[w] = p | _, _ = A >>> 26 - u;\n          }\n          _ && (this.words[w] = _, this.length++);\n        }\n        if (h !== 0) {\n          for (w = this.length - 1; w >= 0; w--)\n            this.words[w + h] = this.words[w];\n          for (w = 0; w < h; w++)\n            this.words[w] = 0;\n          this.length += h;\n        }\n        return this._strip();\n      }, i.prototype.ishln = function(s) {\n        return n(this.negative === 0), this.iushln(s);\n      }, i.prototype.iushrn = function(s, u, h) {\n        n(typeof s == \"number\" && s >= 0);\n        var g;\n        u ? g = (u - u % 26) / 26 : g = 0;\n        var w = s % 26, _ = Math.min((s - w) / 26, this.length), A = 67108863 ^ 67108863 >>> w << w, p = h;\n        if (g -= _, g = Math.max(0, g), p) {\n          for (var a = 0; a < _; a++)\n            p.words[a] = this.words[a];\n          p.length = _;\n        }\n        if (_ !== 0) if (this.length > _)\n          for (this.length -= _, a = 0; a < this.length; a++)\n            this.words[a] = this.words[a + _];\n        else\n          this.words[0] = 0, this.length = 1;\n        var l = 0;\n        for (a = this.length - 1; a >= 0 && (l !== 0 || a >= g); a--) {\n          var M = this.words[a] | 0;\n          this.words[a] = l << 26 - w | M >>> w, l = M & A;\n        }\n        return p && l !== 0 && (p.words[p.length++] = l), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();\n      }, i.prototype.ishrn = function(s, u, h) {\n        return n(this.negative === 0), this.iushrn(s, u, h);\n      }, i.prototype.shln = function(s) {\n        return this.clone().ishln(s);\n      }, i.prototype.ushln = function(s) {\n        return this.clone().iushln(s);\n      }, i.prototype.shrn = function(s) {\n        return this.clone().ishrn(s);\n      }, i.prototype.ushrn = function(s) {\n        return this.clone().iushrn(s);\n      }, i.prototype.testn = function(s) {\n        n(typeof s == \"number\" && s >= 0);\n        var u = s % 26, h = (s - u) / 26, g = 1 << u;\n        if (this.length <= h) return !1;\n        var w = this.words[h];\n        return !!(w & g);\n      }, i.prototype.imaskn = function(s) {\n        n(typeof s == \"number\" && s >= 0);\n        var u = s % 26, h = (s - u) / 26;\n        if (n(this.negative === 0, \"imaskn works only with positive numbers\"), this.length <= h)\n          return this;\n        if (u !== 0 && h++, this.length = Math.min(h, this.length), u !== 0) {\n          var g = 67108863 ^ 67108863 >>> u << u;\n          this.words[this.length - 1] &= g;\n        }\n        return this._strip();\n      }, i.prototype.maskn = function(s) {\n        return this.clone().imaskn(s);\n      }, i.prototype.iaddn = function(s) {\n        return n(typeof s == \"number\"), n(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s);\n      }, i.prototype._iaddn = function(s) {\n        this.words[0] += s;\n        for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)\n          this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;\n        return this.length = Math.max(this.length, u + 1), this;\n      }, i.prototype.isubn = function(s) {\n        if (n(typeof s == \"number\"), n(s < 67108864), s < 0) return this.iaddn(-s);\n        if (this.negative !== 0)\n          return this.negative = 0, this.iaddn(s), this.negative = 1, this;\n        if (this.words[0] -= s, this.length === 1 && this.words[0] < 0)\n          this.words[0] = -this.words[0], this.negative = 1;\n        else\n          for (var u = 0; u < this.length && this.words[u] < 0; u++)\n            this.words[u] += 67108864, this.words[u + 1] -= 1;\n        return this._strip();\n      }, i.prototype.addn = function(s) {\n        return this.clone().iaddn(s);\n      }, i.prototype.subn = function(s) {\n        return this.clone().isubn(s);\n      }, i.prototype.iabs = function() {\n        return this.negative = 0, this;\n      }, i.prototype.abs = function() {\n        return this.clone().iabs();\n      }, i.prototype._ishlnsubmul = function(s, u, h) {\n        var g = s.length + h, w;\n        this._expand(g);\n        var _, A = 0;\n        for (w = 0; w < s.length; w++) {\n          _ = (this.words[w + h] | 0) + A;\n          var p = (s.words[w] | 0) * u;\n          _ -= p & 67108863, A = (_ >> 26) - (p / 67108864 | 0), this.words[w + h] = _ & 67108863;\n        }\n        for (; w < this.length - h; w++)\n          _ = (this.words[w + h] | 0) + A, A = _ >> 26, this.words[w + h] = _ & 67108863;\n        if (A === 0) return this._strip();\n        for (n(A === -1), A = 0, w = 0; w < this.length; w++)\n          _ = -(this.words[w] | 0) + A, A = _ >> 26, this.words[w] = _ & 67108863;\n        return this.negative = 1, this._strip();\n      }, i.prototype._wordDiv = function(s, u) {\n        var h = this.length - s.length, g = this.clone(), w = s, _ = w.words[w.length - 1] | 0, A = this._countBits(_);\n        h = 26 - A, h !== 0 && (w = w.ushln(h), g.iushln(h), _ = w.words[w.length - 1] | 0);\n        var p = g.length - w.length, a;\n        if (u !== \"mod\") {\n          a = new i(null), a.length = p + 1, a.words = new Array(a.length);\n          for (var l = 0; l < a.length; l++)\n            a.words[l] = 0;\n        }\n        var M = g.clone()._ishlnsubmul(w, 1, p);\n        M.negative === 0 && (g = M, a && (a.words[p] = 1));\n        for (var k = p - 1; k >= 0; k--) {\n          var $ = (g.words[w.length + k] | 0) * 67108864 + (g.words[w.length + k - 1] | 0);\n          for ($ = Math.min($ / _ | 0, 67108863), g._ishlnsubmul(w, $, k); g.negative !== 0; )\n            $--, g.negative = 0, g._ishlnsubmul(w, 1, k), g.isZero() || (g.negative ^= 1);\n          a && (a.words[k] = $);\n        }\n        return a && a._strip(), g._strip(), u !== \"div\" && h !== 0 && g.iushrn(h), {\n          div: a || null,\n          mod: g\n        };\n      }, i.prototype.divmod = function(s, u, h) {\n        if (n(!s.isZero()), this.isZero())\n          return {\n            div: new i(0),\n            mod: new i(0)\n          };\n        var g, w, _;\n        return this.negative !== 0 && s.negative === 0 ? (_ = this.neg().divmod(s, u), u !== \"mod\" && (g = _.div.neg()), u !== \"div\" && (w = _.mod.neg(), h && w.negative !== 0 && w.iadd(s)), {\n          div: g,\n          mod: w\n        }) : this.negative === 0 && s.negative !== 0 ? (_ = this.divmod(s.neg(), u), u !== \"mod\" && (g = _.div.neg()), {\n          div: g,\n          mod: _.mod\n        }) : (this.negative & s.negative) !== 0 ? (_ = this.neg().divmod(s.neg(), u), u !== \"div\" && (w = _.mod.neg(), h && w.negative !== 0 && w.isub(s)), {\n          div: _.div,\n          mod: w\n        }) : s.length > this.length || this.cmp(s) < 0 ? {\n          div: new i(0),\n          mod: this\n        } : s.length === 1 ? u === \"div\" ? {\n          div: this.divn(s.words[0]),\n          mod: null\n        } : u === \"mod\" ? {\n          div: null,\n          mod: new i(this.modrn(s.words[0]))\n        } : {\n          div: this.divn(s.words[0]),\n          mod: new i(this.modrn(s.words[0]))\n        } : this._wordDiv(s, u);\n      }, i.prototype.div = function(s) {\n        return this.divmod(s, \"div\", !1).div;\n      }, i.prototype.mod = function(s) {\n        return this.divmod(s, \"mod\", !1).mod;\n      }, i.prototype.umod = function(s) {\n        return this.divmod(s, \"mod\", !0).mod;\n      }, i.prototype.divRound = function(s) {\n        var u = this.divmod(s);\n        if (u.mod.isZero()) return u.div;\n        var h = u.div.negative !== 0 ? u.mod.isub(s) : u.mod, g = s.ushrn(1), w = s.andln(1), _ = h.cmp(g);\n        return _ < 0 || w === 1 && _ === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);\n      }, i.prototype.modrn = function(s) {\n        var u = s < 0;\n        u && (s = -s), n(s <= 67108863);\n        for (var h = (1 << 26) % s, g = 0, w = this.length - 1; w >= 0; w--)\n          g = (h * g + (this.words[w] | 0)) % s;\n        return u ? -g : g;\n      }, i.prototype.modn = function(s) {\n        return this.modrn(s);\n      }, i.prototype.idivn = function(s) {\n        var u = s < 0;\n        u && (s = -s), n(s <= 67108863);\n        for (var h = 0, g = this.length - 1; g >= 0; g--) {\n          var w = (this.words[g] | 0) + h * 67108864;\n          this.words[g] = w / s | 0, h = w % s;\n        }\n        return this._strip(), u ? this.ineg() : this;\n      }, i.prototype.divn = function(s) {\n        return this.clone().idivn(s);\n      }, i.prototype.egcd = function(s) {\n        n(s.negative === 0), n(!s.isZero());\n        var u = this, h = s.clone();\n        u.negative !== 0 ? u = u.umod(s) : u = u.clone();\n        for (var g = new i(1), w = new i(0), _ = new i(0), A = new i(1), p = 0; u.isEven() && h.isEven(); )\n          u.iushrn(1), h.iushrn(1), ++p;\n        for (var a = h.clone(), l = u.clone(); !u.isZero(); ) {\n          for (var M = 0, k = 1; (u.words[0] & k) === 0 && M < 26; ++M, k <<= 1) ;\n          if (M > 0)\n            for (u.iushrn(M); M-- > 0; )\n              (g.isOdd() || w.isOdd()) && (g.iadd(a), w.isub(l)), g.iushrn(1), w.iushrn(1);\n          for (var $ = 0, X = 1; (h.words[0] & X) === 0 && $ < 26; ++$, X <<= 1) ;\n          if ($ > 0)\n            for (h.iushrn($); $-- > 0; )\n              (_.isOdd() || A.isOdd()) && (_.iadd(a), A.isub(l)), _.iushrn(1), A.iushrn(1);\n          u.cmp(h) >= 0 ? (u.isub(h), g.isub(_), w.isub(A)) : (h.isub(u), _.isub(g), A.isub(w));\n        }\n        return {\n          a: _,\n          b: A,\n          gcd: h.iushln(p)\n        };\n      }, i.prototype._invmp = function(s) {\n        n(s.negative === 0), n(!s.isZero());\n        var u = this, h = s.clone();\n        u.negative !== 0 ? u = u.umod(s) : u = u.clone();\n        for (var g = new i(1), w = new i(0), _ = h.clone(); u.cmpn(1) > 0 && h.cmpn(1) > 0; ) {\n          for (var A = 0, p = 1; (u.words[0] & p) === 0 && A < 26; ++A, p <<= 1) ;\n          if (A > 0)\n            for (u.iushrn(A); A-- > 0; )\n              g.isOdd() && g.iadd(_), g.iushrn(1);\n          for (var a = 0, l = 1; (h.words[0] & l) === 0 && a < 26; ++a, l <<= 1) ;\n          if (a > 0)\n            for (h.iushrn(a); a-- > 0; )\n              w.isOdd() && w.iadd(_), w.iushrn(1);\n          u.cmp(h) >= 0 ? (u.isub(h), g.isub(w)) : (h.isub(u), w.isub(g));\n        }\n        var M;\n        return u.cmpn(1) === 0 ? M = g : M = w, M.cmpn(0) < 0 && M.iadd(s), M;\n      }, i.prototype.gcd = function(s) {\n        if (this.isZero()) return s.abs();\n        if (s.isZero()) return this.abs();\n        var u = this.clone(), h = s.clone();\n        u.negative = 0, h.negative = 0;\n        for (var g = 0; u.isEven() && h.isEven(); g++)\n          u.iushrn(1), h.iushrn(1);\n        do {\n          for (; u.isEven(); )\n            u.iushrn(1);\n          for (; h.isEven(); )\n            h.iushrn(1);\n          var w = u.cmp(h);\n          if (w < 0) {\n            var _ = u;\n            u = h, h = _;\n          } else if (w === 0 || h.cmpn(1) === 0)\n            break;\n          u.isub(h);\n        } while (!0);\n        return h.iushln(g);\n      }, i.prototype.invm = function(s) {\n        return this.egcd(s).a.umod(s);\n      }, i.prototype.isEven = function() {\n        return (this.words[0] & 1) === 0;\n      }, i.prototype.isOdd = function() {\n        return (this.words[0] & 1) === 1;\n      }, i.prototype.andln = function(s) {\n        return this.words[0] & s;\n      }, i.prototype.bincn = function(s) {\n        n(typeof s == \"number\");\n        var u = s % 26, h = (s - u) / 26, g = 1 << u;\n        if (this.length <= h)\n          return this._expand(h + 1), this.words[h] |= g, this;\n        for (var w = g, _ = h; w !== 0 && _ < this.length; _++) {\n          var A = this.words[_] | 0;\n          A += w, w = A >>> 26, A &= 67108863, this.words[_] = A;\n        }\n        return w !== 0 && (this.words[_] = w, this.length++), this;\n      }, i.prototype.isZero = function() {\n        return this.length === 1 && this.words[0] === 0;\n      }, i.prototype.cmpn = function(s) {\n        var u = s < 0;\n        if (this.negative !== 0 && !u) return -1;\n        if (this.negative === 0 && u) return 1;\n        this._strip();\n        var h;\n        if (this.length > 1)\n          h = 1;\n        else {\n          u && (s = -s), n(s <= 67108863, \"Number is too big\");\n          var g = this.words[0] | 0;\n          h = g === s ? 0 : g < s ? -1 : 1;\n        }\n        return this.negative !== 0 ? -h | 0 : h;\n      }, i.prototype.cmp = function(s) {\n        if (this.negative !== 0 && s.negative === 0) return -1;\n        if (this.negative === 0 && s.negative !== 0) return 1;\n        var u = this.ucmp(s);\n        return this.negative !== 0 ? -u | 0 : u;\n      }, i.prototype.ucmp = function(s) {\n        if (this.length > s.length) return 1;\n        if (this.length < s.length) return -1;\n        for (var u = 0, h = this.length - 1; h >= 0; h--) {\n          var g = this.words[h] | 0, w = s.words[h] | 0;\n          if (g !== w) {\n            g < w ? u = -1 : g > w && (u = 1);\n            break;\n          }\n        }\n        return u;\n      }, i.prototype.gtn = function(s) {\n        return this.cmpn(s) === 1;\n      }, i.prototype.gt = function(s) {\n        return this.cmp(s) === 1;\n      }, i.prototype.gten = function(s) {\n        return this.cmpn(s) >= 0;\n      }, i.prototype.gte = function(s) {\n        return this.cmp(s) >= 0;\n      }, i.prototype.ltn = function(s) {\n        return this.cmpn(s) === -1;\n      }, i.prototype.lt = function(s) {\n        return this.cmp(s) === -1;\n      }, i.prototype.lten = function(s) {\n        return this.cmpn(s) <= 0;\n      }, i.prototype.lte = function(s) {\n        return this.cmp(s) <= 0;\n      }, i.prototype.eqn = function(s) {\n        return this.cmpn(s) === 0;\n      }, i.prototype.eq = function(s) {\n        return this.cmp(s) === 0;\n      }, i.red = function(s) {\n        return new L(s);\n      }, i.prototype.toRed = function(s) {\n        return n(!this.red, \"Already a number in reduction context\"), n(this.negative === 0, \"red works only with positives\"), s.convertTo(this)._forceRed(s);\n      }, i.prototype.fromRed = function() {\n        return n(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n      }, i.prototype._forceRed = function(s) {\n        return this.red = s, this;\n      }, i.prototype.forceRed = function(s) {\n        return n(!this.red, \"Already a number in reduction context\"), this._forceRed(s);\n      }, i.prototype.redAdd = function(s) {\n        return n(this.red, \"redAdd works only with red numbers\"), this.red.add(this, s);\n      }, i.prototype.redIAdd = function(s) {\n        return n(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, s);\n      }, i.prototype.redSub = function(s) {\n        return n(this.red, \"redSub works only with red numbers\"), this.red.sub(this, s);\n      }, i.prototype.redISub = function(s) {\n        return n(this.red, \"redISub works only with red numbers\"), this.red.isub(this, s);\n      }, i.prototype.redShl = function(s) {\n        return n(this.red, \"redShl works only with red numbers\"), this.red.shl(this, s);\n      }, i.prototype.redMul = function(s) {\n        return n(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, s), this.red.mul(this, s);\n      }, i.prototype.redIMul = function(s) {\n        return n(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, s), this.red.imul(this, s);\n      }, i.prototype.redSqr = function() {\n        return n(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n      }, i.prototype.redISqr = function() {\n        return n(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n      }, i.prototype.redSqrt = function() {\n        return n(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n      }, i.prototype.redInvm = function() {\n        return n(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n      }, i.prototype.redNeg = function() {\n        return n(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n      }, i.prototype.redPow = function(s) {\n        return n(this.red && !s.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, s);\n      };\n      var j = {\n        k256: null,\n        p224: null,\n        p192: null,\n        p25519: null\n      };\n      function V(d, s) {\n        this.name = d, this.p = new i(s, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n      }\n      V.prototype._tmp = function() {\n        var s = new i(null);\n        return s.words = new Array(Math.ceil(this.n / 13)), s;\n      }, V.prototype.ireduce = function(s) {\n        var u = s, h;\n        do\n          this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), h = u.bitLength();\n        while (h > this.n);\n        var g = h < this.n ? -1 : u.ucmp(this.p);\n        return g === 0 ? (u.words[0] = 0, u.length = 1) : g > 0 ? u.isub(this.p) : u.strip !== void 0 ? u.strip() : u._strip(), u;\n      }, V.prototype.split = function(s, u) {\n        s.iushrn(this.n, 0, u);\n      }, V.prototype.imulK = function(s) {\n        return s.imul(this.k);\n      };\n      function ee() {\n        V.call(\n          this,\n          \"k256\",\n          \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\"\n        );\n      }\n      o(ee, V), ee.prototype.split = function(s, u) {\n        for (var h = 4194303, g = Math.min(s.length, 9), w = 0; w < g; w++)\n          u.words[w] = s.words[w];\n        if (u.length = g, s.length <= 9) {\n          s.words[0] = 0, s.length = 1;\n          return;\n        }\n        var _ = s.words[9];\n        for (u.words[u.length++] = _ & h, w = 10; w < s.length; w++) {\n          var A = s.words[w] | 0;\n          s.words[w - 10] = (A & h) << 4 | _ >>> 22, _ = A;\n        }\n        _ >>>= 22, s.words[w - 10] = _, _ === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9;\n      }, ee.prototype.imulK = function(s) {\n        s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;\n        for (var u = 0, h = 0; h < s.length; h++) {\n          var g = s.words[h] | 0;\n          u += g * 977, s.words[h] = u & 67108863, u = g * 64 + (u / 67108864 | 0);\n        }\n        return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s;\n      };\n      function G() {\n        V.call(\n          this,\n          \"p224\",\n          \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\"\n        );\n      }\n      o(G, V);\n      function N() {\n        V.call(\n          this,\n          \"p192\",\n          \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\"\n        );\n      }\n      o(N, V);\n      function O() {\n        V.call(\n          this,\n          \"25519\",\n          \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\"\n        );\n      }\n      o(O, V), O.prototype.imulK = function(s) {\n        for (var u = 0, h = 0; h < s.length; h++) {\n          var g = (s.words[h] | 0) * 19 + u, w = g & 67108863;\n          g >>>= 26, s.words[h] = w, u = g;\n        }\n        return u !== 0 && (s.words[s.length++] = u), s;\n      }, i._prime = function(s) {\n        if (j[s]) return j[s];\n        var u;\n        if (s === \"k256\")\n          u = new ee();\n        else if (s === \"p224\")\n          u = new G();\n        else if (s === \"p192\")\n          u = new N();\n        else if (s === \"p25519\")\n          u = new O();\n        else\n          throw new Error(\"Unknown prime \" + s);\n        return j[s] = u, u;\n      };\n      function L(d) {\n        if (typeof d == \"string\") {\n          var s = i._prime(d);\n          this.m = s.p, this.prime = s;\n        } else\n          n(d.gtn(1), \"modulus must be greater than 1\"), this.m = d, this.prime = null;\n      }\n      L.prototype._verify1 = function(s) {\n        n(s.negative === 0, \"red works only with positives\"), n(s.red, \"red works only with red numbers\");\n      }, L.prototype._verify2 = function(s, u) {\n        n((s.negative | u.negative) === 0, \"red works only with positives\"), n(\n          s.red && s.red === u.red,\n          \"red works only with red numbers\"\n        );\n      }, L.prototype.imod = function(s) {\n        return this.prime ? this.prime.ireduce(s)._forceRed(this) : (b(s, s.umod(this.m)._forceRed(this)), s);\n      }, L.prototype.neg = function(s) {\n        return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this);\n      }, L.prototype.add = function(s, u) {\n        this._verify2(s, u);\n        var h = s.add(u);\n        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);\n      }, L.prototype.iadd = function(s, u) {\n        this._verify2(s, u);\n        var h = s.iadd(u);\n        return h.cmp(this.m) >= 0 && h.isub(this.m), h;\n      }, L.prototype.sub = function(s, u) {\n        this._verify2(s, u);\n        var h = s.sub(u);\n        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);\n      }, L.prototype.isub = function(s, u) {\n        this._verify2(s, u);\n        var h = s.isub(u);\n        return h.cmpn(0) < 0 && h.iadd(this.m), h;\n      }, L.prototype.shl = function(s, u) {\n        return this._verify1(s), this.imod(s.ushln(u));\n      }, L.prototype.imul = function(s, u) {\n        return this._verify2(s, u), this.imod(s.imul(u));\n      }, L.prototype.mul = function(s, u) {\n        return this._verify2(s, u), this.imod(s.mul(u));\n      }, L.prototype.isqr = function(s) {\n        return this.imul(s, s.clone());\n      }, L.prototype.sqr = function(s) {\n        return this.mul(s, s);\n      }, L.prototype.sqrt = function(s) {\n        if (s.isZero()) return s.clone();\n        var u = this.m.andln(3);\n        if (n(u % 2 === 1), u === 3) {\n          var h = this.m.add(new i(1)).iushrn(2);\n          return this.pow(s, h);\n        }\n        for (var g = this.m.subn(1), w = 0; !g.isZero() && g.andln(1) === 0; )\n          w++, g.iushrn(1);\n        n(!g.isZero());\n        var _ = new i(1).toRed(this), A = _.redNeg(), p = this.m.subn(1).iushrn(1), a = this.m.bitLength();\n        for (a = new i(2 * a * a).toRed(this); this.pow(a, p).cmp(A) !== 0; )\n          a.redIAdd(A);\n        for (var l = this.pow(a, g), M = this.pow(s, g.addn(1).iushrn(1)), k = this.pow(s, g), $ = w; k.cmp(_) !== 0; ) {\n          for (var X = k, re = 0; X.cmp(_) !== 0; re++)\n            X = X.redSqr();\n          n(re < $);\n          var se = this.pow(l, new i(1).iushln($ - re - 1));\n          M = M.redMul(se), l = se.redSqr(), k = k.redMul(l), $ = re;\n        }\n        return M;\n      }, L.prototype.invm = function(s) {\n        var u = s._invmp(this.m);\n        return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);\n      }, L.prototype.pow = function(s, u) {\n        if (u.isZero()) return new i(1).toRed(this);\n        if (u.cmpn(1) === 0) return s.clone();\n        var h = 4, g = new Array(1 << h);\n        g[0] = new i(1).toRed(this), g[1] = s;\n        for (var w = 2; w < g.length; w++)\n          g[w] = this.mul(g[w - 1], s);\n        var _ = g[0], A = 0, p = 0, a = u.bitLength() % 26;\n        for (a === 0 && (a = 26), w = u.length - 1; w >= 0; w--) {\n          for (var l = u.words[w], M = a - 1; M >= 0; M--) {\n            var k = l >> M & 1;\n            if (_ !== g[0] && (_ = this.sqr(_)), k === 0 && A === 0) {\n              p = 0;\n              continue;\n            }\n            A <<= 1, A |= k, p++, !(p !== h && (w !== 0 || M !== 0)) && (_ = this.mul(_, g[A]), p = 0, A = 0);\n          }\n          a = 26;\n        }\n        return _;\n      }, L.prototype.convertTo = function(s) {\n        var u = s.umod(this.m);\n        return u === s ? u.clone() : u;\n      }, L.prototype.convertFrom = function(s) {\n        var u = s.clone();\n        return u.red = null, u;\n      }, i.mont = function(s) {\n        return new F(s);\n      };\n      function F(d) {\n        L.call(this, d), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n      }\n      o(F, L), F.prototype.convertTo = function(s) {\n        return this.imod(s.ushln(this.shift));\n      }, F.prototype.convertFrom = function(s) {\n        var u = this.imod(s.mul(this.rinv));\n        return u.red = null, u;\n      }, F.prototype.imul = function(s, u) {\n        if (s.isZero() || u.isZero())\n          return s.words[0] = 0, s.length = 1, s;\n        var h = s.imul(u), g = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = h.isub(g).iushrn(this.shift), _ = w;\n        return w.cmp(this.m) >= 0 ? _ = w.isub(this.m) : w.cmpn(0) < 0 && (_ = w.iadd(this.m)), _._forceRed(this);\n      }, F.prototype.mul = function(s, u) {\n        if (s.isZero() || u.isZero()) return new i(0)._forceRed(this);\n        var h = s.mul(u), g = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = h.isub(g).iushrn(this.shift), _ = w;\n        return w.cmp(this.m) >= 0 ? _ = w.isub(this.m) : w.cmpn(0) < 0 && (_ = w.iadd(this.m)), _._forceRed(this);\n      }, F.prototype.invm = function(s) {\n        var u = this.imod(s._invmp(this.m).mul(this.r2));\n        return u._forceRed(this);\n      };\n    })(t, Xh);\n  }(ns)), ns.exports;\n}\nvar no, eu;\nfunction ed() {\n  if (eu) return no;\n  eu = 1;\n  var t = kc().Buffer;\n  function e(r) {\n    if (r.length >= 255)\n      throw new TypeError(\"Alphabet too long\");\n    for (var n = new Uint8Array(256), o = 0; o < n.length; o++)\n      n[o] = 255;\n    for (var i = 0; i < r.length; i++) {\n      var c = r.charAt(i), f = c.charCodeAt(0);\n      if (n[f] !== 255)\n        throw new TypeError(c + \" is ambiguous\");\n      n[f] = i;\n    }\n    var v = r.length, x = r.charAt(0), b = Math.log(v) / Math.log(256), S = Math.log(256) / Math.log(v);\n    function T(B) {\n      if ((Array.isArray(B) || B instanceof Uint8Array) && (B = t.from(B)), !t.isBuffer(B))\n        throw new TypeError(\"Expected Buffer\");\n      if (B.length === 0)\n        return \"\";\n      for (var R = 0, z = 0, K = 0, Z = B.length; K !== Z && B[K] === 0; )\n        K++, R++;\n      for (var Q = (Z - K) * S + 1 >>> 0, j = new Uint8Array(Q); K !== Z; ) {\n        for (var V = B[K], ee = 0, G = Q - 1; (V !== 0 || ee < z) && G !== -1; G--, ee++)\n          V += 256 * j[G] >>> 0, j[G] = V % v >>> 0, V = V / v >>> 0;\n        if (V !== 0)\n          throw new Error(\"Non-zero carry\");\n        z = ee, K++;\n      }\n      for (var N = Q - z; N !== Q && j[N] === 0; )\n        N++;\n      for (var O = x.repeat(R); N < Q; ++N)\n        O += r.charAt(j[N]);\n      return O;\n    }\n    function C(B) {\n      if (typeof B != \"string\")\n        throw new TypeError(\"Expected String\");\n      if (B.length === 0)\n        return t.alloc(0);\n      for (var R = 0, z = 0, K = 0; B[R] === x; )\n        z++, R++;\n      for (var Z = (B.length - R) * b + 1 >>> 0, Q = new Uint8Array(Z); R < B.length; ) {\n        var j = B.charCodeAt(R);\n        if (j > 255)\n          return;\n        var V = n[j];\n        if (V === 255)\n          return;\n        for (var ee = 0, G = Z - 1; (V !== 0 || ee < K) && G !== -1; G--, ee++)\n          V += v * Q[G] >>> 0, Q[G] = V % 256 >>> 0, V = V / 256 >>> 0;\n        if (V !== 0)\n          throw new Error(\"Non-zero carry\");\n        K = ee, R++;\n      }\n      for (var N = Z - K; N !== Z && Q[N] === 0; )\n        N++;\n      var O = t.allocUnsafe(z + (Z - N));\n      O.fill(0, 0, z);\n      for (var L = z; N !== Z; )\n        O[L++] = Q[N++];\n      return O;\n    }\n    function P(B) {\n      var R = C(B);\n      if (R)\n        return R;\n      throw new Error(\"Non-base\" + v + \" character\");\n    }\n    return {\n      encode: T,\n      decodeUnsafe: C,\n      decode: P\n    };\n  }\n  return no = e, no;\n}\nvar io, tu;\nfunction td() {\n  if (tu) return io;\n  tu = 1;\n  var t = ed(), e = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n  return io = t(e), io;\n}\nfunction gr(t, e, r) {\n  return e <= t && t <= r;\n}\nfunction Us(t) {\n  if (t === void 0) return {};\n  if (t === Object(t)) return t;\n  throw TypeError(\"Could not convert argument to dictionary\");\n}\nfunction rd(t) {\n  for (var e = String(t), r = e.length, n = 0, o = []; n < r; ) {\n    var i = e.charCodeAt(n);\n    if (i < 55296 || i > 57343)\n      o.push(i);\n    else if (56320 <= i && i <= 57343)\n      o.push(65533);\n    else if (55296 <= i && i <= 56319)\n      if (n === r - 1)\n        o.push(65533);\n      else {\n        var c = t.charCodeAt(n + 1);\n        if (56320 <= c && c <= 57343) {\n          var f = i & 1023, v = c & 1023;\n          o.push(65536 + (f << 10) + v), n += 1;\n        } else\n          o.push(65533);\n      }\n    n += 1;\n  }\n  return o;\n}\nfunction nd(t) {\n  for (var e = \"\", r = 0; r < t.length; ++r) {\n    var n = t[r];\n    n <= 65535 ? e += String.fromCharCode(n) : (n -= 65536, e += String.fromCharCode(\n      (n >> 10) + 55296,\n      (n & 1023) + 56320\n    ));\n  }\n  return e;\n}\nvar gs = -1;\nfunction ca(t) {\n  this.tokens = [].slice.call(t);\n}\nca.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n  read: function() {\n    return this.tokens.length ? this.tokens.shift() : gs;\n  },\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(t) {\n    if (Array.isArray(t))\n      for (var e = (\n        /**@type {!Array.<number>}*/\n        t\n      ); e.length; )\n        this.tokens.unshift(e.pop());\n    else\n      this.tokens.unshift(t);\n  },\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(t) {\n    if (Array.isArray(t))\n      for (var e = (\n        /**@type {!Array.<number>}*/\n        t\n      ); e.length; )\n        this.tokens.push(e.shift());\n    else\n      this.tokens.push(t);\n  }\n};\nvar Un = -1;\nfunction so(t, e) {\n  if (t)\n    throw TypeError(\"Decoder error\");\n  return e || 65533;\n}\nvar ys = \"utf-8\";\nfunction vs(t, e) {\n  if (!(this instanceof vs))\n    return new vs(t, e);\n  if (t = t !== void 0 ? String(t).toLowerCase() : ys, t !== ys)\n    throw new Error(\"Encoding not supported. Only utf-8 is supported\");\n  e = Us(e), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!e.fatal, this._ignoreBOM = !!e.ignoreBOM, Object.defineProperty(this, \"encoding\", { value: \"utf-8\" }), Object.defineProperty(this, \"fatal\", { value: this._fatal }), Object.defineProperty(this, \"ignoreBOM\", { value: this._ignoreBOM });\n}\nvs.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function(e, r) {\n    var n;\n    typeof e == \"object\" && e instanceof ArrayBuffer ? n = new Uint8Array(e) : typeof e == \"object\" && \"buffer\" in e && e.buffer instanceof ArrayBuffer ? n = new Uint8Array(\n      e.buffer,\n      e.byteOffset,\n      e.byteLength\n    ) : n = new Uint8Array(0), r = Us(r), this._streaming || (this._decoder = new id({ fatal: this._fatal }), this._BOMseen = !1), this._streaming = !!r.stream;\n    for (var o = new ca(n), i = [], c; !o.endOfStream() && (c = this._decoder.handler(o, o.read()), c !== Un); )\n      c !== null && (Array.isArray(c) ? i.push.apply(\n        i,\n        /**@type {!Array.<number>}*/\n        c\n      ) : i.push(c));\n    if (!this._streaming) {\n      do {\n        if (c = this._decoder.handler(o, o.read()), c === Un)\n          break;\n        c !== null && (Array.isArray(c) ? i.push.apply(\n          i,\n          /**@type {!Array.<number>}*/\n          c\n        ) : i.push(c));\n      } while (!o.endOfStream());\n      this._decoder = null;\n    }\n    return i.length && [\"utf-8\"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (i[0] === 65279 ? (this._BOMseen = !0, i.shift()) : this._BOMseen = !0), nd(i);\n  }\n};\nfunction ws(t, e) {\n  if (!(this instanceof ws))\n    return new ws(t, e);\n  if (t = t !== void 0 ? String(t).toLowerCase() : ys, t !== ys)\n    throw new Error(\"Encoding not supported. Only utf-8 is supported\");\n  e = Us(e), this._streaming = !1, this._encoder = null, this._options = { fatal: !!e.fatal }, Object.defineProperty(this, \"encoding\", { value: \"utf-8\" });\n}\nws.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function(e, r) {\n    e = e ? String(e) : \"\", r = Us(r), this._streaming || (this._encoder = new sd(this._options)), this._streaming = !!r.stream;\n    for (var n = [], o = new ca(rd(e)), i; !o.endOfStream() && (i = this._encoder.handler(o, o.read()), i !== Un); )\n      Array.isArray(i) ? n.push.apply(\n        n,\n        /**@type {!Array.<number>}*/\n        i\n      ) : n.push(i);\n    if (!this._streaming) {\n      for (; i = this._encoder.handler(o, o.read()), i !== Un; )\n        Array.isArray(i) ? n.push.apply(\n          n,\n          /**@type {!Array.<number>}*/\n          i\n        ) : n.push(i);\n      this._encoder = null;\n    }\n    return new Uint8Array(n);\n  }\n};\nfunction id(t) {\n  var e = t.fatal, r = 0, n = 0, o = 0, i = 128, c = 191;\n  this.handler = function(f, v) {\n    if (v === gs && o !== 0)\n      return o = 0, so(e);\n    if (v === gs)\n      return Un;\n    if (o === 0) {\n      if (gr(v, 0, 127))\n        return v;\n      if (gr(v, 194, 223))\n        o = 1, r = v - 192;\n      else if (gr(v, 224, 239))\n        v === 224 && (i = 160), v === 237 && (c = 159), o = 2, r = v - 224;\n      else if (gr(v, 240, 244))\n        v === 240 && (i = 144), v === 244 && (c = 143), o = 3, r = v - 240;\n      else\n        return so(e);\n      return r = r << 6 * o, null;\n    }\n    if (!gr(v, i, c))\n      return r = o = n = 0, i = 128, c = 191, f.prepend(v), so(e);\n    if (i = 128, c = 191, n += 1, r += v - 128 << 6 * (o - n), n !== o)\n      return null;\n    var x = r;\n    return r = o = n = 0, x;\n  };\n}\nfunction sd(t) {\n  t.fatal, this.handler = function(e, r) {\n    if (r === gs)\n      return Un;\n    if (gr(r, 0, 127))\n      return r;\n    var n, o;\n    gr(r, 128, 2047) ? (n = 1, o = 192) : gr(r, 2048, 65535) ? (n = 2, o = 224) : gr(r, 65536, 1114111) && (n = 3, o = 240);\n    for (var i = [(r >> 6 * n) + o]; n > 0; ) {\n      var c = r >> 6 * (n - 1);\n      i.push(128 | c & 63), n -= 1;\n    }\n    return i;\n  };\n}\nconst od = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  TextDecoder: vs,\n  TextEncoder: ws\n}, Symbol.toStringTag, { value: \"Module\" })), ad = /* @__PURE__ */ ea(od);\nvar ru;\nfunction ud() {\n  if (ru) return st;\n  ru = 1;\n  var t = st && st.__createBinding || (Object.create ? function(N, O, L, F) {\n    F === void 0 && (F = L), Object.defineProperty(N, F, { enumerable: !0, get: function() {\n      return O[L];\n    } });\n  } : function(N, O, L, F) {\n    F === void 0 && (F = L), N[F] = O[L];\n  }), e = st && st.__setModuleDefault || (Object.create ? function(N, O) {\n    Object.defineProperty(N, \"default\", { enumerable: !0, value: O });\n  } : function(N, O) {\n    N.default = O;\n  }), r = st && st.__decorate || function(N, O, L, F) {\n    var d = arguments.length, s = d < 3 ? O : F === null ? F = Object.getOwnPropertyDescriptor(O, L) : F, u;\n    if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\") s = Reflect.decorate(N, O, L, F);\n    else for (var h = N.length - 1; h >= 0; h--) (u = N[h]) && (s = (d < 3 ? u(s) : d > 3 ? u(O, L, s) : u(O, L)) || s);\n    return d > 3 && s && Object.defineProperty(O, L, s), s;\n  }, n = st && st.__importStar || function(N) {\n    if (N && N.__esModule) return N;\n    var O = {};\n    if (N != null) for (var L in N) L !== \"default\" && Object.hasOwnProperty.call(N, L) && t(O, N, L);\n    return e(O, N), O;\n  }, o = st && st.__importDefault || function(N) {\n    return N && N.__esModule ? N : { default: N };\n  };\n  Object.defineProperty(st, \"__esModule\", { value: !0 }), st.deserializeUnchecked = st.deserialize = st.serialize = st.BinaryReader = st.BinaryWriter = st.BorshError = st.baseDecode = st.baseEncode = void 0;\n  const i = o(Qh()), c = o(td()), f = n(ad), v = typeof TextDecoder != \"function\" ? f.TextDecoder : TextDecoder, x = new v(\"utf-8\", { fatal: !0 });\n  function b(N) {\n    return typeof N == \"string\" && (N = Buffer.from(N, \"utf8\")), c.default.encode(Buffer.from(N));\n  }\n  st.baseEncode = b;\n  function S(N) {\n    return Buffer.from(c.default.decode(N));\n  }\n  st.baseDecode = S;\n  const T = 1024;\n  class C extends Error {\n    constructor(O) {\n      super(O), this.fieldPath = [], this.originalMessage = O;\n    }\n    addToFieldPath(O) {\n      this.fieldPath.splice(0, 0, O), this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n  }\n  st.BorshError = C;\n  class P {\n    constructor() {\n      this.buf = Buffer.alloc(T), this.length = 0;\n    }\n    maybeResize() {\n      this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(T)]));\n    }\n    writeU8(O) {\n      this.maybeResize(), this.buf.writeUInt8(O, this.length), this.length += 1;\n    }\n    writeU16(O) {\n      this.maybeResize(), this.buf.writeUInt16LE(O, this.length), this.length += 2;\n    }\n    writeU32(O) {\n      this.maybeResize(), this.buf.writeUInt32LE(O, this.length), this.length += 4;\n    }\n    writeU64(O) {\n      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(O).toArray(\"le\", 8)));\n    }\n    writeU128(O) {\n      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(O).toArray(\"le\", 16)));\n    }\n    writeU256(O) {\n      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(O).toArray(\"le\", 32)));\n    }\n    writeU512(O) {\n      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(O).toArray(\"le\", 64)));\n    }\n    writeBuffer(O) {\n      this.buf = Buffer.concat([\n        Buffer.from(this.buf.subarray(0, this.length)),\n        O,\n        Buffer.alloc(T)\n      ]), this.length += O.length;\n    }\n    writeString(O) {\n      this.maybeResize();\n      const L = Buffer.from(O, \"utf8\");\n      this.writeU32(L.length), this.writeBuffer(L);\n    }\n    writeFixedArray(O) {\n      this.writeBuffer(Buffer.from(O));\n    }\n    writeArray(O, L) {\n      this.maybeResize(), this.writeU32(O.length);\n      for (const F of O)\n        this.maybeResize(), L(F);\n    }\n    toArray() {\n      return this.buf.subarray(0, this.length);\n    }\n  }\n  st.BinaryWriter = P;\n  function B(N, O, L) {\n    const F = L.value;\n    L.value = function(...d) {\n      try {\n        return F.apply(this, d);\n      } catch (s) {\n        if (s instanceof RangeError) {\n          const u = s.code;\n          if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(u) >= 0)\n            throw new C(\"Reached the end of buffer when deserializing\");\n        }\n        throw s;\n      }\n    };\n  }\n  class R {\n    constructor(O) {\n      this.buf = O, this.offset = 0;\n    }\n    readU8() {\n      const O = this.buf.readUInt8(this.offset);\n      return this.offset += 1, O;\n    }\n    readU16() {\n      const O = this.buf.readUInt16LE(this.offset);\n      return this.offset += 2, O;\n    }\n    readU32() {\n      const O = this.buf.readUInt32LE(this.offset);\n      return this.offset += 4, O;\n    }\n    readU64() {\n      const O = this.readBuffer(8);\n      return new i.default(O, \"le\");\n    }\n    readU128() {\n      const O = this.readBuffer(16);\n      return new i.default(O, \"le\");\n    }\n    readU256() {\n      const O = this.readBuffer(32);\n      return new i.default(O, \"le\");\n    }\n    readU512() {\n      const O = this.readBuffer(64);\n      return new i.default(O, \"le\");\n    }\n    readBuffer(O) {\n      if (this.offset + O > this.buf.length)\n        throw new C(`Expected buffer length ${O} isn't within bounds`);\n      const L = this.buf.slice(this.offset, this.offset + O);\n      return this.offset += O, L;\n    }\n    readString() {\n      const O = this.readU32(), L = this.readBuffer(O);\n      try {\n        return x.decode(L);\n      } catch (F) {\n        throw new C(`Error decoding UTF-8 string: ${F}`);\n      }\n    }\n    readFixedArray(O) {\n      return new Uint8Array(this.readBuffer(O));\n    }\n    readArray(O) {\n      const L = this.readU32(), F = Array();\n      for (let d = 0; d < L; ++d)\n        F.push(O());\n      return F;\n    }\n  }\n  r([\n    B\n  ], R.prototype, \"readU8\", null), r([\n    B\n  ], R.prototype, \"readU16\", null), r([\n    B\n  ], R.prototype, \"readU32\", null), r([\n    B\n  ], R.prototype, \"readU64\", null), r([\n    B\n  ], R.prototype, \"readU128\", null), r([\n    B\n  ], R.prototype, \"readU256\", null), r([\n    B\n  ], R.prototype, \"readU512\", null), r([\n    B\n  ], R.prototype, \"readString\", null), r([\n    B\n  ], R.prototype, \"readFixedArray\", null), r([\n    B\n  ], R.prototype, \"readArray\", null), st.BinaryReader = R;\n  function z(N) {\n    return N.charAt(0).toUpperCase() + N.slice(1);\n  }\n  function K(N, O, L, F, d) {\n    try {\n      if (typeof F == \"string\")\n        d[`write${z(F)}`](L);\n      else if (F instanceof Array)\n        if (typeof F[0] == \"number\") {\n          if (L.length !== F[0])\n            throw new C(`Expecting byte array of length ${F[0]}, but got ${L.length} bytes`);\n          d.writeFixedArray(L);\n        } else if (F.length === 2 && typeof F[1] == \"number\") {\n          if (L.length !== F[1])\n            throw new C(`Expecting byte array of length ${F[1]}, but got ${L.length} bytes`);\n          for (let s = 0; s < F[1]; s++)\n            K(N, null, L[s], F[0], d);\n        } else\n          d.writeArray(L, (s) => {\n            K(N, O, s, F[0], d);\n          });\n      else if (F.kind !== void 0)\n        switch (F.kind) {\n          case \"option\": {\n            L == null ? d.writeU8(0) : (d.writeU8(1), K(N, O, L, F.type, d));\n            break;\n          }\n          case \"map\": {\n            d.writeU32(L.size), L.forEach((s, u) => {\n              K(N, O, u, F.key, d), K(N, O, s, F.value, d);\n            });\n            break;\n          }\n          default:\n            throw new C(`FieldType ${F} unrecognized`);\n        }\n      else\n        Z(N, L, d);\n    } catch (s) {\n      throw s instanceof C && s.addToFieldPath(O), s;\n    }\n  }\n  function Z(N, O, L) {\n    if (typeof O.borshSerialize == \"function\") {\n      O.borshSerialize(L);\n      return;\n    }\n    const F = N.get(O.constructor);\n    if (!F)\n      throw new C(`Class ${O.constructor.name} is missing in schema`);\n    if (F.kind === \"struct\")\n      F.fields.map(([d, s]) => {\n        K(N, d, O[d], s, L);\n      });\n    else if (F.kind === \"enum\") {\n      const d = O[F.field];\n      for (let s = 0; s < F.values.length; ++s) {\n        const [u, h] = F.values[s];\n        if (u === d) {\n          L.writeU8(s), K(N, u, O[u], h, L);\n          break;\n        }\n      }\n    } else\n      throw new C(`Unexpected schema kind: ${F.kind} for ${O.constructor.name}`);\n  }\n  function Q(N, O, L = P) {\n    const F = new L();\n    return Z(N, O, F), F.toArray();\n  }\n  st.serialize = Q;\n  function j(N, O, L, F) {\n    try {\n      if (typeof L == \"string\")\n        return F[`read${z(L)}`]();\n      if (L instanceof Array) {\n        if (typeof L[0] == \"number\")\n          return F.readFixedArray(L[0]);\n        if (typeof L[1] == \"number\") {\n          const d = [];\n          for (let s = 0; s < L[1]; s++)\n            d.push(j(N, null, L[0], F));\n          return d;\n        } else\n          return F.readArray(() => j(N, O, L[0], F));\n      }\n      if (L.kind === \"option\")\n        return F.readU8() ? j(N, O, L.type, F) : void 0;\n      if (L.kind === \"map\") {\n        let d = /* @__PURE__ */ new Map();\n        const s = F.readU32();\n        for (let u = 0; u < s; u++) {\n          const h = j(N, O, L.key, F), g = j(N, O, L.value, F);\n          d.set(h, g);\n        }\n        return d;\n      }\n      return V(N, L, F);\n    } catch (d) {\n      throw d instanceof C && d.addToFieldPath(O), d;\n    }\n  }\n  function V(N, O, L) {\n    if (typeof O.borshDeserialize == \"function\")\n      return O.borshDeserialize(L);\n    const F = N.get(O);\n    if (!F)\n      throw new C(`Class ${O.name} is missing in schema`);\n    if (F.kind === \"struct\") {\n      const d = {};\n      for (const [s, u] of N.get(O).fields)\n        d[s] = j(N, s, u, L);\n      return new O(d);\n    }\n    if (F.kind === \"enum\") {\n      const d = L.readU8();\n      if (d >= F.values.length)\n        throw new C(`Enum index: ${d} is out of range`);\n      const [s, u] = F.values[d], h = j(N, s, u, L);\n      return new O({ [s]: h });\n    }\n    throw new C(`Unexpected schema kind: ${F.kind} for ${O.constructor.name}`);\n  }\n  function ee(N, O, L, F = R) {\n    const d = new F(L), s = V(N, O, d);\n    if (d.offset < L.length)\n      throw new C(`Unexpected ${L.length - d.offset} bytes after deserialized data`);\n    return s;\n  }\n  st.deserialize = ee;\n  function G(N, O, L, F = R) {\n    const d = new F(L);\n    return V(N, O, d);\n  }\n  return st.deserializeUnchecked = G, st;\n}\nvar oo = ud(), Y = {}, nu;\nfunction cd() {\n  if (nu) return Y;\n  nu = 1, Object.defineProperty(Y, \"__esModule\", { value: !0 }), Y.s16 = Y.s8 = Y.nu64be = Y.u48be = Y.u40be = Y.u32be = Y.u24be = Y.u16be = Y.nu64 = Y.u48 = Y.u40 = Y.u32 = Y.u24 = Y.u16 = Y.u8 = Y.offset = Y.greedy = Y.Constant = Y.UTF8 = Y.CString = Y.Blob = Y.Boolean = Y.BitField = Y.BitStructure = Y.VariantLayout = Y.Union = Y.UnionLayoutDiscriminator = Y.UnionDiscriminator = Y.Structure = Y.Sequence = Y.DoubleBE = Y.Double = Y.FloatBE = Y.Float = Y.NearInt64BE = Y.NearInt64 = Y.NearUInt64BE = Y.NearUInt64 = Y.IntBE = Y.Int = Y.UIntBE = Y.UInt = Y.OffsetLayout = Y.GreedyCount = Y.ExternalLayout = Y.bindConstructorLayout = Y.nameWithProperty = Y.Layout = Y.uint8ArrayToBuffer = Y.checkUint8Array = void 0, Y.constant = Y.utf8 = Y.cstr = Y.blob = Y.unionLayoutDiscriminator = Y.union = Y.seq = Y.bits = Y.struct = Y.f64be = Y.f64 = Y.f32be = Y.f32 = Y.ns64be = Y.s48be = Y.s40be = Y.s32be = Y.s24be = Y.s16be = Y.ns64 = Y.s48 = Y.s40 = Y.s32 = Y.s24 = void 0;\n  const t = na();\n  function e(a) {\n    if (!(a instanceof Uint8Array))\n      throw new TypeError(\"b must be a Uint8Array\");\n  }\n  Y.checkUint8Array = e;\n  function r(a) {\n    return e(a), t.Buffer.from(a.buffer, a.byteOffset, a.length);\n  }\n  Y.uint8ArrayToBuffer = r;\n  let n = class {\n    constructor(l, M) {\n      if (!Number.isInteger(l))\n        throw new TypeError(\"span must be an integer\");\n      this.span = l, this.property = M;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */\n    makeDestinationObject() {\n      return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */\n    getSpan(l, M) {\n      if (0 > this.span)\n        throw new RangeError(\"indeterminate span\");\n      return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */\n    replicate(l) {\n      const M = Object.create(this.constructor.prototype);\n      return Object.assign(M, this), M.property = l, M;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */\n    fromArray(l) {\n    }\n  };\n  Y.Layout = n;\n  function o(a, l) {\n    return l.property ? a + \"[\" + l.property + \"]\" : a;\n  }\n  Y.nameWithProperty = o;\n  function i(a, l) {\n    if (typeof a != \"function\")\n      throw new TypeError(\"Class must be constructor\");\n    if (Object.prototype.hasOwnProperty.call(a, \"layout_\"))\n      throw new Error(\"Class is already bound to a layout\");\n    if (!(l && l instanceof n))\n      throw new TypeError(\"layout must be a Layout\");\n    if (Object.prototype.hasOwnProperty.call(l, \"boundConstructor_\"))\n      throw new Error(\"layout is already bound to a constructor\");\n    a.layout_ = l, l.boundConstructor_ = a, l.makeDestinationObject = () => new a(), Object.defineProperty(a.prototype, \"encode\", {\n      value(M, k) {\n        return l.encode(this, M, k);\n      },\n      writable: !0\n    }), Object.defineProperty(a, \"decode\", {\n      value(M, k) {\n        return l.decode(M, k);\n      },\n      writable: !0\n    });\n  }\n  Y.bindConstructorLayout = i;\n  class c extends n {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */\n    isCount() {\n      throw new Error(\"ExternalLayout is abstract\");\n    }\n  }\n  Y.ExternalLayout = c;\n  class f extends c {\n    constructor(l = 1, M) {\n      if (!Number.isInteger(l) || 0 >= l)\n        throw new TypeError(\"elementSpan must be a (positive) integer\");\n      super(-1, M), this.elementSpan = l;\n    }\n    /** @override */\n    isCount() {\n      return !0;\n    }\n    /** @override */\n    decode(l, M = 0) {\n      e(l);\n      const k = l.length - M;\n      return Math.floor(k / this.elementSpan);\n    }\n    /** @override */\n    encode(l, M, k) {\n      return 0;\n    }\n  }\n  Y.GreedyCount = f;\n  class v extends c {\n    constructor(l, M = 0, k) {\n      if (!(l instanceof n))\n        throw new TypeError(\"layout must be a Layout\");\n      if (!Number.isInteger(M))\n        throw new TypeError(\"offset must be integer or undefined\");\n      super(l.span, k || l.property), this.layout = l, this.offset = M;\n    }\n    /** @override */\n    isCount() {\n      return this.layout instanceof x || this.layout instanceof b;\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return this.layout.decode(l, M + this.offset);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return this.layout.encode(l, M, k + this.offset);\n    }\n  }\n  Y.OffsetLayout = v;\n  class x extends n {\n    constructor(l, M) {\n      if (super(l, M), 6 < this.span)\n        throw new RangeError(\"span must not exceed 6 bytes\");\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return r(l).readUIntLE(M, this.span);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return r(M).writeUIntLE(l, k, this.span), this.span;\n    }\n  }\n  Y.UInt = x;\n  class b extends n {\n    constructor(l, M) {\n      if (super(l, M), 6 < this.span)\n        throw new RangeError(\"span must not exceed 6 bytes\");\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return r(l).readUIntBE(M, this.span);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return r(M).writeUIntBE(l, k, this.span), this.span;\n    }\n  }\n  Y.UIntBE = b;\n  class S extends n {\n    constructor(l, M) {\n      if (super(l, M), 6 < this.span)\n        throw new RangeError(\"span must not exceed 6 bytes\");\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return r(l).readIntLE(M, this.span);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return r(M).writeIntLE(l, k, this.span), this.span;\n    }\n  }\n  Y.Int = S;\n  class T extends n {\n    constructor(l, M) {\n      if (super(l, M), 6 < this.span)\n        throw new RangeError(\"span must not exceed 6 bytes\");\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return r(l).readIntBE(M, this.span);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return r(M).writeIntBE(l, k, this.span), this.span;\n    }\n  }\n  Y.IntBE = T;\n  const C = Math.pow(2, 32);\n  function P(a) {\n    const l = Math.floor(a / C), M = a - l * C;\n    return { hi32: l, lo32: M };\n  }\n  function B(a, l) {\n    return a * C + l;\n  }\n  class R extends n {\n    constructor(l) {\n      super(8, l);\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = r(l), $ = k.readUInt32LE(M), X = k.readUInt32LE(M + 4);\n      return B(X, $);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      const $ = P(l), X = r(M);\n      return X.writeUInt32LE($.lo32, k), X.writeUInt32LE($.hi32, k + 4), 8;\n    }\n  }\n  Y.NearUInt64 = R;\n  class z extends n {\n    constructor(l) {\n      super(8, l);\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = r(l), $ = k.readUInt32BE(M), X = k.readUInt32BE(M + 4);\n      return B($, X);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      const $ = P(l), X = r(M);\n      return X.writeUInt32BE($.hi32, k), X.writeUInt32BE($.lo32, k + 4), 8;\n    }\n  }\n  Y.NearUInt64BE = z;\n  class K extends n {\n    constructor(l) {\n      super(8, l);\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = r(l), $ = k.readUInt32LE(M), X = k.readInt32LE(M + 4);\n      return B(X, $);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      const $ = P(l), X = r(M);\n      return X.writeUInt32LE($.lo32, k), X.writeInt32LE($.hi32, k + 4), 8;\n    }\n  }\n  Y.NearInt64 = K;\n  class Z extends n {\n    constructor(l) {\n      super(8, l);\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = r(l), $ = k.readInt32BE(M), X = k.readUInt32BE(M + 4);\n      return B($, X);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      const $ = P(l), X = r(M);\n      return X.writeInt32BE($.hi32, k), X.writeUInt32BE($.lo32, k + 4), 8;\n    }\n  }\n  Y.NearInt64BE = Z;\n  class Q extends n {\n    constructor(l) {\n      super(4, l);\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return r(l).readFloatLE(M);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return r(M).writeFloatLE(l, k), 4;\n    }\n  }\n  Y.Float = Q;\n  class j extends n {\n    constructor(l) {\n      super(4, l);\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return r(l).readFloatBE(M);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return r(M).writeFloatBE(l, k), 4;\n    }\n  }\n  Y.FloatBE = j;\n  class V extends n {\n    constructor(l) {\n      super(8, l);\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return r(l).readDoubleLE(M);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return r(M).writeDoubleLE(l, k), 8;\n    }\n  }\n  Y.Double = V;\n  class ee extends n {\n    constructor(l) {\n      super(8, l);\n    }\n    /** @override */\n    decode(l, M = 0) {\n      return r(l).readDoubleBE(M);\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      return r(M).writeDoubleBE(l, k), 8;\n    }\n  }\n  Y.DoubleBE = ee;\n  class G extends n {\n    constructor(l, M, k) {\n      if (!(l instanceof n))\n        throw new TypeError(\"elementLayout must be a Layout\");\n      if (!(M instanceof c && M.isCount() || Number.isInteger(M) && 0 <= M))\n        throw new TypeError(\"count must be non-negative integer or an unsigned integer ExternalLayout\");\n      let $ = -1;\n      !(M instanceof c) && 0 < l.span && ($ = M * l.span), super($, k), this.elementLayout = l, this.count = M;\n    }\n    /** @override */\n    getSpan(l, M = 0) {\n      if (0 <= this.span)\n        return this.span;\n      let k = 0, $ = this.count;\n      if ($ instanceof c && ($ = $.decode(l, M)), 0 < this.elementLayout.span)\n        k = $ * this.elementLayout.span;\n      else {\n        let X = 0;\n        for (; X < $; )\n          k += this.elementLayout.getSpan(l, M + k), ++X;\n      }\n      return k;\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = [];\n      let $ = 0, X = this.count;\n      for (X instanceof c && (X = X.decode(l, M)); $ < X; )\n        k.push(this.elementLayout.decode(l, M)), M += this.elementLayout.getSpan(l, M), $ += 1;\n      return k;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(l, M, k = 0) {\n      const $ = this.elementLayout, X = l.reduce((re, se) => re + $.encode(se, M, k + re), 0);\n      return this.count instanceof c && this.count.encode(l.length, M, k), X;\n    }\n  }\n  Y.Sequence = G;\n  class N extends n {\n    constructor(l, M, k) {\n      if (!(Array.isArray(l) && l.reduce((X, re) => X && re instanceof n, !0)))\n        throw new TypeError(\"fields must be array of Layout instances\");\n      typeof M == \"boolean\" && k === void 0 && (k = M, M = void 0);\n      for (const X of l)\n        if (0 > X.span && X.property === void 0)\n          throw new Error(\"fields cannot contain unnamed variable-length layout\");\n      let $ = -1;\n      try {\n        $ = l.reduce((X, re) => X + re.getSpan(), 0);\n      } catch {\n      }\n      super($, M), this.fields = l, this.decodePrefixes = !!k;\n    }\n    /** @override */\n    getSpan(l, M = 0) {\n      if (0 <= this.span)\n        return this.span;\n      let k = 0;\n      try {\n        k = this.fields.reduce(($, X) => {\n          const re = X.getSpan(l, M);\n          return M += re, $ + re;\n        }, 0);\n      } catch {\n        throw new RangeError(\"indeterminate span\");\n      }\n      return k;\n    }\n    /** @override */\n    decode(l, M = 0) {\n      e(l);\n      const k = this.makeDestinationObject();\n      for (const $ of this.fields)\n        if ($.property !== void 0 && (k[$.property] = $.decode(l, M)), M += $.getSpan(l, M), this.decodePrefixes && l.length === M)\n          break;\n      return k;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */\n    encode(l, M, k = 0) {\n      const $ = k;\n      let X = 0, re = 0;\n      for (const se of this.fields) {\n        let ut = se.span;\n        if (re = 0 < ut ? ut : 0, se.property !== void 0) {\n          const xe = l[se.property];\n          xe !== void 0 && (re = se.encode(xe, M, k), 0 > ut && (ut = se.getSpan(M, k)));\n        }\n        X = k, k += ut;\n      }\n      return X + re - $;\n    }\n    /** @override */\n    fromArray(l) {\n      const M = this.makeDestinationObject();\n      for (const k of this.fields)\n        k.property !== void 0 && 0 < l.length && (M[k.property] = l.shift());\n      return M;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */\n    layoutFor(l) {\n      if (typeof l != \"string\")\n        throw new TypeError(\"property must be string\");\n      for (const M of this.fields)\n        if (M.property === l)\n          return M;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */\n    offsetOf(l) {\n      if (typeof l != \"string\")\n        throw new TypeError(\"property must be string\");\n      let M = 0;\n      for (const k of this.fields) {\n        if (k.property === l)\n          return M;\n        0 > k.span ? M = -1 : 0 <= M && (M += k.span);\n      }\n    }\n  }\n  Y.Structure = N;\n  class O {\n    constructor(l) {\n      this.property = l;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */\n    decode(l, M) {\n      throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */\n    encode(l, M, k) {\n      throw new Error(\"UnionDiscriminator is abstract\");\n    }\n  }\n  Y.UnionDiscriminator = O;\n  class L extends O {\n    constructor(l, M) {\n      if (!(l instanceof c && l.isCount()))\n        throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n      super(M || l.property || \"variant\"), this.layout = l;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    decode(l, M) {\n      return this.layout.decode(l, M);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    encode(l, M, k) {\n      return this.layout.encode(l, M, k);\n    }\n  }\n  Y.UnionLayoutDiscriminator = L;\n  class F extends n {\n    constructor(l, M, k) {\n      let $;\n      if (l instanceof x || l instanceof b)\n        $ = new L(new v(l));\n      else if (l instanceof c && l.isCount())\n        $ = new L(l);\n      else if (l instanceof O)\n        $ = l;\n      else\n        throw new TypeError(\"discr must be a UnionDiscriminator or an unsigned integer layout\");\n      if (M === void 0 && (M = null), !(M === null || M instanceof n))\n        throw new TypeError(\"defaultLayout must be null or a Layout\");\n      if (M !== null) {\n        if (0 > M.span)\n          throw new Error(\"defaultLayout must have constant span\");\n        M.property === void 0 && (M = M.replicate(\"content\"));\n      }\n      let X = -1;\n      M && (X = M.span, 0 <= X && (l instanceof x || l instanceof b) && (X += $.layout.span)), super(X, k), this.discriminator = $, this.usesPrefixDiscriminator = l instanceof x || l instanceof b, this.defaultLayout = M, this.registry = {};\n      let re = this.defaultGetSourceVariant.bind(this);\n      this.getSourceVariant = function(se) {\n        return re(se);\n      }, this.configGetSourceVariant = function(se) {\n        re = se.bind(this);\n      };\n    }\n    /** @override */\n    getSpan(l, M = 0) {\n      if (0 <= this.span)\n        return this.span;\n      const k = this.getVariant(l, M);\n      if (!k)\n        throw new Error(\"unable to determine span for unrecognized variant\");\n      return k.getSpan(l, M);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */\n    defaultGetSourceVariant(l) {\n      if (Object.prototype.hasOwnProperty.call(l, this.discriminator.property)) {\n        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(l, this.defaultLayout.property))\n          return;\n        const M = this.registry[l[this.discriminator.property]];\n        if (M && (!M.layout || M.property && Object.prototype.hasOwnProperty.call(l, M.property)))\n          return M;\n      } else\n        for (const M in this.registry) {\n          const k = this.registry[M];\n          if (k.property && Object.prototype.hasOwnProperty.call(l, k.property))\n            return k;\n        }\n      throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */\n    decode(l, M = 0) {\n      let k;\n      const $ = this.discriminator, X = $.decode(l, M), re = this.registry[X];\n      if (re === void 0) {\n        const se = this.defaultLayout;\n        let ut = 0;\n        this.usesPrefixDiscriminator && (ut = $.layout.span), k = this.makeDestinationObject(), k[$.property] = X, k[se.property] = se.decode(l, M + ut);\n      } else\n        k = re.decode(l, M);\n      return k;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */\n    encode(l, M, k = 0) {\n      const $ = this.getSourceVariant(l);\n      if ($ === void 0) {\n        const X = this.discriminator, re = this.defaultLayout;\n        let se = 0;\n        return this.usesPrefixDiscriminator && (se = X.layout.span), X.encode(l[X.property], M, k), se + re.encode(l[re.property], M, k + se);\n      }\n      return $.encode(l, M, k);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */\n    addVariant(l, M, k) {\n      const $ = new d(this, l, M, k);\n      return this.registry[l] = $, $;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */\n    getVariant(l, M = 0) {\n      let k;\n      return l instanceof Uint8Array ? k = this.discriminator.decode(l, M) : k = l, this.registry[k];\n    }\n  }\n  Y.Union = F;\n  class d extends n {\n    constructor(l, M, k, $) {\n      if (!(l instanceof F))\n        throw new TypeError(\"union must be a Union\");\n      if (!Number.isInteger(M) || 0 > M)\n        throw new TypeError(\"variant must be a (non-negative) integer\");\n      if (typeof k == \"string\" && $ === void 0 && ($ = k, k = null), k) {\n        if (!(k instanceof n))\n          throw new TypeError(\"layout must be a Layout\");\n        if (l.defaultLayout !== null && 0 <= k.span && k.span > l.defaultLayout.span)\n          throw new Error(\"variant span exceeds span of containing union\");\n        if (typeof $ != \"string\")\n          throw new TypeError(\"variant must have a String property\");\n      }\n      let X = l.span;\n      0 > l.span && (X = k ? k.span : 0, 0 <= X && l.usesPrefixDiscriminator && (X += l.discriminator.layout.span)), super(X, $), this.union = l, this.variant = M, this.layout = k || null;\n    }\n    /** @override */\n    getSpan(l, M = 0) {\n      if (0 <= this.span)\n        return this.span;\n      let k = 0;\n      this.union.usesPrefixDiscriminator && (k = this.union.discriminator.layout.span);\n      let $ = 0;\n      return this.layout && ($ = this.layout.getSpan(l, M + k)), k + $;\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = this.makeDestinationObject();\n      if (this !== this.union.getVariant(l, M))\n        throw new Error(\"variant mismatch\");\n      let $ = 0;\n      return this.union.usesPrefixDiscriminator && ($ = this.union.discriminator.layout.span), this.layout ? k[this.property] = this.layout.decode(l, M + $) : this.property ? k[this.property] = !0 : this.union.usesPrefixDiscriminator && (k[this.union.discriminator.property] = this.variant), k;\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      let $ = 0;\n      if (this.union.usesPrefixDiscriminator && ($ = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(l, this.property))\n        throw new TypeError(\"variant lacks property \" + this.property);\n      this.union.discriminator.encode(this.variant, M, k);\n      let X = $;\n      if (this.layout && (this.layout.encode(l[this.property], M, k + $), X += this.layout.getSpan(M, k + $), 0 <= this.union.span && X > this.union.span))\n        throw new Error(\"encoded variant overruns containing union\");\n      return X;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */\n    fromArray(l) {\n      if (this.layout)\n        return this.layout.fromArray(l);\n    }\n  }\n  Y.VariantLayout = d;\n  function s(a) {\n    return 0 > a && (a += 4294967296), a;\n  }\n  class u extends n {\n    constructor(l, M, k) {\n      if (!(l instanceof x || l instanceof b))\n        throw new TypeError(\"word must be a UInt or UIntBE layout\");\n      if (typeof M == \"string\" && k === void 0 && (k = M, M = !1), 4 < l.span)\n        throw new RangeError(\"word cannot exceed 32 bits\");\n      super(l.span, k), this.word = l, this.msb = !!M, this.fields = [];\n      let $ = 0;\n      this._packedSetValue = function(X) {\n        return $ = s(X), this;\n      }, this._packedGetValue = function() {\n        return $;\n      };\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = this.makeDestinationObject(), $ = this.word.decode(l, M);\n      this._packedSetValue($);\n      for (const X of this.fields)\n        X.property !== void 0 && (k[X.property] = X.decode(l));\n      return k;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */\n    encode(l, M, k = 0) {\n      const $ = this.word.decode(M, k);\n      this._packedSetValue($);\n      for (const X of this.fields)\n        if (X.property !== void 0) {\n          const re = l[X.property];\n          re !== void 0 && X.encode(re);\n        }\n      return this.word.encode(this._packedGetValue(), M, k);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */\n    addField(l, M) {\n      const k = new h(this, l, M);\n      return this.fields.push(k), k;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */\n    // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(l) {\n      const M = new g(this, l);\n      return this.fields.push(M), M;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */\n    fieldFor(l) {\n      if (typeof l != \"string\")\n        throw new TypeError(\"property must be string\");\n      for (const M of this.fields)\n        if (M.property === l)\n          return M;\n    }\n  }\n  Y.BitStructure = u;\n  class h {\n    constructor(l, M, k) {\n      if (!(l instanceof u))\n        throw new TypeError(\"container must be a BitStructure\");\n      if (!Number.isInteger(M) || 0 >= M)\n        throw new TypeError(\"bits must be positive integer\");\n      const $ = 8 * l.span, X = l.fields.reduce((re, se) => re + se.bits, 0);\n      if (M + X > $)\n        throw new Error(\"bits too long for span remainder (\" + ($ - X) + \" of \" + $ + \" remain)\");\n      this.container = l, this.bits = M, this.valueMask = (1 << M) - 1, M === 32 && (this.valueMask = 4294967295), this.start = X, this.container.msb && (this.start = $ - X - M), this.wordMask = s(this.valueMask << this.start), this.property = k;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */\n    decode(l, M) {\n      const k = this.container._packedGetValue();\n      return s(k & this.wordMask) >>> this.start;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */\n    encode(l) {\n      if (typeof l != \"number\" || !Number.isInteger(l) || l !== s(l & this.valueMask))\n        throw new TypeError(o(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n      const M = this.container._packedGetValue(), k = s(l << this.start);\n      this.container._packedSetValue(s(M & ~this.wordMask) | k);\n    }\n  }\n  Y.BitField = h;\n  class g extends h {\n    constructor(l, M) {\n      super(l, 1, M);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */\n    decode(l, M) {\n      return !!super.decode(l, M);\n    }\n    /** @override */\n    encode(l) {\n      typeof l == \"boolean\" && (l = +l), super.encode(l);\n    }\n  }\n  Y.Boolean = g;\n  class w extends n {\n    constructor(l, M) {\n      if (!(l instanceof c && l.isCount() || Number.isInteger(l) && 0 <= l))\n        throw new TypeError(\"length must be positive integer or an unsigned integer ExternalLayout\");\n      let k = -1;\n      l instanceof c || (k = l), super(k, M), this.length = l;\n    }\n    /** @override */\n    getSpan(l, M) {\n      let k = this.span;\n      return 0 > k && (k = this.length.decode(l, M)), k;\n    }\n    /** @override */\n    decode(l, M = 0) {\n      let k = this.span;\n      return 0 > k && (k = this.length.decode(l, M)), r(l).slice(M, M + k);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(l, M, k) {\n      let $ = this.length;\n      if (this.length instanceof c && ($ = l.length), !(l instanceof Uint8Array && $ === l.length))\n        throw new TypeError(o(\"Blob.encode\", this) + \" requires (length \" + $ + \") Uint8Array as src\");\n      if (k + $ > M.length)\n        throw new RangeError(\"encoding overruns Uint8Array\");\n      const X = r(l);\n      return r(M).write(X.toString(\"hex\"), k, $, \"hex\"), this.length instanceof c && this.length.encode($, M, k), $;\n    }\n  }\n  Y.Blob = w;\n  class _ extends n {\n    constructor(l) {\n      super(-1, l);\n    }\n    /** @override */\n    getSpan(l, M = 0) {\n      e(l);\n      let k = M;\n      for (; k < l.length && l[k] !== 0; )\n        k += 1;\n      return 1 + k - M;\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = this.getSpan(l, M);\n      return r(l).slice(M, M + k - 1).toString(\"utf-8\");\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      typeof l != \"string\" && (l = String(l));\n      const $ = t.Buffer.from(l, \"utf8\"), X = $.length;\n      if (k + X > M.length)\n        throw new RangeError(\"encoding overruns Buffer\");\n      const re = r(M);\n      return $.copy(re, k), re[k + X] = 0, X + 1;\n    }\n  }\n  Y.CString = _;\n  class A extends n {\n    constructor(l, M) {\n      if (typeof l == \"string\" && M === void 0 && (M = l, l = void 0), l === void 0)\n        l = -1;\n      else if (!Number.isInteger(l))\n        throw new TypeError(\"maxSpan must be an integer\");\n      super(-1, M), this.maxSpan = l;\n    }\n    /** @override */\n    getSpan(l, M = 0) {\n      return e(l), l.length - M;\n    }\n    /** @override */\n    decode(l, M = 0) {\n      const k = this.getSpan(l, M);\n      if (0 <= this.maxSpan && this.maxSpan < k)\n        throw new RangeError(\"text length exceeds maxSpan\");\n      return r(l).slice(M, M + k).toString(\"utf-8\");\n    }\n    /** @override */\n    encode(l, M, k = 0) {\n      typeof l != \"string\" && (l = String(l));\n      const $ = t.Buffer.from(l, \"utf8\"), X = $.length;\n      if (0 <= this.maxSpan && this.maxSpan < X)\n        throw new RangeError(\"text length exceeds maxSpan\");\n      if (k + X > M.length)\n        throw new RangeError(\"encoding overruns Buffer\");\n      return $.copy(r(M), k), X;\n    }\n  }\n  Y.UTF8 = A;\n  class p extends n {\n    constructor(l, M) {\n      super(0, M), this.value = l;\n    }\n    /** @override */\n    decode(l, M) {\n      return this.value;\n    }\n    /** @override */\n    encode(l, M, k) {\n      return 0;\n    }\n  }\n  return Y.Constant = p, Y.greedy = (a, l) => new f(a, l), Y.offset = (a, l, M) => new v(a, l, M), Y.u8 = (a) => new x(1, a), Y.u16 = (a) => new x(2, a), Y.u24 = (a) => new x(3, a), Y.u32 = (a) => new x(4, a), Y.u40 = (a) => new x(5, a), Y.u48 = (a) => new x(6, a), Y.nu64 = (a) => new R(a), Y.u16be = (a) => new b(2, a), Y.u24be = (a) => new b(3, a), Y.u32be = (a) => new b(4, a), Y.u40be = (a) => new b(5, a), Y.u48be = (a) => new b(6, a), Y.nu64be = (a) => new z(a), Y.s8 = (a) => new S(1, a), Y.s16 = (a) => new S(2, a), Y.s24 = (a) => new S(3, a), Y.s32 = (a) => new S(4, a), Y.s40 = (a) => new S(5, a), Y.s48 = (a) => new S(6, a), Y.ns64 = (a) => new K(a), Y.s16be = (a) => new T(2, a), Y.s24be = (a) => new T(3, a), Y.s32be = (a) => new T(4, a), Y.s40be = (a) => new T(5, a), Y.s48be = (a) => new T(6, a), Y.ns64be = (a) => new Z(a), Y.f32 = (a) => new Q(a), Y.f32be = (a) => new j(a), Y.f64 = (a) => new V(a), Y.f64be = (a) => new ee(a), Y.struct = (a, l, M) => new N(a, l, M), Y.bits = (a, l, M) => new u(a, l, M), Y.seq = (a, l, M) => new G(a, l, M), Y.union = (a, l, M) => new F(a, l, M), Y.unionLayoutDiscriminator = (a, l) => new L(a, l), Y.blob = (a, l) => new w(a, l), Y.cstr = (a) => new _(a), Y.utf8 = (a, l) => new A(a, l), Y.constant = (a, l) => new p(a, l), Y;\n}\nvar D = cd(), ld = 8078e3, fd = 8078001, hd = 8078004, dd = 8078005, pd = 8078006, md = 8078011;\nfunction Rc(t) {\n  return Array.isArray(t) ? \"%5B\" + t.map(Rc).join(\n    \"%2C%20\"\n    /* \", \" */\n  ) + /* \"]\" */\n  \"%5D\" : typeof t == \"bigint\" ? `${t}n` : encodeURIComponent(\n    String(\n      t != null && Object.getPrototypeOf(t) === null ? (\n        // Plain objects with no prototype don't have a `toString` method.\n        // Convert them before stringifying them.\n        { ...t }\n      ) : t\n    )\n  );\n}\nfunction gd([t, e]) {\n  return `${t}=${Rc(e)}`;\n}\nfunction yd(t) {\n  const e = Object.entries(t).map(gd).join(\"&\");\n  return btoa(e);\n}\nfunction vd(t, e = {}) {\n  {\n    let r = `Solana error #${t}; Decode this error by running \\`npx @solana/errors decode -- ${t}`;\n    return Object.keys(e).length && (r += ` '${yd(e)}'`), `${r}\\``;\n  }\n}\nvar In = class extends Error {\n  constructor(...[e, r]) {\n    let n, o;\n    if (r) {\n      const { cause: c, ...f } = r;\n      c && (o = { cause: c }), Object.keys(f).length > 0 && (n = f);\n    }\n    const i = vd(e, n);\n    super(i, o);\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    br(this, \"cause\", this.cause);\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    br(this, \"context\");\n    this.context = {\n      __code: e,\n      ...n\n    }, this.name = \"SolanaError\";\n  }\n};\nfunction wd(t, e) {\n  return \"fixedSize\" in e ? e.fixedSize : e.getSizeFromValue(t);\n}\nfunction xd(t) {\n  return Object.freeze({\n    ...t,\n    encode: (e) => {\n      const r = new Uint8Array(wd(e, t));\n      return t.write(e, r, 0), r;\n    }\n  });\n}\nfunction bd(t) {\n  return Object.freeze({\n    ...t,\n    decode: (e, r = 0) => t.read(e, r)[0]\n  });\n}\nfunction _n(t) {\n  return \"fixedSize\" in t && typeof t.fixedSize == \"number\";\n}\nfunction _d(t, e) {\n  if (_n(t) !== _n(e))\n    throw new In(hd);\n  if (_n(t) && _n(e) && t.fixedSize !== e.fixedSize)\n    throw new In(dd, {\n      decoderFixedSize: e.fixedSize,\n      encoderFixedSize: t.fixedSize\n    });\n  if (!_n(t) && !_n(e) && t.maxSize !== e.maxSize)\n    throw new In(pd, {\n      decoderMaxSize: e.maxSize,\n      encoderMaxSize: t.maxSize\n    });\n  return {\n    ...e,\n    ...t,\n    decode: e.decode,\n    encode: t.encode,\n    read: e.read,\n    write: t.write\n  };\n}\nfunction Ed(t, e, r = 0) {\n  if (e.length - r <= 0)\n    throw new In(ld, {\n      codecDescription: t\n    });\n}\nfunction Md(t, e, r, n = 0) {\n  const o = r.length - n;\n  if (o < e)\n    throw new In(fd, {\n      bytesLength: o,\n      codecDescription: t,\n      expected: e\n    });\n}\nfunction Cd(t, e, r, n) {\n  if (n < e || n > r)\n    throw new In(md, {\n      codecDescription: t,\n      max: r,\n      min: e,\n      value: n\n    });\n}\nfunction Tc(t) {\n  return (t == null ? void 0 : t.endian) !== 1;\n}\nfunction Sd(t) {\n  return xd({\n    fixedSize: t.size,\n    write(e, r, n) {\n      t.range && Cd(t.name, t.range[0], t.range[1], e);\n      const o = new ArrayBuffer(t.size);\n      return t.set(new DataView(o), e, Tc(t.config)), r.set(new Uint8Array(o), n), n + t.size;\n    }\n  });\n}\nfunction Ad(t) {\n  return bd({\n    fixedSize: t.size,\n    read(e, r = 0) {\n      Ed(t.name, e, r), Md(t.name, t.size, e, r);\n      const n = new DataView(kd(e, r, t.size));\n      return [t.get(n, Tc(t.config)), r + t.size];\n    }\n  });\n}\nfunction kd(t, e, r) {\n  const n = t.byteOffset + (e ?? 0), o = r ?? t.byteLength;\n  return t.buffer.slice(n, n + o);\n}\nvar Id = (t = {}) => Sd({\n  config: t,\n  name: \"u64\",\n  range: [0n, BigInt(\"0xffffffffffffffff\")],\n  set: (e, r, n) => e.setBigUint64(0, BigInt(r), n),\n  size: 8\n}), Bd = (t = {}) => Ad({\n  config: t,\n  get: (e, r) => e.getBigUint64(0, r),\n  name: \"u64\",\n  size: 8\n}), Rd = (t = {}) => _d(Id(t), Bd(t));\nclass Td extends TypeError {\n  constructor(e, r) {\n    let n;\n    const { message: o, explanation: i, ...c } = e, { path: f } = e, v = f.length === 0 ? o : `At path: ${f.join(\".\")} -- ${o}`;\n    super(i ?? v), i != null && (this.cause = v), Object.assign(this, c), this.name = this.constructor.name, this.failures = () => n ?? (n = [e, ...r()]);\n  }\n}\nfunction Ld(t) {\n  return Pi(t) && typeof t[Symbol.iterator] == \"function\";\n}\nfunction Pi(t) {\n  return typeof t == \"object\" && t != null;\n}\nfunction xs(t) {\n  return Pi(t) && !Array.isArray(t);\n}\nfunction Jt(t) {\n  return typeof t == \"symbol\" ? t.toString() : typeof t == \"string\" ? JSON.stringify(t) : `${t}`;\n}\nfunction Od(t) {\n  const { done: e, value: r } = t.next();\n  return e ? void 0 : r;\n}\nfunction Nd(t, e, r, n) {\n  if (t === !0)\n    return;\n  t === !1 ? t = {} : typeof t == \"string\" && (t = { message: t });\n  const { path: o, branch: i } = e, { type: c } = r, { refinement: f, message: v = `Expected a value of type \\`${c}\\`${f ? ` with refinement \\`${f}\\`` : \"\"}, but received: \\`${Jt(n)}\\`` } = t;\n  return {\n    value: n,\n    type: c,\n    refinement: f,\n    key: o[o.length - 1],\n    path: o,\n    branch: i,\n    ...t,\n    message: v\n  };\n}\nfunction* iu(t, e, r, n) {\n  Ld(t) || (t = [t]);\n  for (const o of t) {\n    const i = Nd(o, e, r, n);\n    i && (yield i);\n  }\n}\nfunction* la(t, e, r = {}) {\n  const { path: n = [], branch: o = [t], coerce: i = !1, mask: c = !1 } = r, f = { path: n, branch: o, mask: c };\n  i && (t = e.coercer(t, f));\n  let v = \"valid\";\n  for (const x of e.validator(t, f))\n    x.explanation = r.message, v = \"not_valid\", yield [x, void 0];\n  for (let [x, b, S] of e.entries(t, f)) {\n    const T = la(b, S, {\n      path: x === void 0 ? n : [...n, x],\n      branch: x === void 0 ? o : [...o, b],\n      coerce: i,\n      mask: c,\n      message: r.message\n    });\n    for (const C of T)\n      C[0] ? (v = C[0].refinement != null ? \"not_refined\" : \"not_valid\", yield [C[0], void 0]) : i && (b = C[1], x === void 0 ? t = b : t instanceof Map ? t.set(x, b) : t instanceof Set ? t.add(b) : Pi(t) && (b !== void 0 || x in t) && (t[x] = b));\n  }\n  if (v !== \"not_valid\")\n    for (const x of e.refiner(t, f))\n      x.explanation = r.message, v = \"not_refined\", yield [x, void 0];\n  v === \"valid\" && (yield [void 0, t]);\n}\nlet cr = class {\n  constructor(e) {\n    const { type: r, schema: n, validator: o, refiner: i, coercer: c = (v) => v, entries: f = function* () {\n    } } = e;\n    this.type = r, this.schema = n, this.entries = f, this.coercer = c, o ? this.validator = (v, x) => {\n      const b = o(v, x);\n      return iu(b, x, this, v);\n    } : this.validator = () => [], i ? this.refiner = (v, x) => {\n      const b = i(v, x);\n      return iu(b, x, this, v);\n    } : this.refiner = () => [];\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n  assert(e, r) {\n    return jd(e, this, r);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n  create(e, r) {\n    return xi(e, this, r);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n  is(e) {\n    return Lc(e, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema. Masking applies recursively to\n   * props of `object` structs only.\n   */\n  mask(e, r) {\n    return Ud(e, this, r);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `coerce` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful. Also, `mask` will turn on\n   * masking of the unknown `object` props recursively if passed.\n   */\n  validate(e, r = {}) {\n    return Di(e, this, r);\n  }\n};\nfunction jd(t, e, r) {\n  const n = Di(t, e, { message: r });\n  if (n[0])\n    throw n[0];\n}\nfunction xi(t, e, r) {\n  const n = Di(t, e, { coerce: !0, message: r });\n  if (n[0])\n    throw n[0];\n  return n[1];\n}\nfunction Ud(t, e, r) {\n  const n = Di(t, e, { coerce: !0, mask: !0, message: r });\n  if (n[0])\n    throw n[0];\n  return n[1];\n}\nfunction Lc(t, e) {\n  return !Di(t, e)[0];\n}\nfunction Di(t, e, r = {}) {\n  const n = la(t, e, r), o = Od(n);\n  return o[0] ? [new Td(o[0], function* () {\n    for (const c of n)\n      c[0] && (yield c[0]);\n  }), void 0] : [void 0, o[1]];\n}\nfunction hn(t, e) {\n  return new cr({ type: t, schema: null, validator: e });\n}\nfunction Fd() {\n  return hn(\"any\", () => !0);\n}\nfunction fe(t) {\n  return new cr({\n    type: \"array\",\n    schema: t,\n    *entries(e) {\n      if (t && Array.isArray(e))\n        for (const [r, n] of e.entries())\n          yield [r, n, t];\n    },\n    coercer(e) {\n      return Array.isArray(e) ? e.slice() : e;\n    },\n    validator(e) {\n      return Array.isArray(e) || `Expected an array value, but received: ${Jt(e)}`;\n    }\n  });\n}\nfunction ur() {\n  return hn(\"boolean\", (t) => typeof t == \"boolean\");\n}\nfunction fa(t) {\n  return hn(\"instance\", (e) => e instanceof t || `Expected a \\`${t.name}\\` instance, but received: ${Jt(e)}`);\n}\nfunction dt(t) {\n  const e = Jt(t), r = typeof t;\n  return new cr({\n    type: \"literal\",\n    schema: r === \"string\" || r === \"number\" || r === \"boolean\" ? t : null,\n    validator(n) {\n      return n === t || `Expected the literal \\`${e}\\`, but received: ${Jt(n)}`;\n    }\n  });\n}\nfunction Pd() {\n  return hn(\"never\", () => !1);\n}\nfunction he(t) {\n  return new cr({\n    ...t,\n    validator: (e, r) => e === null || t.validator(e, r),\n    refiner: (e, r) => e === null || t.refiner(e, r)\n  });\n}\nfunction J() {\n  return hn(\"number\", (t) => typeof t == \"number\" && !isNaN(t) || `Expected a number, but received: ${Jt(t)}`);\n}\nfunction Ee(t) {\n  return new cr({\n    ...t,\n    validator: (e, r) => e === void 0 || t.validator(e, r),\n    refiner: (e, r) => e === void 0 || t.refiner(e, r)\n  });\n}\nfunction Oc(t, e) {\n  return new cr({\n    type: \"record\",\n    schema: null,\n    *entries(r) {\n      if (Pi(r))\n        for (const n in r) {\n          const o = r[n];\n          yield [n, n, t], yield [n, o, e];\n        }\n    },\n    validator(r) {\n      return xs(r) || `Expected an object, but received: ${Jt(r)}`;\n    },\n    coercer(r) {\n      return xs(r) ? { ...r } : r;\n    }\n  });\n}\nfunction ie() {\n  return hn(\"string\", (t) => typeof t == \"string\" || `Expected a string, but received: ${Jt(t)}`);\n}\nfunction ha(t) {\n  const e = Pd();\n  return new cr({\n    type: \"tuple\",\n    schema: null,\n    *entries(r) {\n      if (Array.isArray(r)) {\n        const n = Math.max(t.length, r.length);\n        for (let o = 0; o < n; o++)\n          yield [o, r[o], t[o] || e];\n      }\n    },\n    validator(r) {\n      return Array.isArray(r) || `Expected an array, but received: ${Jt(r)}`;\n    },\n    coercer(r) {\n      return Array.isArray(r) ? r.slice() : r;\n    }\n  });\n}\nfunction te(t) {\n  const e = Object.keys(t);\n  return new cr({\n    type: \"type\",\n    schema: t,\n    *entries(r) {\n      if (Pi(r))\n        for (const n of e)\n          yield [n, r[n], t[n]];\n    },\n    validator(r) {\n      return xs(r) || `Expected an object, but received: ${Jt(r)}`;\n    },\n    coercer(r) {\n      return xs(r) ? { ...r } : r;\n    }\n  });\n}\nfunction Ut(t) {\n  const e = t.map((r) => r.type).join(\" | \");\n  return new cr({\n    type: \"union\",\n    schema: null,\n    coercer(r, n) {\n      for (const o of t) {\n        const [i, c] = o.validate(r, {\n          coerce: !0,\n          mask: n.mask\n        });\n        if (!i)\n          return c;\n      }\n      return r;\n    },\n    validator(r, n) {\n      const o = [];\n      for (const i of t) {\n        const [...c] = la(r, i, n), [f] = c;\n        if (f[0])\n          for (const [v] of c)\n            v && o.push(v);\n        else\n          return [];\n      }\n      return [\n        `Expected the value to satisfy a union of \\`${e}\\`, but received: ${Jt(r)}`,\n        ...o\n      ];\n    }\n  });\n}\nfunction zn() {\n  return hn(\"unknown\", () => !0);\n}\nfunction $i(t, e, r) {\n  return new cr({\n    ...t,\n    coercer: (n, o) => Lc(n, e) ? t.coercer(r(n, o), o) : t.coercer(n, o)\n  });\n}\nvar Gi, Dd = new Uint8Array(16);\nfunction Nc() {\n  if (!Gi && (Gi = typeof crypto < \"u\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < \"u\" && typeof msCrypto.getRandomValues == \"function\" && msCrypto.getRandomValues.bind(msCrypto), !Gi))\n    throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return Gi(Dd);\n}\nconst $d = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nfunction Fs(t) {\n  return typeof t == \"string\" && $d.test(t);\n}\nvar Mt = [];\nfor (var ao = 0; ao < 256; ++ao)\n  Mt.push((ao + 256).toString(16).substr(1));\nfunction Ps(t) {\n  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = (Mt[t[e + 0]] + Mt[t[e + 1]] + Mt[t[e + 2]] + Mt[t[e + 3]] + \"-\" + Mt[t[e + 4]] + Mt[t[e + 5]] + \"-\" + Mt[t[e + 6]] + Mt[t[e + 7]] + \"-\" + Mt[t[e + 8]] + Mt[t[e + 9]] + \"-\" + Mt[t[e + 10]] + Mt[t[e + 11]] + Mt[t[e + 12]] + Mt[t[e + 13]] + Mt[t[e + 14]] + Mt[t[e + 15]]).toLowerCase();\n  if (!Fs(r))\n    throw TypeError(\"Stringified UUID is invalid\");\n  return r;\n}\nvar su, uo, co = 0, lo = 0;\nfunction zd(t, e, r) {\n  var n = e && r || 0, o = e || new Array(16);\n  t = t || {};\n  var i = t.node || su, c = t.clockseq !== void 0 ? t.clockseq : uo;\n  if (i == null || c == null) {\n    var f = t.random || (t.rng || Nc)();\n    i == null && (i = su = [f[0] | 1, f[1], f[2], f[3], f[4], f[5]]), c == null && (c = uo = (f[6] << 8 | f[7]) & 16383);\n  }\n  var v = t.msecs !== void 0 ? t.msecs : Date.now(), x = t.nsecs !== void 0 ? t.nsecs : lo + 1, b = v - co + (x - lo) / 1e4;\n  if (b < 0 && t.clockseq === void 0 && (c = c + 1 & 16383), (b < 0 || v > co) && t.nsecs === void 0 && (x = 0), x >= 1e4)\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  co = v, lo = x, uo = c, v += 122192928e5;\n  var S = ((v & 268435455) * 1e4 + x) % 4294967296;\n  o[n++] = S >>> 24 & 255, o[n++] = S >>> 16 & 255, o[n++] = S >>> 8 & 255, o[n++] = S & 255;\n  var T = v / 4294967296 * 1e4 & 268435455;\n  o[n++] = T >>> 8 & 255, o[n++] = T & 255, o[n++] = T >>> 24 & 15 | 16, o[n++] = T >>> 16 & 255, o[n++] = c >>> 8 | 128, o[n++] = c & 255;\n  for (var C = 0; C < 6; ++C)\n    o[n + C] = i[C];\n  return e || Ps(o);\n}\nfunction jc(t) {\n  if (!Fs(t))\n    throw TypeError(\"Invalid UUID\");\n  var e, r = new Uint8Array(16);\n  return r[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, r[1] = e >>> 16 & 255, r[2] = e >>> 8 & 255, r[3] = e & 255, r[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, r[5] = e & 255, r[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, r[7] = e & 255, r[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, r[9] = e & 255, r[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = e / 4294967296 & 255, r[12] = e >>> 24 & 255, r[13] = e >>> 16 & 255, r[14] = e >>> 8 & 255, r[15] = e & 255, r;\n}\nfunction qd(t) {\n  t = unescape(encodeURIComponent(t));\n  for (var e = [], r = 0; r < t.length; ++r)\n    e.push(t.charCodeAt(r));\n  return e;\n}\nvar Zd = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\", Vd = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\nfunction Uc(t, e, r) {\n  function n(o, i, c, f) {\n    if (typeof o == \"string\" && (o = qd(o)), typeof i == \"string\" && (i = jc(i)), i.length !== 16)\n      throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n    var v = new Uint8Array(16 + o.length);\n    if (v.set(i), v.set(o, i.length), v = r(v), v[6] = v[6] & 15 | e, v[8] = v[8] & 63 | 128, c) {\n      f = f || 0;\n      for (var x = 0; x < 16; ++x)\n        c[f + x] = v[x];\n      return c;\n    }\n    return Ps(v);\n  }\n  try {\n    n.name = t;\n  } catch {\n  }\n  return n.DNS = Zd, n.URL = Vd, n;\n}\nfunction Hd(t) {\n  if (typeof t == \"string\") {\n    var e = unescape(encodeURIComponent(t));\n    t = new Uint8Array(e.length);\n    for (var r = 0; r < e.length; ++r)\n      t[r] = e.charCodeAt(r);\n  }\n  return Kd(Wd(Gd(t), t.length * 8));\n}\nfunction Kd(t) {\n  for (var e = [], r = t.length * 32, n = \"0123456789abcdef\", o = 0; o < r; o += 8) {\n    var i = t[o >> 5] >>> o % 32 & 255, c = parseInt(n.charAt(i >>> 4 & 15) + n.charAt(i & 15), 16);\n    e.push(c);\n  }\n  return e;\n}\nfunction Fc(t) {\n  return (t + 64 >>> 9 << 4) + 14 + 1;\n}\nfunction Wd(t, e) {\n  t[e >> 5] |= 128 << e % 32, t[Fc(e) - 1] = e;\n  for (var r = 1732584193, n = -271733879, o = -1732584194, i = 271733878, c = 0; c < t.length; c += 16) {\n    var f = r, v = n, x = o, b = i;\n    r = At(r, n, o, i, t[c], 7, -680876936), i = At(i, r, n, o, t[c + 1], 12, -389564586), o = At(o, i, r, n, t[c + 2], 17, 606105819), n = At(n, o, i, r, t[c + 3], 22, -1044525330), r = At(r, n, o, i, t[c + 4], 7, -176418897), i = At(i, r, n, o, t[c + 5], 12, 1200080426), o = At(o, i, r, n, t[c + 6], 17, -1473231341), n = At(n, o, i, r, t[c + 7], 22, -45705983), r = At(r, n, o, i, t[c + 8], 7, 1770035416), i = At(i, r, n, o, t[c + 9], 12, -1958414417), o = At(o, i, r, n, t[c + 10], 17, -42063), n = At(n, o, i, r, t[c + 11], 22, -1990404162), r = At(r, n, o, i, t[c + 12], 7, 1804603682), i = At(i, r, n, o, t[c + 13], 12, -40341101), o = At(o, i, r, n, t[c + 14], 17, -1502002290), n = At(n, o, i, r, t[c + 15], 22, 1236535329), r = kt(r, n, o, i, t[c + 1], 5, -165796510), i = kt(i, r, n, o, t[c + 6], 9, -1069501632), o = kt(o, i, r, n, t[c + 11], 14, 643717713), n = kt(n, o, i, r, t[c], 20, -373897302), r = kt(r, n, o, i, t[c + 5], 5, -701558691), i = kt(i, r, n, o, t[c + 10], 9, 38016083), o = kt(o, i, r, n, t[c + 15], 14, -660478335), n = kt(n, o, i, r, t[c + 4], 20, -405537848), r = kt(r, n, o, i, t[c + 9], 5, 568446438), i = kt(i, r, n, o, t[c + 14], 9, -1019803690), o = kt(o, i, r, n, t[c + 3], 14, -187363961), n = kt(n, o, i, r, t[c + 8], 20, 1163531501), r = kt(r, n, o, i, t[c + 13], 5, -1444681467), i = kt(i, r, n, o, t[c + 2], 9, -51403784), o = kt(o, i, r, n, t[c + 7], 14, 1735328473), n = kt(n, o, i, r, t[c + 12], 20, -1926607734), r = It(r, n, o, i, t[c + 5], 4, -378558), i = It(i, r, n, o, t[c + 8], 11, -2022574463), o = It(o, i, r, n, t[c + 11], 16, 1839030562), n = It(n, o, i, r, t[c + 14], 23, -35309556), r = It(r, n, o, i, t[c + 1], 4, -1530992060), i = It(i, r, n, o, t[c + 4], 11, 1272893353), o = It(o, i, r, n, t[c + 7], 16, -155497632), n = It(n, o, i, r, t[c + 10], 23, -1094730640), r = It(r, n, o, i, t[c + 13], 4, 681279174), i = It(i, r, n, o, t[c], 11, -358537222), o = It(o, i, r, n, t[c + 3], 16, -722521979), n = It(n, o, i, r, t[c + 6], 23, 76029189), r = It(r, n, o, i, t[c + 9], 4, -640364487), i = It(i, r, n, o, t[c + 12], 11, -421815835), o = It(o, i, r, n, t[c + 15], 16, 530742520), n = It(n, o, i, r, t[c + 2], 23, -995338651), r = Bt(r, n, o, i, t[c], 6, -198630844), i = Bt(i, r, n, o, t[c + 7], 10, 1126891415), o = Bt(o, i, r, n, t[c + 14], 15, -1416354905), n = Bt(n, o, i, r, t[c + 5], 21, -57434055), r = Bt(r, n, o, i, t[c + 12], 6, 1700485571), i = Bt(i, r, n, o, t[c + 3], 10, -1894986606), o = Bt(o, i, r, n, t[c + 10], 15, -1051523), n = Bt(n, o, i, r, t[c + 1], 21, -2054922799), r = Bt(r, n, o, i, t[c + 8], 6, 1873313359), i = Bt(i, r, n, o, t[c + 15], 10, -30611744), o = Bt(o, i, r, n, t[c + 6], 15, -1560198380), n = Bt(n, o, i, r, t[c + 13], 21, 1309151649), r = Bt(r, n, o, i, t[c + 4], 6, -145523070), i = Bt(i, r, n, o, t[c + 11], 10, -1120210379), o = Bt(o, i, r, n, t[c + 2], 15, 718787259), n = Bt(n, o, i, r, t[c + 9], 21, -343485551), r = Ir(r, f), n = Ir(n, v), o = Ir(o, x), i = Ir(i, b);\n  }\n  return [r, n, o, i];\n}\nfunction Gd(t) {\n  if (t.length === 0)\n    return [];\n  for (var e = t.length * 8, r = new Uint32Array(Fc(e)), n = 0; n < e; n += 8)\n    r[n >> 5] |= (t[n / 8] & 255) << n % 32;\n  return r;\n}\nfunction Ir(t, e) {\n  var r = (t & 65535) + (e & 65535), n = (t >> 16) + (e >> 16) + (r >> 16);\n  return n << 16 | r & 65535;\n}\nfunction Yd(t, e) {\n  return t << e | t >>> 32 - e;\n}\nfunction Ds(t, e, r, n, o, i) {\n  return Ir(Yd(Ir(Ir(e, t), Ir(n, i)), o), r);\n}\nfunction At(t, e, r, n, o, i, c) {\n  return Ds(e & r | ~e & n, t, e, o, i, c);\n}\nfunction kt(t, e, r, n, o, i, c) {\n  return Ds(e & n | r & ~n, t, e, o, i, c);\n}\nfunction It(t, e, r, n, o, i, c) {\n  return Ds(e ^ r ^ n, t, e, o, i, c);\n}\nfunction Bt(t, e, r, n, o, i, c) {\n  return Ds(r ^ (e | ~n), t, e, o, i, c);\n}\nvar Jd = Uc(\"v3\", 48, Hd);\nfunction Xd(t, e, r) {\n  t = t || {};\n  var n = t.random || (t.rng || Nc)();\n  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {\n    r = r || 0;\n    for (var o = 0; o < 16; ++o)\n      e[r + o] = n[o];\n    return e;\n  }\n  return Ps(n);\n}\nfunction Qd(t, e, r, n) {\n  switch (t) {\n    case 0:\n      return e & r ^ ~e & n;\n    case 1:\n      return e ^ r ^ n;\n    case 2:\n      return e & r ^ e & n ^ r & n;\n    case 3:\n      return e ^ r ^ n;\n  }\n}\nfunction fo(t, e) {\n  return t << e | t >>> 32 - e;\n}\nfunction e1(t) {\n  var e = [1518500249, 1859775393, 2400959708, 3395469782], r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n  if (typeof t == \"string\") {\n    var n = unescape(encodeURIComponent(t));\n    t = [];\n    for (var o = 0; o < n.length; ++o)\n      t.push(n.charCodeAt(o));\n  } else Array.isArray(t) || (t = Array.prototype.slice.call(t));\n  t.push(128);\n  for (var i = t.length / 4 + 2, c = Math.ceil(i / 16), f = new Array(c), v = 0; v < c; ++v) {\n    for (var x = new Uint32Array(16), b = 0; b < 16; ++b)\n      x[b] = t[v * 64 + b * 4] << 24 | t[v * 64 + b * 4 + 1] << 16 | t[v * 64 + b * 4 + 2] << 8 | t[v * 64 + b * 4 + 3];\n    f[v] = x;\n  }\n  f[c - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), f[c - 1][14] = Math.floor(f[c - 1][14]), f[c - 1][15] = (t.length - 1) * 8 & 4294967295;\n  for (var S = 0; S < c; ++S) {\n    for (var T = new Uint32Array(80), C = 0; C < 16; ++C)\n      T[C] = f[S][C];\n    for (var P = 16; P < 80; ++P)\n      T[P] = fo(T[P - 3] ^ T[P - 8] ^ T[P - 14] ^ T[P - 16], 1);\n    for (var B = r[0], R = r[1], z = r[2], K = r[3], Z = r[4], Q = 0; Q < 80; ++Q) {\n      var j = Math.floor(Q / 20), V = fo(B, 5) + Qd(j, R, z, K) + Z + e[j] + T[Q] >>> 0;\n      Z = K, K = z, z = fo(R, 30) >>> 0, R = B, B = V;\n    }\n    r[0] = r[0] + B >>> 0, r[1] = r[1] + R >>> 0, r[2] = r[2] + z >>> 0, r[3] = r[3] + K >>> 0, r[4] = r[4] + Z >>> 0;\n  }\n  return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, r[0] & 255, r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, r[1] & 255, r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, r[2] & 255, r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, r[3] & 255, r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, r[4] & 255];\n}\nvar t1 = Uc(\"v5\", 80, e1);\nconst r1 = \"00000000-0000-0000-0000-000000000000\";\nfunction n1(t) {\n  if (!Fs(t))\n    throw TypeError(\"Invalid UUID\");\n  return parseInt(t.substr(14, 1), 16);\n}\nconst i1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  NIL: r1,\n  parse: jc,\n  stringify: Ps,\n  v1: zd,\n  v3: Jd,\n  v4: Xd,\n  v5: t1,\n  validate: Fs,\n  version: n1\n}, Symbol.toStringTag, { value: \"Module\" })), Pc = /* @__PURE__ */ ea(i1);\nvar ho, ou;\nfunction s1() {\n  if (ou) return ho;\n  ou = 1;\n  const t = Pc.v4;\n  return ho = function(r, n, o, i) {\n    if (typeof r != \"string\")\n      throw new TypeError(r + \" must be a string\");\n    i = i || {};\n    const c = typeof i.version == \"number\" ? i.version : 2;\n    if (c !== 1 && c !== 2)\n      throw new TypeError(c + \" must be 1 or 2\");\n    const f = {\n      method: r\n    };\n    if (c === 2 && (f.jsonrpc = \"2.0\"), n) {\n      if (typeof n != \"object\" && !Array.isArray(n))\n        throw new TypeError(n + \" must be an object, array or omitted\");\n      f.params = n;\n    }\n    if (typeof o > \"u\") {\n      const v = typeof i.generator == \"function\" ? i.generator : function() {\n        return t();\n      };\n      f.id = v(f, i);\n    } else c === 2 && o === null ? i.notificationIdNull && (f.id = null) : f.id = o;\n    return f;\n  }, ho;\n}\nvar po, au;\nfunction o1() {\n  if (au) return po;\n  au = 1;\n  const t = Pc.v4, e = s1(), r = function(n, o) {\n    if (!(this instanceof r))\n      return new r(n, o);\n    o || (o = {}), this.options = {\n      reviver: typeof o.reviver < \"u\" ? o.reviver : null,\n      replacer: typeof o.replacer < \"u\" ? o.replacer : null,\n      generator: typeof o.generator < \"u\" ? o.generator : function() {\n        return t();\n      },\n      version: typeof o.version < \"u\" ? o.version : 2,\n      notificationIdNull: typeof o.notificationIdNull == \"boolean\" ? o.notificationIdNull : !1\n    }, this.callServer = n;\n  };\n  return po = r, r.prototype.request = function(n, o, i, c) {\n    const f = this;\n    let v = null;\n    const x = Array.isArray(n) && typeof o == \"function\";\n    if (this.options.version === 1 && x)\n      throw new TypeError(\"JSON-RPC 1.0 does not support batching\");\n    if (x || !x && n && typeof n == \"object\" && typeof o == \"function\")\n      c = o, v = n;\n    else {\n      typeof i == \"function\" && (c = i, i = void 0);\n      const T = typeof c == \"function\";\n      try {\n        v = e(n, o, i, {\n          generator: this.options.generator,\n          version: this.options.version,\n          notificationIdNull: this.options.notificationIdNull\n        });\n      } catch (C) {\n        if (T)\n          return c(C);\n        throw C;\n      }\n      if (!T)\n        return v;\n    }\n    let S;\n    try {\n      S = JSON.stringify(v, this.options.replacer);\n    } catch (T) {\n      return c(T);\n    }\n    return this.callServer(S, function(T, C) {\n      f._parseResponse(T, C, c);\n    }), v;\n  }, r.prototype._parseResponse = function(n, o, i) {\n    if (n) {\n      i(n);\n      return;\n    }\n    if (!o)\n      return i();\n    let c;\n    try {\n      c = JSON.parse(o, this.options.reviver);\n    } catch (f) {\n      return i(f);\n    }\n    if (i.length === 3)\n      if (Array.isArray(c)) {\n        const f = function(x) {\n          return typeof x.error < \"u\";\n        }, v = function(x) {\n          return !f(x);\n        };\n        return i(null, c.filter(f), c.filter(v));\n      } else\n        return i(null, c.error, c.result);\n    i(null, c);\n  }, po;\n}\no1();\nvar mo = { exports: {} }, uu;\nfunction a1() {\n  return uu || (uu = 1, function(t) {\n    var e = Object.prototype.hasOwnProperty, r = \"~\";\n    function n() {\n    }\n    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));\n    function o(v, x, b) {\n      this.fn = v, this.context = x, this.once = b || !1;\n    }\n    function i(v, x, b, S, T) {\n      if (typeof b != \"function\")\n        throw new TypeError(\"The listener must be a function\");\n      var C = new o(b, S || v, T), P = r ? r + x : x;\n      return v._events[P] ? v._events[P].fn ? v._events[P] = [v._events[P], C] : v._events[P].push(C) : (v._events[P] = C, v._eventsCount++), v;\n    }\n    function c(v, x) {\n      --v._eventsCount === 0 ? v._events = new n() : delete v._events[x];\n    }\n    function f() {\n      this._events = new n(), this._eventsCount = 0;\n    }\n    f.prototype.eventNames = function() {\n      var x = [], b, S;\n      if (this._eventsCount === 0) return x;\n      for (S in b = this._events)\n        e.call(b, S) && x.push(r ? S.slice(1) : S);\n      return Object.getOwnPropertySymbols ? x.concat(Object.getOwnPropertySymbols(b)) : x;\n    }, f.prototype.listeners = function(x) {\n      var b = r ? r + x : x, S = this._events[b];\n      if (!S) return [];\n      if (S.fn) return [S.fn];\n      for (var T = 0, C = S.length, P = new Array(C); T < C; T++)\n        P[T] = S[T].fn;\n      return P;\n    }, f.prototype.listenerCount = function(x) {\n      var b = r ? r + x : x, S = this._events[b];\n      return S ? S.fn ? 1 : S.length : 0;\n    }, f.prototype.emit = function(x, b, S, T, C, P) {\n      var B = r ? r + x : x;\n      if (!this._events[B]) return !1;\n      var R = this._events[B], z = arguments.length, K, Z;\n      if (R.fn) {\n        switch (R.once && this.removeListener(x, R.fn, void 0, !0), z) {\n          case 1:\n            return R.fn.call(R.context), !0;\n          case 2:\n            return R.fn.call(R.context, b), !0;\n          case 3:\n            return R.fn.call(R.context, b, S), !0;\n          case 4:\n            return R.fn.call(R.context, b, S, T), !0;\n          case 5:\n            return R.fn.call(R.context, b, S, T, C), !0;\n          case 6:\n            return R.fn.call(R.context, b, S, T, C, P), !0;\n        }\n        for (Z = 1, K = new Array(z - 1); Z < z; Z++)\n          K[Z - 1] = arguments[Z];\n        R.fn.apply(R.context, K);\n      } else {\n        var Q = R.length, j;\n        for (Z = 0; Z < Q; Z++)\n          switch (R[Z].once && this.removeListener(x, R[Z].fn, void 0, !0), z) {\n            case 1:\n              R[Z].fn.call(R[Z].context);\n              break;\n            case 2:\n              R[Z].fn.call(R[Z].context, b);\n              break;\n            case 3:\n              R[Z].fn.call(R[Z].context, b, S);\n              break;\n            case 4:\n              R[Z].fn.call(R[Z].context, b, S, T);\n              break;\n            default:\n              if (!K) for (j = 1, K = new Array(z - 1); j < z; j++)\n                K[j - 1] = arguments[j];\n              R[Z].fn.apply(R[Z].context, K);\n          }\n      }\n      return !0;\n    }, f.prototype.on = function(x, b, S) {\n      return i(this, x, b, S, !1);\n    }, f.prototype.once = function(x, b, S) {\n      return i(this, x, b, S, !0);\n    }, f.prototype.removeListener = function(x, b, S, T) {\n      var C = r ? r + x : x;\n      if (!this._events[C]) return this;\n      if (!b)\n        return c(this, C), this;\n      var P = this._events[C];\n      if (P.fn)\n        P.fn === b && (!T || P.once) && (!S || P.context === S) && c(this, C);\n      else {\n        for (var B = 0, R = [], z = P.length; B < z; B++)\n          (P[B].fn !== b || T && !P[B].once || S && P[B].context !== S) && R.push(P[B]);\n        R.length ? this._events[C] = R.length === 1 ? R[0] : R : c(this, C);\n      }\n      return this;\n    }, f.prototype.removeAllListeners = function(x) {\n      var b;\n      return x ? (b = r ? r + x : x, this._events[b] && c(this, b)) : (this._events = new n(), this._eventsCount = 0), this;\n    }, f.prototype.off = f.prototype.removeListener, f.prototype.addListener = f.prototype.on, f.prefixed = r, f.EventEmitter = f, t.exports = f;\n  }(mo)), mo.exports;\n}\nvar u1 = a1();\nconst Dc = /* @__PURE__ */ Qo(u1);\nclass $c extends uc {\n  constructor(e, r) {\n    super(), this.finished = !1, this.destroyed = !1, L0(e);\n    const n = oa(r);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\")\n      throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const o = this.blockLen, i = new Uint8Array(o);\n    i.set(n.length > o ? e.create().update(n).digest() : n);\n    for (let c = 0; c < i.length; c++)\n      i[c] ^= 54;\n    this.iHash.update(i), this.oHash = e.create();\n    for (let c = 0; c < i.length; c++)\n      i[c] ^= 106;\n    this.oHash.update(i), On(i);\n  }\n  update(e) {\n    return ps(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    ps(this), ar(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash: r, iHash: n, finished: o, destroyed: i, blockLen: c, outputLen: f } = this;\n    return e = e, e.finished = o, e.destroyed = i, e.blockLen = c, e.outputLen = f, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;\n  }\n  clone() {\n    return this._cloneInto();\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst zc = (t, e, r) => new $c(t, e).update(r).digest();\nzc.create = (t, e) => new $c(t, e);\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction cu(t) {\n  t.lowS !== void 0 && fn(\"lowS\", t.lowS), t.prehash !== void 0 && fn(\"prehash\", t.prehash);\n}\nclass c1 extends Error {\n  constructor(e = \"\") {\n    super(e);\n  }\n}\nconst mr = {\n  // asn.1 DER encoding utils\n  Err: c1,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (t, e) => {\n      const { Err: r } = mr;\n      if (t < 0 || t > 256)\n        throw new r(\"tlv.encode: wrong tag\");\n      if (e.length & 1)\n        throw new r(\"tlv.encode: unpadded data\");\n      const n = e.length / 2, o = Ki(n);\n      if (o.length / 2 & 128)\n        throw new r(\"tlv.encode: long form length too big\");\n      const i = n > 127 ? Ki(o.length / 2 | 128) : \"\";\n      return Ki(t) + i + o + e;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(t, e) {\n      const { Err: r } = mr;\n      let n = 0;\n      if (t < 0 || t > 256)\n        throw new r(\"tlv.encode: wrong tag\");\n      if (e.length < 2 || e[n++] !== t)\n        throw new r(\"tlv.decode: wrong tlv\");\n      const o = e[n++], i = !!(o & 128);\n      let c = 0;\n      if (!i)\n        c = o;\n      else {\n        const v = o & 127;\n        if (!v)\n          throw new r(\"tlv.decode(long): indefinite length not supported\");\n        if (v > 4)\n          throw new r(\"tlv.decode(long): byte length is too big\");\n        const x = e.subarray(n, n + v);\n        if (x.length !== v)\n          throw new r(\"tlv.decode: length bytes not complete\");\n        if (x[0] === 0)\n          throw new r(\"tlv.decode(long): zero leftmost byte\");\n        for (const b of x)\n          c = c << 8 | b;\n        if (n += v, c < 128)\n          throw new r(\"tlv.decode(long): not minimal encoding\");\n      }\n      const f = e.subarray(n, n + c);\n      if (f.length !== c)\n        throw new r(\"tlv.decode: wrong value length\");\n      return { v: f, l: e.subarray(n + c) };\n    }\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(t) {\n      const { Err: e } = mr;\n      if (t < ii)\n        throw new e(\"integer: negative integers are not allowed\");\n      let r = Ki(t);\n      if (Number.parseInt(r[0], 16) & 8 && (r = \"00\" + r), r.length & 1)\n        throw new e(\"unexpected DER parsing assertion: unpadded hex\");\n      return r;\n    },\n    decode(t) {\n      const { Err: e } = mr;\n      if (t[0] & 128)\n        throw new e(\"invalid signature integer: negative\");\n      if (t[0] === 0 && !(t[1] & 128))\n        throw new e(\"invalid signature integer: unnecessary leading zero\");\n      return Ls(t);\n    }\n  },\n  toSig(t) {\n    const { Err: e, _int: r, _tlv: n } = mr, o = vt(\"signature\", t), { v: i, l: c } = n.decode(48, o);\n    if (c.length)\n      throw new e(\"invalid signature: left bytes after parsing\");\n    const { v: f, l: v } = n.decode(2, i), { v: x, l: b } = n.decode(2, v);\n    if (b.length)\n      throw new e(\"invalid signature: left bytes after parsing\");\n    return { r: r.decode(f), s: r.decode(x) };\n  },\n  hexFromSig(t) {\n    const { _tlv: e, _int: r } = mr, n = e.encode(2, r.encode(t.r)), o = e.encode(2, r.encode(t.s)), i = n + o;\n    return e.encode(48, i);\n  }\n}, ii = BigInt(0), si = BigInt(1), l1 = BigInt(2), Yi = BigInt(3), f1 = BigInt(4);\nfunction h1(t, e, r) {\n  function n(o) {\n    const i = t.sqr(o), c = t.mul(i, o);\n    return t.add(t.add(c, t.mul(o, e)), r);\n  }\n  return n;\n}\nfunction qc(t, e, r) {\n  const { BYTES: n } = t;\n  function o(i) {\n    let c;\n    if (typeof i == \"bigint\")\n      c = i;\n    else {\n      let f = vt(\"private key\", i);\n      if (e) {\n        if (!e.includes(f.length * 2))\n          throw new Error(\"invalid private key\");\n        const v = new Uint8Array(n);\n        v.set(f, v.length - f.length), f = v;\n      }\n      try {\n        c = t.fromBytes(f);\n      } catch {\n        throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof i}`);\n      }\n    }\n    if (r && (c = t.create(c)), !t.isValidNot0(c))\n      throw new Error(\"invalid private key: out of range [1..N-1]\");\n    return c;\n  }\n  return o;\n}\nfunction d1(t, e = {}) {\n  const { Fp: r, Fn: n } = Sc(\"weierstrass\", t, e), { h: o, n: i } = t;\n  Ui(e, {}, {\n    allowInfinityPoint: \"boolean\",\n    clearCofactor: \"function\",\n    isTorsionFree: \"function\",\n    fromBytes: \"function\",\n    toBytes: \"function\",\n    endo: \"object\",\n    wrapPrivateKey: \"boolean\"\n  });\n  const { endo: c } = e;\n  if (c && (!r.is0(t.a) || typeof c.beta != \"bigint\" || typeof c.splitScalar != \"function\"))\n    throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n  function f() {\n    if (!r.isOdd)\n      throw new Error(\"compression is not supported: Field does not have .isOdd()\");\n  }\n  function v(G, N, O) {\n    const { x: L, y: F } = N.toAffine(), d = r.toBytes(L);\n    if (fn(\"isCompressed\", O), O) {\n      f();\n      const s = !r.isOdd(F);\n      return vr(Zc(s), d);\n    } else\n      return vr(Uint8Array.of(4), d, r.toBytes(F));\n  }\n  function x(G) {\n    ar(G);\n    const N = r.BYTES, O = N + 1, L = 2 * N + 1, F = G.length, d = G[0], s = G.subarray(1);\n    if (F === O && (d === 2 || d === 3)) {\n      const u = r.fromBytes(s);\n      if (!r.isValid(u))\n        throw new Error(\"bad point: is not on curve, wrong x\");\n      const h = T(u);\n      let g;\n      try {\n        g = r.sqrt(h);\n      } catch (A) {\n        const p = A instanceof Error ? \": \" + A.message : \"\";\n        throw new Error(\"bad point: is not on curve, sqrt error\" + p);\n      }\n      f();\n      const w = r.isOdd(g);\n      return (d & 1) === 1 !== w && (g = r.neg(g)), { x: u, y: g };\n    } else if (F === L && d === 4) {\n      const u = r.fromBytes(s.subarray(N * 0, N * 1)), h = r.fromBytes(s.subarray(N * 1, N * 2));\n      if (!C(u, h))\n        throw new Error(\"bad point: is not on curve\");\n      return { x: u, y: h };\n    } else\n      throw new Error(`bad point: got length ${F}, expected compressed=${O} or uncompressed=${L}`);\n  }\n  const b = e.toBytes || v, S = e.fromBytes || x, T = h1(r, t.a, t.b);\n  function C(G, N) {\n    const O = r.sqr(N), L = T(G);\n    return r.eql(O, L);\n  }\n  if (!C(t.Gx, t.Gy))\n    throw new Error(\"bad curve params: generator point\");\n  const P = r.mul(r.pow(t.a, Yi), f1), B = r.mul(r.sqr(t.b), BigInt(27));\n  if (r.is0(r.add(P, B)))\n    throw new Error(\"bad curve params: a or b\");\n  function R(G, N, O = !1) {\n    if (!r.isValid(N) || O && r.is0(N))\n      throw new Error(`bad point coordinate ${G}`);\n    return N;\n  }\n  function z(G) {\n    if (!(G instanceof j))\n      throw new Error(\"ProjectivePoint expected\");\n  }\n  const K = ms((G, N) => {\n    const { px: O, py: L, pz: F } = G;\n    if (r.eql(F, r.ONE))\n      return { x: O, y: L };\n    const d = G.is0();\n    N == null && (N = d ? r.ONE : r.inv(F));\n    const s = r.mul(O, N), u = r.mul(L, N), h = r.mul(F, N);\n    if (d)\n      return { x: r.ZERO, y: r.ZERO };\n    if (!r.eql(h, r.ONE))\n      throw new Error(\"invZ was invalid\");\n    return { x: s, y: u };\n  }), Z = ms((G) => {\n    if (G.is0()) {\n      if (e.allowInfinityPoint && !r.is0(G.py))\n        return;\n      throw new Error(\"bad point: ZERO\");\n    }\n    const { x: N, y: O } = G.toAffine();\n    if (!r.isValid(N) || !r.isValid(O))\n      throw new Error(\"bad point: x or y not field elements\");\n    if (!C(N, O))\n      throw new Error(\"bad point: equation left != right\");\n    if (!G.isTorsionFree())\n      throw new Error(\"bad point: not in prime-order subgroup\");\n    return !0;\n  });\n  function Q(G, N, O, L, F) {\n    return O = new j(r.mul(O.px, G), O.py, O.pz), N = ni(L, N), O = ni(F, O), N.add(O);\n  }\n  class j {\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(N, O, L) {\n      this.px = R(\"x\", N), this.py = R(\"y\", O, !0), this.pz = R(\"z\", L), Object.freeze(this);\n    }\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(N) {\n      const { x: O, y: L } = N || {};\n      if (!N || !r.isValid(O) || !r.isValid(L))\n        throw new Error(\"invalid affine point\");\n      if (N instanceof j)\n        throw new Error(\"projective point not allowed\");\n      return r.is0(O) && r.is0(L) ? j.ZERO : new j(O, L, r.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static normalizeZ(N) {\n      return bc(j, \"pz\", N);\n    }\n    static fromBytes(N) {\n      return ar(N), j.fromHex(N);\n    }\n    /** Converts hash string or Uint8Array to Point. */\n    static fromHex(N) {\n      const O = j.fromAffine(S(vt(\"pointHex\", N)));\n      return O.assertValidity(), O;\n    }\n    /** Multiplies generator point by privateKey. */\n    static fromPrivateKey(N) {\n      const O = qc(n, e.allowedPrivateKeyLengths, e.wrapPrivateKey);\n      return j.BASE.multiply(O(N));\n    }\n    /** Multiscalar Multiplication */\n    static msm(N, O) {\n      return Cc(j, n, N, O);\n    }\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(N = 8, O = !0) {\n      return ee.setWindowSize(this, N), O || this.multiply(Yi), this;\n    }\n    /** \"Private method\", don't use it directly */\n    _setWindowSize(N) {\n      this.precompute(N);\n    }\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity() {\n      Z(this);\n    }\n    hasEvenY() {\n      const { y: N } = this.toAffine();\n      if (!r.isOdd)\n        throw new Error(\"Field doesn't support isOdd\");\n      return !r.isOdd(N);\n    }\n    /** Compare one point to another. */\n    equals(N) {\n      z(N);\n      const { px: O, py: L, pz: F } = this, { px: d, py: s, pz: u } = N, h = r.eql(r.mul(O, u), r.mul(d, F)), g = r.eql(r.mul(L, u), r.mul(s, F));\n      return h && g;\n    }\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate() {\n      return new j(this.px, r.neg(this.py), this.pz);\n    }\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a: N, b: O } = t, L = r.mul(O, Yi), { px: F, py: d, pz: s } = this;\n      let u = r.ZERO, h = r.ZERO, g = r.ZERO, w = r.mul(F, F), _ = r.mul(d, d), A = r.mul(s, s), p = r.mul(F, d);\n      return p = r.add(p, p), g = r.mul(F, s), g = r.add(g, g), u = r.mul(N, g), h = r.mul(L, A), h = r.add(u, h), u = r.sub(_, h), h = r.add(_, h), h = r.mul(u, h), u = r.mul(p, u), g = r.mul(L, g), A = r.mul(N, A), p = r.sub(w, A), p = r.mul(N, p), p = r.add(p, g), g = r.add(w, w), w = r.add(g, w), w = r.add(w, A), w = r.mul(w, p), h = r.add(h, w), A = r.mul(d, s), A = r.add(A, A), w = r.mul(A, p), u = r.sub(u, w), g = r.mul(A, _), g = r.add(g, g), g = r.add(g, g), new j(u, h, g);\n    }\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(N) {\n      z(N);\n      const { px: O, py: L, pz: F } = this, { px: d, py: s, pz: u } = N;\n      let h = r.ZERO, g = r.ZERO, w = r.ZERO;\n      const _ = t.a, A = r.mul(t.b, Yi);\n      let p = r.mul(O, d), a = r.mul(L, s), l = r.mul(F, u), M = r.add(O, L), k = r.add(d, s);\n      M = r.mul(M, k), k = r.add(p, a), M = r.sub(M, k), k = r.add(O, F);\n      let $ = r.add(d, u);\n      return k = r.mul(k, $), $ = r.add(p, l), k = r.sub(k, $), $ = r.add(L, F), h = r.add(s, u), $ = r.mul($, h), h = r.add(a, l), $ = r.sub($, h), w = r.mul(_, k), h = r.mul(A, l), w = r.add(h, w), h = r.sub(a, w), w = r.add(a, w), g = r.mul(h, w), a = r.add(p, p), a = r.add(a, p), l = r.mul(_, l), k = r.mul(A, k), a = r.add(a, l), l = r.sub(p, l), l = r.mul(_, l), k = r.add(k, l), p = r.mul(a, k), g = r.add(g, p), p = r.mul($, k), h = r.mul(M, h), h = r.sub(h, p), p = r.mul(M, a), w = r.mul($, w), w = r.add(w, p), new j(h, g, w);\n    }\n    subtract(N) {\n      return this.add(N.negate());\n    }\n    is0() {\n      return this.equals(j.ZERO);\n    }\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(N) {\n      const { endo: O } = e;\n      if (!n.isValidNot0(N))\n        throw new Error(\"invalid scalar: out of range\");\n      let L, F;\n      const d = (s) => ee.wNAFCached(this, s, j.normalizeZ);\n      if (O) {\n        const { k1neg: s, k1: u, k2neg: h, k2: g } = O.splitScalar(N), { p: w, f: _ } = d(u), { p: A, f: p } = d(g);\n        F = _.add(p), L = Q(O.beta, w, A, s, h);\n      } else {\n        const { p: s, f: u } = d(N);\n        L = s, F = u;\n      }\n      return j.normalizeZ([L, F])[0];\n    }\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(N) {\n      const { endo: O } = e, L = this;\n      if (!n.isValid(N))\n        throw new Error(\"invalid scalar: out of range\");\n      if (N === ii || L.is0())\n        return j.ZERO;\n      if (N === si)\n        return L;\n      if (ee.hasPrecomputes(this))\n        return this.multiply(N);\n      if (O) {\n        const { k1neg: F, k1: d, k2neg: s, k2: u } = O.splitScalar(N), { p1: h, p2: g } = gh(j, L, d, u);\n        return Q(O.beta, h, g, F, s);\n      } else\n        return ee.wNAFCachedUnsafe(L, N);\n    }\n    multiplyAndAddUnsafe(N, O, L) {\n      const F = this.multiplyUnsafe(O).add(N.multiplyUnsafe(L));\n      return F.is0() ? void 0 : F;\n    }\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(N) {\n      return K(this, N);\n    }\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree() {\n      const { isTorsionFree: N } = e;\n      return o === si ? !0 : N ? N(j, this) : ee.wNAFCachedUnsafe(this, i).is0();\n    }\n    clearCofactor() {\n      const { clearCofactor: N } = e;\n      return o === si ? this : N ? N(j, this) : this.multiplyUnsafe(o);\n    }\n    toBytes(N = !0) {\n      return fn(\"isCompressed\", N), this.assertValidity(), b(j, this, N);\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes(N = !0) {\n      return this.toBytes(N);\n    }\n    toHex(N = !0) {\n      return Nn(this.toBytes(N));\n    }\n    toString() {\n      return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n    }\n  }\n  j.BASE = new j(t.Gx, t.Gy, r.ONE), j.ZERO = new j(r.ZERO, r.ONE, r.ZERO), j.Fp = r, j.Fn = n;\n  const V = n.BITS, ee = Mc(j, e.endo ? Math.ceil(V / 2) : V);\n  return j;\n}\nfunction Zc(t) {\n  return Uint8Array.of(t ? 2 : 3);\n}\nfunction p1(t, e, r = {}) {\n  Ui(e, { hash: \"function\" }, {\n    hmac: \"function\",\n    lowS: \"boolean\",\n    randomBytes: \"function\",\n    bits2int: \"function\",\n    bits2int_modN: \"function\"\n  });\n  const n = e.randomBytes || lc, o = e.hmac || ((L, ...F) => zc(e.hash, L, vr(...F))), { Fp: i, Fn: c } = t, { ORDER: f, BITS: v } = c;\n  function x(L) {\n    const F = f >> si;\n    return L > F;\n  }\n  function b(L) {\n    return x(L) ? c.neg(L) : L;\n  }\n  function S(L, F) {\n    if (!c.isValidNot0(F))\n      throw new Error(`invalid signature ${L}: out of range 1..CURVE.n`);\n  }\n  class T {\n    constructor(F, d, s) {\n      S(\"r\", F), S(\"s\", d), this.r = F, this.s = d, s != null && (this.recovery = s), Object.freeze(this);\n    }\n    // pair (bytes of r, bytes of s)\n    static fromCompact(F) {\n      const d = c.BYTES, s = vt(\"compactSignature\", F, d * 2);\n      return new T(c.fromBytes(s.subarray(0, d)), c.fromBytes(s.subarray(d, d * 2)));\n    }\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(F) {\n      const { r: d, s } = mr.toSig(vt(\"DER\", F));\n      return new T(d, s);\n    }\n    /**\n     * @todo remove\n     * @deprecated\n     */\n    assertValidity() {\n    }\n    addRecoveryBit(F) {\n      return new T(this.r, this.s, F);\n    }\n    // ProjPointType<bigint>\n    recoverPublicKey(F) {\n      const d = i.ORDER, { r: s, s: u, recovery: h } = this;\n      if (h == null || ![0, 1, 2, 3].includes(h))\n        throw new Error(\"recovery id invalid\");\n      if (f * l1 < d && h > 1)\n        throw new Error(\"recovery id is ambiguous for h>1 curve\");\n      const w = h === 2 || h === 3 ? s + f : s;\n      if (!i.isValid(w))\n        throw new Error(\"recovery id 2 or 3 invalid\");\n      const _ = i.toBytes(w), A = t.fromHex(vr(Zc((h & 1) === 0), _)), p = c.inv(w), a = Z(vt(\"msgHash\", F)), l = c.create(-a * p), M = c.create(u * p), k = t.BASE.multiplyUnsafe(l).add(A.multiplyUnsafe(M));\n      if (k.is0())\n        throw new Error(\"point at infinify\");\n      return k.assertValidity(), k;\n    }\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS() {\n      return x(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new T(this.r, c.neg(this.s), this.recovery) : this;\n    }\n    toBytes(F) {\n      if (F === \"compact\")\n        return vr(c.toBytes(this.r), c.toBytes(this.s));\n      if (F === \"der\")\n        return sa(mr.hexFromSig(this));\n      throw new Error(\"invalid format\");\n    }\n    // DER-encoded\n    toDERRawBytes() {\n      return this.toBytes(\"der\");\n    }\n    toDERHex() {\n      return Nn(this.toBytes(\"der\"));\n    }\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return this.toBytes(\"compact\");\n    }\n    toCompactHex() {\n      return Nn(this.toBytes(\"compact\"));\n    }\n  }\n  const C = qc(c, r.allowedPrivateKeyLengths, r.wrapPrivateKey), P = {\n    isValidPrivateKey(L) {\n      try {\n        return C(L), !0;\n      } catch {\n        return !1;\n      }\n    },\n    normPrivateKeyToScalar: C,\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: () => {\n      const L = f;\n      return dh(n(xc(L)), L);\n    },\n    precompute(L = 8, F = t.BASE) {\n      return F.precompute(L, !1);\n    }\n  };\n  function B(L, F = !0) {\n    return t.fromPrivateKey(L).toBytes(F);\n  }\n  function R(L) {\n    if (typeof L == \"bigint\")\n      return !1;\n    if (L instanceof t)\n      return !0;\n    const d = vt(\"key\", L).length, s = i.BYTES, u = s + 1, h = 2 * s + 1;\n    if (!(r.allowedPrivateKeyLengths || c.BYTES === u))\n      return d === u || d === h;\n  }\n  function z(L, F, d = !0) {\n    if (R(L) === !0)\n      throw new Error(\"first arg must be private key\");\n    if (R(F) === !1)\n      throw new Error(\"second arg must be public key\");\n    return t.fromHex(F).multiply(C(L)).toBytes(d);\n  }\n  const K = e.bits2int || function(L) {\n    if (L.length > 8192)\n      throw new Error(\"input is too large\");\n    const F = Ls(L), d = L.length * 8 - v;\n    return d > 0 ? F >> BigInt(d) : F;\n  }, Z = e.bits2int_modN || function(L) {\n    return c.create(K(L));\n  }, Q = Ns(v);\n  function j(L) {\n    return Sn(\"num < 2^\" + v, L, ii, Q), c.toBytes(L);\n  }\n  function V(L, F, d = ee) {\n    if ([\"recovered\", \"canonical\"].some((M) => M in d))\n      throw new Error(\"sign() legacy options not supported\");\n    const { hash: s } = e;\n    let { lowS: u, prehash: h, extraEntropy: g } = d;\n    u == null && (u = !0), L = vt(\"msgHash\", L), cu(d), h && (L = vt(\"prehashed msgHash\", s(L)));\n    const w = Z(L), _ = C(F), A = [j(_), j(w)];\n    if (g != null && g !== !1) {\n      const M = g === !0 ? n(i.BYTES) : g;\n      A.push(vt(\"extraEntropy\", M));\n    }\n    const p = vr(...A), a = w;\n    function l(M) {\n      const k = K(M);\n      if (!c.isValidNot0(k))\n        return;\n      const $ = c.inv(k), X = t.BASE.multiply(k).toAffine(), re = c.create(X.x);\n      if (re === ii)\n        return;\n      const se = c.create($ * c.create(a + re * _));\n      if (se === ii)\n        return;\n      let ut = (X.x === re ? 0 : 2) | Number(X.y & si), xe = se;\n      return u && x(se) && (xe = b(se), ut ^= 1), new T(re, xe, ut);\n    }\n    return { seed: p, k2sig: l };\n  }\n  const ee = { lowS: e.lowS, prehash: !1 }, G = { lowS: e.lowS, prehash: !1 };\n  function N(L, F, d = ee) {\n    const { seed: s, k2sig: u } = V(L, F, d);\n    return nh(e.hash.outputLen, c.BYTES, o)(s, u);\n  }\n  t.BASE.precompute(8);\n  function O(L, F, d, s = G) {\n    const u = L;\n    F = vt(\"msgHash\", F), d = vt(\"publicKey\", d), cu(s);\n    const { lowS: h, prehash: g, format: w } = s;\n    if (\"strict\" in s)\n      throw new Error(\"options.strict was renamed to lowS\");\n    if (w !== void 0 && ![\"compact\", \"der\", \"js\"].includes(w))\n      throw new Error('format must be \"compact\", \"der\" or \"js\"');\n    const _ = typeof u == \"string\" || ia(u), A = !_ && !w && typeof u == \"object\" && u !== null && typeof u.r == \"bigint\" && typeof u.s == \"bigint\";\n    if (!_ && !A)\n      throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n    let p, a;\n    try {\n      if (A)\n        if (w === void 0 || w === \"js\")\n          p = new T(u.r, u.s);\n        else\n          throw new Error(\"invalid format\");\n      if (_) {\n        try {\n          w !== \"compact\" && (p = T.fromDER(u));\n        } catch (xe) {\n          if (!(xe instanceof mr.Err))\n            throw xe;\n        }\n        !p && w !== \"der\" && (p = T.fromCompact(u));\n      }\n      a = t.fromHex(d);\n    } catch {\n      return !1;\n    }\n    if (!p || h && p.hasHighS())\n      return !1;\n    g && (F = e.hash(F));\n    const { r: l, s: M } = p, k = Z(F), $ = c.inv(M), X = c.create(k * $), re = c.create(l * $), se = t.BASE.multiplyUnsafe(X).add(a.multiplyUnsafe(re));\n    return se.is0() ? !1 : c.create(se.x) === l;\n  }\n  return Object.freeze({\n    getPublicKey: B,\n    getSharedSecret: z,\n    sign: N,\n    verify: O,\n    utils: P,\n    Point: t,\n    Signature: T\n  });\n}\nfunction m1(t) {\n  const e = {\n    a: t.a,\n    b: t.b,\n    p: t.Fp.ORDER,\n    n: t.n,\n    h: t.h,\n    Gx: t.Gx,\n    Gy: t.Gy\n  }, r = t.Fp, n = $n(e.n, t.nBitLength), o = {\n    Fp: r,\n    Fn: n,\n    allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,\n    allowInfinityPoint: t.allowInfinityPoint,\n    endo: t.endo,\n    wrapPrivateKey: t.wrapPrivateKey,\n    isTorsionFree: t.isTorsionFree,\n    clearCofactor: t.clearCofactor,\n    fromBytes: t.fromBytes,\n    toBytes: t.toBytes\n  };\n  return { CURVE: e, curveOpts: o };\n}\nfunction g1(t) {\n  const { CURVE: e, curveOpts: r } = m1(t), n = {\n    hash: t.hash,\n    hmac: t.hmac,\n    randomBytes: t.randomBytes,\n    lowS: t.lowS,\n    bits2int: t.bits2int,\n    bits2int_modN: t.bits2int_modN\n  };\n  return { CURVE: e, curveOpts: r, ecdsaOpts: n };\n}\nfunction y1(t, e) {\n  return Object.assign({}, e, {\n    ProjectivePoint: e.Point,\n    CURVE: t\n  });\n}\nfunction v1(t) {\n  const { CURVE: e, curveOpts: r, ecdsaOpts: n } = g1(t), o = d1(e, r), i = p1(o, n, r);\n  return y1(t, i);\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction w1(t, e) {\n  const r = (n) => v1({ ...t, hash: n });\n  return { ...r(e), create: r };\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst bs = {\n  p: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n  n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n  h: BigInt(1),\n  a: BigInt(0),\n  b: BigInt(7),\n  Gx: BigInt(\"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"),\n  Gy: BigInt(\"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n};\nBigInt(0);\nconst x1 = BigInt(1), Oo = BigInt(2), lu = (t, e) => (t + e / Oo) / e;\nfunction b1(t) {\n  const e = bs.p, r = BigInt(3), n = BigInt(6), o = BigInt(11), i = BigInt(22), c = BigInt(23), f = BigInt(44), v = BigInt(88), x = t * t * t % e, b = x * x * t % e, S = pt(b, r, e) * b % e, T = pt(S, r, e) * b % e, C = pt(T, Oo, e) * x % e, P = pt(C, o, e) * C % e, B = pt(P, i, e) * P % e, R = pt(B, f, e) * B % e, z = pt(R, v, e) * R % e, K = pt(z, f, e) * B % e, Z = pt(K, r, e) * b % e, Q = pt(Z, c, e) * P % e, j = pt(Q, n, e) * x % e, V = pt(j, Oo, e);\n  if (!No.eql(No.sqr(V), t))\n    throw new Error(\"Cannot find square root\");\n  return V;\n}\nconst No = $n(bs.p, void 0, void 0, { sqrt: b1 }), _1 = w1({\n  ...bs,\n  Fp: No,\n  lowS: !0,\n  // Allow only low-S signatures by default in sign() and verify()\n  endo: {\n    // Endomorphism, see above\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    splitScalar: (t) => {\n      const e = bs.n, r = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"), n = -x1 * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"), o = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"), i = r, c = BigInt(\"0x100000000000000000000000000000000\"), f = lu(i * t, e), v = lu(-n * t, e);\n      let x = wt(t - f * r - v * o, e), b = wt(-f * n - v * i, e);\n      const S = x > c, T = b > c;\n      if (S && (x = e - x), T && (b = e - b), x > c || b > c)\n        throw new Error(\"splitScalar: Endomorphism failed, k=\" + t);\n      return { k1neg: S, k1: x, k2neg: T, k2: b };\n    }\n  }\n}, Q0);\nFi.utils.randomPrivateKey;\nFi.getPublicKey;\nfunction fu(t) {\n  try {\n    return Fi.ExtendedPoint.fromHex(t), !0;\n  } catch {\n    return !1;\n  }\n}\nconst Vc = (t, e) => Fi.sign(t, e.slice(0, 32)), E1 = Fi.verify, da = (t) => et.Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? et.Buffer.from(t.buffer, t.byteOffset, t.byteLength) : et.Buffer.from(t);\nclass M1 {\n  constructor(e) {\n    Object.assign(this, e);\n  }\n  encode() {\n    return et.Buffer.from(oo.serialize(is, this));\n  }\n  static decode(e) {\n    return oo.deserialize(is, this, e);\n  }\n  static decodeUnchecked(e) {\n    return oo.deserializeUnchecked(is, this, e);\n  }\n}\nconst is = /* @__PURE__ */ new Map();\nvar Hc;\nconst C1 = 32, Rr = 32;\nfunction S1(t) {\n  return t._bn !== void 0;\n}\nlet hu = 1;\nclass Re extends M1 {\n  /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */\n  constructor(e) {\n    if (super({}), this._bn = void 0, S1(e))\n      this._bn = e._bn;\n    else {\n      if (typeof e == \"string\") {\n        const r = Nt.decode(e);\n        if (r.length != Rr)\n          throw new Error(\"Invalid public key input\");\n        this._bn = new Ka(r);\n      } else\n        this._bn = new Ka(e);\n      if (this._bn.byteLength() > Rr)\n        throw new Error(\"Invalid public key input\");\n    }\n  }\n  /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */\n  static unique() {\n    const e = new Re(hu);\n    return hu += 1, new Re(e.toBuffer());\n  }\n  /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */\n  /**\n   * Checks if two publicKeys are equal\n   */\n  equals(e) {\n    return this._bn.eq(e._bn);\n  }\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toBase58() {\n    return Nt.encode(this.toBytes());\n  }\n  toJSON() {\n    return this.toBase58();\n  }\n  /**\n   * Return the byte array representation of the public key in big endian\n   */\n  toBytes() {\n    const e = this.toBuffer();\n    return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n  }\n  /**\n   * Return the Buffer representation of the public key in big endian\n   */\n  toBuffer() {\n    const e = this._bn.toArrayLike(et.Buffer);\n    if (e.length === Rr)\n      return e;\n    const r = et.Buffer.alloc(32);\n    return e.copy(r, 32 - e.length), r;\n  }\n  get [Symbol.toStringTag]() {\n    return `PublicKey(${this.toString()})`;\n  }\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toString() {\n    return this.toBase58();\n  }\n  /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */\n  /* eslint-disable require-await */\n  static async createWithSeed(e, r, n) {\n    const o = et.Buffer.concat([e.toBuffer(), et.Buffer.from(r), n.toBuffer()]), i = Xa(o);\n    return new Re(i);\n  }\n  /**\n   * Derive a program address from seeds and a program ID.\n   */\n  /* eslint-disable require-await */\n  static createProgramAddressSync(e, r) {\n    let n = et.Buffer.alloc(0);\n    e.forEach(function(i) {\n      if (i.length > C1)\n        throw new TypeError(\"Max seed length exceeded\");\n      n = et.Buffer.concat([n, da(i)]);\n    }), n = et.Buffer.concat([n, r.toBuffer(), et.Buffer.from(\"ProgramDerivedAddress\")]);\n    const o = Xa(n);\n    if (fu(o))\n      throw new Error(\"Invalid seeds, address must fall off the curve\");\n    return new Re(o);\n  }\n  /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */\n  /* eslint-disable require-await */\n  static async createProgramAddress(e, r) {\n    return this.createProgramAddressSync(e, r);\n  }\n  /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */\n  static findProgramAddressSync(e, r) {\n    let n = 255, o;\n    for (; n != 0; ) {\n      try {\n        const i = e.concat(et.Buffer.from([n]));\n        o = this.createProgramAddressSync(i, r);\n      } catch (i) {\n        if (i instanceof TypeError)\n          throw i;\n        n--;\n        continue;\n      }\n      return [o, n];\n    }\n    throw new Error(\"Unable to find a viable program address nonce\");\n  }\n  /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */\n  static async findProgramAddress(e, r) {\n    return this.findProgramAddressSync(e, r);\n  }\n  /**\n   * Check that a pubkey is on the ed25519 curve.\n   */\n  static isOnCurve(e) {\n    const r = new Re(e);\n    return fu(r.toBytes());\n  }\n}\nHc = Re;\nRe.default = new Hc(\"11111111111111111111111111111111\");\nis.set(Re, {\n  kind: \"struct\",\n  fields: [[\"_bn\", \"u256\"]]\n});\nnew Re(\"BPFLoader1111111111111111111111111111111111\");\nconst Bn = 1232, pa = 127, _s = 64;\nclass Es {\n  constructor(e, r) {\n    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e, this.accountKeysFromLookups = r;\n  }\n  keySegments() {\n    const e = [this.staticAccountKeys];\n    return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable), e.push(this.accountKeysFromLookups.readonly)), e;\n  }\n  get(e) {\n    for (const r of this.keySegments()) {\n      if (e < r.length)\n        return r[e];\n      e -= r.length;\n    }\n  }\n  get length() {\n    return this.keySegments().flat().length;\n  }\n  compileInstructions(e) {\n    if (this.length > 256)\n      throw new Error(\"Account index overflow encountered during compilation\");\n    const n = /* @__PURE__ */ new Map();\n    this.keySegments().flat().forEach((i, c) => {\n      n.set(i.toBase58(), c);\n    });\n    const o = (i) => {\n      const c = n.get(i.toBase58());\n      if (c === void 0) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n      return c;\n    };\n    return e.map((i) => ({\n      programIdIndex: o(i.programId),\n      accountKeyIndexes: i.keys.map((c) => o(c.pubkey)),\n      data: i.data\n    }));\n  }\n}\nconst tt = (t = \"publicKey\") => D.blob(32, t), A1 = (t = \"signature\") => D.blob(64, t), An = (t = \"string\") => {\n  const e = D.struct([D.u32(\"length\"), D.u32(\"lengthPadding\"), D.blob(D.offset(D.u32(), -8), \"chars\")], t), r = e.decode.bind(e), n = e.encode.bind(e), o = e;\n  return o.decode = (i, c) => r(i, c).chars.toString(), o.encode = (i, c, f) => {\n    const v = {\n      chars: et.Buffer.from(i, \"utf8\")\n    };\n    return n(v, c, f);\n  }, o.alloc = (i) => D.u32().span + D.u32().span + et.Buffer.from(i, \"utf8\").length, o;\n}, k1 = (t = \"authorized\") => D.struct([tt(\"staker\"), tt(\"withdrawer\")], t), I1 = (t = \"lockup\") => D.struct([D.ns64(\"unixTimestamp\"), D.ns64(\"epoch\"), tt(\"custodian\")], t), B1 = (t = \"voteInit\") => D.struct([tt(\"nodePubkey\"), tt(\"authorizedVoter\"), tt(\"authorizedWithdrawer\"), D.u8(\"commission\")], t), R1 = (t = \"voteAuthorizeWithSeedArgs\") => D.struct([D.u32(\"voteAuthorizationType\"), tt(\"currentAuthorityDerivedKeyOwnerPubkey\"), An(\"currentAuthorityDerivedKeySeed\"), tt(\"newAuthorized\")], t);\nfunction $t(t) {\n  let e = 0, r = 0;\n  for (; ; ) {\n    let n = t.shift();\n    if (e |= (n & 127) << r * 7, r += 1, (n & 128) === 0)\n      break;\n  }\n  return e;\n}\nfunction zt(t, e) {\n  let r = e;\n  for (; ; ) {\n    let n = r & 127;\n    if (r >>= 7, r == 0) {\n      t.push(n);\n      break;\n    } else\n      n |= 128, t.push(n);\n  }\n}\nfunction bt(t, e) {\n  if (!t)\n    throw new Error(e || \"Assertion failed\");\n}\nclass $s {\n  constructor(e, r) {\n    this.payer = void 0, this.keyMetaMap = void 0, this.payer = e, this.keyMetaMap = r;\n  }\n  static compile(e, r) {\n    const n = /* @__PURE__ */ new Map(), o = (c) => {\n      const f = c.toBase58();\n      let v = n.get(f);\n      return v === void 0 && (v = {\n        isSigner: !1,\n        isWritable: !1,\n        isInvoked: !1\n      }, n.set(f, v)), v;\n    }, i = o(r);\n    i.isSigner = !0, i.isWritable = !0;\n    for (const c of e) {\n      o(c.programId).isInvoked = !0;\n      for (const f of c.keys) {\n        const v = o(f.pubkey);\n        v.isSigner || (v.isSigner = f.isSigner), v.isWritable || (v.isWritable = f.isWritable);\n      }\n    }\n    return new $s(r, n);\n  }\n  getMessageComponents() {\n    const e = [...this.keyMetaMap.entries()];\n    bt(e.length <= 256, \"Max static account keys length exceeded\");\n    const r = e.filter(([, v]) => v.isSigner && v.isWritable), n = e.filter(([, v]) => v.isSigner && !v.isWritable), o = e.filter(([, v]) => !v.isSigner && v.isWritable), i = e.filter(([, v]) => !v.isSigner && !v.isWritable), c = {\n      numRequiredSignatures: r.length + n.length,\n      numReadonlySignedAccounts: n.length,\n      numReadonlyUnsignedAccounts: i.length\n    };\n    {\n      bt(r.length > 0, \"Expected at least one writable signer key\");\n      const [v] = r[0];\n      bt(v === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n    }\n    const f = [...r.map(([v]) => new Re(v)), ...n.map(([v]) => new Re(v)), ...o.map(([v]) => new Re(v)), ...i.map(([v]) => new Re(v))];\n    return [c, f];\n  }\n  extractTableLookup(e) {\n    const [r, n] = this.drainKeysFoundInLookupTable(e.state.addresses, (c) => !c.isSigner && !c.isInvoked && c.isWritable), [o, i] = this.drainKeysFoundInLookupTable(e.state.addresses, (c) => !c.isSigner && !c.isInvoked && !c.isWritable);\n    if (!(r.length === 0 && o.length === 0))\n      return [{\n        accountKey: e.key,\n        writableIndexes: r,\n        readonlyIndexes: o\n      }, {\n        writable: n,\n        readonly: i\n      }];\n  }\n  /** @internal */\n  drainKeysFoundInLookupTable(e, r) {\n    const n = new Array(), o = new Array();\n    for (const [i, c] of this.keyMetaMap.entries())\n      if (r(c)) {\n        const f = new Re(i), v = e.findIndex((x) => x.equals(f));\n        v >= 0 && (bt(v < 256, \"Max lookup table index exceeded\"), n.push(v), o.push(f), this.keyMetaMap.delete(i));\n      }\n    return [n, o];\n  }\n}\nconst Kc = \"Reached end of buffer unexpectedly\";\nfunction yr(t) {\n  if (t.length === 0)\n    throw new Error(Kc);\n  return t.shift();\n}\nfunction qt(t, ...e) {\n  const [r] = e;\n  if (e.length === 2 ? r + (e[1] ?? 0) > t.length : r >= t.length)\n    throw new Error(Kc);\n  return t.splice(...e);\n}\nclass Fn {\n  constructor(e) {\n    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = e.header, this.accountKeys = e.accountKeys.map((r) => new Re(r)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach((r) => this.indexToProgramIds.set(r.programIdIndex, this.accountKeys[r.programIdIndex]));\n  }\n  get version() {\n    return \"legacy\";\n  }\n  get staticAccountKeys() {\n    return this.accountKeys;\n  }\n  get compiledInstructions() {\n    return this.instructions.map((e) => ({\n      programIdIndex: e.programIdIndex,\n      accountKeyIndexes: e.accounts,\n      data: Nt.decode(e.data)\n    }));\n  }\n  get addressTableLookups() {\n    return [];\n  }\n  getAccountKeys() {\n    return new Es(this.staticAccountKeys);\n  }\n  static compile(e) {\n    const r = $s.compile(e.instructions, e.payerKey), [n, o] = r.getMessageComponents(), c = new Es(o).compileInstructions(e.instructions).map((f) => ({\n      programIdIndex: f.programIdIndex,\n      accounts: f.accountKeyIndexes,\n      data: Nt.encode(f.data)\n    }));\n    return new Fn({\n      header: n,\n      accountKeys: o,\n      recentBlockhash: e.recentBlockhash,\n      instructions: c\n    });\n  }\n  isAccountSigner(e) {\n    return e < this.header.numRequiredSignatures;\n  }\n  isAccountWritable(e) {\n    const r = this.header.numRequiredSignatures;\n    if (e >= this.header.numRequiredSignatures) {\n      const n = e - r, i = this.accountKeys.length - r - this.header.numReadonlyUnsignedAccounts;\n      return n < i;\n    } else {\n      const n = r - this.header.numReadonlySignedAccounts;\n      return e < n;\n    }\n  }\n  isProgramId(e) {\n    return this.indexToProgramIds.has(e);\n  }\n  programIds() {\n    return [...this.indexToProgramIds.values()];\n  }\n  nonProgramIds() {\n    return this.accountKeys.filter((e, r) => !this.isProgramId(r));\n  }\n  serialize() {\n    const e = this.accountKeys.length;\n    let r = [];\n    zt(r, e);\n    const n = this.instructions.map((S) => {\n      const {\n        accounts: T,\n        programIdIndex: C\n      } = S, P = Array.from(Nt.decode(S.data));\n      let B = [];\n      zt(B, T.length);\n      let R = [];\n      return zt(R, P.length), {\n        programIdIndex: C,\n        keyIndicesCount: et.Buffer.from(B),\n        keyIndices: T,\n        dataLength: et.Buffer.from(R),\n        data: P\n      };\n    });\n    let o = [];\n    zt(o, n.length);\n    let i = et.Buffer.alloc(Bn);\n    et.Buffer.from(o).copy(i);\n    let c = o.length;\n    n.forEach((S) => {\n      const C = D.struct([D.u8(\"programIdIndex\"), D.blob(S.keyIndicesCount.length, \"keyIndicesCount\"), D.seq(D.u8(\"keyIndex\"), S.keyIndices.length, \"keyIndices\"), D.blob(S.dataLength.length, \"dataLength\"), D.seq(D.u8(\"userdatum\"), S.data.length, \"data\")]).encode(S, i, c);\n      c += C;\n    }), i = i.slice(0, c);\n    const f = D.struct([D.blob(1, \"numRequiredSignatures\"), D.blob(1, \"numReadonlySignedAccounts\"), D.blob(1, \"numReadonlyUnsignedAccounts\"), D.blob(r.length, \"keyCount\"), D.seq(tt(\"key\"), e, \"keys\"), tt(\"recentBlockhash\")]), v = {\n      numRequiredSignatures: et.Buffer.from([this.header.numRequiredSignatures]),\n      numReadonlySignedAccounts: et.Buffer.from([this.header.numReadonlySignedAccounts]),\n      numReadonlyUnsignedAccounts: et.Buffer.from([this.header.numReadonlyUnsignedAccounts]),\n      keyCount: et.Buffer.from(r),\n      keys: this.accountKeys.map((S) => da(S.toBytes())),\n      recentBlockhash: Nt.decode(this.recentBlockhash)\n    };\n    let x = et.Buffer.alloc(2048);\n    const b = f.encode(v, x);\n    return i.copy(x, b), x.slice(0, b + i.length);\n  }\n  /**\n   * Decode a compiled message into a Message object.\n   */\n  static from(e) {\n    let r = [...e];\n    const n = yr(r);\n    if (n !== (n & pa))\n      throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n    const o = yr(r), i = yr(r), c = $t(r);\n    let f = [];\n    for (let T = 0; T < c; T++) {\n      const C = qt(r, 0, Rr);\n      f.push(new Re(et.Buffer.from(C)));\n    }\n    const v = qt(r, 0, Rr), x = $t(r);\n    let b = [];\n    for (let T = 0; T < x; T++) {\n      const C = yr(r), P = $t(r), B = qt(r, 0, P), R = $t(r), z = qt(r, 0, R), K = Nt.encode(et.Buffer.from(z));\n      b.push({\n        programIdIndex: C,\n        accounts: B,\n        data: K\n      });\n    }\n    const S = {\n      header: {\n        numRequiredSignatures: n,\n        numReadonlySignedAccounts: o,\n        numReadonlyUnsignedAccounts: i\n      },\n      recentBlockhash: Nt.encode(et.Buffer.from(v)),\n      accountKeys: f,\n      instructions: b\n    };\n    return new Fn(S);\n  }\n}\nclass Ms {\n  constructor(e) {\n    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = e.header, this.staticAccountKeys = e.staticAccountKeys, this.recentBlockhash = e.recentBlockhash, this.compiledInstructions = e.compiledInstructions, this.addressTableLookups = e.addressTableLookups;\n  }\n  get version() {\n    return 0;\n  }\n  get numAccountKeysFromLookups() {\n    let e = 0;\n    for (const r of this.addressTableLookups)\n      e += r.readonlyIndexes.length + r.writableIndexes.length;\n    return e;\n  }\n  getAccountKeys(e) {\n    let r;\n    if (e && \"accountKeysFromLookups\" in e && e.accountKeysFromLookups) {\n      if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length)\n        throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n      r = e.accountKeysFromLookups;\n    } else if (e && \"addressLookupTableAccounts\" in e && e.addressLookupTableAccounts)\n      r = this.resolveAddressTableLookups(e.addressLookupTableAccounts);\n    else if (this.addressTableLookups.length > 0)\n      throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n    return new Es(this.staticAccountKeys, r);\n  }\n  isAccountSigner(e) {\n    return e < this.header.numRequiredSignatures;\n  }\n  isAccountWritable(e) {\n    const r = this.header.numRequiredSignatures, n = this.staticAccountKeys.length;\n    if (e >= n) {\n      const o = e - n, i = this.addressTableLookups.reduce((c, f) => c + f.writableIndexes.length, 0);\n      return o < i;\n    } else if (e >= this.header.numRequiredSignatures) {\n      const o = e - r, c = n - r - this.header.numReadonlyUnsignedAccounts;\n      return o < c;\n    } else {\n      const o = r - this.header.numReadonlySignedAccounts;\n      return e < o;\n    }\n  }\n  resolveAddressTableLookups(e) {\n    const r = {\n      writable: [],\n      readonly: []\n    };\n    for (const n of this.addressTableLookups) {\n      const o = e.find((i) => i.key.equals(n.accountKey));\n      if (!o)\n        throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);\n      for (const i of n.writableIndexes)\n        if (i < o.state.addresses.length)\n          r.writable.push(o.state.addresses[i]);\n        else\n          throw new Error(`Failed to find address for index ${i} in address lookup table ${n.accountKey.toBase58()}`);\n      for (const i of n.readonlyIndexes)\n        if (i < o.state.addresses.length)\n          r.readonly.push(o.state.addresses[i]);\n        else\n          throw new Error(`Failed to find address for index ${i} in address lookup table ${n.accountKey.toBase58()}`);\n    }\n    return r;\n  }\n  static compile(e) {\n    const r = $s.compile(e.instructions, e.payerKey), n = new Array(), o = {\n      writable: new Array(),\n      readonly: new Array()\n    }, i = e.addressLookupTableAccounts || [];\n    for (const b of i) {\n      const S = r.extractTableLookup(b);\n      if (S !== void 0) {\n        const [T, {\n          writable: C,\n          readonly: P\n        }] = S;\n        n.push(T), o.writable.push(...C), o.readonly.push(...P);\n      }\n    }\n    const [c, f] = r.getMessageComponents(), x = new Es(f, o).compileInstructions(e.instructions);\n    return new Ms({\n      header: c,\n      staticAccountKeys: f,\n      recentBlockhash: e.recentBlockhash,\n      compiledInstructions: x,\n      addressTableLookups: n\n    });\n  }\n  serialize() {\n    const e = Array();\n    zt(e, this.staticAccountKeys.length);\n    const r = this.serializeInstructions(), n = Array();\n    zt(n, this.compiledInstructions.length);\n    const o = this.serializeAddressTableLookups(), i = Array();\n    zt(i, this.addressTableLookups.length);\n    const c = D.struct([D.u8(\"prefix\"), D.struct([D.u8(\"numRequiredSignatures\"), D.u8(\"numReadonlySignedAccounts\"), D.u8(\"numReadonlyUnsignedAccounts\")], \"header\"), D.blob(e.length, \"staticAccountKeysLength\"), D.seq(tt(), this.staticAccountKeys.length, \"staticAccountKeys\"), tt(\"recentBlockhash\"), D.blob(n.length, \"instructionsLength\"), D.blob(r.length, \"serializedInstructions\"), D.blob(i.length, \"addressTableLookupsLength\"), D.blob(o.length, \"serializedAddressTableLookups\")]), f = new Uint8Array(Bn), x = c.encode({\n      prefix: 128,\n      header: this.header,\n      staticAccountKeysLength: new Uint8Array(e),\n      staticAccountKeys: this.staticAccountKeys.map((b) => b.toBytes()),\n      recentBlockhash: Nt.decode(this.recentBlockhash),\n      instructionsLength: new Uint8Array(n),\n      serializedInstructions: r,\n      addressTableLookupsLength: new Uint8Array(i),\n      serializedAddressTableLookups: o\n    }, f);\n    return f.slice(0, x);\n  }\n  serializeInstructions() {\n    let e = 0;\n    const r = new Uint8Array(Bn);\n    for (const n of this.compiledInstructions) {\n      const o = Array();\n      zt(o, n.accountKeyIndexes.length);\n      const i = Array();\n      zt(i, n.data.length);\n      const c = D.struct([D.u8(\"programIdIndex\"), D.blob(o.length, \"encodedAccountKeyIndexesLength\"), D.seq(D.u8(), n.accountKeyIndexes.length, \"accountKeyIndexes\"), D.blob(i.length, \"encodedDataLength\"), D.blob(n.data.length, \"data\")]);\n      e += c.encode({\n        programIdIndex: n.programIdIndex,\n        encodedAccountKeyIndexesLength: new Uint8Array(o),\n        accountKeyIndexes: n.accountKeyIndexes,\n        encodedDataLength: new Uint8Array(i),\n        data: n.data\n      }, r, e);\n    }\n    return r.slice(0, e);\n  }\n  serializeAddressTableLookups() {\n    let e = 0;\n    const r = new Uint8Array(Bn);\n    for (const n of this.addressTableLookups) {\n      const o = Array();\n      zt(o, n.writableIndexes.length);\n      const i = Array();\n      zt(i, n.readonlyIndexes.length);\n      const c = D.struct([tt(\"accountKey\"), D.blob(o.length, \"encodedWritableIndexesLength\"), D.seq(D.u8(), n.writableIndexes.length, \"writableIndexes\"), D.blob(i.length, \"encodedReadonlyIndexesLength\"), D.seq(D.u8(), n.readonlyIndexes.length, \"readonlyIndexes\")]);\n      e += c.encode({\n        accountKey: n.accountKey.toBytes(),\n        encodedWritableIndexesLength: new Uint8Array(o),\n        writableIndexes: n.writableIndexes,\n        encodedReadonlyIndexesLength: new Uint8Array(i),\n        readonlyIndexes: n.readonlyIndexes\n      }, r, e);\n    }\n    return r.slice(0, e);\n  }\n  static deserialize(e) {\n    let r = [...e];\n    const n = yr(r), o = n & pa;\n    bt(n !== o, \"Expected versioned message but received legacy message\");\n    const i = o;\n    bt(i === 0, `Expected versioned message with version 0 but found version ${i}`);\n    const c = {\n      numRequiredSignatures: yr(r),\n      numReadonlySignedAccounts: yr(r),\n      numReadonlyUnsignedAccounts: yr(r)\n    }, f = [], v = $t(r);\n    for (let P = 0; P < v; P++)\n      f.push(new Re(qt(r, 0, Rr)));\n    const x = Nt.encode(qt(r, 0, Rr)), b = $t(r), S = [];\n    for (let P = 0; P < b; P++) {\n      const B = yr(r), R = $t(r), z = qt(r, 0, R), K = $t(r), Z = new Uint8Array(qt(r, 0, K));\n      S.push({\n        programIdIndex: B,\n        accountKeyIndexes: z,\n        data: Z\n      });\n    }\n    const T = $t(r), C = [];\n    for (let P = 0; P < T; P++) {\n      const B = new Re(qt(r, 0, Rr)), R = $t(r), z = qt(r, 0, R), K = $t(r), Z = qt(r, 0, K);\n      C.push({\n        accountKey: B,\n        writableIndexes: z,\n        readonlyIndexes: Z\n      });\n    }\n    return new Ms({\n      header: c,\n      staticAccountKeys: f,\n      recentBlockhash: x,\n      compiledInstructions: S,\n      addressTableLookups: C\n    });\n  }\n}\nconst ma = {\n  deserializeMessageVersion(t) {\n    const e = t[0], r = e & pa;\n    return r === e ? \"legacy\" : r;\n  },\n  deserialize: (t) => {\n    const e = ma.deserializeMessageVersion(t);\n    if (e === \"legacy\")\n      return Fn.from(t);\n    if (e === 0)\n      return Ms.deserialize(t);\n    throw new Error(`Transaction message version ${e} deserialization is not supported`);\n  }\n}, T1 = et.Buffer.alloc(_s).fill(0);\nclass du {\n  constructor(e) {\n    this.keys = void 0, this.programId = void 0, this.data = et.Buffer.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data);\n  }\n  /**\n   * @internal\n   */\n  toJSON() {\n    return {\n      keys: this.keys.map(({\n        pubkey: e,\n        isSigner: r,\n        isWritable: n\n      }) => ({\n        pubkey: e.toJSON(),\n        isSigner: r,\n        isWritable: n\n      })),\n      programId: this.programId.toJSON(),\n      data: [...this.data]\n    };\n  }\n}\nclass Cs {\n  /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */\n  get signature() {\n    return this.signatures.length > 0 ? this.signatures[0].signature : null;\n  }\n  /**\n   * The transaction fee payer\n   */\n  // Construct a transaction with a blockhash and lastValidBlockHeight\n  // Construct a transaction using a durable nonce\n  /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(e) {\n    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!e)\n      if (e.feePayer && (this.feePayer = e.feePayer), e.signatures && (this.signatures = e.signatures), Object.prototype.hasOwnProperty.call(e, \"nonceInfo\")) {\n        const {\n          minContextSlot: r,\n          nonceInfo: n\n        } = e;\n        this.minNonceContextSlot = r, this.nonceInfo = n;\n      } else if (Object.prototype.hasOwnProperty.call(e, \"lastValidBlockHeight\")) {\n        const {\n          blockhash: r,\n          lastValidBlockHeight: n\n        } = e;\n        this.recentBlockhash = r, this.lastValidBlockHeight = n;\n      } else {\n        const {\n          recentBlockhash: r,\n          nonceInfo: n\n        } = e;\n        n && (this.nonceInfo = n), this.recentBlockhash = r;\n      }\n  }\n  /**\n   * @internal\n   */\n  toJSON() {\n    return {\n      recentBlockhash: this.recentBlockhash || null,\n      feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n      nonceInfo: this.nonceInfo ? {\n        nonce: this.nonceInfo.nonce,\n        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n      } : null,\n      instructions: this.instructions.map((e) => e.toJSON()),\n      signers: this.signatures.map(({\n        publicKey: e\n      }) => e.toJSON())\n    };\n  }\n  /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */\n  add(...e) {\n    if (e.length === 0)\n      throw new Error(\"No instructions\");\n    return e.forEach((r) => {\n      \"instructions\" in r ? this.instructions = this.instructions.concat(r.instructions) : \"data\" in r && \"programId\" in r && \"keys\" in r ? this.instructions.push(r) : this.instructions.push(new du(r));\n    }), this;\n  }\n  /**\n   * Compile transaction data\n   */\n  compileMessage() {\n    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))\n      return this._message;\n    let e, r;\n    if (this.nonceInfo ? (e = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? r = [this.nonceInfo.nonceInstruction, ...this.instructions] : r = this.instructions) : (e = this.recentBlockhash, r = this.instructions), !e)\n      throw new Error(\"Transaction recentBlockhash required\");\n    r.length < 1 && console.warn(\"No instructions provided\");\n    let n;\n    if (this.feePayer)\n      n = this.feePayer;\n    else if (this.signatures.length > 0 && this.signatures[0].publicKey)\n      n = this.signatures[0].publicKey;\n    else\n      throw new Error(\"Transaction fee payer required\");\n    for (let B = 0; B < r.length; B++)\n      if (r[B].programId === void 0)\n        throw new Error(`Transaction instruction index ${B} has undefined program id`);\n    const o = [], i = [];\n    r.forEach((B) => {\n      B.keys.forEach((z) => {\n        i.push({\n          ...z\n        });\n      });\n      const R = B.programId.toString();\n      o.includes(R) || o.push(R);\n    }), o.forEach((B) => {\n      i.push({\n        pubkey: new Re(B),\n        isSigner: !1,\n        isWritable: !1\n      });\n    });\n    const c = [];\n    i.forEach((B) => {\n      const R = B.pubkey.toString(), z = c.findIndex((K) => K.pubkey.toString() === R);\n      z > -1 ? (c[z].isWritable = c[z].isWritable || B.isWritable, c[z].isSigner = c[z].isSigner || B.isSigner) : c.push(B);\n    }), c.sort(function(B, R) {\n      if (B.isSigner !== R.isSigner)\n        return B.isSigner ? -1 : 1;\n      if (B.isWritable !== R.isWritable)\n        return B.isWritable ? -1 : 1;\n      const z = {\n        localeMatcher: \"best fit\",\n        usage: \"sort\",\n        sensitivity: \"variant\",\n        ignorePunctuation: !1,\n        numeric: !1,\n        caseFirst: \"lower\"\n      };\n      return B.pubkey.toBase58().localeCompare(R.pubkey.toBase58(), \"en\", z);\n    });\n    const f = c.findIndex((B) => B.pubkey.equals(n));\n    if (f > -1) {\n      const [B] = c.splice(f, 1);\n      B.isSigner = !0, B.isWritable = !0, c.unshift(B);\n    } else\n      c.unshift({\n        pubkey: n,\n        isSigner: !0,\n        isWritable: !0\n      });\n    for (const B of this.signatures) {\n      const R = c.findIndex((z) => z.pubkey.equals(B.publicKey));\n      if (R > -1)\n        c[R].isSigner || (c[R].isSigner = !0, console.warn(\"Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.\"));\n      else\n        throw new Error(`unknown signer: ${B.publicKey.toString()}`);\n    }\n    let v = 0, x = 0, b = 0;\n    const S = [], T = [];\n    c.forEach(({\n      pubkey: B,\n      isSigner: R,\n      isWritable: z\n    }) => {\n      R ? (S.push(B.toString()), v += 1, z || (x += 1)) : (T.push(B.toString()), z || (b += 1));\n    });\n    const C = S.concat(T), P = r.map((B) => {\n      const {\n        data: R,\n        programId: z\n      } = B;\n      return {\n        programIdIndex: C.indexOf(z.toString()),\n        accounts: B.keys.map((K) => C.indexOf(K.pubkey.toString())),\n        data: Nt.encode(R)\n      };\n    });\n    return P.forEach((B) => {\n      bt(B.programIdIndex >= 0), B.accounts.forEach((R) => bt(R >= 0));\n    }), new Fn({\n      header: {\n        numRequiredSignatures: v,\n        numReadonlySignedAccounts: x,\n        numReadonlyUnsignedAccounts: b\n      },\n      accountKeys: C,\n      recentBlockhash: e,\n      instructions: P\n    });\n  }\n  /**\n   * @internal\n   */\n  _compile() {\n    const e = this.compileMessage(), r = e.accountKeys.slice(0, e.header.numRequiredSignatures);\n    return this.signatures.length === r.length && this.signatures.every((o, i) => r[i].equals(o.publicKey)) || (this.signatures = r.map((n) => ({\n      signature: null,\n      publicKey: n\n    }))), e;\n  }\n  /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */\n  serializeMessage() {\n    return this._compile().serialize();\n  }\n  /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */\n  async getEstimatedFee(e) {\n    return (await e.getFeeForMessage(this.compileMessage())).value;\n  }\n  /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */\n  setSigners(...e) {\n    if (e.length === 0)\n      throw new Error(\"No signers\");\n    const r = /* @__PURE__ */ new Set();\n    this.signatures = e.filter((n) => {\n      const o = n.toString();\n      return r.has(o) ? !1 : (r.add(o), !0);\n    }).map((n) => ({\n      signature: null,\n      publicKey: n\n    }));\n  }\n  /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  sign(...e) {\n    if (e.length === 0)\n      throw new Error(\"No signers\");\n    const r = /* @__PURE__ */ new Set(), n = [];\n    for (const i of e) {\n      const c = i.publicKey.toString();\n      r.has(c) || (r.add(c), n.push(i));\n    }\n    this.signatures = n.map((i) => ({\n      signature: null,\n      publicKey: i.publicKey\n    }));\n    const o = this._compile();\n    this._partialSign(o, ...n);\n  }\n  /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  partialSign(...e) {\n    if (e.length === 0)\n      throw new Error(\"No signers\");\n    const r = /* @__PURE__ */ new Set(), n = [];\n    for (const i of e) {\n      const c = i.publicKey.toString();\n      r.has(c) || (r.add(c), n.push(i));\n    }\n    const o = this._compile();\n    this._partialSign(o, ...n);\n  }\n  /**\n   * @internal\n   */\n  _partialSign(e, ...r) {\n    const n = e.serialize();\n    r.forEach((o) => {\n      const i = Vc(n, o.secretKey);\n      this._addSignature(o.publicKey, da(i));\n    });\n  }\n  /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */\n  addSignature(e, r) {\n    this._compile(), this._addSignature(e, r);\n  }\n  /**\n   * @internal\n   */\n  _addSignature(e, r) {\n    bt(r.length === 64);\n    const n = this.signatures.findIndex((o) => e.equals(o.publicKey));\n    if (n < 0)\n      throw new Error(`unknown signer: ${e.toString()}`);\n    this.signatures[n].signature = et.Buffer.from(r);\n  }\n  /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */\n  verifySignatures(e = !0) {\n    return !this._getMessageSignednessErrors(this.serializeMessage(), e);\n  }\n  /**\n   * @internal\n   */\n  _getMessageSignednessErrors(e, r) {\n    const n = {};\n    for (const {\n      signature: o,\n      publicKey: i\n    } of this.signatures)\n      o === null ? r && (n.missing || (n.missing = [])).push(i) : E1(o, e, i.toBytes()) || (n.invalid || (n.invalid = [])).push(i);\n    return n.invalid || n.missing ? n : void 0;\n  }\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */\n  serialize(e) {\n    const {\n      requireAllSignatures: r,\n      verifySignatures: n\n    } = Object.assign({\n      requireAllSignatures: !0,\n      verifySignatures: !0\n    }, e), o = this.serializeMessage();\n    if (n) {\n      const i = this._getMessageSignednessErrors(o, r);\n      if (i) {\n        let c = \"Signature verification failed.\";\n        throw i.invalid && (c += `\nInvalid signature for public key${i.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${i.invalid.map((f) => f.toBase58()).join(\"`, `\")}\\`].`), i.missing && (c += `\nMissing signature for public key${i.missing.length === 1 ? \"\" : \"(s)\"} [\\`${i.missing.map((f) => f.toBase58()).join(\"`, `\")}\\`].`), new Error(c);\n      }\n    }\n    return this._serialize(o);\n  }\n  /**\n   * @internal\n   */\n  _serialize(e) {\n    const {\n      signatures: r\n    } = this, n = [];\n    zt(n, r.length);\n    const o = n.length + r.length * 64 + e.length, i = et.Buffer.alloc(o);\n    return bt(r.length < 256), et.Buffer.from(n).copy(i, 0), r.forEach(({\n      signature: c\n    }, f) => {\n      c !== null && (bt(c.length === 64, \"signature has invalid length\"), et.Buffer.from(c).copy(i, n.length + f * 64));\n    }), e.copy(i, n.length + r.length * 64), bt(i.length <= Bn, `Transaction too large: ${i.length} > ${Bn}`), i;\n  }\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get keys() {\n    return bt(this.instructions.length === 1), this.instructions[0].keys.map((e) => e.pubkey);\n  }\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get programId() {\n    return bt(this.instructions.length === 1), this.instructions[0].programId;\n  }\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get data() {\n    return bt(this.instructions.length === 1), this.instructions[0].data;\n  }\n  /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */\n  static from(e) {\n    let r = [...e];\n    const n = $t(r);\n    let o = [];\n    for (let i = 0; i < n; i++) {\n      const c = qt(r, 0, _s);\n      o.push(Nt.encode(et.Buffer.from(c)));\n    }\n    return Cs.populate(Fn.from(r), o);\n  }\n  /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */\n  static populate(e, r = []) {\n    const n = new Cs();\n    return n.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (n.feePayer = e.accountKeys[0]), r.forEach((o, i) => {\n      const c = {\n        signature: o == Nt.encode(T1) ? null : Nt.decode(o),\n        publicKey: e.accountKeys[i]\n      };\n      n.signatures.push(c);\n    }), e.instructions.forEach((o) => {\n      const i = o.accounts.map((c) => {\n        const f = e.accountKeys[c];\n        return {\n          pubkey: f,\n          isSigner: n.signatures.some((v) => v.publicKey.toString() === f.toString()) || e.isAccountSigner(c),\n          isWritable: e.isAccountWritable(c)\n        };\n      });\n      n.instructions.push(new du({\n        keys: i,\n        programId: e.accountKeys[o.programIdIndex],\n        data: Nt.decode(o.data)\n      }));\n    }), n._message = e, n._json = n.toJSON(), n;\n  }\n}\nclass ga {\n  get version() {\n    return this.message.version;\n  }\n  constructor(e, r) {\n    if (this.signatures = void 0, this.message = void 0, r !== void 0)\n      bt(r.length === e.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\"), this.signatures = r;\n    else {\n      const n = [];\n      for (let o = 0; o < e.header.numRequiredSignatures; o++)\n        n.push(new Uint8Array(_s));\n      this.signatures = n;\n    }\n    this.message = e;\n  }\n  serialize() {\n    const e = this.message.serialize(), r = Array();\n    zt(r, this.signatures.length);\n    const n = D.struct([D.blob(r.length, \"encodedSignaturesLength\"), D.seq(A1(), this.signatures.length, \"signatures\"), D.blob(e.length, \"serializedMessage\")]), o = new Uint8Array(2048), i = n.encode({\n      encodedSignaturesLength: new Uint8Array(r),\n      signatures: this.signatures,\n      serializedMessage: e\n    }, o);\n    return o.slice(0, i);\n  }\n  static deserialize(e) {\n    let r = [...e];\n    const n = [], o = $t(r);\n    for (let c = 0; c < o; c++)\n      n.push(new Uint8Array(qt(r, 0, _s)));\n    const i = ma.deserialize(new Uint8Array(r));\n    return new ga(i, n);\n  }\n  sign(e) {\n    const r = this.message.serialize(), n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n    for (const o of e) {\n      const i = n.findIndex((c) => c.equals(o.publicKey));\n      bt(i >= 0, `Cannot sign with non signer key ${o.publicKey.toBase58()}`), this.signatures[i] = Vc(r, o.secretKey);\n    }\n  }\n  addSignature(e, r) {\n    bt(r.byteLength === 64, \"Signature must be 64 bytes long\");\n    const o = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((i) => i.equals(e));\n    bt(o >= 0, `Can not add signature; \\`${e.toBase58()}\\` is not required to sign this transaction`), this.signatures[o] = r;\n  }\n}\nnew Re(\"SysvarC1ock11111111111111111111111111111111\");\nnew Re(\"SysvarEpochSchedu1e111111111111111111111111\");\nnew Re(\"Sysvar1nstructions1111111111111111111111111\");\nnew Re(\"SysvarRecentB1ockHashes11111111111111111111\");\nnew Re(\"SysvarRent111111111111111111111111111111111\");\nnew Re(\"SysvarRewards111111111111111111111111111111\");\nnew Re(\"SysvarS1otHashes111111111111111111111111111\");\nnew Re(\"SysvarS1otHistory11111111111111111111111111\");\nnew Re(\"SysvarStakeHistory1111111111111111111111111\");\nconst L1 = D.nu64(\"lamportsPerSignature\"), O1 = D.struct([D.u32(\"version\"), D.u32(\"state\"), tt(\"authorizedPubkey\"), tt(\"nonce\"), D.struct([L1], \"feeCalculator\")]);\nO1.span;\nfunction Pn(t) {\n  const e = D.blob(8, t), r = e.decode.bind(e), n = e.encode.bind(e), o = e, i = Rd();\n  return o.decode = (c, f) => {\n    const v = r(c, f);\n    return i.decode(v);\n  }, o.encode = (c, f, v) => {\n    const x = i.encode(c);\n    return n(x, f, v);\n  }, o;\n}\nObject.freeze({\n  Create: {\n    index: 0,\n    layout: D.struct([D.u32(\"instruction\"), D.ns64(\"lamports\"), D.ns64(\"space\"), tt(\"programId\")])\n  },\n  Assign: {\n    index: 1,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"programId\")])\n  },\n  Transfer: {\n    index: 2,\n    layout: D.struct([D.u32(\"instruction\"), Pn(\"lamports\")])\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"base\"), An(\"seed\"), D.ns64(\"lamports\"), D.ns64(\"space\"), tt(\"programId\")])\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: D.struct([D.u32(\"instruction\")])\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: D.struct([D.u32(\"instruction\"), D.ns64(\"lamports\")])\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"authorized\")])\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"authorized\")])\n  },\n  Allocate: {\n    index: 8,\n    layout: D.struct([D.u32(\"instruction\"), D.ns64(\"space\")])\n  },\n  AllocateWithSeed: {\n    index: 9,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"base\"), An(\"seed\"), D.ns64(\"space\"), tt(\"programId\")])\n  },\n  AssignWithSeed: {\n    index: 10,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"base\"), An(\"seed\"), tt(\"programId\")])\n  },\n  TransferWithSeed: {\n    index: 11,\n    layout: D.struct([D.u32(\"instruction\"), Pn(\"lamports\"), An(\"seed\"), tt(\"programId\")])\n  },\n  UpgradeNonceAccount: {\n    index: 12,\n    layout: D.struct([D.u32(\"instruction\")])\n  }\n});\nnew Re(\"11111111111111111111111111111111\");\nnew Re(\"BPFLoader2111111111111111111111111111111111\");\nD.struct([\n  D.u32(\"typeIndex\"),\n  Pn(\"deactivationSlot\"),\n  D.nu64(\"lastExtendedSlot\"),\n  D.u8(\"lastExtendedStartIndex\"),\n  D.u8(),\n  // option\n  D.seq(tt(), D.offset(D.u8(), -1), \"authority\")\n]);\nconst gt = $i(fa(Re), ie(), (t) => new Re(t)), Wc = ha([ie(), dt(\"base64\")]), ya = $i(fa(et.Buffer), Wc, (t) => et.Buffer.from(t[0], \"base64\"));\nfunction Gc(t) {\n  return Ut([te({\n    jsonrpc: dt(\"2.0\"),\n    id: ie(),\n    result: t\n  }), te({\n    jsonrpc: dt(\"2.0\"),\n    id: ie(),\n    error: te({\n      code: zn(),\n      message: ie(),\n      data: Ee(Fd())\n    })\n  })]);\n}\nconst N1 = Gc(zn());\nfunction lt(t) {\n  return $i(Gc(t), N1, (e) => \"error\" in e ? e : {\n    ...e,\n    result: xi(e.result, t)\n  });\n}\nfunction Xt(t) {\n  return lt(te({\n    context: te({\n      slot: J()\n    }),\n    value: t\n  }));\n}\nfunction zs(t) {\n  return te({\n    context: te({\n      slot: J()\n    }),\n    value: t\n  });\n}\nconst j1 = te({\n  foundation: J(),\n  foundationTerm: J(),\n  initial: J(),\n  taper: J(),\n  terminal: J()\n});\nlt(fe(he(te({\n  epoch: J(),\n  effectiveSlot: J(),\n  amount: J(),\n  postBalance: J(),\n  commission: Ee(he(J()))\n}))));\nconst U1 = fe(te({\n  slot: J(),\n  prioritizationFee: J()\n})), F1 = te({\n  total: J(),\n  validator: J(),\n  foundation: J(),\n  epoch: J()\n}), P1 = te({\n  epoch: J(),\n  slotIndex: J(),\n  slotsInEpoch: J(),\n  absoluteSlot: J(),\n  blockHeight: Ee(J()),\n  transactionCount: Ee(J())\n}), D1 = te({\n  slotsPerEpoch: J(),\n  leaderScheduleSlotOffset: J(),\n  warmup: ur(),\n  firstNormalEpoch: J(),\n  firstNormalSlot: J()\n}), $1 = Oc(ie(), fe(J())), dn = he(Ut([te({}), ie()])), z1 = te({\n  err: dn\n}), q1 = dt(\"receivedSignature\");\nte({\n  \"solana-core\": ie(),\n  \"feature-set\": Ee(J())\n});\nconst Z1 = te({\n  program: ie(),\n  programId: gt,\n  parsed: zn()\n}), V1 = te({\n  programId: gt,\n  accounts: fe(gt),\n  data: ie()\n});\nXt(te({\n  err: he(Ut([te({}), ie()])),\n  logs: he(fe(ie())),\n  accounts: Ee(he(fe(he(te({\n    executable: ur(),\n    owner: ie(),\n    lamports: J(),\n    data: fe(ie()),\n    rentEpoch: Ee(J())\n  }))))),\n  unitsConsumed: Ee(J()),\n  returnData: Ee(he(te({\n    programId: ie(),\n    data: ha([ie(), dt(\"base64\")])\n  }))),\n  innerInstructions: Ee(he(fe(te({\n    index: J(),\n    instructions: fe(Ut([Z1, V1]))\n  }))))\n}));\nXt(te({\n  byIdentity: Oc(ie(), fe(J())),\n  range: te({\n    firstSlot: J(),\n    lastSlot: J()\n  })\n}));\nlt(j1);\nlt(F1);\nlt(U1);\nlt(P1);\nlt(D1);\nlt($1);\nlt(J());\nXt(te({\n  total: J(),\n  circulating: J(),\n  nonCirculating: J(),\n  nonCirculatingAccounts: fe(gt)\n}));\nconst H1 = te({\n  amount: ie(),\n  uiAmount: he(J()),\n  decimals: J(),\n  uiAmountString: Ee(ie())\n});\nXt(fe(te({\n  address: gt,\n  amount: ie(),\n  uiAmount: he(J()),\n  decimals: J(),\n  uiAmountString: Ee(ie())\n})));\nXt(fe(te({\n  pubkey: gt,\n  account: te({\n    executable: ur(),\n    owner: gt,\n    lamports: J(),\n    data: ya,\n    rentEpoch: J()\n  })\n})));\nconst jo = te({\n  program: ie(),\n  parsed: zn(),\n  space: J()\n});\nXt(fe(te({\n  pubkey: gt,\n  account: te({\n    executable: ur(),\n    owner: gt,\n    lamports: J(),\n    data: jo,\n    rentEpoch: J()\n  })\n})));\nXt(fe(te({\n  lamports: J(),\n  address: gt\n})));\nconst va = te({\n  executable: ur(),\n  owner: gt,\n  lamports: J(),\n  data: ya,\n  rentEpoch: J()\n});\nte({\n  pubkey: gt,\n  account: va\n});\nconst K1 = $i(Ut([fa(et.Buffer), jo]), Ut([Wc, jo]), (t) => Array.isArray(t) ? xi(t, ya) : t), W1 = te({\n  executable: ur(),\n  owner: gt,\n  lamports: J(),\n  data: K1,\n  rentEpoch: J()\n});\nte({\n  pubkey: gt,\n  account: W1\n});\nte({\n  state: Ut([dt(\"active\"), dt(\"inactive\"), dt(\"activating\"), dt(\"deactivating\")]),\n  active: J(),\n  inactive: J()\n});\nlt(fe(te({\n  signature: ie(),\n  slot: J(),\n  err: dn,\n  memo: he(ie()),\n  blockTime: Ee(he(J()))\n})));\nlt(fe(te({\n  signature: ie(),\n  slot: J(),\n  err: dn,\n  memo: he(ie()),\n  blockTime: Ee(he(J()))\n})));\nte({\n  subscription: J(),\n  result: zs(va)\n});\nconst G1 = te({\n  pubkey: gt,\n  account: va\n});\nte({\n  subscription: J(),\n  result: zs(G1)\n});\nconst Y1 = te({\n  parent: J(),\n  slot: J(),\n  root: J()\n});\nte({\n  subscription: J(),\n  result: Y1\n});\nconst J1 = Ut([te({\n  type: Ut([dt(\"firstShredReceived\"), dt(\"completed\"), dt(\"optimisticConfirmation\"), dt(\"root\")]),\n  slot: J(),\n  timestamp: J()\n}), te({\n  type: dt(\"createdBank\"),\n  parent: J(),\n  slot: J(),\n  timestamp: J()\n}), te({\n  type: dt(\"frozen\"),\n  slot: J(),\n  timestamp: J(),\n  stats: te({\n    numTransactionEntries: J(),\n    numSuccessfulTransactions: J(),\n    numFailedTransactions: J(),\n    maxTransactionsPerEntry: J()\n  })\n}), te({\n  type: dt(\"dead\"),\n  slot: J(),\n  timestamp: J(),\n  err: ie()\n})]);\nte({\n  subscription: J(),\n  result: J1\n});\nte({\n  subscription: J(),\n  result: zs(Ut([z1, q1]))\n});\nte({\n  subscription: J(),\n  result: J()\n});\nte({\n  pubkey: ie(),\n  gossip: he(ie()),\n  tpu: he(ie()),\n  rpc: he(ie()),\n  version: he(ie())\n});\nconst pu = te({\n  votePubkey: ie(),\n  nodePubkey: ie(),\n  activatedStake: J(),\n  epochVoteAccount: ur(),\n  epochCredits: fe(ha([J(), J(), J()])),\n  commission: J(),\n  lastVote: J(),\n  rootSlot: he(J())\n});\nlt(te({\n  current: fe(pu),\n  delinquent: fe(pu)\n}));\nconst X1 = Ut([dt(\"processed\"), dt(\"confirmed\"), dt(\"finalized\")]), Q1 = te({\n  slot: J(),\n  confirmations: he(J()),\n  err: dn,\n  confirmationStatus: Ee(X1)\n});\nXt(fe(he(Q1)));\nlt(J());\nconst Yc = te({\n  accountKey: gt,\n  writableIndexes: fe(J()),\n  readonlyIndexes: fe(J())\n}), wa = te({\n  signatures: fe(ie()),\n  message: te({\n    accountKeys: fe(ie()),\n    header: te({\n      numRequiredSignatures: J(),\n      numReadonlySignedAccounts: J(),\n      numReadonlyUnsignedAccounts: J()\n    }),\n    instructions: fe(te({\n      accounts: fe(J()),\n      data: ie(),\n      programIdIndex: J()\n    })),\n    recentBlockhash: ie(),\n    addressTableLookups: Ee(fe(Yc))\n  })\n}), Jc = te({\n  pubkey: gt,\n  signer: ur(),\n  writable: ur(),\n  source: Ee(Ut([dt(\"transaction\"), dt(\"lookupTable\")]))\n}), Xc = te({\n  accountKeys: fe(Jc),\n  signatures: fe(ie())\n}), Qc = te({\n  parsed: zn(),\n  program: ie(),\n  programId: gt\n}), el = te({\n  accounts: fe(gt),\n  data: ie(),\n  programId: gt\n}), ep = Ut([el, Qc]), tp = Ut([te({\n  parsed: zn(),\n  program: ie(),\n  programId: ie()\n}), te({\n  accounts: fe(ie()),\n  data: ie(),\n  programId: ie()\n})]), tl = $i(ep, tp, (t) => \"accounts\" in t ? xi(t, el) : xi(t, Qc)), rl = te({\n  signatures: fe(ie()),\n  message: te({\n    accountKeys: fe(Jc),\n    instructions: fe(tl),\n    recentBlockhash: ie(),\n    addressTableLookups: Ee(he(fe(Yc)))\n  })\n}), Ss = te({\n  accountIndex: J(),\n  mint: ie(),\n  owner: Ee(ie()),\n  programId: Ee(ie()),\n  uiTokenAmount: H1\n}), nl = te({\n  writable: fe(gt),\n  readonly: fe(gt)\n}), qs = te({\n  err: dn,\n  fee: J(),\n  innerInstructions: Ee(he(fe(te({\n    index: J(),\n    instructions: fe(te({\n      accounts: fe(J()),\n      data: ie(),\n      programIdIndex: J()\n    }))\n  })))),\n  preBalances: fe(J()),\n  postBalances: fe(J()),\n  logMessages: Ee(he(fe(ie()))),\n  preTokenBalances: Ee(he(fe(Ss))),\n  postTokenBalances: Ee(he(fe(Ss))),\n  loadedAddresses: Ee(nl),\n  computeUnitsConsumed: Ee(J())\n}), xa = te({\n  err: dn,\n  fee: J(),\n  innerInstructions: Ee(he(fe(te({\n    index: J(),\n    instructions: fe(tl)\n  })))),\n  preBalances: fe(J()),\n  postBalances: fe(J()),\n  logMessages: Ee(he(fe(ie()))),\n  preTokenBalances: Ee(he(fe(Ss))),\n  postTokenBalances: Ee(he(fe(Ss))),\n  loadedAddresses: Ee(nl),\n  computeUnitsConsumed: Ee(J())\n}), qn = Ut([dt(0), dt(\"legacy\")]), pn = te({\n  pubkey: ie(),\n  lamports: J(),\n  postBalance: he(J()),\n  rewardType: he(ie()),\n  commission: Ee(he(J()))\n});\nlt(he(te({\n  blockhash: ie(),\n  previousBlockhash: ie(),\n  parentSlot: J(),\n  transactions: fe(te({\n    transaction: wa,\n    meta: he(qs),\n    version: Ee(qn)\n  })),\n  rewards: Ee(fe(pn)),\n  blockTime: he(J()),\n  blockHeight: he(J())\n})));\nlt(he(te({\n  blockhash: ie(),\n  previousBlockhash: ie(),\n  parentSlot: J(),\n  rewards: Ee(fe(pn)),\n  blockTime: he(J()),\n  blockHeight: he(J())\n})));\nlt(he(te({\n  blockhash: ie(),\n  previousBlockhash: ie(),\n  parentSlot: J(),\n  transactions: fe(te({\n    transaction: Xc,\n    meta: he(qs),\n    version: Ee(qn)\n  })),\n  rewards: Ee(fe(pn)),\n  blockTime: he(J()),\n  blockHeight: he(J())\n})));\nlt(he(te({\n  blockhash: ie(),\n  previousBlockhash: ie(),\n  parentSlot: J(),\n  transactions: fe(te({\n    transaction: rl,\n    meta: he(xa),\n    version: Ee(qn)\n  })),\n  rewards: Ee(fe(pn)),\n  blockTime: he(J()),\n  blockHeight: he(J())\n})));\nlt(he(te({\n  blockhash: ie(),\n  previousBlockhash: ie(),\n  parentSlot: J(),\n  transactions: fe(te({\n    transaction: Xc,\n    meta: he(xa),\n    version: Ee(qn)\n  })),\n  rewards: Ee(fe(pn)),\n  blockTime: he(J()),\n  blockHeight: he(J())\n})));\nlt(he(te({\n  blockhash: ie(),\n  previousBlockhash: ie(),\n  parentSlot: J(),\n  rewards: Ee(fe(pn)),\n  blockTime: he(J()),\n  blockHeight: he(J())\n})));\nlt(he(te({\n  blockhash: ie(),\n  previousBlockhash: ie(),\n  parentSlot: J(),\n  transactions: fe(te({\n    transaction: wa,\n    meta: he(qs)\n  })),\n  rewards: Ee(fe(pn)),\n  blockTime: he(J())\n})));\nlt(he(te({\n  blockhash: ie(),\n  previousBlockhash: ie(),\n  parentSlot: J(),\n  signatures: fe(ie()),\n  blockTime: he(J())\n})));\nlt(he(te({\n  slot: J(),\n  meta: he(qs),\n  blockTime: Ee(he(J())),\n  transaction: wa,\n  version: Ee(qn)\n})));\nlt(he(te({\n  slot: J(),\n  transaction: rl,\n  meta: he(xa),\n  blockTime: Ee(he(J())),\n  version: Ee(qn)\n})));\nXt(te({\n  blockhash: ie(),\n  lastValidBlockHeight: J()\n}));\nXt(ur());\nconst rp = te({\n  slot: J(),\n  numTransactions: J(),\n  numSlots: J(),\n  samplePeriodSecs: J()\n});\nlt(fe(rp));\nXt(he(te({\n  feeCalculator: te({\n    lamportsPerSignature: J()\n  })\n})));\nlt(ie());\nlt(ie());\nconst np = te({\n  err: dn,\n  logs: fe(ie()),\n  signature: ie()\n});\nte({\n  result: zs(np),\n  subscription: J()\n});\nObject.freeze({\n  CreateLookupTable: {\n    index: 0,\n    layout: D.struct([D.u32(\"instruction\"), Pn(\"recentSlot\"), D.u8(\"bumpSeed\")])\n  },\n  FreezeLookupTable: {\n    index: 1,\n    layout: D.struct([D.u32(\"instruction\")])\n  },\n  ExtendLookupTable: {\n    index: 2,\n    layout: D.struct([D.u32(\"instruction\"), Pn(), D.seq(tt(), D.offset(D.u32(), -8), \"addresses\")])\n  },\n  DeactivateLookupTable: {\n    index: 3,\n    layout: D.struct([D.u32(\"instruction\")])\n  },\n  CloseLookupTable: {\n    index: 4,\n    layout: D.struct([D.u32(\"instruction\")])\n  }\n});\nnew Re(\"AddressLookupTab1e1111111111111111111111111\");\nObject.freeze({\n  RequestUnits: {\n    index: 0,\n    layout: D.struct([D.u8(\"instruction\"), D.u32(\"units\"), D.u32(\"additionalFee\")])\n  },\n  RequestHeapFrame: {\n    index: 1,\n    layout: D.struct([D.u8(\"instruction\"), D.u32(\"bytes\")])\n  },\n  SetComputeUnitLimit: {\n    index: 2,\n    layout: D.struct([D.u8(\"instruction\"), D.u32(\"units\")])\n  },\n  SetComputeUnitPrice: {\n    index: 3,\n    layout: D.struct([D.u8(\"instruction\"), Pn(\"microLamports\")])\n  }\n});\nnew Re(\"ComputeBudget111111111111111111111111111111\");\nD.struct([D.u8(\"numSignatures\"), D.u8(\"padding\"), D.u16(\"signatureOffset\"), D.u16(\"signatureInstructionIndex\"), D.u16(\"publicKeyOffset\"), D.u16(\"publicKeyInstructionIndex\"), D.u16(\"messageDataOffset\"), D.u16(\"messageDataSize\"), D.u16(\"messageInstructionIndex\")]);\nnew Re(\"Ed25519SigVerify111111111111111111111111111\");\n_1.utils.isValidPrivateKey;\nD.struct([D.u8(\"numSignatures\"), D.u16(\"signatureOffset\"), D.u8(\"signatureInstructionIndex\"), D.u16(\"ethAddressOffset\"), D.u8(\"ethAddressInstructionIndex\"), D.u16(\"messageDataOffset\"), D.u16(\"messageDataSize\"), D.u8(\"messageInstructionIndex\"), D.blob(20, \"ethAddress\"), D.blob(64, \"signature\"), D.u8(\"recoveryId\")]);\nnew Re(\"KeccakSecp256k11111111111111111111111111111\");\nvar il;\nnew Re(\"StakeConfig11111111111111111111111111111111\");\nclass sl {\n  /**\n   * Create a new Lockup object\n   */\n  constructor(e, r, n) {\n    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = r, this.custodian = n;\n  }\n  /**\n   * Default, inactive Lockup value\n   */\n}\nil = sl;\nsl.default = new il(0, 0, Re.default);\nObject.freeze({\n  Initialize: {\n    index: 0,\n    layout: D.struct([D.u32(\"instruction\"), k1(), I1()])\n  },\n  Authorize: {\n    index: 1,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"newAuthorized\"), D.u32(\"stakeAuthorizationType\")])\n  },\n  Delegate: {\n    index: 2,\n    layout: D.struct([D.u32(\"instruction\")])\n  },\n  Split: {\n    index: 3,\n    layout: D.struct([D.u32(\"instruction\"), D.ns64(\"lamports\")])\n  },\n  Withdraw: {\n    index: 4,\n    layout: D.struct([D.u32(\"instruction\"), D.ns64(\"lamports\")])\n  },\n  Deactivate: {\n    index: 5,\n    layout: D.struct([D.u32(\"instruction\")])\n  },\n  Merge: {\n    index: 7,\n    layout: D.struct([D.u32(\"instruction\")])\n  },\n  AuthorizeWithSeed: {\n    index: 8,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"newAuthorized\"), D.u32(\"stakeAuthorizationType\"), An(\"authoritySeed\"), tt(\"authorityOwner\")])\n  }\n});\nnew Re(\"Stake11111111111111111111111111111111111111\");\nObject.freeze({\n  InitializeAccount: {\n    index: 0,\n    layout: D.struct([D.u32(\"instruction\"), B1()])\n  },\n  Authorize: {\n    index: 1,\n    layout: D.struct([D.u32(\"instruction\"), tt(\"newAuthorized\"), D.u32(\"voteAuthorizationType\")])\n  },\n  Withdraw: {\n    index: 3,\n    layout: D.struct([D.u32(\"instruction\"), D.ns64(\"lamports\")])\n  },\n  UpdateValidatorIdentity: {\n    index: 4,\n    layout: D.struct([D.u32(\"instruction\")])\n  },\n  AuthorizeWithSeed: {\n    index: 10,\n    layout: D.struct([D.u32(\"instruction\"), R1()])\n  }\n});\nnew Re(\"Vote111111111111111111111111111111111111111\");\nnew Re(\"Va1idator1nfo111111111111111111111111111111\");\nte({\n  name: ie(),\n  website: Ee(ie()),\n  details: Ee(ie()),\n  iconUrl: Ee(ie()),\n  keybaseUsername: Ee(ie())\n});\nnew Re(\"Vote111111111111111111111111111111111111111\");\nD.struct([\n  tt(\"nodePubkey\"),\n  tt(\"authorizedWithdrawer\"),\n  D.u8(\"commission\"),\n  D.nu64(),\n  // votes.length\n  D.seq(D.struct([D.nu64(\"slot\"), D.u32(\"confirmationCount\")]), D.offset(D.u32(), -8), \"votes\"),\n  D.u8(\"rootSlotValid\"),\n  D.nu64(\"rootSlot\"),\n  D.nu64(),\n  // authorizedVoters.length\n  D.seq(D.struct([D.nu64(\"epoch\"), tt(\"authorizedVoter\")]), D.offset(D.u32(), -8), \"authorizedVoters\"),\n  D.struct([D.seq(D.struct([tt(\"authorizedPubkey\"), D.nu64(\"epochOfLastAuthorizedSwitch\"), D.nu64(\"targetEpoch\")]), 32, \"buf\"), D.nu64(\"idx\"), D.u8(\"isEmpty\")], \"priorVoters\"),\n  D.nu64(),\n  // epochCredits.length\n  D.seq(D.struct([D.nu64(\"epoch\"), D.nu64(\"credits\"), D.nu64(\"prevCredits\")]), D.offset(D.u32(), -8), \"epochCredits\"),\n  D.struct([D.nu64(\"slot\"), D.nu64(\"timestamp\")], \"lastTimestamp\")\n]);\nconst ip = (t) => ({\n  request: t,\n  signMessage: (e) => t({ method: \"signMessage\", params: { message: e } }),\n  signTransaction: (e) => t({ method: \"signTransaction\", params: { transaction: e } }),\n  signAndSendTransaction: (e) => t({\n    method: \"signAndSendTransaction\",\n    params: e\n  })\n});\nfunction mu(t) {\n  return Buffer.from(t.serialize({\n    verifySignatures: !1\n  })).toString(\"base64\");\n}\nfunction sp(t) {\n  const e = Buffer.from(t, \"base64\");\n  return ma.deserializeMessageVersion(e) === \"legacy\" ? ga.deserialize(e) : Cs.from(e);\n}\nfunction op(t) {\n  return async (r) => {\n    if (r.method === \"connect\")\n      return await t(r);\n    if (r.method === \"signMessage\")\n      return await t(r);\n    if (r.method === \"signAndSendTransaction\") {\n      const { transaction: n, options: o } = r.params, i = {\n        transaction: mu(n)\n      };\n      return await t({\n        method: \"signAndSendTransaction\",\n        params: i\n      });\n    }\n    if (r.method === \"signTransaction\") {\n      const { transaction: n } = r.params, o = {\n        transaction: mu(n)\n      }, { signedTransaction: i } = await t({\n        method: \"signTransaction\",\n        params: o\n      });\n      return { signedTransaction: sp(i) };\n    }\n  };\n}\nlet ol = class al extends Error {\n  constructor(e, r = {}) {\n    const n = (() => {\n      var i;\n      if (r.cause instanceof al) {\n        if (r.cause.details)\n          return r.cause.details;\n        if (r.cause.shortMessage)\n          return r.cause.shortMessage;\n      }\n      return r.cause && \"details\" in r.cause && typeof r.cause.details == \"string\" ? r.cause.details : (i = r.cause) != null && i.message ? r.cause.message : r.details;\n    })(), o = [\n      e || \"An error occurred.\",\n      ...r.metaMessages ? [\"\", ...r.metaMessages] : [],\n      ...n ? [\n        \"\",\n        n ? `Details: ${n}` : void 0\n      ] : []\n    ].filter((i) => typeof i == \"string\").join(`\n`);\n    super(o, r.cause ? { cause: r.cause } : void 0), this.name = \"BaseError\", this.cause = r.cause, this.details = n, this.shortMessage = e;\n  }\n};\nclass ul extends ol {\n  constructor({ status: e }) {\n    super(`Request failed with status ${e}`), this.name = \"RequestFailedError\";\n  }\n}\nclass ap extends ol {\n  constructor(e) {\n    super(e), this.name = \"InvalidToken\";\n  }\n}\nasync function up({ origin: t }) {\n  const e = await fetch(`${t}/nonce`, {\n    method: \"POST\"\n  });\n  if (!e.ok)\n    throw new ul({ status: e.status });\n  return await e.json();\n}\nasync function cp({ origin: t }, e) {\n  const r = await fetch(`${t}/verify-siwf`, {\n    method: \"POST\",\n    headers: new Headers({ \"Content-Type\": \"application/json\" }),\n    body: JSON.stringify(e)\n  });\n  if (!r.ok)\n    throw new ul({ status: r.status });\n  const n = await r.json();\n  if (n.valid === !1)\n    throw new ap(n.message ?? \"unknown\");\n  return { token: n.token };\n}\nfunction lp(t = {}) {\n  return {\n    origin: t.origin ?? \"https://auth.farcaster.xyz\"\n  };\n}\nfunction fp(t = {}) {\n  const e = lp(t);\n  return {\n    generateNonce: () => up(e),\n    verifySiwf: (r) => cp(e, r)\n  };\n}\nconst hp = \"0.1.1\";\nfunction dp() {\n  return hp;\n}\nlet pp = class Uo extends Error {\n  constructor(e, r = {}) {\n    const n = (() => {\n      var v;\n      if (r.cause instanceof Uo) {\n        if (r.cause.details)\n          return r.cause.details;\n        if (r.cause.shortMessage)\n          return r.cause.shortMessage;\n      }\n      return (v = r.cause) != null && v.message ? r.cause.message : r.details;\n    })(), o = r.cause instanceof Uo && r.cause.docsPath || r.docsPath, c = `https://oxlib.sh${o ?? \"\"}`, f = [\n      e || \"An error occurred.\",\n      ...r.metaMessages ? [\"\", ...r.metaMessages] : [],\n      ...n || o ? [\n        \"\",\n        n ? `Details: ${n}` : void 0,\n        o ? `See: ${c}` : void 0\n      ] : []\n    ].filter((v) => typeof v == \"string\").join(`\n`);\n    super(f, r.cause ? { cause: r.cause } : void 0), Object.defineProperty(this, \"details\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"docs\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"docsPath\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"shortMessage\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"cause\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"BaseError\"\n    }), Object.defineProperty(this, \"version\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: `ox@${dp()}`\n    }), this.cause = r.cause, this.details = n, this.docs = c, this.docsPath = o, this.shortMessage = e;\n  }\n  walk(e) {\n    return cl(this, e);\n  }\n};\nfunction cl(t, e) {\n  return e != null && e(t) ? t : t && typeof t == \"object\" && \"cause\" in t && t.cause ? cl(t.cause, e) : e ? null : t;\n}\nconst mp = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?<address>0x[a-fA-F0-9]{40})\\n\\n(?:(?<statement>.*)\\n\\n)?/, gp = /(?:URI: (?<uri>.+))\\n(?:Version: (?<version>.+))\\n(?:Chain ID: (?<chainId>\\d+))\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\n(?:Issued At: (?<issuedAt>.+))(?:\\nExpiration Time: (?<expirationTime>.+))?(?:\\nNot Before: (?<notBefore>.+))?(?:\\nRequest ID: (?<requestId>.+))?/;\nfunction yp(t) {\n  var S, T, C;\n  const { scheme: e, statement: r, ...n } = ((S = t.match(mp)) == null ? void 0 : S.groups) ?? {}, { chainId: o, expirationTime: i, issuedAt: c, notBefore: f, requestId: v, ...x } = ((T = t.match(gp)) == null ? void 0 : T.groups) ?? {}, b = (C = t.split(\"Resources:\")[1]) == null ? void 0 : C.split(`\n- `).slice(1);\n  return {\n    ...n,\n    ...x,\n    ...o ? { chainId: Number(o) } : {},\n    ...i ? { expirationTime: new Date(i) } : {},\n    ...c ? { issuedAt: new Date(c) } : {},\n    ...f ? { notBefore: new Date(f) } : {},\n    ...v ? { requestId: v } : {},\n    ...b ? { resources: b } : {},\n    ...e ? { scheme: e } : {},\n    ...r ? { statement: r } : {}\n  };\n}\nconst vp = ({ frameHost: t, emitter: e }) => {\n  let r, n = null;\n  return {\n    visible: !1,\n    get onback() {\n      return n;\n    },\n    set onback(o) {\n      n && e.removeListener(\"backNavigationTriggered\", n), n = o, o && e.addListener(\"backNavigationTriggered\", o);\n    },\n    async show() {\n      await t.updateBackState({\n        visible: !0\n      }), this.visible = !0;\n    },\n    async hide() {\n      await t.updateBackState({\n        visible: !1\n      }), this.visible = !1;\n    },\n    async enableWebNavigation() {\n      r = wp({\n        back: this,\n        emitter: e\n      });\n    },\n    async disableWebNavigation() {\n      r == null || r(), r = void 0;\n    }\n  };\n};\nfunction wp({ emitter: t, back: e }) {\n  const r = xp();\n  if (r)\n    return bp({ emitter: t, back: e, navigation: r });\n  if (typeof window < \"u\")\n    return _p({ emitter: t, back: e, window });\n}\nfunction xp() {\n  if (typeof window < \"u\" && window.navigation !== void 0)\n    return window.navigation;\n}\nfunction bp({ emitter: t, back: e, navigation: r }) {\n  function n() {\n    r.canGoBack ? e.show() : e.hide();\n  }\n  function o() {\n    e.visible && r.canGoBack && r.back();\n  }\n  return r.addEventListener(\"navigatesuccess\", n), t.addListener(\"backNavigationTriggered\", o), () => {\n    r.removeEventListener(\"navigatesuccess\", n), t.removeListener(\"backNavigationTriggered\", o);\n  };\n}\nfunction _p({ emitter: t, back: e, window: r }) {\n  e.show();\n  function n() {\n    e.visible && r.history.back();\n  }\n  return t.addListener(\"backNavigationTriggered\", n), () => {\n    t.removeListener(\"backNavigationTriggered\", n);\n  };\n}\nfunction ll(t, e = {}) {\n  const { raw: r = !1 } = e, n = t;\n  if (r)\n    return t;\n  if (n.error) {\n    const { code: o } = n.error, i = o === Dn.code ? Dn : o === bi.code ? bi : o === Bi.code ? Bi : o === ki.code ? ki : o === Si.code ? Si : o === Ii.code ? Ii : o === Ci.code ? Ci : o === Ri.code ? Ri : o === _i.code ? _i : o === Ei.code ? Ei : o === Mi.code ? Mi : o === Ai.code ? Ai : Pt;\n    throw new i(n.error);\n  }\n  return n.result;\n}\nclass Pt extends Error {\n  constructor(e) {\n    const { code: r, message: n, data: o } = e;\n    super(n), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.BaseError\"\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"data\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), this.code = r, this.data = o;\n  }\n}\nclass bi extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Missing or invalid parameters.\",\n      ...e,\n      code: bi.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32e3\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.InvalidInputError\"\n    });\n  }\n}\nObject.defineProperty(bi, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32e3\n});\nclass _i extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Requested resource not found.\",\n      ...e,\n      code: _i.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32001\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.ResourceNotFoundError\"\n    });\n  }\n}\nObject.defineProperty(_i, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32001\n});\nclass Ei extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Requested resource not available.\",\n      ...e,\n      code: Ei.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32002\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.ResourceUnavailableError\"\n    });\n  }\n}\nObject.defineProperty(Ei, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32002\n});\nclass Mi extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Transaction creation failed.\",\n      ...e,\n      code: Mi.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32003\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.TransactionRejectedError\"\n    });\n  }\n}\nObject.defineProperty(Mi, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32003\n});\nclass Ci extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Method is not implemented.\",\n      ...e,\n      code: Ci.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32004\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.MethodNotSupportedError\"\n    });\n  }\n}\nObject.defineProperty(Ci, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32004\n});\nclass Si extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Rate limit exceeded.\",\n      ...e,\n      code: Si.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32005\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.LimitExceededError\"\n    });\n  }\n}\nObject.defineProperty(Si, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32005\n});\nclass Ai extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"JSON-RPC version not supported.\",\n      ...e,\n      code: Ai.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32006\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.VersionNotSupportedError\"\n    });\n  }\n}\nObject.defineProperty(Ai, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32006\n});\nclass ki extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Input is not a valid JSON-RPC request.\",\n      ...e,\n      code: ki.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32600\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.InvalidRequestError\"\n    });\n  }\n}\nObject.defineProperty(ki, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32600\n});\nclass Ii extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Method does not exist.\",\n      ...e,\n      code: Ii.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32601\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.MethodNotFoundError\"\n    });\n  }\n}\nObject.defineProperty(Ii, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32601\n});\nclass Bi extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Invalid method parameters.\",\n      ...e,\n      code: Bi.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32602\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.InvalidParamsError\"\n    });\n  }\n}\nObject.defineProperty(Bi, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32602\n});\nclass Dn extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Internal JSON-RPC error.\",\n      ...e,\n      code: Dn.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32603\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.InternalErrorError\"\n    });\n  }\n}\nObject.defineProperty(Dn, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32603\n});\nclass Ri extends Pt {\n  constructor(e = {}) {\n    super({\n      message: \"Failed to parse JSON-RPC response.\",\n      ...e,\n      code: Ri.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32700\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.ParseError\"\n    });\n  }\n}\nObject.defineProperty(Ri, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32700\n});\nclass mn extends Error {\n  constructor(e, r) {\n    super(r), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"ProviderRpcError\"\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"details\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), this.code = e, this.details = r;\n  }\n}\nclass fl extends mn {\n  constructor({ message: e = \"The user rejected the request.\" } = {}) {\n    super(4001, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.UserRejectedRequestError\"\n    });\n  }\n}\nObject.defineProperty(fl, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4001\n});\nclass hl extends mn {\n  constructor({ message: e = \"The requested method and/or account has not been authorized by the user.\" } = {}) {\n    super(4100, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.UnauthorizedError\"\n    });\n  }\n}\nObject.defineProperty(hl, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4100\n});\nclass dl extends mn {\n  constructor({ message: e = \"The provider does not support the requested method.\" } = {}) {\n    super(4200, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.UnsupportedMethodError\"\n    });\n  }\n}\nObject.defineProperty(dl, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4200\n});\nclass pl extends mn {\n  constructor({ message: e = \"The provider is disconnected from all chains.\" } = {}) {\n    super(4900, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.DisconnectedError\"\n    });\n  }\n}\nObject.defineProperty(pl, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4900\n});\nclass ml extends mn {\n  constructor({ message: e = \"The provider is not connected to the requested chain.\" } = {}) {\n    super(4901, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.ChainDisconnectedError\"\n    });\n  }\n}\nObject.defineProperty(ml, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4901\n});\nfunction Ep() {\n  const t = new Dc();\n  return {\n    get eventNames() {\n      return t.eventNames.bind(t);\n    },\n    get listenerCount() {\n      return t.listenerCount.bind(t);\n    },\n    get listeners() {\n      return t.listeners.bind(t);\n    },\n    addListener: t.addListener.bind(t),\n    emit: t.emit.bind(t),\n    off: t.off.bind(t),\n    on: t.on.bind(t),\n    once: t.once.bind(t),\n    removeAllListeners: t.removeAllListeners.bind(t),\n    removeListener: t.removeListener.bind(t)\n  };\n}\nfunction Mp(t, e = {}) {\n  var n, o;\n  const { includeEvents: r = !0 } = e;\n  if (!t)\n    throw new Cp();\n  return {\n    ...r ? {\n      on: (n = t.on) == null ? void 0 : n.bind(t),\n      removeListener: (o = t.removeListener) == null ? void 0 : o.bind(t)\n    } : {},\n    async request(i) {\n      const c = await t.request(i);\n      return c && typeof c == \"object\" && \"jsonrpc\" in c ? ll(c) : c;\n    }\n  };\n}\nclass Cp extends pp {\n  constructor() {\n    super(\"`provider` is undefined.\"), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.IsUndefinedError\"\n    });\n  }\n}\nfunction Sp(t = {}) {\n  let e = t.id ?? 0;\n  return {\n    prepare(r) {\n      return Ap({\n        id: e++,\n        ...r\n      });\n    },\n    get id() {\n      return e;\n    }\n  };\n}\nfunction Ap(t) {\n  return {\n    ...t,\n    jsonrpc: \"2.0\"\n  };\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst gl = Symbol(\"Comlink.proxy\"), kp = Symbol(\"Comlink.endpoint\"), Ip = Symbol(\"Comlink.releaseProxy\"), go = Symbol(\"Comlink.finalizer\"), ss = Symbol(\"Comlink.thrown\"), yl = (t) => typeof t == \"object\" && t !== null || typeof t == \"function\", Bp = {\n  canHandle: (t) => yl(t) && t[gl],\n  serialize(t) {\n    const { port1: e, port2: r } = new MessageChannel();\n    return wl(t, e), [r, [r]];\n  },\n  deserialize(t) {\n    return t.start(), bl(t);\n  }\n}, Rp = {\n  canHandle: (t) => yl(t) && ss in t,\n  serialize({ value: t }) {\n    let e;\n    return t instanceof Error ? e = {\n      isError: !0,\n      value: {\n        message: t.message,\n        name: t.name,\n        stack: t.stack\n      }\n    } : e = { isError: !1, value: t }, [e, []];\n  },\n  deserialize(t) {\n    throw t.isError ? Object.assign(new Error(t.value.message), t.value) : t.value;\n  }\n}, vl = /* @__PURE__ */ new Map([\n  [\"proxy\", Bp],\n  [\"throw\", Rp]\n]);\nfunction Tp(t, e) {\n  for (const r of t)\n    if (e === r || r === \"*\" || r instanceof RegExp && r.test(e))\n      return !0;\n  return !1;\n}\nfunction wl(t, e = globalThis, r = [\"*\"]) {\n  e.addEventListener(\"message\", function n(o) {\n    if (!o || !o.data)\n      return;\n    if (!Tp(r, o.origin)) {\n      console.warn(`Invalid origin '${o.origin}' for comlink proxy`);\n      return;\n    }\n    const { id: i, type: c, path: f } = Object.assign({ path: [] }, o.data), v = (o.data.argumentList || []).map(nn);\n    let x;\n    try {\n      const b = f.slice(0, -1).reduce((T, C) => T[C], t), S = f.reduce((T, C) => T[C], t);\n      switch (c) {\n        case \"GET\":\n          x = S;\n          break;\n        case \"SET\":\n          b[f.slice(-1)[0]] = nn(o.data.value), x = !0;\n          break;\n        case \"APPLY\":\n          x = S.apply(b, v);\n          break;\n        case \"CONSTRUCT\":\n          {\n            const T = new S(...v);\n            x = Fp(T);\n          }\n          break;\n        case \"ENDPOINT\":\n          {\n            const { port1: T, port2: C } = new MessageChannel();\n            wl(t, C), x = Up(T, [T]);\n          }\n          break;\n        case \"RELEASE\":\n          x = void 0;\n          break;\n        default:\n          return;\n      }\n    } catch (b) {\n      x = { value: b, [ss]: 0 };\n    }\n    Promise.resolve(x).catch((b) => ({ value: b, [ss]: 0 })).then((b) => {\n      const [S, T] = Is(b);\n      e.postMessage(Object.assign(Object.assign({}, S), { id: i }), T), c === \"RELEASE\" && (e.removeEventListener(\"message\", n), xl(e), go in t && typeof t[go] == \"function\" && t[go]());\n    }).catch((b) => {\n      const [S, T] = Is({\n        value: new TypeError(\"Unserializable return value\"),\n        [ss]: 0\n      });\n      e.postMessage(Object.assign(Object.assign({}, S), { id: i }), T);\n    });\n  }), e.start && e.start();\n}\nfunction Lp(t) {\n  return t.constructor.name === \"MessagePort\";\n}\nfunction xl(t) {\n  Lp(t) && t.close();\n}\nfunction bl(t, e) {\n  const r = /* @__PURE__ */ new Map();\n  return t.addEventListener(\"message\", function(o) {\n    const { data: i } = o;\n    if (!i || !i.id)\n      return;\n    const c = r.get(i.id);\n    if (c)\n      try {\n        c(i);\n      } finally {\n        r.delete(i.id);\n      }\n  }), Fo(t, r, [], e);\n}\nfunction Ji(t) {\n  if (t)\n    throw new Error(\"Proxy has been released and is not useable\");\n}\nfunction _l(t) {\n  return Mn(t, /* @__PURE__ */ new Map(), {\n    type: \"RELEASE\"\n  }).then(() => {\n    xl(t);\n  });\n}\nconst As = /* @__PURE__ */ new WeakMap(), ks = \"FinalizationRegistry\" in globalThis && new FinalizationRegistry((t) => {\n  const e = (As.get(t) || 0) - 1;\n  As.set(t, e), e === 0 && _l(t);\n});\nfunction Op(t, e) {\n  const r = (As.get(e) || 0) + 1;\n  As.set(e, r), ks && ks.register(t, e, t);\n}\nfunction Np(t) {\n  ks && ks.unregister(t);\n}\nfunction Fo(t, e, r = [], n = function() {\n}) {\n  let o = !1;\n  const i = new Proxy(n, {\n    get(c, f) {\n      if (Ji(o), f === Ip)\n        return () => {\n          Np(i), _l(t), e.clear(), o = !0;\n        };\n      if (f === \"then\") {\n        if (r.length === 0)\n          return { then: () => i };\n        const v = Mn(t, e, {\n          type: \"GET\",\n          path: r.map((x) => x.toString())\n        }).then(nn);\n        return v.then.bind(v);\n      }\n      return Fo(t, e, [...r, f]);\n    },\n    set(c, f, v) {\n      Ji(o);\n      const [x, b] = Is(v);\n      return Mn(t, e, {\n        type: \"SET\",\n        path: [...r, f].map((S) => S.toString()),\n        value: x\n      }, b).then(nn);\n    },\n    apply(c, f, v) {\n      Ji(o);\n      const x = r[r.length - 1];\n      if (x === kp)\n        return Mn(t, e, {\n          type: \"ENDPOINT\"\n        }).then(nn);\n      if (x === \"bind\")\n        return Fo(t, e, r.slice(0, -1));\n      const [b, S] = gu(v);\n      return Mn(t, e, {\n        type: \"APPLY\",\n        path: r.map((T) => T.toString()),\n        argumentList: b\n      }, S).then(nn);\n    },\n    construct(c, f) {\n      Ji(o);\n      const [v, x] = gu(f);\n      return Mn(t, e, {\n        type: \"CONSTRUCT\",\n        path: r.map((b) => b.toString()),\n        argumentList: v\n      }, x).then(nn);\n    }\n  });\n  return Op(i, t), i;\n}\nfunction jp(t) {\n  return Array.prototype.concat.apply([], t);\n}\nfunction gu(t) {\n  const e = t.map(Is);\n  return [e.map((r) => r[0]), jp(e.map((r) => r[1]))];\n}\nconst El = /* @__PURE__ */ new WeakMap();\nfunction Up(t, e) {\n  return El.set(t, e), t;\n}\nfunction Fp(t) {\n  return Object.assign(t, { [gl]: !0 });\n}\nfunction Pp(t, e = globalThis, r = \"*\") {\n  return {\n    postMessage: (n, o) => t.postMessage(n, r, o),\n    addEventListener: e.addEventListener.bind(e),\n    removeEventListener: e.removeEventListener.bind(e)\n  };\n}\nfunction Is(t) {\n  for (const [e, r] of vl)\n    if (r.canHandle(t)) {\n      const [n, o] = r.serialize(t);\n      return [\n        {\n          type: \"HANDLER\",\n          name: e,\n          value: n\n        },\n        o\n      ];\n    }\n  return [\n    {\n      type: \"RAW\",\n      value: t\n    },\n    El.get(t) || []\n  ];\n}\nfunction nn(t) {\n  switch (t.type) {\n    case \"HANDLER\":\n      return vl.get(t.name).deserialize(t.value);\n    case \"RAW\":\n      return t.value;\n  }\n}\nfunction Mn(t, e, r, n) {\n  return new Promise((o) => {\n    const i = Dp();\n    e.set(i, o), t.start && t.start(), t.postMessage(Object.assign({ id: i }, r), n);\n  });\n}\nfunction Dp() {\n  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join(\"-\");\n}\nconst $p = {\n  postMessage() {\n  },\n  addEventListener: () => {\n  },\n  removeEventListener: () => {\n  }\n}, zp = {\n  postMessage: (t) => {\n    console.debug(\"[webview:req]\", t), window.ReactNativeWebView.postMessage(JSON.stringify(t));\n  },\n  addEventListener: (t, e, ...r) => {\n    document.addEventListener(\"FarcasterFrameCallback\", e, ...r);\n  },\n  removeEventListener: (t, e) => {\n    document.removeEventListener(\"FarcasterFrameCallback\", e);\n  }\n}, qp = typeof window > \"u\" ? $p : window != null && window.ReactNativeWebView ? zp : Pp((window == null ? void 0 : window.parent) ?? window), Qe = bl(qp), ba = Ep(), Zp = Sp();\nfunction Vp({ code: t, details: e }) {\n  switch (t) {\n    case 4001:\n      return new fl();\n    case 4100:\n      return new hl();\n    case 4200:\n      return new dl();\n    case 4900:\n      return new pl();\n    case 4901:\n      return new ml();\n    default:\n      return new mn(t, e ?? \"Unknown provider RPC error\");\n  }\n}\nconst Ti = Mp({\n  ...ba,\n  async request(t) {\n    const e = Zp.prepare(t);\n    try {\n      const r = await Qe.ethProviderRequestV2(e).then((n) => ll(n, { request: e, raw: !0 }));\n      if (r.error)\n        throw Vp(r.error);\n      return r.result;\n    } catch (r) {\n      if (r instanceof Error && r.message.match(/cannot read property 'apply'/i))\n        return await Qe.ethProviderRequest(e);\n      throw r instanceof mn || r instanceof Pt ? r : new Dn({\n        message: r instanceof Error ? r.message : void 0\n      });\n    }\n  }\n});\nasync function Hp() {\n  try {\n    const t = await Qe.getCapabilities();\n    return !t.includes(\"wallet.getEthereumProvider\") && !t.includes(\"wallet.getEvmProvider\") ? void 0 : Ti;\n  } catch {\n    return Ti;\n  }\n}\nfunction Ml(t) {\n  const e = new CustomEvent(\"eip6963:announceProvider\", { detail: Object.freeze(t) });\n  window.dispatchEvent(e);\n  const r = () => window.dispatchEvent(e);\n  return window.addEventListener(\"eip6963:requestProvider\", r), () => window.removeEventListener(\"eip6963:requestProvider\", r);\n}\ntypeof document < \"u\" && (document.addEventListener(\"eip6963:requestProvider\", () => {\n  Qe.eip6963RequestProvider();\n}), document.addEventListener(\"FarcasterFrameEthProviderEvent\", (t) => {\n  if (t instanceof MessageEvent) {\n    const e = t.data;\n    ba.emit(e.event, ...e.params);\n  }\n}), document.addEventListener(\"FarcasterFrameEvent\", (t) => {\n  if (t instanceof MessageEvent) {\n    const e = t.data;\n    e.event === \"eip6963:announceProvider\" && Ml({\n      info: e.info,\n      provider: Ti\n    });\n  }\n}));\ntypeof window < \"u\" && (window.addEventListener(\"eip6963:requestProvider\", () => {\n  Qe.eip6963RequestProvider();\n}), window.addEventListener(\"message\", (t) => {\n  if (t instanceof MessageEvent && t.data.type === \"frameEthProviderEvent\") {\n    const e = t.data;\n    ba.emit(e.event, ...e.params);\n  }\n}), window.addEventListener(\"message\", (t) => {\n  if (t instanceof MessageEvent && t.data.type === \"frameEvent\") {\n    const e = t.data.event;\n    e.event === \"eip6963:announceProvider\" && Ml({\n      info: e.info,\n      provider: Ti\n    });\n  }\n}));\nfunction Kp() {\n  const t = new Dc();\n  return {\n    get eventNames() {\n      return t.eventNames.bind(t);\n    },\n    get listenerCount() {\n      return t.listenerCount.bind(t);\n    },\n    get listeners() {\n      return t.listeners.bind(t);\n    },\n    addListener: t.addListener.bind(t),\n    emit: t.emit.bind(t),\n    off: t.off.bind(t),\n    on: t.on.bind(t),\n    once: t.once.bind(t),\n    removeAllListeners: t.removeAllListeners.bind(t),\n    removeListener: t.removeListener.bind(t)\n  };\n}\nconst Tt = Kp(), { solanaProviderRequest: yu } = Qe;\nlet Cl;\nyu && (Cl = ip(op(yu)));\nasync function vu() {\n  let t;\n  try {\n    t = await Qe.getCapabilities();\n  } catch {\n  }\n  if (t != null && t.includes(\"wallet.getSolanaProvider\"))\n    return Cl;\n}\nlet wu = null;\nasync function Wp(t = 50) {\n  if (wu === !0)\n    return !0;\n  if (typeof window > \"u\" || !window.ReactNativeWebView && window === window.parent)\n    return !1;\n  const e = await Promise.race([\n    Qe.context.then((r) => !!r),\n    // Check if context resolves to truthy\n    new Promise((r) => {\n      setTimeout(() => r(!1), t);\n    })\n  ]).catch(() => !1);\n  return e && (wu = !0), e;\n}\nconst xu = async (t = {}) => {\n  const e = fp({\n    origin: t.quickAuthServerOrigin\n  }), { nonce: r } = await e.generateNonce(), n = await Qe.signIn({\n    nonce: r,\n    acceptAuthAddress: !0\n  });\n  if (n.result) {\n    const o = yp(n.result.message);\n    if (!o.domain)\n      throw new Error(\"Missing domain on SIWE message\");\n    return await e.verifySiwf({\n      domain: o.domain,\n      message: n.result.message,\n      signature: n.result.signature\n    });\n  }\n  throw n.error.type === \"rejected_by_user\" ? new Hu() : new Error(\"Unreachable\");\n}, bu = async () => {\n  const t = await Qe.addFrame();\n  if (t.result)\n    return t.result;\n  throw t.error.type === \"invalid_domain_manifest\" ? new nf() : t.error.type === \"rejected_by_user\" ? new sf() : new Error(\"Unreachable\");\n}, yt = {\n  ...Tt,\n  getCapabilities: Qe.getCapabilities,\n  getChains: Qe.getChains,\n  isInMiniApp: Wp,\n  context: Qe.context,\n  back: vp({ frameHost: Qe, emitter: Tt }),\n  actions: {\n    setPrimaryButton: Qe.setPrimaryButton.bind(Qe),\n    ready: async (t = {}) => await Qe.ready(t),\n    close: Qe.close.bind(Qe),\n    viewCast: Qe.viewCast.bind(Qe),\n    viewProfile: Qe.viewProfile.bind(Qe),\n    signIn: async (t) => {\n      const e = await Qe.signIn(t);\n      if (e.result)\n        return e.result;\n      throw e.error.type === \"rejected_by_user\" ? new Hu() : new Error(\"Unreachable\");\n    },\n    openUrl: (t) => {\n      const e = typeof t == \"string\" ? t : t.url;\n      return Qe.openUrl(e.trim());\n    },\n    addFrame: bu,\n    addMiniApp: bu,\n    composeCast(t = {}) {\n      return Qe.composeCast(t);\n    },\n    viewToken: Qe.viewToken.bind(Qe),\n    sendToken: Qe.sendToken.bind(Qe),\n    swapToken: Qe.swapToken.bind(Qe),\n    quickAuth: xu\n  },\n  experimental: {\n    getSolanaProvider: vu,\n    quickAuth: xu\n  },\n  wallet: {\n    ethProvider: Ti,\n    getEthereumProvider: Hp,\n    getSolanaProvider: vu\n  },\n  haptics: {\n    impactOccurred: Qe.impactOccurred.bind(Qe),\n    notificationOccurred: Qe.notificationOccurred.bind(Qe),\n    selectionChanged: Qe.selectionChanged.bind(Qe)\n  }\n};\ntypeof document < \"u\" && document.addEventListener(\"FarcasterFrameEvent\", (t) => {\n  if (t instanceof MessageEvent) {\n    const e = t.data;\n    e.event === \"primary_button_clicked\" ? Tt.emit(\"primaryButtonClicked\") : e.event === \"frame_added\" ? Tt.emit(\"frameAdded\", {\n      notificationDetails: e.notificationDetails\n    }) : e.event === \"frame_add_rejected\" ? Tt.emit(\"frameAddRejected\", { reason: e.reason }) : e.event === \"frame_removed\" ? Tt.emit(\"frameRemoved\") : e.event === \"notifications_enabled\" ? Tt.emit(\"notificationsEnabled\", {\n      notificationDetails: e.notificationDetails\n    }) : e.event === \"notifications_disabled\" ? Tt.emit(\"notificationsDisabled\") : e.event === \"back_navigation_triggered\" && Tt.emit(\"backNavigationTriggered\");\n  }\n});\ntypeof window < \"u\" && window.addEventListener(\"message\", (t) => {\n  if (t instanceof MessageEvent && t.data.type === \"frameEvent\") {\n    const e = t.data.event;\n    e.event === \"primary_button_clicked\" ? Tt.emit(\"primaryButtonClicked\") : e.event === \"frame_added\" ? Tt.emit(\"frameAdded\", {\n      notificationDetails: e.notificationDetails\n    }) : e.event === \"frame_add_rejected\" ? Tt.emit(\"frameAddRejected\", { reason: e.reason }) : e.event === \"frame_removed\" ? Tt.emit(\"frameRemoved\") : e.event === \"notifications_enabled\" ? Tt.emit(\"notificationsEnabled\", {\n      notificationDetails: e.notificationDetails\n    }) : e.event === \"notifications_disabled\" ? Tt.emit(\"notificationsDisabled\") : e.event === \"back_navigation_triggered\" && Tt.emit(\"backNavigationTriggered\");\n  }\n});\nfunction Gp(t) {\n  if (typeof window > \"u\")\n    return;\n  const e = (r) => t(r.detail);\n  return window.addEventListener(\"eip6963:announceProvider\", e), window.dispatchEvent(new CustomEvent(\"eip6963:requestProvider\")), () => window.removeEventListener(\"eip6963:announceProvider\", e);\n}\nfunction Yp() {\n  const t = /* @__PURE__ */ new Set();\n  let e = [];\n  const r = () => Gp((o) => {\n    e.some(({ info: i }) => i.uuid === o.info.uuid) || (e = [...e, o], t.forEach((i) => i(e, { added: [o] })));\n  });\n  let n = r();\n  return {\n    _listeners() {\n      return t;\n    },\n    clear() {\n      t.forEach((o) => o([], { removed: [...e] })), e = [];\n    },\n    destroy() {\n      this.clear(), t.clear(), n == null || n();\n    },\n    findProvider({ rdns: o }) {\n      return e.find((i) => i.info.rdns === o);\n    },\n    getProviders() {\n      return e;\n    },\n    reset() {\n      this.clear(), n == null || n(), n = r();\n    },\n    subscribe(o, { emitImmediately: i } = {}) {\n      return t.add(o), i && o(e, { added: e }), () => t.delete(o);\n    }\n  };\n}\nfunction Jp(t, e = {}, r) {\n  const n = {\n    event_type: t,\n    api_key: \"0c4fe46171b9bb8eca2ca61eb71f2e19\",\n    time: Date.now(),\n    user_id: r,\n    ...Object.keys(e).length && {\n      event_properties: e\n    }\n  };\n  fetch(\"https://api2.amplitude.com/2/httpapi\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      api_key: \"0c4fe46171b9bb8eca2ca61eb71f2e19\",\n      events: [n]\n    })\n  }).catch((o) => {\n    console.error(\"Amplitude tracking error:\", o);\n  });\n}\nconst Xp = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(void 0);\nfunction Qp(t = !1) {\n  const [e, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [i, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [f, v] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [x, b] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [S, T] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}), [C, P] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), B = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((Z, Q = {}, j) => {\n    t && Jp(Z, Q, j);\n  }, [t]), R = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (Z) => {\n    await yt.isInMiniApp() ? await yt.actions.openUrl(Z) : window.open(Z, \"_blank\");\n  }, [yt]), z = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    await yt.isInMiniApp() ? await yt.actions.close() : window.close();\n  }, [yt]), K = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (Z, Q) => (Q && t && B(\"cast.composed\", {\n    ...S,\n    castText: Z == null ? void 0 : Z.text,\n    source: Q\n  }, C), yt.actions.composeCast(Z)), [yt, t, B, S, C]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const Z = async () => {\n      var O, L;\n      const Q = await yt.context;\n      o(Q), r(!0);\n      const j = new URLSearchParams(window.location.search), V = j.get(\"utm_source\"), ee = j.get(\"utm_medium\"), G = j.get(\"utm_campaign\");\n      if (V === \"neynar\" && (ee != null && ee.startsWith(\"share-cast-\"))) {\n        const F = ee.replace(\"share-cast-\", \"\");\n        (O = Q == null ? void 0 : Q.user) != null && O.fid && B(\"cast.shared\", {\n          ...S,\n          sharedByFid: F\n        }, C);\n      }\n      if (V === \"neynar\" && G && ((L = Q == null ? void 0 : Q.user) != null && L.fid)) {\n        const F = `neynar_notification_tracked_${G}`;\n        if (!localStorage.getItem(F))\n          try {\n            const s = await fetch(\"https://api.neynar.com/v2/farcaster/frame/notifications/open\", {\n              method: \"POST\",\n              headers: {\n                \"content-type\": \"application/json\"\n              },\n              body: JSON.stringify({\n                campaign_id: G,\n                fid: Q.user.fid,\n                app_fid: Q.client.clientFid\n              })\n            });\n            s.ok ? localStorage.setItem(F, \"true\") : console.error(\"Failed to mark notification as opened: \", await s.text());\n          } catch (s) {\n            console.error(\"Error marking notification as opened: \", s);\n          }\n      }\n      yt.on(\"frameAdded\", ({\n        notificationDetails: F\n      }) => {\n        console.log(\"Frame added\", F), c(!0), v(F ?? null), b(\"Frame added\"), B(\"frame.added\", S, C);\n      }), yt.on(\"frameAddRejected\", ({\n        reason: F\n      }) => {\n        console.log(\"Frame add rejected\", F), c(!1), b(`Frame add rejected: ${F}`), B(\"frame.add.rejected\", S, C);\n      }), yt.on(\"frameRemoved\", () => {\n        console.log(\"Frame removed\"), c(!1), b(\"Frame removed\"), B(\"frame.removed\", S, C);\n      }), yt.on(\"notificationsEnabled\", ({\n        notificationDetails: F\n      }) => {\n        console.log(\"Notifications enabled\", F), v(F ?? null), b(\"Notifications enabled\"), B(\"notifications.enabled\", S, C);\n      }), yt.on(\"notificationsDisabled\", () => {\n        console.log(\"Notifications disabled\"), v(null), b(\"Notifications disabled\"), B(\"notifications.disabled\", S, C);\n      }), yt.on(\"primaryButtonClicked\", () => {\n        console.log(\"Primary button clicked\"), b(\"Primary button clicked\"), B(\"primary-button.clicked\", S, C);\n      }), console.log(\"Calling ready\"), yt.actions.ready({}), Yp().subscribe((F) => {\n        console.log(\"PROVIDER DETAILS\", F);\n      });\n    };\n    if (yt && !e)\n      return console.log(\"Calling load\"), r(!0), Z(), () => {\n        yt.removeAllListeners();\n      };\n  }, [yt, S, C, e, B]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n != null && n.user && (n != null && n.client) && (T({\n      username: n.user.username,\n      clientFid: n.client.clientFid\n    }), P(`${n.user.fid}`), B(\"frame.opened\", {\n      username: n.user.username,\n      clientFid: n.client.clientFid,\n      location: n.location,\n      added: n.client.added\n    }, `${n.user.fid}`));\n  }, [n, B]), {\n    ...yt,\n    isSDKLoaded: e,\n    context: n,\n    added: i,\n    notificationDetails: f,\n    lastEvent: x,\n    actions: {\n      ...yt.actions,\n      openUrl: R,\n      close: z,\n      composeCast: K\n    }\n  };\n}\nfunction sy({\n  children: t,\n  analyticsEnabled: e = !1\n}) {\n  const r = Qp(e);\n  return r.isSDKLoaded ? /* @__PURE__ */ U.jsx(Xp.Provider, {\n    value: r,\n    children: t\n  }) : /* @__PURE__ */ U.jsx(\"div\", {\n    children: \"Loading...\"\n  });\n}\nvar Sl = /* @__PURE__ */ ((t) => (t.Light = \"light\", t.Dark = \"dark\", t))(Sl || {}), wr = /* @__PURE__ */ ((t) => (t.FARCASTER = \"farcaster\", t.NEYNAR = \"neynar\", t.WARPCAST = \"warpcast\", t))(wr || {});\nfunction _a(t, e = \"\", {\n  serialize: r = JSON.stringify,\n  deserialize: n = JSON.parse\n} = {}) {\n  const [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n    if (typeof window > \"u\")\n      return e;\n    try {\n      const v = window.localStorage.getItem(t);\n      return v ? n(v) : e;\n    } catch (v) {\n      return console.error(\"Error reading from localStorage\", v), e;\n    }\n  });\n  return [o, (v) => {\n    try {\n      const x = v instanceof Function ? v(o) : v;\n      i(x), typeof window < \"u\" && window.localStorage.setItem(t, r(x));\n    } catch (x) {\n      console.error(\"Error writing to localStorage\", x);\n    }\n  }, () => {\n    try {\n      window.localStorage.removeItem(t), i(e);\n    } catch (v) {\n      console.error(\"Error removing from localStorage\", v);\n    }\n  }];\n}\nvar Zn = /* @__PURE__ */ ((t) => (t.NEYNAR_AUTHENTICATED_USER = \"neynar_authenticated_user\", t))(Zn || {});\nconst Al = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), em = ({\n  children: t,\n  _setIsAuthenticated: e,\n  _setUser: r,\n  _onAuthSuccess: n,\n  _onSignout: o\n}) => {\n  const {\n    isAuthenticated: i\n  } = lr(), [c, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [v, x] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [b] = _a(Zn.NEYNAR_AUTHENTICATED_USER);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    e(c);\n  }, [c]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    f(i);\n  }, [i]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    b ? (x(b), f(!0)) : (x(null), f(!1));\n  }, []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    r(v);\n  }, [v]);\n  const S = (P) => {\n    n && n(P);\n  }, T = (P) => {\n    o && o(P);\n  }, C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    isAuthenticated: c,\n    user: v,\n    setIsAuthenticated: f,\n    setUser: x,\n    onAuthSuccess: S,\n    onSignout: T\n  }), [c, v]);\n  return /* @__PURE__ */ U.jsx(Al.Provider, {\n    value: C,\n    children: t\n  });\n}, kl = () => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Al);\n  if (!t)\n    throw new Error(\"useAuth must be used within a AuthContextProvider\");\n  return t;\n}, tm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"tbaom7c\"]\n}), rm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"t1ff44zi\"],\n  variants: [{\n    props: {\n      type: \"success\"\n    },\n    className: \"t1ff44zi-1\"\n  }, {\n    props: {\n      type: \"error\"\n    },\n    className: \"t1ff44zi-2\"\n  }, {\n    props: {\n      type: \"warning\"\n    },\n    className: \"t1ff44zi-3\"\n  }, {\n    props: {\n      type: \"info\"\n    },\n    className: \"t1ff44zi-4\"\n  }]\n});\nvar Il = /* @__PURE__ */ ((t) => (t.Success = \"success\", t.Error = \"error\", t.Warning = \"warning\", t.Info = \"info\", t))(Il || {});\nconst Bl = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), oy = ({\n  children: t,\n  settings: {\n    clientId: e,\n    defaultTheme: r = Sl.Light,\n    eventsCallbacks: n\n  }\n}) => {\n  const [o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e), [i, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [f, v] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(r), [x, b] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [S, T] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), C = (Z, Q) => {\n    const j = {\n      type: Z,\n      message: Q\n    };\n    b((V) => [...V, j]), setTimeout(() => P(j), 5e3);\n  }, P = (Z) => {\n    b((Q) => Q.filter((j) => j !== Z));\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const Z = document.querySelector(\":root\");\n    Z && (f === \"light\" ? (Z.classList.add(\"theme-light\"), Z.classList.remove(\"theme-dark\")) : f === \"dark\" && (Z.classList.add(\"theme-dark\"), Z.classList.remove(\"theme-light\")));\n  }, [f]);\n  const B = (Z) => {\n    c(Z);\n  }, R = (Z) => {\n    T(Z);\n  }, z = () => {\n    if (S) {\n      const {\n        signer_uuid: Z,\n        ...Q\n      } = S;\n      T(null), c(!1), localStorage.removeItem(Zn.NEYNAR_AUTHENTICATED_USER), n != null && n.onSignout && n.onSignout(Q);\n    }\n  }, K = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    client_id: o,\n    theme: f,\n    isAuthenticated: i,\n    user: S,\n    setTheme: v,\n    showToast: C,\n    logoutUser: z\n  }), [o, f, i, S, v, C, z]);\n  return /* @__PURE__ */ U.jsx(Bl.Provider, {\n    value: K,\n    children: /* @__PURE__ */ U.jsxs(em, {\n      _setIsAuthenticated: B,\n      _setUser: R,\n      _onAuthSuccess: n == null ? void 0 : n.onAuthSuccess,\n      _onSignout: n == null ? void 0 : n.onSignout,\n      children: [t, /* @__PURE__ */ U.jsx(tm, {\n        children: x.map((Z, Q) => /* @__PURE__ */ U.jsx(rm, {\n          type: Z.type,\n          children: Z.message\n        }, Q))\n      })]\n    })\n  });\n}, lr = () => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Bl);\n  if (!t)\n    throw new Error(\"useNeynarContext must be used within a NeynarContextProvider\");\n  return t;\n}, nm = () => /* @__PURE__ */ U.jsxs(\"svg\", {\n  width: \"18\",\n  height: \"17\",\n  viewBox: \"0 0 18 17\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: [/* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M13.7222 0H4.27778C2.19137 0 0.5 1.69137 0.5 3.77778V13.2222C0.5 15.3086 2.19137 17 4.27778 17H13.7222C15.8086 17 17.5 15.3086 17.5 13.2222V3.77778C17.5 1.69137 15.8086 0 13.7222 0Z\",\n    fill: \"#855DCD\"\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M4.88281 2.64453H13.1184V14.3556H11.9095V8.9912H11.8976C11.764 7.50859 10.518 6.34675 9.00059 6.34675C7.4832 6.34675 6.23717 7.50859 6.10356 8.9912H6.0917V14.3556H4.88281V2.64453Z\",\n    fill: \"white\"\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M2.69141 4.30664L3.18252 5.96886H3.59807V12.6933C3.38943 12.6933 3.2203 12.8625 3.2203 13.0711V13.5244H3.14474C2.9361 13.5244 2.76696 13.6936 2.76696 13.9022V14.3555H6.99807V13.9022C6.99807 13.6936 6.82893 13.5244 6.6203 13.5244H6.54474V13.0711C6.54474 12.8625 6.3756 12.6933 6.16696 12.6933H5.71363V4.30664H2.69141Z\",\n    fill: \"white\"\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M11.9854 12.6933C11.7768 12.6933 11.6076 12.8625 11.6076 13.0711V13.5244H11.5321C11.3235 13.5244 11.1543 13.6936 11.1543 13.9022V14.3555H15.3854V13.9022C15.3854 13.6936 15.2162 13.5244 15.0076 13.5244H14.9321V13.0711C14.9321 12.8625 14.7629 12.6933 14.5543 12.6933V5.96886H14.9699L15.461 4.30664H12.4387V12.6933H11.9854Z\",\n    fill: \"white\"\n  })]\n}), _u = () => /* @__PURE__ */ U.jsxs(\"svg\", {\n  width: \"32\",\n  height: \"17\",\n  viewBox: \"0 0 50 28\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: [/* @__PURE__ */ U.jsx(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M38.3744 13.7311C38.3744 16.1209 37.7639 18.368 36.6904 20.3252C32.5685 19.8525 27.847 18.9503 22.8999 17.6247C20.4058 16.9564 18.0151 16.2236 15.7697 15.4495L15.7693 15.4486C15.7579 15.445 15.7465 15.4413 15.7351 15.4376C15.6448 15.4064 15.5547 15.3752 15.4649 15.3439C12.8978 14.399 11.2356 12.2056 11.4168 10.0315L11.4482 10.0399L11.4215 10.0133C13.0427 4.23612 18.3483 0 24.6434 0C32.2268 0 38.3744 6.14762 38.3744 13.7311Z\",\n    fill: \"black\"\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M11.3804 17.2987C12.4882 16.5313 13.9658 16.1804 15.5002 16.3953C17.7731 17.156 20.1682 17.8782 22.6535 18.5441C27.397 19.8151 31.9584 20.7444 36.0833 21.3275C33.623 25.0252 29.4177 27.4619 24.6434 27.4619C18.294 27.4619 12.9511 23.1524 11.3804 17.2987Z\",\n    fill: \"black\"\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M43.0917 13.4458C41.6461 12.6648 39.9756 11.8759 38.1233 11.1029C38.0363 10.6544 37.9275 10.2136 37.7981 9.78174C39.9806 10.6648 41.9403 11.5752 43.6139 12.4794C45.7007 13.6069 47.3703 14.7394 48.4714 15.816C49.5356 16.8566 50.2295 18.0063 49.93 19.1241C49.6304 20.2419 48.4547 20.8906 47.0128 21.2597C45.5209 21.6415 43.5087 21.7875 41.1377 21.7206C39.6046 21.6773 37.9082 21.5444 36.0864 21.3234C36.3086 20.9891 36.5165 20.6446 36.7094 20.2906C38.3134 20.4733 39.8091 20.5841 41.1687 20.6225C43.4946 20.6882 45.3908 20.5409 46.7404 20.1955C48.14 19.8373 48.7389 19.3249 48.8689 18.8398C48.9989 18.3547 48.7364 17.6115 47.7034 16.6015C46.7073 15.6275 45.1388 14.5519 43.0917 13.4458ZM8.86229 3.16772C10.7583 3.22128 12.9038 3.41177 15.2278 3.73661C14.8974 4.04803 14.5824 4.37566 14.2841 4.71822C12.3016 4.46314 10.4678 4.312 8.83127 4.26577C6.50541 4.20006 4.6092 4.34737 3.25958 4.69279C1.86001 5.05099 1.26107 5.56342 1.13109 6.04849C1.00112 6.53356 1.2636 7.27681 2.29657 8.2868C3.29267 9.26075 4.86118 10.3364 6.90828 11.4425C6.94181 11.4606 6.97546 11.4787 7.00923 11.4968C6.84251 11.5938 6.72574 11.7161 6.66353 11.8645C6.57791 12.0688 6.60013 12.3121 6.72013 12.5874C6.60757 12.5279 6.49623 12.4684 6.38612 12.4089C4.29926 11.2814 2.62971 10.1489 1.5286 9.07223C0.464367 8.03166 -0.229485 6.882 0.0700354 5.76418C0.369556 4.64635 1.54528 3.99764 2.98722 3.6286C4.47911 3.24677 6.49126 3.10074 8.86229 3.16772Z\",\n    fill: \"black\"\n  }), /* @__PURE__ */ U.jsx(\"ellipse\", {\n    cx: \"5.94866\",\n    cy: \"11.5309\",\n    rx: \"3.76009\",\n    ry: \"0.575832\",\n    transform: \"rotate(29.2824 5.94866 11.5309)\",\n    fill: \"black\"\n  })]\n}), im = () => /* @__PURE__ */ U.jsxs(\"svg\", {\n  width: \"17\",\n  height: \"17\",\n  viewBox: \"0 0 17 17\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: [/* @__PURE__ */ U.jsx(\"mask\", {\n    id: \"mask0_875_48\",\n    maskUnits: \"userSpaceOnUse\",\n    x: \"0\",\n    y: \"0\",\n    width: \"17\",\n    height: \"17\",\n    children: /* @__PURE__ */ U.jsx(\"path\", {\n      d: \"M16.9947 0H0V16.9947H16.9947V0Z\",\n      fill: \"white\"\n    })\n  }), /* @__PURE__ */ U.jsxs(\"g\", {\n    mask: \"url(#mask0_875_48)\",\n    children: [/* @__PURE__ */ U.jsx(\"path\", {\n      d: \"M12.7871 16.9947H4.20765C1.88755 16.9947 0 15.1073 0 12.7871V4.20771C0 1.88756 1.88755 0 4.20765 0H12.7871C15.1072 0 16.9947 1.88756 16.9947 4.20771V12.7871C16.9947 15.1073 15.1072 16.9947 12.7871 16.9947Z\",\n      fill: \"#472A91\"\n    }), /* @__PURE__ */ U.jsx(\"path\", {\n      d: \"M11.1523 5.37891L10.3143 8.52601L9.47364 5.37891H7.53893L6.69017 8.54919L5.84419 5.37891H3.64062L5.68823 12.3371H7.58931L8.49835 9.10599L9.40736 12.3371H11.3125L13.3557 5.37891H11.1523Z\",\n      fill: \"white\"\n    })]\n  })]\n});\nvar sm = {};\nconst Po = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"img\")({\n  classes: [\"ippfsqr\"]\n}), om = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"button\")({\n  classes: [\"b1yzssjb\"]\n}), am = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"m1xn8b2e\"]\n}), um = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"button\")({\n  classes: [\"mwuiqyg\"]\n}), cm = (t, e) => {\n  if (e)\n    return e;\n  switch (t) {\n    case wr.FARCASTER:\n      return \"Sign in with Farcaster\";\n    case wr.NEYNAR:\n      return \"Sign in with Neynar\";\n    case wr.WARPCAST:\n      return \"Sign in with Warpcast\";\n    default:\n      return \"Sign in with Neynar\";\n  }\n}, lm = (t, e, r) => {\n  if (e)\n    return e;\n  if (r)\n    return /* @__PURE__ */ U.jsx(Po, {\n      src: r,\n      alt: \"Custom logo\"\n    });\n  switch (t) {\n    case wr.FARCASTER:\n      return /* @__PURE__ */ U.jsx(nm, {});\n    case wr.NEYNAR:\n      return /* @__PURE__ */ U.jsx(_u, {});\n    case wr.WARPCAST:\n      return /* @__PURE__ */ U.jsx(im, {});\n    default:\n      return /* @__PURE__ */ U.jsx(_u, {});\n  }\n}, fm = ({\n  children: t,\n  label: e,\n  variant: r = wr.NEYNAR,\n  icon: n,\n  customLogoUrl: o,\n  modalStyle: i = {},\n  modalButtonStyle: c = {},\n  ...f\n}) => {\n  const {\n    client_id: v,\n    user: x,\n    isAuthenticated: b\n  } = lr(), {\n    setIsAuthenticated: S,\n    setUser: T,\n    onAuthSuccess: C,\n    onSignout: P\n  } = kl(), [B, R, z] = _a(Zn.NEYNAR_AUTHENTICATED_USER), [K, Z] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), Q = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), j = `${sm.NEYNAR_LOGIN_URL ?? \"https://app.neynar.com/login\"}?client_id=${v}`, V = new URL(j).origin, ee = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), G = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (s) => {\n    var u;\n    if (s.origin === V && s.data && s.data.is_authenticated) {\n      S(!0), (u = Q.current) == null || u.close(), window.removeEventListener(\"message\", G);\n      const h = {\n        signer_uuid: s.data.signer_uuid,\n        ...s.data.user\n      };\n      R(h), T(h), C({\n        user: h\n      });\n    }\n  }, [v, S]), N = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const h = window.screen.width / 2 - 300, w = `width=600,height=700,top=${window.screen.height / 2 - 700 / 2},left=${h}`;\n    if (Q.current = window.open(j, \"_blank\", w), !Q.current) {\n      console.error(\"Failed to open the authentication window. Please check your pop-up blocker settings.\");\n      return;\n    }\n    window.addEventListener(\"message\", G, !1);\n  }, [v, G]), O = () => {\n    if (x) {\n      const s = x;\n      z(), S(!1), F();\n      const {\n        signer_uuid: u,\n        ...h\n      } = s;\n      P(h);\n    }\n  }, L = () => Z(!0), F = () => Z(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => {\n    window.removeEventListener(\"message\", G);\n  }, [G]);\n  const d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((s) => {\n    ee.current && !ee.current.contains(s.target) && F();\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (K ? document.addEventListener(\"mousedown\", d) : document.removeEventListener(\"mousedown\", d), () => {\n    document.removeEventListener(\"mousedown\", d);\n  }), [K, d]), /* @__PURE__ */ U.jsxs(U.Fragment, {\n    children: [K && /* @__PURE__ */ U.jsxs(am, {\n      style: i,\n      ref: ee,\n      children: [/* @__PURE__ */ U.jsx(Po, {\n        src: x == null ? void 0 : x.pfp_url,\n        alt: x == null ? void 0 : x.username\n      }), /* @__PURE__ */ U.jsxs(\"span\", {\n        children: [\"@\", x == null ? void 0 : x.username]\n      }), /* @__PURE__ */ U.jsx(um, {\n        style: c,\n        onClick: O,\n        children: \"Sign out\"\n      })]\n    }), /* @__PURE__ */ U.jsx(om, {\n      onClick: b ? L : N,\n      ...f,\n      children: b ? /* @__PURE__ */ U.jsxs(U.Fragment, {\n        children: [/* @__PURE__ */ U.jsx(Po, {\n          src: x == null ? void 0 : x.pfp_url,\n          alt: `${x == null ? void 0 : x.username} profile picture`\n        }), /* @__PURE__ */ U.jsxs(\"span\", {\n          style: {\n            marginLeft: \"10px\"\n          },\n          children: [\"@\", x == null ? void 0 : x.username]\n        })]\n      }) : /* @__PURE__ */ U.jsxs(U.Fragment, {\n        children: [lm(r, n, o), /* @__PURE__ */ U.jsx(\"span\", {\n          style: {\n            marginLeft: \"5px\"\n          },\n          children: cm(r, e)\n        })]\n      })\n    })]\n  });\n}, Bs = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"img\")({\n  classes: [\"a11pt0xp\"],\n  vars: {\n    \"a11pt0xp-0\": [(t, e = rr) => t.width || \"45px\", !1],\n    \"a11pt0xp-1\": [(t, e = rr) => t.width || \"45px\", !1]\n  }\n}), Eu = \"https://farcaster.xyz\", Rl = /(^|\\s)\\/\\w+/g, Tl = /@\\w+(\\.eth)?/g, Ll = /((https?:\\/\\/)?([a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})(\\/[^\\s]*)?)/g, Mu = new RegExp(`(${Rl.source})|(${Tl.source})|(${Ll.source})`, \"g\"), hm = (t) => Rl.test(t) ? `${Eu}/~/channel${t.trim()}` : Tl.test(t) ? `${Eu}/${t.substring(1)}` : Ll.test(t) ? t.startsWith(\"http\") ? t : `http://${t}` : \"\", dm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"a\")({\n  classes: [\"s4xymqs\"]\n}), pm = (t) => t.filter((e) => e.url).map((e) => e.url), mm = (t, e) => {\n  if (!t) return [];\n  const r = pm(e), n = [];\n  let o = 0, i;\n  for (; (i = Mu.exec(t)) !== null; ) {\n    const c = i.index;\n    o < c && n.push(t.slice(o, c));\n    const f = i[0].trim();\n    if (r.includes(f))\n      n.push(f);\n    else {\n      const v = hm(f);\n      n.push(/* @__PURE__ */ U.jsx(dm, {\n        href: v,\n        target: \"_blank\",\n        children: f\n      }, c));\n    }\n    o = Mu.lastIndex;\n  }\n  return o < t.length && n.push(t.slice(o)), n;\n}, Vt = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"be87m0m\"],\n  vars: {\n    \"be87m0m-0\": [(t, e = rr) => t.alignItems || \"flex-start\", !1],\n    \"be87m0m-1\": [(t, e = rr) => t.justifyContent || \"flex-start\", !1],\n    \"be87m0m-2\": [(t, e = rr) => t.flexGrow || \"initial\", !0],\n    \"be87m0m-3\": [(t, e = rr) => t.flexShrink || \"initial\", !0],\n    \"be87m0m-4\": [(t, e = rr) => t.spacing ?? t.spacingVertical ?? t.spacingTop ?? \"0px\", !1],\n    \"be87m0m-5\": [(t, e = rr) => t.spacing ?? t.spacingHorizontal ?? t.spacingRight ?? \"0px\", !1],\n    \"be87m0m-6\": [(t, e = rr) => t.spacing ?? t.spacingVertical ?? t.spacingBottom ?? \"0px\", !1],\n    \"be87m0m-7\": [(t, e = rr) => t.spacing ?? t.spacingHorizontal ?? t.spacingLeft ?? \"0px\", !1]\n  }\n}), gm = () => Vt, Ol = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(gm())({\n  classes: [\"v1lr8cv7\"]\n}), ym = () => Vt, Ht = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(ym())({\n  classes: [\"ha1dvpi\"]\n}), gn = \"https://sdk-api.neynar.com\", vm = \"https://api.allorigins.win/get\", Li = \"https://i.imgur.com/gxH8azy.png\";\nvar wm = {\n  SDK_VERSION: '\"1.2.3\"'\n};\nconst xm = wm.SDK_VERSION, yn = async (t, e = {}) => (e.headers = {\n  ...e.headers,\n  \"x-sdk\": \"react\",\n  \"x-sdk-version\": xm\n}, fetch(t, e));\nasync function bm({\n  type: t,\n  identifier: e,\n  viewerFid: r,\n  client_id: n\n}) {\n  try {\n    let o = `${gn}/v2/farcaster/cast?type=${t}&identifier=${e}${r ? `&viewer_fid=${r}` : \"\"}&client_id=${n}`;\n    const c = await (await yn(o)).json();\n    return (c == null ? void 0 : c.cast) || null;\n  } catch (o) {\n    return console.error(\"Error fetching cast by identifier\", o), null;\n  }\n}\nconst _m = ({\n  type: t,\n  identifier: e,\n  viewerFid: r,\n  allowReactions: n = !1,\n  renderEmbeds: o = !0,\n  renderFrames: i = !1,\n  onLikeBtnPress: c,\n  onRecastBtnPress: f,\n  onCommentBtnPress: v,\n  onFrameBtnPress: x,\n  containerStyles: b,\n  textStyles: S\n}) => {\n  var Q;\n  const {\n    client_id: T\n  } = lr(), [C, P] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), [B, R] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!0), [z, K] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), Z = (C == null ? void 0 : C.author.fid) === r;\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() => {\n    t && e && (R(!0), K(null), bm({\n      type: t,\n      identifier: e,\n      viewerFid: r,\n      client_id: T\n    }).then((j) => {\n      P(j);\n    }).catch((j) => {\n      K(j);\n    }).finally(() => {\n      R(!1);\n    }));\n  }, [t, e, r, T]), B ? /* @__PURE__ */ U.jsx(\"div\", {\n    children: \"Loading...\"\n  }) : !C || z ? /* @__PURE__ */ U.jsx(\"div\", {\n    children: \"Error: could not fetch cast data\"\n  }) : i && !x ? /* @__PURE__ */ U.jsx(\"div\", {\n    children: \"Error: onFrameBtnPress must be provided when renderEmbeds is true.\"\n  }) : /* @__PURE__ */ U.jsx(Rs, {\n    username: C.author.username,\n    displayName: C.author.display_name,\n    avatarImgUrl: C.author.pfp_url,\n    text: C.text,\n    hash: C.hash,\n    reactions: C.reactions,\n    replies: C.replies.count,\n    embeds: C.embeds ?? [],\n    frames: C.frames ?? [],\n    renderEmbeds: o,\n    renderFrames: i,\n    channel: C.channel ? {\n      id: C.channel.id,\n      name: C.channel.name,\n      url: C.parent_url\n    } : void 0,\n    viewerFid: r,\n    allowReactions: n,\n    hasPowerBadge: C.author.power_badge,\n    appAvatarImgUrl: ((Q = C.app) == null ? void 0 : Q.pfp_url) || null,\n    isOwnProfile: Z,\n    containerStyles: b,\n    textStyles: S,\n    onLikeBtnPress: c,\n    onRecastBtnPress: f,\n    onCommentBtnPress: v,\n    onFrameBtnPress: x,\n    timestamp: C.timestamp\n  });\n}, Em = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"a\")({\n  classes: [\"s1uo4lx4\"]\n}), yo = /* @__PURE__ */ new Map(), Xi = /* @__PURE__ */ new Map(), Cu = /* @__PURE__ */ new Map(), Su = (t) => new Promise((e) => setTimeout(e, t)), Nl = async (t, e = 0) => {\n  const r = new URL(t).hostname;\n  if (Cu.get(r))\n    return {\n      ogImage: \"\",\n      ogTitle: \"\",\n      ogDescription: \"\"\n    };\n  if (yo.has(t))\n    return yo.get(t);\n  if (Xi.has(t))\n    return Xi.get(t);\n  const n = (async () => {\n    try {\n      await Su(100);\n      const o = await fetch(`${vm}?url=${encodeURIComponent(t)}`, {\n        method: \"GET\"\n      });\n      if (!o.ok) {\n        if (o.status === 429 && e < 5) {\n          const R = Math.pow(2, e) * 1e3;\n          return await Su(R), Nl(t, e + 1);\n        }\n        throw Cu.set(r, !0), new Error(`Failed to fetch Open Graph data: ${o.statusText}`);\n      }\n      const i = await o.json(), f = new DOMParser().parseFromString(i.contents, \"text/html\"), v = f.querySelector('meta[property=\"og:image\"]'), x = f.querySelector('meta[property=\"og:title\"]'), b = f.querySelector('meta[property=\"og:description\"]'), S = f.querySelector(\"title\"), T = v && v.getAttribute(\"content\") || \"\", C = x ? x.getAttribute(\"content\") || \"\" : S ? S.innerText : \"\", P = b && b.getAttribute(\"content\") || \"\", B = {\n        ogImage: T,\n        ogTitle: C,\n        ogDescription: P\n      };\n      return yo.set(t, B), B;\n    } catch (o) {\n      return console.error(\"Error fetching Open Graph data\", o), {\n        ogImage: \"\",\n        ogTitle: \"\",\n        ogDescription: \"\"\n      };\n    } finally {\n      Xi.delete(t);\n    }\n  })();\n  return Xi.set(t, n), n;\n}, Do = [];\nlet vo = 0;\nconst Mm = 5, Cm = (t) => {\n  Do.push(t), jl();\n}, jl = async () => {\n  if (vo >= Mm || Do.length === 0)\n    return;\n  vo++;\n  const t = Do.shift();\n  t && await t(), vo--, jl();\n}, Sm = ({\n  src: t,\n  alt: e,\n  style: r\n}) => /* @__PURE__ */ U.jsx(\"img\", {\n  src: t,\n  alt: e,\n  style: {\n    display: \"block\",\n    height: \"auto\",\n    maxHeight: \"150px\",\n    width: \"auto\",\n    maxWidth: \"100%\",\n    objectFit: \"cover\",\n    border: \"1px solid grey\",\n    borderRadius: \"10px\",\n    margin: \"4px 0\",\n    ...r\n  }\n}), Am = ({\n  url: t\n}) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() => {\n    if (e.current)\n      if (hls_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isSupported() && t.endsWith(\".m3u8\")) {\n        const r = new hls_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        r.loadSource(t), r.attachMedia(e.current), r.on(hls_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Events.MANIFEST_PARSED, () => {\n          e.current.play();\n        });\n      } else\n        e.current.src = t, e.current.addEventListener(\"loadedmetadata\", () => {\n          e.current.play();\n        });\n  }, [t]), /* @__PURE__ */ U.jsx(\"video\", {\n    ref: e,\n    controls: !0,\n    muted: !0,\n    style: {\n      width: \"auto\",\n      maxWidth: \"100%\",\n      maxHeight: \"400px\",\n      borderRadius: \"10px\",\n      margin: \"10px 0\",\n      objectFit: \"contain\"\n    }\n  });\n}, km = (t) => /\\.(jpeg|jpg|gif|png|webp|bmp|svg)$/.test(t) || t.startsWith(\"https://imagedelivery.net\"), Im = (t, e, r) => {\n  const [n, o] = react__WEBPACK_IMPORTED_MODULE_0___default().useState([]), i = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(async (c) => (await Promise.all(c.map(async (v) => {\n    if (v.url) {\n      const x = v.url;\n      return km(x) ? /* @__PURE__ */ U.jsx(Sm, {\n        src: x,\n        alt: \"Embedded image\"\n      }, x) : x.endsWith(\".m3u8\") || x.endsWith(\".mp4\") ? /* @__PURE__ */ U.jsx(Am, {\n        url: x\n      }, x) : new Promise((b) => {\n        Cm(async () => {\n          const {\n            ogImage: S,\n            ogTitle: T\n          } = await Nl(x), C = new URL(x).hostname.replace(\"www.\", \"\");\n          b(/* @__PURE__ */ U.jsxs(Em, {\n            href: x,\n            target: \"_blank\",\n            rel: \"noreferrer\",\n            children: [S && /* @__PURE__ */ U.jsx(\"img\", {\n              src: S,\n              alt: T,\n              style: {\n                width: \"50px\",\n                height: \"50px\",\n                objectFit: \"cover\",\n                borderRadius: \"5px\"\n              }\n            }), /* @__PURE__ */ U.jsxs(\"div\", {\n              style: {\n                display: \"flex\",\n                flexDirection: \"column\"\n              },\n              children: [/* @__PURE__ */ U.jsx(\"p\", {\n                style: {\n                  margin: 0\n                },\n                children: T || x\n              }), /* @__PURE__ */ U.jsx(\"p\", {\n                style: {\n                  margin: 0,\n                  color: \"grey\",\n                  fontSize: \"12px\"\n                },\n                children: C\n              })]\n            })]\n          }, x));\n        });\n      });\n    } else if (v.cast_id)\n      return /* @__PURE__ */ U.jsx(\"div\", {\n        style: {\n          maxWidth: \"85%\"\n        },\n        children: /* @__PURE__ */ U.jsx(_m, {\n          type: \"hash\",\n          identifier: v.cast_id.hash,\n          viewerFid: r,\n          allowReactions: e,\n          renderEmbeds: !1\n        }, v.cast_id.fid)\n      }, `cast-${v.cast_id.hash}`);\n    return null;\n  }))).filter((v) => v !== null), [e, r]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() => {\n    i(t).then(o);\n  }, [t, i]), n;\n}, Bm = ({\n  onClick: t\n}) => /* @__PURE__ */ U.jsx(\"svg\", {\n  width: \"18\",\n  height: \"17\",\n  viewBox: \"0 0 18 17\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  onClick: (e) => t ? t(e) : void 0,\n  style: {\n    cursor: \"pointer\"\n  },\n  children: /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M6.22857 12.6828H7.01285C7.01285 12.2496 6.66172 11.8985 6.22857 11.8985V12.6828ZM6.22857 15.8199H5.4443C5.4443 16.1137 5.60848 16.3828 5.8697 16.5172C6.13092 16.6517 6.44537 16.6288 6.68443 16.4581L6.22857 15.8199ZM10.6205 12.6828V11.8985C10.4571 11.8985 10.2977 11.9496 10.1647 12.0446L10.6205 12.6828ZM1.78428 3.27146C1.78428 2.54955 2.3695 1.96433 3.09141 1.96433V0.395777C1.50321 0.395777 0.215723 1.68327 0.215723 3.27146H1.78428ZM1.78428 10.5914V3.27146H0.215723V10.5914H1.78428ZM3.0914 11.8985C2.3695 11.8985 1.78428 11.3133 1.78428 10.5914H0.215723C0.215723 12.1796 1.50321 13.4671 3.0914 13.4671V11.8985ZM6.22857 11.8985H3.0914V13.4671H6.22857V11.8985ZM7.01285 15.8199V12.6828H5.4443V15.8199H7.01285ZM10.1647 12.0446L5.77272 15.1817L6.68443 16.4581L11.0764 13.321L10.1647 12.0446ZM14.5941 11.8985H10.6205V13.4671H14.5941V11.8985ZM15.9013 10.5914C15.9013 11.3133 15.316 11.8985 14.5941 11.8985V13.4671C16.1823 13.4671 17.4698 12.1796 17.4698 10.5914H15.9013ZM15.9013 3.27146V10.5914H17.4698V3.27146H15.9013ZM14.5941 1.96433C15.316 1.96433 15.9013 2.54955 15.9013 3.27146H17.4698C17.4698 1.68326 16.1823 0.395777 14.5941 0.395777V1.96433ZM3.09141 1.96433H14.5941V0.395777H3.09141V1.96433Z\",\n    fill: \"#A0A3AD\"\n  })\n}), Rm = ({\n  fill: t,\n  onClick: e\n}) => /* @__PURE__ */ U.jsxs(\"svg\", {\n  width: \"16\",\n  height: \"15\",\n  viewBox: \"0 0 16 15\",\n  fill: t || \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  onClick: (r) => e ? e(r) : void 0,\n  style: {\n    cursor: \"pointer\"\n  },\n  children: [/* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M14.9245 14.2506C14.7258 14.2506 14.5352 14.1716 14.3946 14.0311C14.2541 13.8905 14.1751 13.6999 14.1751 13.5011V10.5034H11.1774C10.9787 10.5034 10.7881 10.4245 10.6475 10.2839C10.507 10.1434 10.428 9.95279 10.428 9.75403C10.428 9.55527 10.507 9.36465 10.6475 9.22411C10.7881 9.08357 10.9787 9.00461 11.1774 9.00461H14.9245C15.1233 9.00461 15.3139 9.08357 15.4545 9.22411C15.595 9.36465 15.674 9.55527 15.674 9.75403V13.5011C15.674 13.6999 15.595 13.8905 15.4545 14.0311C15.3139 14.1716 15.1233 14.2506 14.9245 14.2506ZM5.18207 6.00693H1.43497C1.23621 6.00693 1.04559 5.92797 0.905047 5.78743C0.764503 5.64688 0.685547 5.45627 0.685547 5.25751V1.51041C0.685547 1.31165 0.764503 1.12103 0.905047 0.980486C1.04559 0.839943 1.23621 0.760986 1.43497 0.760986C1.63373 0.760986 1.82434 0.839943 1.96489 0.980486C2.10543 1.12103 2.18439 1.31165 2.18439 1.51041V4.50809H5.18207C5.38083 4.50809 5.57145 4.58704 5.71199 4.72759C5.85253 4.86813 5.93149 5.05875 5.93149 5.25751C5.93149 5.45627 5.85253 5.64688 5.71199 5.78743C5.57145 5.92797 5.38083 6.00693 5.18207 6.00693Z\",\n    fill: t || \"#A0A3AD\"\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M8.17934 15C6.33556 15.0003 4.55637 14.3209 3.18205 13.0918C1.80774 11.8627 0.934766 10.17 0.730106 8.33765C0.719281 8.23923 0.727945 8.13965 0.755606 8.04458C0.783266 7.94951 0.82938 7.86083 0.891315 7.78358C1.0164 7.62758 1.19833 7.52765 1.39709 7.50579C1.59585 7.48393 1.79515 7.54191 1.95116 7.667C2.10716 7.79208 2.20708 7.97401 2.22895 8.17277C2.37708 9.52376 2.97983 10.7843 3.93838 11.7478C4.89692 12.7113 6.15438 13.3205 7.50459 13.4755C8.85479 13.6306 10.2176 13.3223 11.3696 12.6012C12.5216 11.8801 13.3944 10.789 13.845 9.50674C13.8731 9.40817 13.9211 9.31642 13.986 9.23714C14.051 9.15787 14.1316 9.09277 14.2227 9.04586C14.3138 8.99895 14.4136 8.97123 14.5159 8.96442C14.6181 8.95761 14.7207 8.97185 14.8173 9.00625C14.9138 9.04066 15.0023 9.09451 15.0772 9.16446C15.1521 9.23442 15.2118 9.31899 15.2528 9.41296C15.2937 9.50693 15.3149 9.6083 15.3151 9.71079C15.3153 9.81329 15.2944 9.91473 15.2539 10.0089C14.7359 11.4705 13.7774 12.7355 12.5103 13.6294C11.2432 14.5233 9.73002 15.0022 8.17934 15ZM14.8792 7.50579C14.6939 7.50691 14.5148 7.43937 14.3764 7.3162C14.238 7.19302 14.1501 7.02295 14.1297 6.8388C13.975 5.49429 13.3699 4.24169 12.4128 3.28476C11.4558 2.32782 10.2031 1.72285 8.85858 1.56824C7.51405 1.41364 6.15676 1.7185 5.0075 2.43324C3.85823 3.14798 2.9846 4.23054 2.52872 5.50484C2.50062 5.6034 2.4526 5.69516 2.38763 5.77443C2.32266 5.85371 2.24212 5.91881 2.15099 5.96572C2.05987 6.01263 1.96008 6.04035 1.85781 6.04716C1.75555 6.05397 1.65297 6.03973 1.55642 6.00532C1.45988 5.97092 1.37141 5.91707 1.29651 5.84712C1.2216 5.77716 1.16183 5.69258 1.12091 5.59861C1.07999 5.50464 1.05878 5.40328 1.05859 5.30078C1.0584 5.19829 1.07923 5.09685 1.1198 5.00273C1.68406 3.40202 2.77497 2.04025 4.21397 1.14029C5.65297 0.240337 7.35485 -0.144505 9.04106 0.0487522C10.7273 0.242009 12.2979 1.00192 13.496 2.20411C14.6941 3.4063 15.4486 4.97958 15.6361 6.66644C15.6571 6.86306 15.5997 7.06004 15.4761 7.21445C15.3526 7.36887 15.173 7.4682 14.9766 7.4908L14.8792 7.50579Z\",\n    fill: t || \"#A0A3AD\"\n  })]\n}), Tm = ({\n  fill: t,\n  onClick: e\n}) => /* @__PURE__ */ U.jsxs(\"svg\", {\n  width: \"17\",\n  height: \"15\",\n  viewBox: \"0 0 17 15\",\n  fill: t ? \"red\" : \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  onClick: (r) => e ? e(r) : void 0,\n  style: {\n    cursor: \"pointer\"\n  },\n  children: [/* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M13.8719 2.25042L14.2947 1.58984L13.8719 2.25042C15.2467 3.13022 15.7676 5.22206 14.8856 7.61317C14.0436 9.89583 11.9555 12.2374 8.51573 13.3648C5.07606 12.2374 2.98799 9.89584 2.14596 7.61316C1.26392 5.22203 1.7848 3.13022 3.15951 2.25042L3.15951 2.25042C4.58542 1.33783 5.64997 1.52983 6.39945 1.92503C7.21272 2.35388 7.73108 3.07114 7.86143 3.26838L8.51573 4.25838L9.17002 3.26838C9.30038 3.07113 9.81873 2.35388 10.632 1.92503C11.3815 1.52983 12.446 1.33783 13.8719 2.25042Z\",\n    stroke: t || \"#A0A3AD\",\n    strokeWidth: \"1.56855\"\n  }), /* @__PURE__ */ U.jsx(\"mask\", {\n    id: \"path-2-inside-1_187_1051\",\n    fill: \"white\",\n    children: /* @__PURE__ */ U.jsx(\"path\", {\n      d: \"M8.58444 13.9397C7.76139 13.6864 7.05334 13.3937 6.29976 12.9825C5.95633 12.7951 5.62285 12.5895 5.3003 12.3681C5.14416 12.2609 4.99108 12.1493 4.84063 12.0343C4.78132 11.9889 4.88038 12.0652 4.82156 12.0195C4.80388 12.0058 4.7863 11.9919 4.76869 11.9781C4.73364 11.9505 4.69884 11.9225 4.66413 11.8945C4.58948 11.8342 4.51582 11.7727 4.4428 11.7105C3.90499 11.252 3.41381 10.7389 2.98016 10.1809C3.01856 10.2303 2.97651 10.176 2.97064 10.1683C2.9583 10.1522 2.94604 10.1359 2.9338 10.1197C2.90939 10.0874 2.88527 10.0548 2.86126 10.0221C2.80961 9.95189 2.75908 9.8808 2.70932 9.8092C2.61492 9.67345 2.52441 9.535 2.4371 9.39457C2.2673 9.12145 2.11213 8.83926 1.97147 8.55006C1.93849 8.48228 1.90657 8.41396 1.87531 8.34537C1.85978 8.3113 1.84459 8.27709 1.82948 8.24284C1.82195 8.22575 1.81456 8.20864 1.80714 8.19152C1.80167 8.17889 1.76856 8.10061 1.79664 8.16736C1.73728 8.0262 1.68205 7.88329 1.63029 7.73916C1.52982 7.45942 1.44498 7.17407 1.37575 6.88502C1.34218 6.74492 1.31301 6.60379 1.28746 6.46202C1.2754 6.39502 1.2645 6.32782 1.2543 6.26052C1.24925 6.22713 1.24453 6.19369 1.23994 6.16023C1.25136 6.24358 1.23495 6.11772 1.23231 6.09532C1.20042 5.82444 1.18535 5.55158 1.18721 5.27885C1.18811 5.14691 1.19374 5.01501 1.20334 4.88343C1.20788 4.82128 1.21368 4.75922 1.22023 4.69726C1.2235 4.66651 1.22713 4.6358 1.23089 4.60511C1.23278 4.58982 1.23477 4.57457 1.23678 4.5593C1.22562 4.64425 1.23563 4.56956 1.23823 4.55163C1.27428 4.30419 1.32861 4.05943 1.40097 3.82006C1.43614 3.70375 1.47635 3.58899 1.52072 3.47587C1.53125 3.449 1.54219 3.42229 1.55326 3.39564C1.51941 3.47716 1.55889 3.38334 1.56717 3.36464C1.59226 3.30803 1.61886 3.25209 1.64643 3.19664C1.75101 2.98624 1.87476 2.78549 2.01534 2.59724C2.02371 2.58603 2.03221 2.57492 2.04071 2.5638C1.99275 2.62656 2.02446 2.58496 2.03493 2.57169C2.05223 2.54974 2.06993 2.52808 2.08773 2.50653C2.12631 2.45984 2.16629 2.41434 2.20713 2.36962C2.28587 2.28341 2.36926 2.20151 2.456 2.12339C2.49787 2.08568 2.54084 2.0492 2.58443 2.01352C2.60631 1.99561 2.62852 1.97808 2.65084 1.9607C2.58164 2.01466 2.67191 1.94557 2.68962 1.93265C2.83338 1.8277 2.98587 1.7348 3.14013 1.6463C3.54393 1.41459 3.92437 1.25567 4.3831 1.15072C4.47716 1.12921 4.57219 1.11204 4.6676 1.09771C4.74483 1.08611 4.61527 1.10399 4.69217 1.09444C4.71513 1.0916 4.73817 1.08917 4.76119 1.08677C4.81403 1.08124 4.86704 1.07739 4.92007 1.07423C5.10084 1.06348 5.28237 1.06851 5.46252 1.0864C5.48336 1.08846 5.50417 1.09092 5.52495 1.09338C5.59508 1.10167 5.46943 1.08526 5.53899 1.09521C5.57965 1.10103 5.62016 1.10795 5.66059 1.11524C5.74647 1.13073 5.83159 1.1503 5.91604 1.17227C6.0728 1.21311 6.22621 1.26621 6.37595 1.32786C6.31111 1.30115 6.41877 1.34702 6.43584 1.35477C6.46987 1.3702 6.50356 1.38639 6.53714 1.4028C6.60865 1.43779 6.67886 1.47543 6.74817 1.51462C6.87662 1.58723 7.00062 1.66753 7.12092 1.7529C7.14882 1.77271 7.17637 1.79297 7.20383 1.81338C7.21739 1.82348 7.23087 1.8337 7.24432 1.84396C7.29158 1.87992 7.1988 1.80839 7.24529 1.84482C7.30109 1.88853 7.35568 1.93375 7.40949 1.97982C7.50652 2.06288 7.59994 2.15008 7.69053 2.24011C7.84008 2.38879 7.98044 2.54677 8.11149 2.71194C8.12572 2.72987 8.17533 2.79414 8.11485 2.7157C8.12636 2.73065 8.13776 2.74568 8.1491 2.76075C8.1694 2.78769 8.18934 2.81491 8.20905 2.8423C8.23825 2.88286 8.2667 2.92398 8.29429 2.96566C8.40374 3.131 8.6286 3.131 8.73805 2.96566C8.76707 2.92181 8.79712 2.87866 8.82785 2.83598C8.84783 2.80823 8.86819 2.78075 8.88875 2.75344C8.90242 2.73529 8.94928 2.67474 8.88935 2.75214C8.90409 2.73312 8.919 2.71424 8.93399 2.69542C9.0671 2.52834 9.21071 2.36968 9.36261 2.21954C9.45411 2.12907 9.5493 2.04234 9.64732 1.95897C9.69737 1.91641 9.74847 1.87507 9.80017 1.83456C9.7388 1.88263 9.82694 1.81457 9.84213 1.80327C9.87427 1.77937 9.90683 1.75606 9.9396 1.73301C10.0608 1.64773 10.1866 1.56915 10.3159 1.49682C10.3802 1.46084 10.4457 1.42703 10.5119 1.39467C10.5455 1.37823 10.5795 1.36251 10.6136 1.34704C10.6308 1.33926 10.6481 1.33171 10.6654 1.32417C10.6915 1.31296 10.6885 1.3142 10.6564 1.3279C10.6681 1.32303 10.6798 1.31822 10.6916 1.31349C10.8423 1.25235 10.9973 1.20246 11.1548 1.16239C11.2332 1.14248 11.3123 1.12599 11.3918 1.11166C11.4323 1.10435 11.473 1.09815 11.5138 1.09231C11.4471 1.10186 11.5171 1.09226 11.5281 1.09095C11.5559 1.08767 11.5838 1.08499 11.6117 1.0824C11.793 1.06553 11.9757 1.06513 12.1573 1.0771C12.203 1.08011 12.2485 1.08444 12.294 1.08921C12.3172 1.09163 12.3402 1.0945 12.3633 1.09734C12.3036 1.08994 12.3813 1.10022 12.3881 1.10123C12.4921 1.11685 12.5952 1.13785 12.6975 1.16193C13.1586 1.27048 13.5378 1.44037 13.9464 1.67761C14.0904 1.76129 14.2314 1.8507 14.3656 1.9495C14.377 1.95791 14.3884 1.96648 14.3997 1.97503C14.4419 2.00688 14.351 1.93696 14.3926 1.96945C14.4149 1.98683 14.4369 2.00462 14.4588 2.02252C14.5059 2.06115 14.5519 2.1013 14.5971 2.14228C14.6835 2.22073 14.7656 2.30388 14.8439 2.39035C14.8815 2.43176 14.9178 2.47427 14.9534 2.51736C14.9712 2.53891 14.9887 2.56077 15.006 2.58274C15.0384 2.62388 14.9682 2.53335 15 2.575C15.0114 2.58983 15.0225 2.60479 15.0336 2.61978C15.1736 2.80871 15.2946 3.01142 15.3985 3.22224C15.4238 3.27356 15.4477 3.32553 15.4709 3.37782C15.4767 3.39096 15.4824 3.40414 15.4881 3.41734C15.5093 3.46656 15.464 3.35945 15.4845 3.40902C15.4975 3.44013 15.5099 3.47148 15.5221 3.50289C15.5661 3.61632 15.6049 3.73175 15.6398 3.84833C15.7115 4.08832 15.763 4.33416 15.7984 4.58204C15.8064 4.63806 15.7901 4.51842 15.7975 4.57463C15.7995 4.58992 15.8014 4.60521 15.8033 4.6205C15.807 4.6512 15.8104 4.68197 15.8137 4.71273C15.8208 4.77994 15.8264 4.84732 15.8312 4.91474C15.8404 5.04658 15.8447 5.17876 15.8453 5.31093C15.8464 5.58418 15.8287 5.85737 15.7961 6.12862C15.7941 6.14529 15.7919 6.16192 15.7898 6.17856C15.7822 6.23827 15.7983 6.11722 15.7901 6.17697C15.7855 6.21044 15.7806 6.24389 15.7755 6.27731C15.7644 6.35031 15.752 6.4231 15.7388 6.49573C15.7129 6.63769 15.6823 6.7788 15.6484 6.91905C15.5784 7.20843 15.4909 7.49348 15.3897 7.77343C15.3648 7.84232 15.3388 7.9108 15.3121 7.97902C15.2987 8.01338 15.2849 8.0476 15.2711 8.08179C15.2641 8.09896 15.257 8.11604 15.25 8.13315C15.2452 8.14458 15.2405 8.15598 15.2357 8.16738C15.2496 8.13453 15.251 8.13117 15.2399 8.15734C15.1786 8.30137 15.1131 8.44355 15.0443 8.58416C14.9028 8.87351 14.7451 9.15483 14.5745 9.42799C14.4868 9.56844 14.395 9.70634 14.3002 9.84213C14.254 9.90821 14.2069 9.97355 14.1592 10.0385C14.1351 10.0711 14.1108 10.1036 14.0864 10.136C14.0741 10.1522 14.0617 10.1684 14.0494 10.1845C14.0319 10.2073 14.0329 10.2061 14.0522 10.181C14.0439 10.1918 14.0355 10.2025 14.0271 10.2132C13.8135 10.4869 13.5849 10.7488 13.3445 10.9992C13.0948 11.2594 12.8309 11.5058 12.556 11.7391C12.4884 11.7965 12.4199 11.8528 12.3509 11.9086C12.3162 11.9366 12.2812 11.9643 12.2461 11.992C12.2285 12.0058 12.2108 12.0196 12.1931 12.0333C12.2377 11.9987 12.1636 12.0558 12.156 12.0616C12.005 12.1765 11.8508 12.2871 11.6942 12.3941C11.3706 12.6153 11.0348 12.8185 10.6904 13.0055C10.5122 13.1023 10.3313 13.1939 10.1484 13.2815C10.059 13.3243 9.96904 13.3658 9.87868 13.4064C9.8331 13.4269 9.78733 13.4469 9.74151 13.4669C9.7185 13.4769 9.69541 13.4868 9.67233 13.4966C9.6442 13.5086 9.64146 13.5098 9.66417 13.5002C9.64864 13.5067 9.63313 13.5132 9.61758 13.5196C9.2349 13.6788 8.84398 13.8179 8.44786 13.9398C8.31409 13.9809 8.2304 14.1178 8.26839 14.2559C8.3047 14.3878 8.45064 14.4765 8.5845 14.4353C10.1534 13.9525 11.626 13.1871 12.8857 12.131C13.9425 11.245 14.8349 10.1456 15.4543 8.91165C15.9942 7.83608 16.3357 6.64744 16.3583 5.43967C16.3774 4.41628 16.149 3.35704 15.5742 2.49789C15.2929 2.07732 14.9371 1.71816 14.5205 1.43134C13.7956 0.932295 12.9294 0.592822 12.045 0.557214C10.7717 0.505949 9.60126 1.17157 8.7697 2.09685C8.59779 2.28813 8.43634 2.49172 8.29431 2.70629C8.44223 2.70629 8.59015 2.70629 8.73807 2.70629C8.22434 1.93023 7.48255 1.25338 6.6264 0.880424C5.9305 0.577258 5.18555 0.490164 4.43721 0.617179C3.98766 0.69348 3.55546 0.856508 3.14849 1.05915C2.81945 1.22296 2.50653 1.41842 2.22115 1.65017C1.44904 2.27713 0.973026 3.20995 0.783732 4.17519C0.56509 5.29004 0.68737 6.45381 1.02051 7.53339C1.41084 8.79827 2.09407 9.95916 2.95641 10.9589C3.94757 12.1081 5.19614 13.0306 6.5582 13.6933C7.16712 13.9896 7.8008 14.2362 8.44788 14.4353C8.58174 14.4765 8.72768 14.3878 8.76399 14.2559C8.80189 14.1177 8.71821 13.9809 8.58444 13.9397Z\"\n    })\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M8.58444 13.9397C7.76139 13.6864 7.05334 13.3937 6.29976 12.9825C5.95633 12.7951 5.62285 12.5895 5.3003 12.3681C5.14416 12.2609 4.99108 12.1493 4.84063 12.0343C4.78132 11.9889 4.88038 12.0652 4.82156 12.0195C4.80388 12.0058 4.7863 11.9919 4.76869 11.9781C4.73364 11.9505 4.69884 11.9225 4.66413 11.8945C4.58948 11.8342 4.51582 11.7727 4.4428 11.7105C3.90499 11.252 3.41381 10.7389 2.98016 10.1809C3.01856 10.2303 2.97651 10.176 2.97064 10.1683C2.9583 10.1522 2.94604 10.1359 2.9338 10.1197C2.90939 10.0874 2.88527 10.0548 2.86126 10.0221C2.80961 9.95189 2.75908 9.8808 2.70932 9.8092C2.61492 9.67345 2.52441 9.535 2.4371 9.39457C2.2673 9.12145 2.11213 8.83926 1.97147 8.55006C1.93849 8.48228 1.90657 8.41396 1.87531 8.34537C1.85978 8.3113 1.84459 8.27709 1.82948 8.24284C1.82195 8.22575 1.81456 8.20864 1.80714 8.19152C1.80167 8.17889 1.76856 8.10061 1.79664 8.16736C1.73728 8.0262 1.68205 7.88329 1.63029 7.73916C1.52982 7.45942 1.44498 7.17407 1.37575 6.88502C1.34218 6.74492 1.31301 6.60379 1.28746 6.46202C1.2754 6.39502 1.2645 6.32782 1.2543 6.26052C1.24925 6.22713 1.24453 6.19369 1.23994 6.16023C1.25136 6.24358 1.23495 6.11772 1.23231 6.09532C1.20042 5.82444 1.18535 5.55158 1.18721 5.27885C1.18811 5.14691 1.19374 5.01501 1.20334 4.88343C1.20788 4.82128 1.21368 4.75922 1.22023 4.69726C1.2235 4.66651 1.22713 4.6358 1.23089 4.60511C1.23278 4.58982 1.23477 4.57457 1.23678 4.5593C1.22562 4.64425 1.23563 4.56956 1.23823 4.55163C1.27428 4.30419 1.32861 4.05943 1.40097 3.82006C1.43614 3.70375 1.47635 3.58899 1.52072 3.47587C1.53125 3.449 1.54219 3.42229 1.55326 3.39564C1.51941 3.47716 1.55889 3.38334 1.56717 3.36464C1.59226 3.30803 1.61886 3.25209 1.64643 3.19664C1.75101 2.98624 1.87476 2.78549 2.01534 2.59724C2.02371 2.58603 2.03221 2.57492 2.04071 2.5638C1.99275 2.62656 2.02446 2.58496 2.03493 2.57169C2.05223 2.54974 2.06993 2.52808 2.08773 2.50653C2.12631 2.45984 2.16629 2.41434 2.20713 2.36962C2.28587 2.28341 2.36926 2.20151 2.456 2.12339C2.49787 2.08568 2.54084 2.0492 2.58443 2.01352C2.60631 1.99561 2.62852 1.97808 2.65084 1.9607C2.58164 2.01466 2.67191 1.94557 2.68962 1.93265C2.83338 1.8277 2.98587 1.7348 3.14013 1.6463C3.54393 1.41459 3.92437 1.25567 4.3831 1.15072C4.47716 1.12921 4.57219 1.11204 4.6676 1.09771C4.74483 1.08611 4.61527 1.10399 4.69217 1.09444C4.71513 1.0916 4.73817 1.08917 4.76119 1.08677C4.81403 1.08124 4.86704 1.07739 4.92007 1.07423C5.10084 1.06348 5.28237 1.06851 5.46252 1.0864C5.48336 1.08846 5.50417 1.09092 5.52495 1.09338C5.59508 1.10167 5.46943 1.08526 5.53899 1.09521C5.57965 1.10103 5.62016 1.10795 5.66059 1.11524C5.74647 1.13073 5.83159 1.1503 5.91604 1.17227C6.0728 1.21311 6.22621 1.26621 6.37595 1.32786C6.31111 1.30115 6.41877 1.34702 6.43584 1.35477C6.46987 1.3702 6.50356 1.38639 6.53714 1.4028C6.60865 1.43779 6.67886 1.47543 6.74817 1.51462C6.87662 1.58723 7.00062 1.66753 7.12092 1.7529C7.14882 1.77271 7.17637 1.79297 7.20383 1.81338C7.21739 1.82348 7.23087 1.8337 7.24432 1.84396C7.29158 1.87992 7.1988 1.80839 7.24529 1.84482C7.30109 1.88853 7.35568 1.93375 7.40949 1.97982C7.50652 2.06288 7.59994 2.15008 7.69053 2.24011C7.84008 2.38879 7.98044 2.54677 8.11149 2.71194C8.12572 2.72987 8.17533 2.79414 8.11485 2.7157C8.12636 2.73065 8.13776 2.74568 8.1491 2.76075C8.1694 2.78769 8.18934 2.81491 8.20905 2.8423C8.23825 2.88286 8.2667 2.92398 8.29429 2.96566C8.40374 3.131 8.6286 3.131 8.73805 2.96566C8.76707 2.92181 8.79712 2.87866 8.82785 2.83598C8.84783 2.80823 8.86819 2.78075 8.88875 2.75344C8.90242 2.73529 8.94928 2.67474 8.88935 2.75214C8.90409 2.73312 8.919 2.71424 8.93399 2.69542C9.0671 2.52834 9.21071 2.36968 9.36261 2.21954C9.45411 2.12907 9.5493 2.04234 9.64732 1.95897C9.69737 1.91641 9.74847 1.87507 9.80017 1.83456C9.7388 1.88263 9.82694 1.81457 9.84213 1.80327C9.87427 1.77937 9.90683 1.75606 9.9396 1.73301C10.0608 1.64773 10.1866 1.56915 10.3159 1.49682C10.3802 1.46084 10.4457 1.42703 10.5119 1.39467C10.5455 1.37823 10.5795 1.36251 10.6136 1.34704C10.6308 1.33926 10.6481 1.33171 10.6654 1.32417C10.6915 1.31296 10.6885 1.3142 10.6564 1.3279C10.6681 1.32303 10.6798 1.31822 10.6916 1.31349C10.8423 1.25235 10.9973 1.20246 11.1548 1.16239C11.2332 1.14248 11.3123 1.12599 11.3918 1.11166C11.4323 1.10435 11.473 1.09815 11.5138 1.09231C11.4471 1.10186 11.5171 1.09226 11.5281 1.09095C11.5559 1.08767 11.5838 1.08499 11.6117 1.0824C11.793 1.06553 11.9757 1.06513 12.1573 1.0771C12.203 1.08011 12.2485 1.08444 12.294 1.08921C12.3172 1.09163 12.3402 1.0945 12.3633 1.09734C12.3036 1.08994 12.3813 1.10022 12.3881 1.10123C12.4921 1.11685 12.5952 1.13785 12.6975 1.16193C13.1586 1.27048 13.5378 1.44037 13.9464 1.67761C14.0904 1.76129 14.2314 1.8507 14.3656 1.9495C14.377 1.95791 14.3884 1.96648 14.3997 1.97503C14.4419 2.00688 14.351 1.93696 14.3926 1.96945C14.4149 1.98683 14.4369 2.00462 14.4588 2.02252C14.5059 2.06115 14.5519 2.1013 14.5971 2.14228C14.6835 2.22073 14.7656 2.30388 14.8439 2.39035C14.8815 2.43176 14.9178 2.47427 14.9534 2.51736C14.9712 2.53891 14.9887 2.56077 15.006 2.58274C15.0384 2.62388 14.9682 2.53335 15 2.575C15.0114 2.58983 15.0225 2.60479 15.0336 2.61978C15.1736 2.80871 15.2946 3.01142 15.3985 3.22224C15.4238 3.27356 15.4477 3.32553 15.4709 3.37782C15.4767 3.39096 15.4824 3.40414 15.4881 3.41734C15.5093 3.46656 15.464 3.35945 15.4845 3.40902C15.4975 3.44013 15.5099 3.47148 15.5221 3.50289C15.5661 3.61632 15.6049 3.73175 15.6398 3.84833C15.7115 4.08832 15.763 4.33416 15.7984 4.58204C15.8064 4.63806 15.7901 4.51842 15.7975 4.57463C15.7995 4.58992 15.8014 4.60521 15.8033 4.6205C15.807 4.6512 15.8104 4.68197 15.8137 4.71273C15.8208 4.77994 15.8264 4.84732 15.8312 4.91474C15.8404 5.04658 15.8447 5.17876 15.8453 5.31093C15.8464 5.58418 15.8287 5.85737 15.7961 6.12862C15.7941 6.14529 15.7919 6.16192 15.7898 6.17856C15.7822 6.23827 15.7983 6.11722 15.7901 6.17697C15.7855 6.21044 15.7806 6.24389 15.7755 6.27731C15.7644 6.35031 15.752 6.4231 15.7388 6.49573C15.7129 6.63769 15.6823 6.7788 15.6484 6.91905C15.5784 7.20843 15.4909 7.49348 15.3897 7.77343C15.3648 7.84232 15.3388 7.9108 15.3121 7.97902C15.2987 8.01338 15.2849 8.0476 15.2711 8.08179C15.2641 8.09896 15.257 8.11604 15.25 8.13315C15.2452 8.14458 15.2405 8.15598 15.2357 8.16738C15.2496 8.13453 15.251 8.13117 15.2399 8.15734C15.1786 8.30137 15.1131 8.44355 15.0443 8.58416C14.9028 8.87351 14.7451 9.15483 14.5745 9.42799C14.4868 9.56844 14.395 9.70634 14.3002 9.84213C14.254 9.90821 14.2069 9.97355 14.1592 10.0385C14.1351 10.0711 14.1108 10.1036 14.0864 10.136C14.0741 10.1522 14.0617 10.1684 14.0494 10.1845C14.0319 10.2073 14.0329 10.2061 14.0522 10.181C14.0439 10.1918 14.0355 10.2025 14.0271 10.2132C13.8135 10.4869 13.5849 10.7488 13.3445 10.9992C13.0948 11.2594 12.8309 11.5058 12.556 11.7391C12.4884 11.7965 12.4199 11.8528 12.3509 11.9086C12.3162 11.9366 12.2812 11.9643 12.2461 11.992C12.2285 12.0058 12.2108 12.0196 12.1931 12.0333C12.2377 11.9987 12.1636 12.0558 12.156 12.0616C12.005 12.1765 11.8508 12.2871 11.6942 12.3941C11.3706 12.6153 11.0348 12.8185 10.6904 13.0055C10.5122 13.1023 10.3313 13.1939 10.1484 13.2815C10.059 13.3243 9.96904 13.3658 9.87868 13.4064C9.8331 13.4269 9.78733 13.4469 9.74151 13.4669C9.7185 13.4769 9.69541 13.4868 9.67233 13.4966C9.6442 13.5086 9.64146 13.5098 9.66417 13.5002C9.64864 13.5067 9.63313 13.5132 9.61758 13.5196C9.2349 13.6788 8.84398 13.8179 8.44786 13.9398C8.31409 13.9809 8.2304 14.1178 8.26839 14.2559C8.3047 14.3878 8.45064 14.4765 8.5845 14.4353C10.1534 13.9525 11.626 13.1871 12.8857 12.131C13.9425 11.245 14.8349 10.1456 15.4543 8.91165C15.9942 7.83608 16.3357 6.64744 16.3583 5.43967C16.3774 4.41628 16.149 3.35704 15.5742 2.49789C15.2929 2.07732 14.9371 1.71816 14.5205 1.43134C13.7956 0.932295 12.9294 0.592822 12.045 0.557214C10.7717 0.505949 9.60126 1.17157 8.7697 2.09685C8.59779 2.28813 8.43634 2.49172 8.29431 2.70629C8.44223 2.70629 8.59015 2.70629 8.73807 2.70629C8.22434 1.93023 7.48255 1.25338 6.6264 0.880424C5.9305 0.577258 5.18555 0.490164 4.43721 0.617179C3.98766 0.69348 3.55546 0.856508 3.14849 1.05915C2.81945 1.22296 2.50653 1.41842 2.22115 1.65017C1.44904 2.27713 0.973026 3.20995 0.783732 4.17519C0.56509 5.29004 0.68737 6.45381 1.02051 7.53339C1.41084 8.79827 2.09407 9.95916 2.95641 10.9589C3.94757 12.1081 5.19614 13.0306 6.5582 13.6933C7.16712 13.9896 7.8008 14.2362 8.44788 14.4353C8.58174 14.4765 8.72768 14.3878 8.76399 14.2559C8.80189 14.1177 8.71821 13.9809 8.58444 13.9397Z\",\n    stroke: t || \"#A0A3AD\",\n    strokeWidth: \"3.13711\",\n    mask: \"url(#path-2-inside-1_187_1051)\"\n  })]\n});\nfunction Ul({\n  onClick: t,\n  size: e = 24\n}) {\n  return /* @__PURE__ */ U.jsx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    focusable: \"false\",\n    role: \"img\",\n    viewBox: \"0 0 16 16\",\n    width: e,\n    height: e,\n    fill: \"#4A4A4A\",\n    style: {\n      display: \"inline-block\",\n      userSelect: \"none\",\n      verticalAlign: \"text-bottom\",\n      overflow: \"visible\",\n      cursor: \"pointer\",\n      padding: \"4px\"\n    },\n    onClick: t,\n    children: /* @__PURE__ */ U.jsx(\"path\", {\n      d: \"M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734L9.06 8l3.22 3.22a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215L8 9.06l-3.22 3.22a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z\"\n    })\n  });\n}\nconst Lm = () => Vt, Om = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(Lm())({\n  classes: [\"rect7e5\"]\n}), Nm = () => Vt, jm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(Nm())({\n  classes: [\"p13mqntt\"]\n}), Um = () => Vt, Fm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(Um())({\n  classes: [\"p1r47dz2\"]\n}), Pm = () => Vt, Dm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(Pm())({\n  classes: [\"cnojpqv\"]\n}), $m = ({\n  hash: t,\n  reactions: e,\n  onComment: r,\n  onRecast: n,\n  onLike: o,\n  isLiked: i\n}) => {\n  const {\n    client_id: c,\n    user: f,\n    isAuthenticated: v\n  } = lr(), [x, b] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!1), [S, T] = react__WEBPACK_IMPORTED_MODULE_0___default().useState({\n    top: 0,\n    left: 0\n  }), [C, P] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), [B, R] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(i), [z, K] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!1), Z = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null), Q = react__WEBPACK_IMPORTED_MODULE_0___default().useRef({\n    comment: null,\n    recast: null,\n    like: null\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    R(e.likes.some((V) => V.fid === (f == null ? void 0 : f.fid))), K(e.recasts.some((V) => V.fid === (f == null ? void 0 : f.fid)));\n  }, [e, f]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const V = localStorage.getItem(Zn.NEYNAR_AUTHENTICATED_USER);\n    if (V)\n      try {\n        P(JSON.parse(V).signer_uuid);\n      } catch (ee) {\n        console.error(\"Error parsing JSON from local storage:\", ee), P(null);\n      }\n    else\n      console.warn(\"No NEYNAR_AUTHENTICATED_USER found in local storage.\");\n  }, [v]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (C || v) && x && b(!1);\n  }, [C, v, x]);\n  const j = async (V, ee) => {\n    if (C)\n      switch (ee) {\n        case \"comment\":\n          if (r)\n            r();\n          else\n            throw new Error(\"No comment handler function provided\");\n          break;\n        case \"recast\":\n          if (n)\n            K(n());\n          else\n            throw new Error(\"No recast handler function provided\");\n          break;\n        case \"like\":\n          if (o)\n            R(o());\n          else\n            throw new Error(\"No like handler function provided\");\n          break;\n      }\n    const G = Q.current[ee];\n    if (G) {\n      const N = G.getBoundingClientRect(), O = Z.current;\n      if (O) {\n        const L = O.getBoundingClientRect();\n        T({\n          top: N.top - L.height - 10,\n          left: N.left + N.width / 2 - L.width / 2\n        });\n      }\n    }\n  };\n  return /* @__PURE__ */ U.jsxs(Om, {\n    children: [x && /* @__PURE__ */ U.jsxs(jm, {\n      ref: Z,\n      style: {\n        top: S.top,\n        left: S.left\n      },\n      children: [/* @__PURE__ */ U.jsx(Fm, {\n        children: /* @__PURE__ */ U.jsx(fm, {\n          variant: wr.NEYNAR\n        })\n      }), /* @__PURE__ */ U.jsx(Dm, {\n        children: /* @__PURE__ */ U.jsx(Ul, {\n          onClick: () => b(!1),\n          size: 16\n        })\n      })]\n    }), /* @__PURE__ */ U.jsx(Vt, {\n      style: {\n        display: \"flex\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\"\n      },\n      children: /* @__PURE__ */ U.jsxs(Vt, {\n        spacingVertical: \"15px\",\n        style: {\n          display: \"flex\",\n          gap: \"10px\"\n        },\n        children: [/* @__PURE__ */ U.jsx(\"div\", {\n          ref: (V) => Q.current.comment = V,\n          children: /* @__PURE__ */ U.jsx(Bm, {\n            onClick: (V) => j(V, \"comment\")\n          })\n        }), /* @__PURE__ */ U.jsx(\"div\", {\n          ref: (V) => Q.current.recast = V,\n          children: /* @__PURE__ */ U.jsx(Rm, {\n            fill: z ? \"green\" : void 0,\n            onClick: (V) => j(V, \"recast\")\n          })\n        }), /* @__PURE__ */ U.jsx(\"div\", {\n          ref: (V) => Q.current.like = V,\n          children: /* @__PURE__ */ U.jsx(Tm, {\n            fill: B ? \"red\" : void 0,\n            onClick: (V) => j(V, \"like\")\n          })\n        })]\n      })\n    })]\n  });\n};\nfunction zm({\n  onClick: t\n}) {\n  return /* @__PURE__ */ U.jsx(\"svg\", {\n    style: {\n      cursor: \"pointer\"\n    },\n    width: \"16\",\n    height: \"15\",\n    viewBox: \"0 0 16 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    onClick: (e) => t ? t(e) : void 0,\n    children: /* @__PURE__ */ U.jsx(\"path\", {\n      d: \"M15.2003 7.49063C14.7504 7.49063 14.4504 7.79057 14.4504 8.24048V12.7396C14.4504 13.1895 14.1505 13.4894 13.7006 13.4894H3.20268C2.75277 13.4894 2.45283 13.1895 2.45283 12.7396V8.24048C2.45283 7.79057 2.15289 7.49063 1.70298 7.49063C1.25307 7.49063 0.953125 7.79057 0.953125 8.24048V12.7396C0.953125 14.0143 1.92793 14.9891 3.20268 14.9891H13.7006C14.9753 14.9891 15.9501 14.0143 15.9501 12.7396V8.24048C15.9501 7.79057 15.6502 7.49063 15.2003 7.49063ZM5.97713 4.26627L7.70178 2.54161V9.74018C7.70178 10.1901 8.00172 10.49 8.45163 10.49C8.90155 10.49 9.20149 10.1901 9.20149 9.74018V2.54161L10.9261 4.26627C11.2261 4.56621 11.676 4.56621 11.9759 4.26627C12.2759 3.96633 12.2759 3.51642 11.9759 3.21648L8.97653 0.217073C8.90155 0.142088 8.82656 0.0671031 8.75157 0.0671031C8.6016 -0.00788202 8.37665 -0.00788202 8.15169 0.0671031C8.07671 0.0671031 8.00172 0.142088 7.92674 0.217073L4.92734 3.21648C4.62739 3.51642 4.62739 3.96633 4.92734 4.26627C5.22728 4.56621 5.67719 4.56621 5.97713 4.26627Z\",\n      fill: \"#A0A3AD\"\n    })\n  });\n}\nconst Au = ({\n  url: t\n}) => {\n  const [e, r] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!1), n = async (o) => {\n    try {\n      await navigator.clipboard.writeText(t), r(!0), setTimeout(() => {\n        r(!1);\n      }, 2e3);\n    } catch (i) {\n      console.error(\"Failed to copy the text to clipboard:\", i);\n    }\n  };\n  return /* @__PURE__ */ U.jsx(\"div\", {\n    children: e ? /* @__PURE__ */ U.jsx(\"svg\", {\n      style: {\n        cursor: \"pointer\",\n        fill: \"green\"\n      },\n      width: \"16\",\n      height: \"15\",\n      viewBox: \"0 0 16 15\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      children: /* @__PURE__ */ U.jsx(\"path\", {\n        d: \"M5.99967 12.8136L1.71967 8.53364L0.559673 9.69364L5.99967 15.1336L16.4397 4.69364L15.2797 3.53364L5.99967 12.8136Z\"\n      })\n    }) : /* @__PURE__ */ U.jsx(zm, {\n      onClick: n\n    })\n  });\n}, qm = () => /* @__PURE__ */ U.jsxs(\"svg\", {\n  width: \"10\",\n  height: \"10\",\n  viewBox: \"0 0 10 10\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: [/* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M5.85855 0.555664H8.31281M8.31281 0.555664V2.73754M8.31281 0.555664L4.31445 4.11122\",\n    stroke: \"#FFFFFF\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\"\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    \"fill-rule\": \"evenodd\",\n    \"clip-rule\": \"evenodd\",\n    d: \"M3.31445 1H1.31445C0.762168 1 0.314453 1.44772 0.314453 2V8C0.314453 8.55228 0.762168 9 1.31445 9H7.31445C7.86674 9 8.31445 8.55228 8.31445 8V6H7.31445V8H1.31445V2H3.31445V1Z\",\n    fill: \"#FFFFFF\"\n  })]\n}), Zm = () => /* @__PURE__ */ U.jsx(\"svg\", {\n  width: \"10\",\n  height: \"14\",\n  viewBox: \"0 0 10 14\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M5.01451 12.5187L4.96833 12.5174L4.93914 12.522C4.93113 12.516 4.92402 12.5087 4.91808 12.5005L4.51231 12.7926L4.91808 12.5005C4.9049 12.4822 4.89824 12.46 4.89913 12.4375L4.89953 12.4275V12.4176V8.81194V8.31194H4.39953H1.8876H1.88753C1.76188 8.31196 1.63853 8.27825 1.53036 8.21433C1.42218 8.1504 1.33315 8.05862 1.27256 7.94854C1.21196 7.83847 1.18203 7.71415 1.18588 7.58856C1.18973 7.46301 1.2272 7.34079 1.29438 7.23466C1.2944 7.23463 1.29442 7.23459 1.29444 7.23456L4.90001 1.54377L4.90567 1.53483L4.91095 1.52567C4.92227 1.50601 4.93988 1.49074 4.96094 1.48232C4.982 1.47389 5.00528 1.47281 5.02703 1.47924L5.02912 1.47985C5.05077 1.48614 5.06969 1.4995 5.08286 1.5178C5.09603 1.53609 5.1027 1.55827 5.1018 1.58079L5.10141 1.59073V1.60067V5.20631V5.70631H5.60141H8.11333H8.1134C8.23905 5.70629 8.3624 5.74 8.47058 5.80392C8.57875 5.86784 8.66778 5.95963 8.72838 6.06971C8.78897 6.17978 8.81891 6.3041 8.81506 6.42969C8.81121 6.55528 8.77371 6.67753 8.70649 6.78369L5.10232 12.4723C5.10219 12.4725 5.10205 12.4727 5.10191 12.4729C5.09255 12.4873 5.07969 12.499 5.06452 12.507C5.04914 12.5152 5.03191 12.5192 5.01451 12.5187Z\",\n    stroke: \"#FFFFFF\"\n  })\n}), Vm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"button\")({\n  classes: [\"f1hmcrrf\"]\n}), Hm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"f1ki4il6\"]\n}), Km = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"bgnz0ud\"]\n}), Wm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"img\")({\n  classes: [\"f1gbget9\"]\n}), Gm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"f4rwe4i\"]\n}), Ym = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"f1qellgw\"]\n}), Jm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"input\")({\n  classes: [\"i1hgxwhi\"]\n}), Xm = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"s1ahcfax\"]\n}), Qm = () => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (t.current) {\n      let e = 0;\n      const r = () => {\n        e += 6, t.current && (t.current.style.transform = `rotate(${e}deg)`), requestAnimationFrame(r);\n      };\n      requestAnimationFrame(r);\n    }\n  }, []), /* @__PURE__ */ U.jsx(\"svg\", {\n    ref: t,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    strokeWidth: \"1.5\",\n    stroke: \"currentColor\",\n    className: \"size-6 text-white\",\n    style: {\n      width: \"24px\",\n      height: \"24px\"\n    },\n    children: /* @__PURE__ */ U.jsx(\"path\", {\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\",\n      d: \"M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99\"\n    })\n  });\n};\nfunction eg({\n  number: t,\n  text: e,\n  actionType: r,\n  target: n,\n  frameUrl: o,\n  handleOnClick: i\n}) {\n  return /* @__PURE__ */ U.jsxs(Vm, {\n    onClick: () => i(t),\n    children: [e, (r === \"link\" || r === \"post_redirect\" || r === \"mint\") && /* @__PURE__ */ U.jsx(qm, {}), r === \"tx\" && /* @__PURE__ */ U.jsx(Zm, {})]\n  });\n}\nfunction tg({\n  frame: t,\n  onFrameBtnPress: e\n}) {\n  var T;\n  const [r, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(t), [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [c, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), v = () => {\n    const C = r.buttons.map((P) => /* @__PURE__ */ U.jsx(eg, {\n      number: P.index,\n      text: P.title,\n      actionType: P.action_type,\n      target: P.target,\n      frameUrl: t.frames_url,\n      handleOnClick: (B) => {\n        f(!0), e(B, r, n, o).finally(() => f(!1));\n      }\n    }, P.index));\n    return /* @__PURE__ */ U.jsx(Km, {\n      children: C\n    });\n  }, x = (C) => {\n    i(C);\n  }, b = (C) => {\n    try {\n      return new URL(C).hostname.replace(\"www.\", \"\");\n    } catch {\n      return \"\";\n    }\n  }, S = () => {\n    switch (r.image_aspect_ratio) {\n      case \"1:1\":\n        return {\n          aspectRatio: \"1 / 1\"\n        };\n      case \"1.91:1\":\n        return {\n          aspectRatio: \"1.91 / 1\"\n        };\n      default:\n        return {\n          aspectRatio: \"1.91 / 1\"\n        };\n    }\n  };\n  return /* @__PURE__ */ U.jsxs(U.Fragment, {\n    children: [/* @__PURE__ */ U.jsxs(Hm, {\n      children: [c && /* @__PURE__ */ U.jsx(Xm, {\n        children: /* @__PURE__ */ U.jsx(Qm, {})\n      }), r.frames_url && /* @__PURE__ */ U.jsxs(U.Fragment, {\n        children: [/* @__PURE__ */ U.jsx(\"a\", {\n          href: r.frames_url,\n          target: \"_blank\",\n          rel: \"noopener noreferrer\",\n          style: {\n            width: \"100%\"\n          },\n          children: /* @__PURE__ */ U.jsx(Wm, {\n            src: r.image,\n            alt: `Frame image for ${r.frames_url}`,\n            style: S()\n          })\n        }), ((T = r.input) == null ? void 0 : T.text) && /* @__PURE__ */ U.jsx(Jm, {\n          type: \"text\",\n          placeholder: r.input.text,\n          value: o,\n          onChange: (C) => x(C.target.value)\n        }), v()]\n      })]\n    }), r.frames_url && /* @__PURE__ */ U.jsx(Gm, {\n      children: b(r.frames_url)\n    })]\n  });\n}\nconst rg = ({\n  frame: t,\n  onFrameBtnPress: e\n}) => /* @__PURE__ */ U.jsx(Ym, {\n  children: t ? /* @__PURE__ */ U.jsx(tg, {\n    frame: t,\n    onFrameBtnPress: e\n  }) : /* @__PURE__ */ U.jsx(U.Fragment, {})\n}), ng = ({\n  url: t,\n  onFrameBtnPress: e,\n  initialFrame: r\n}) => {\n  const {\n    client_id: n,\n    showToast: o\n  } = lr(), [i] = _a(Zn.NEYNAR_AUTHENTICATED_USER, null), [c, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [v, x] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(r || null), [b, S] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    i ? f(i.signer_uuid) : console.warn(\"No NEYNAR_AUTHENTICATED_USER found in local storage.\");\n  }, [i]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    r || (async () => {\n      try {\n        const B = await ig(`${gn}/v2/farcaster/frame/crawl?url=${t}&client_id=${n}`, {\n          method: \"GET\"\n        });\n        if (B.ok) {\n          const z = (await B.json()).frame;\n          if (Object.keys(z).length === 0)\n            throw new Error(\"No frame data available\");\n          x(z), S(null);\n        } else\n          throw new Error(`HTTP error! status: ${B.status}`);\n      } catch (B) {\n        console.error(`An error occurred: ${B}`), S(`Failed to fetch: ${B.message}`);\n      }\n    })();\n  }, [t, o, r]);\n  const T = (P) => {\n    if (typeof P != \"object\" || P === null) return !1;\n    const B = [\"version\", \"image\", \"buttons\", \"frames_url\"];\n    for (const R of B)\n      if (!(R in P)) return !1;\n    return !(!Array.isArray(P.buttons) || P.buttons.some((R) => typeof R.index != \"number\"));\n  }, C = async (P, B, R, z) => {\n    try {\n      const K = await e(P, B, R, z);\n      if (!T(K))\n        throw new Error(\"Invalid frame data received\");\n      R(K);\n    } catch (K) {\n      o(Il.Error, `An error occurred while processing the button press: ${K}`);\n    }\n  };\n  return b ? /* @__PURE__ */ U.jsx(\"div\", {\n    style: {\n      color: \"red\",\n      padding: \"10px\",\n      border: \"1px solid red\",\n      borderRadius: \"5px\"\n    },\n    children: b\n  }) : /* @__PURE__ */ U.jsx(rg, {\n    frame: v,\n    onFrameBtnPress: C\n  });\n};\nfunction ig(t, e, r = 8e3) {\n  return Promise.race([yn(t, e), new Promise((n, o) => setTimeout(() => o(new Error(\"Request timed out\")), r))]);\n}\nfunction ku(t) {\n  const e = Math.min(t, 1e9);\n  return e >= 1e9 ? Math.floor(e / 1e8) / 10 + \"B\" : e >= 1e6 ? Math.floor(e / 1e5) / 10 + \"M\" : e >= 1e3 ? Math.floor(e / 100) / 10 + \"K\" : e.toString();\n}\nfunction sg(t) {\n  if (!t)\n    return console.error(\"Error: Timestamp is undefined or empty.\"), \"Invalid timestamp\";\n  const e = new Date(t);\n  if (isNaN(e.getTime()))\n    return console.error(\"Error: Invalid timestamp provided:\", t), \"Invalid timestamp\";\n  const r = /* @__PURE__ */ new Date(), o = new Intl.DateTimeFormat(void 0, {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: !0\n  }).format(e).replace(\" \", \"\"), i = r.toDateString() === e.toDateString(), c = new Date(r.setDate(r.getDate() - 1)).toDateString() === e.toDateString();\n  if (i)\n    return `${o}, today`;\n  if (c)\n    return `${o}, yesterday`;\n  const f = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], v = e.getDate(), x = f[e.getMonth()], b = e.getFullYear(), T = `${x} ${((C) => {\n    if (C > 3 && C < 21) return `${C}th`;\n    const P = [\"st\", \"nd\", \"rd\"], B = C % 10;\n    return `${C}${P[B - 1] || \"th\"}`;\n  })(v)} ${b}`;\n  return `${o}, ${T}`;\n}\nconst og = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"sxqvxvq\"]\n}), ag = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"a\")({\n  classes: [\"s3kamov\"]\n}), ug = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"m1wrvvhk\"]\n}), cg = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"t1lcaq27\"]\n}), lg = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"ugtp1wh\"]\n}), fg = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"l1dqpn4e\"]\n}), hg = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"l1bjnv2t\"]\n}), Iu = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"e15yf123\"]\n}), dg = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"rxra94g\"]\n}), Bu = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"s1whgqrs\"]\n}), Rs = react__WEBPACK_IMPORTED_MODULE_0___default().memo(({\n  username: t,\n  displayName: e,\n  avatarImgUrl: r,\n  text: n = \"\",\n  hash: o,\n  reactions: i,\n  replies: c,\n  embeds: f = [],\n  frames: v = [],\n  channel: x,\n  viewerFid: b,\n  hasPowerBadge: S,\n  isEmbed: T = !0,\n  allowReactions: C,\n  renderEmbeds: P,\n  renderFrames: B,\n  onLikeBtnPress: R,\n  onRecastBtnPress: z,\n  onCommentBtnPress: K,\n  onFrameBtnPress: Z,\n  direct_replies: Q,\n  containerStyles: j,\n  textStyles: V,\n  timestamp: ee,\n  appAvatarImgUrl: G\n}) => {\n  const [N, O] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(i.likes_count), [L, F] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(i.likes.some((A) => A.fid === b)), d = /* @__PURE__ */ U.jsx(hg, {\n    children: mm(n, f)\n  }), s = (f == null ? void 0 : f.length) === 1, u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => v.map((A) => A.frames_url), [v]), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => f.filter((A) => !u.includes(A.url)), [f, u]), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((A) => {\n    A.currentTarget.src = Li;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    F(i.likes.some((A) => A.fid === b));\n  }, [i.likes, b]);\n  const w = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => R && R() ? (O((p) => p + 1), F(!L), !0) : !1, [R]), _ = Im(h, C, b);\n  return /* @__PURE__ */ U.jsx(og, {\n    style: {\n      ...j,\n      borderWidth: T ? \"1px\" : \"0\"\n    },\n    children: /* @__PURE__ */ U.jsxs(Ht, {\n      children: [/* @__PURE__ */ U.jsx(Vt, {\n        spacingRight: \"10px\",\n        children: /* @__PURE__ */ U.jsx(Bs, {\n          src: r && r.length > 0 ? r : Li,\n          onError: g,\n          loading: \"lazy\",\n          alt: `${e ?? \"Skeleton\"} Avatar`\n        })\n      }), /* @__PURE__ */ U.jsxs(ug, {\n        children: [/* @__PURE__ */ U.jsx(Ht, {\n          justifyContent: \"space-between\",\n          flexGrow: 1,\n          alignItems: \"center\",\n          children: /* @__PURE__ */ U.jsxs(Ol, {\n            children: [/* @__PURE__ */ U.jsxs(Ht, {\n              children: [/* @__PURE__ */ U.jsx(\"strong\", {\n                children: e\n              }), \" \", G && /* @__PURE__ */ U.jsx(Vt, {\n                spacingLeft: \"5px\",\n                children: /* @__PURE__ */ U.jsx(\"img\", {\n                  style: {\n                    padding: \"2px\",\n                    borderWidth: \"0.5px\"\n                  },\n                  className: \"border-white rounded-full\",\n                  src: G,\n                  width: \"18\",\n                  height: \"18\",\n                  onError: (A) => {\n                    A.currentTarget.style.display = \"none\";\n                  }\n                })\n              })]\n            }), /* @__PURE__ */ U.jsxs(Ht, {\n              alignItems: \"center\",\n              children: [/* @__PURE__ */ U.jsxs(lg, {\n                children: [\"@\", t, \" ·\"]\n              }), \" \", /* @__PURE__ */ U.jsx(cg, {\n                children: sg(ee)\n              })]\n            })]\n          })\n        }), /* @__PURE__ */ U.jsx(Vt, {\n          children: /* @__PURE__ */ U.jsx(fg, {\n            style: V,\n            children: d\n          })\n        }), P && h && h.length > 0 ? /* @__PURE__ */ U.jsx(Iu, {\n          style: {\n            margin: s ? \"4px 0\" : \"0\"\n          },\n          children: _.map((A, p) => /* @__PURE__ */ U.jsx(\"div\", {\n            style: {\n              width: \"100%\"\n            },\n            children: A\n          }, p))\n        }) : /* @__PURE__ */ U.jsx(U.Fragment, {}), B && v && v.length > 0 ? /* @__PURE__ */ U.jsx(Iu, {\n          children: v.map((A) => /* @__PURE__ */ U.jsx(ng, {\n            url: A.frames_url,\n            initialFrame: A,\n            onFrameBtnPress: Z\n          }, A.frames_url))\n        }) : null, /* @__PURE__ */ U.jsxs(dg, {\n          style: {\n            justifyContent: C ? \"space-between\" : \"flex-end\"\n          },\n          children: [C && /* @__PURE__ */ U.jsx($m, {\n            hash: o,\n            reactions: i,\n            onComment: K,\n            onRecast: z,\n            onLike: w,\n            isLiked: L\n          }), C && t && o && /* @__PURE__ */ U.jsx(Au, {\n            url: `https://farcaster.xyz/${t}/${o.slice(0, 10)}`\n          })]\n        }), /* @__PURE__ */ U.jsxs(Bu, {\n          style: {\n            justifyContent: C ? \"\" : \"space-between\"\n          },\n          children: [/* @__PURE__ */ U.jsxs(Bu, {\n            style: {\n              justifyContent: C ? \"\" : \"space-between\",\n              gap: 6\n            },\n            children: [/* @__PURE__ */ U.jsxs(\"div\", {\n              children: [c, \" replies\"]\n            }), /* @__PURE__ */ U.jsx(\"div\", {\n              children: \"·\"\n            }), /* @__PURE__ */ U.jsxs(\"div\", {\n              children: [N, \" likes\"]\n            }), x && /* @__PURE__ */ U.jsxs(U.Fragment, {\n              children: [/* @__PURE__ */ U.jsx(\"div\", {\n                children: \"·\"\n              }), /* @__PURE__ */ U.jsx(ag, {\n                href: `https://farcaster.xyz/~/channel/${x.id}`,\n                target: \"_blank\",\n                children: x.id\n              })]\n            })]\n          }), !C && t && o && /* @__PURE__ */ U.jsx(Au, {\n            url: `https://farcaster.xyz/${t}/${o.slice(0, 10)}`\n          })]\n        })]\n      })]\n    })\n  });\n}), pg = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"s1m6ob1a\"]\n}), Ru = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"r1esevc7\"]\n}), Tu = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"vxb1f00\"]\n}), mg = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"htv0qz7\"]\n}), Lu = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"rzksy2\"]\n});\nfunction gg(t) {\n  return /* @__PURE__ */ U.jsx(pg, {\n    children: t.casts.map((e, r) => /* @__PURE__ */ U.jsxs(Ru, {\n      children: [r !== 0 && /* @__PURE__ */ U.jsx(Tu, {\n        style: {\n          left: \"42px\"\n        }\n      }), /* @__PURE__ */ U.jsxs(Lu, {\n        children: [/* @__PURE__ */ U.jsx(Rs, {\n          isEmbed: !1,\n          ...e\n        }), r === 0 && /* @__PURE__ */ U.jsx(mg, {}), e.direct_replies && e.direct_replies.length > 0 && e.direct_replies.map((n, o) => /* @__PURE__ */ U.jsxs(Ru, {\n          children: [/* @__PURE__ */ U.jsx(Tu, {\n            style: {\n              left: \"42px\"\n            }\n          }), /* @__PURE__ */ U.jsx(Lu, {\n            children: /* @__PURE__ */ U.jsx(Rs, {\n              isEmbed: !1,\n              ...n\n            })\n          })]\n        }, o))]\n      })]\n    }, r))\n  });\n}\nasync function yg({\n  type: t,\n  identifier: e,\n  replyDepth: r = 2,\n  includeChronologicalParentCasts: n = !1,\n  limit: o = 20,\n  viewerFid: i,\n  clientId: c\n}) {\n  try {\n    let f = `${gn}/v2/farcaster/cast/conversation?identifier=${encodeURIComponent(e)}&type=${t}&reply_depth=${r}&include_chronological_parent_casts=${n}&limit=${o}&client_id=${c}`;\n    return i && (f += `&viewer_fid=${i}`), await (await yn(f, {\n      method: \"GET\",\n      headers: {\n        accept: \"application/json\"\n      }\n    })).json() || null;\n  } catch (f) {\n    return console.error(\"Error fetching conversation\", f), null;\n  }\n}\nfunction Fl(t) {\n  return {\n    username: t.author.username,\n    displayName: t.author.display_name,\n    avatarImgUrl: t.author.pfp_url,\n    text: t.text,\n    hash: t.hash,\n    reactions: t.reactions,\n    replies: t.replies.count,\n    embeds: t.embeds,\n    frames: t.frames,\n    renderEmbeds: t.renderEmbeds,\n    channel: t.channel,\n    viewerFid: 2,\n    hasPowerBadge: t.author.power_badge,\n    appAvatarImgUrl: t.app.pfp_url,\n    isOwnProfile: !1,\n    allowReactions: !0,\n    renderFrames: !1,\n    direct_replies: t.direct_replies ? t.direct_replies.map(Fl) : [],\n    timestamp: t.timestamp\n  };\n}\nfunction vg(t) {\n  const e = [];\n  return t.cast && e.push(Fl(t.cast)), e;\n}\nconst ay = ({\n  type: t,\n  identifier: e,\n  replyDepth: r = 2,\n  includeChronologicalParentCasts: n = !1,\n  limit: o = 20,\n  viewerFid: i\n}) => {\n  const {\n    client_id: c\n  } = lr(), [f, v] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), [x, b] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!0), [S, T] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() => {\n    b(!0), T(null), yg({\n      type: t,\n      identifier: e,\n      replyDepth: r,\n      includeChronologicalParentCasts: n,\n      limit: o,\n      viewerFid: i,\n      clientId: c\n    }).then((C) => {\n      v(C);\n    }).catch((C) => {\n      T(C);\n    }).finally(() => {\n      b(!1);\n    });\n  }, [t, e, r, n, o, i, c]), x ? /* @__PURE__ */ U.jsx(U.Fragment, {\n    children: \" \"\n  }) : S ? /* @__PURE__ */ U.jsx(U.Fragment, {\n    children: \" \"\n  }) : /* @__PURE__ */ U.jsx(gg, {\n    casts: vg(f.conversation)\n  });\n};\nvar wo = { exports: {} }, xo = {};\n/**\n * @license React\n * use-sync-external-store-shim.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ou;\nfunction wg() {\n  if (Ou) return xo;\n  Ou = 1;\n  var t = (react__WEBPACK_IMPORTED_MODULE_0___default());\n  function e(S, T) {\n    return S === T && (S !== 0 || 1 / S === 1 / T) || S !== S && T !== T;\n  }\n  var r = typeof Object.is == \"function\" ? Object.is : e, n = t.useState, o = t.useEffect, i = t.useLayoutEffect, c = t.useDebugValue;\n  function f(S, T) {\n    var C = T(), P = n({ inst: { value: C, getSnapshot: T } }), B = P[0].inst, R = P[1];\n    return i(\n      function() {\n        B.value = C, B.getSnapshot = T, v(B) && R({ inst: B });\n      },\n      [S, C, T]\n    ), o(\n      function() {\n        return v(B) && R({ inst: B }), S(function() {\n          v(B) && R({ inst: B });\n        });\n      },\n      [S]\n    ), c(C), C;\n  }\n  function v(S) {\n    var T = S.getSnapshot;\n    S = S.value;\n    try {\n      var C = T();\n      return !r(S, C);\n    } catch {\n      return !0;\n    }\n  }\n  function x(S, T) {\n    return T();\n  }\n  var b = typeof window > \"u\" || typeof window.document > \"u\" || typeof window.document.createElement > \"u\" ? x : f;\n  return xo.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : b, xo;\n}\nvar Nu;\nfunction xg() {\n  return Nu || (Nu = 1, wo.exports = wg()), wo.exports;\n}\nvar Pl = xg();\nconst Dl = 0, $l = 1, zl = 2, ju = 3;\nvar Uu = Object.prototype.hasOwnProperty;\nfunction $o(t, e) {\n  var r, n;\n  if (t === e) return !0;\n  if (t && e && (r = t.constructor) === e.constructor) {\n    if (r === Date) return t.getTime() === e.getTime();\n    if (r === RegExp) return t.toString() === e.toString();\n    if (r === Array) {\n      if ((n = t.length) === e.length)\n        for (; n-- && $o(t[n], e[n]); ) ;\n      return n === -1;\n    }\n    if (!r || typeof t == \"object\") {\n      n = 0;\n      for (r in t)\n        if (Uu.call(t, r) && ++n && !Uu.call(e, r) || !(r in e) || !$o(t[r], e[r])) return !1;\n      return Object.keys(e).length === n;\n    }\n  }\n  return t !== t && e !== e;\n}\nconst nr = /* @__PURE__ */ new WeakMap(), Br = () => {\n}, Et = (\n  /*#__NOINLINE__*/\n  Br()\n), zo = Object, Ye = (t) => t === Et, Kt = (t) => typeof t == \"function\", Ur = (t, e) => ({\n  ...t,\n  ...e\n}), ql = (t) => Kt(t.then), bo = {}, Qi = {}, Ea = \"undefined\", zi = typeof window != Ea, qo = typeof document != Ea, bg = zi && \"Deno\" in window, _g = () => zi && typeof window.requestAnimationFrame != Ea, kr = (t, e) => {\n  const r = nr.get(t);\n  return [\n    // Getter\n    () => !Ye(e) && t.get(e) || bo,\n    // Setter\n    (n) => {\n      if (!Ye(e)) {\n        const o = t.get(e);\n        e in Qi || (Qi[e] = o), r[5](e, Ur(o, n), o || bo);\n      }\n    },\n    // Subscriber\n    r[6],\n    // Get server cache snapshot\n    () => !Ye(e) && e in Qi ? Qi[e] : !Ye(e) && t.get(e) || bo\n  ];\n};\nlet Zo = !0;\nconst Eg = () => Zo, [Vo, Ho] = zi && window.addEventListener ? [\n  window.addEventListener.bind(window),\n  window.removeEventListener.bind(window)\n] : [\n  Br,\n  Br\n], Mg = () => {\n  const t = qo && document.visibilityState;\n  return Ye(t) || t !== \"hidden\";\n}, Cg = (t) => (qo && document.addEventListener(\"visibilitychange\", t), Vo(\"focus\", t), () => {\n  qo && document.removeEventListener(\"visibilitychange\", t), Ho(\"focus\", t);\n}), Sg = (t) => {\n  const e = () => {\n    Zo = !0, t();\n  }, r = () => {\n    Zo = !1;\n  };\n  return Vo(\"online\", e), Vo(\"offline\", r), () => {\n    Ho(\"online\", e), Ho(\"offline\", r);\n  };\n}, Ag = {\n  isOnline: Eg,\n  isVisible: Mg\n}, kg = {\n  initFocus: Cg,\n  initReconnect: Sg\n}, Fu = !(react__WEBPACK_IMPORTED_MODULE_0___default().useId), Oi = !zi || bg, Ig = (t) => _g() ? window.requestAnimationFrame(t) : setTimeout(t, 1), os = Oi ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect, _o = typeof navigator < \"u\" && navigator.connection, Pu = !Oi && _o && ([\n  \"slow-2g\",\n  \"2g\"\n].includes(_o.effectiveType) || _o.saveData), es = /* @__PURE__ */ new WeakMap(), Eo = (t, e) => zo.prototype.toString.call(t) === `[object ${e}]`;\nlet Bg = 0;\nconst Ko = (t) => {\n  const e = typeof t, r = Eo(t, \"Date\"), n = Eo(t, \"RegExp\"), o = Eo(t, \"Object\");\n  let i, c;\n  if (zo(t) === t && !r && !n) {\n    if (i = es.get(t), i) return i;\n    if (i = ++Bg + \"~\", es.set(t, i), Array.isArray(t)) {\n      for (i = \"@\", c = 0; c < t.length; c++)\n        i += Ko(t[c]) + \",\";\n      es.set(t, i);\n    }\n    if (o) {\n      i = \"#\";\n      const f = zo.keys(t).sort();\n      for (; !Ye(c = f.pop()); )\n        Ye(t[c]) || (i += c + \":\" + Ko(t[c]) + \",\");\n      es.set(t, i);\n    }\n  } else\n    i = r ? t.toJSON() : e == \"symbol\" ? t.toString() : e == \"string\" ? JSON.stringify(t) : \"\" + t;\n  return i;\n}, Ni = (t) => {\n  if (Kt(t))\n    try {\n      t = t();\n    } catch {\n      t = \"\";\n    }\n  const e = t;\n  return t = typeof t == \"string\" ? t : (Array.isArray(t) ? t.length : t) ? Ko(t) : \"\", [\n    t,\n    e\n  ];\n};\nlet Rg = 0;\nconst Wo = () => ++Rg;\nasync function Zl(...t) {\n  const [e, r, n, o] = t, i = Ur({\n    populateCache: !0,\n    throwOnError: !0\n  }, typeof o == \"boolean\" ? {\n    revalidate: o\n  } : o || {});\n  let c = i.populateCache;\n  const f = i.rollbackOnError;\n  let v = i.optimisticData;\n  const x = (T) => typeof f == \"function\" ? f(T) : f !== !1, b = i.throwOnError;\n  if (Kt(r)) {\n    const T = r, C = [], P = e.keys();\n    for (const B of P)\n      // Skip the special useSWRInfinite and useSWRSubscription keys.\n      !/^\\$(inf|sub)\\$/.test(B) && T(e.get(B)._k) && C.push(B);\n    return Promise.all(C.map(S));\n  }\n  return S(r);\n  async function S(T) {\n    const [C] = Ni(T);\n    if (!C) return;\n    const [P, B] = kr(e, C), [R, z, K, Z] = nr.get(e), Q = () => {\n      const d = R[C];\n      return (Kt(i.revalidate) ? i.revalidate(P().data, T) : i.revalidate !== !1) && (delete K[C], delete Z[C], d && d[0]) ? d[0](zl).then(() => P().data) : P().data;\n    };\n    if (t.length < 3)\n      return Q();\n    let j = n, V;\n    const ee = Wo();\n    z[C] = [\n      ee,\n      0\n    ];\n    const G = !Ye(v), N = P(), O = N.data, L = N._c, F = Ye(L) ? O : L;\n    if (G && (v = Kt(v) ? v(F, O) : v, B({\n      data: v,\n      _c: F\n    })), Kt(j))\n      try {\n        j = j(F);\n      } catch (d) {\n        V = d;\n      }\n    if (j && ql(j))\n      if (j = await j.catch((d) => {\n        V = d;\n      }), ee !== z[C][0]) {\n        if (V) throw V;\n        return j;\n      } else V && G && x(V) && (c = !0, B({\n        data: F,\n        _c: Et\n      }));\n    if (c && !V)\n      if (Kt(c)) {\n        const d = c(j, F);\n        B({\n          data: d,\n          error: Et,\n          _c: Et\n        });\n      } else\n        B({\n          data: j,\n          error: Et,\n          _c: Et\n        });\n    if (z[C][1] = Wo(), Promise.resolve(Q()).then(() => {\n      B({\n        _c: Et\n      });\n    }), V) {\n      if (b) throw V;\n      return;\n    }\n    return j;\n  }\n}\nconst Du = (t, e) => {\n  for (const r in t)\n    t[r][0] && t[r][0](e);\n}, Tg = (t, e) => {\n  if (!nr.has(t)) {\n    const r = Ur(kg, e), n = /* @__PURE__ */ Object.create(null), o = Zl.bind(Et, t);\n    let i = Br;\n    const c = /* @__PURE__ */ Object.create(null), f = (b, S) => {\n      const T = c[b] || [];\n      return c[b] = T, T.push(S), () => T.splice(T.indexOf(S), 1);\n    }, v = (b, S, T) => {\n      t.set(b, S);\n      const C = c[b];\n      if (C)\n        for (const P of C)\n          P(S, T);\n    }, x = () => {\n      if (!nr.has(t) && (nr.set(t, [\n        n,\n        /* @__PURE__ */ Object.create(null),\n        /* @__PURE__ */ Object.create(null),\n        /* @__PURE__ */ Object.create(null),\n        o,\n        v,\n        f\n      ]), !Oi)) {\n        const b = r.initFocus(setTimeout.bind(Et, Du.bind(Et, n, Dl))), S = r.initReconnect(setTimeout.bind(Et, Du.bind(Et, n, $l)));\n        i = () => {\n          b && b(), S && S(), nr.delete(t);\n        };\n      }\n    };\n    return x(), [\n      t,\n      o,\n      x,\n      i\n    ];\n  }\n  return [\n    t,\n    nr.get(t)[4]\n  ];\n}, Lg = (t, e, r, n, o) => {\n  const i = r.errorRetryCount, c = o.retryCount, f = ~~((Math.random() + 0.5) * (1 << (c < 8 ? c : 8))) * r.errorRetryInterval;\n  !Ye(i) && c > i || setTimeout(n, f, o);\n}, Og = $o, [Ma, Ng] = Tg(/* @__PURE__ */ new Map()), jg = Ur(\n  {\n    // events\n    onLoadingSlow: Br,\n    onSuccess: Br,\n    onError: Br,\n    onErrorRetry: Lg,\n    onDiscarded: Br,\n    // switches\n    revalidateOnFocus: !0,\n    revalidateOnReconnect: !0,\n    revalidateIfStale: !0,\n    shouldRetryOnError: !0,\n    // timeouts\n    errorRetryInterval: Pu ? 1e4 : 5e3,\n    focusThrottleInterval: 5 * 1e3,\n    dedupingInterval: 2 * 1e3,\n    loadingTimeout: Pu ? 5e3 : 3e3,\n    // providers\n    compare: Og,\n    isPaused: () => !1,\n    cache: Ma,\n    mutate: Ng,\n    fallback: {}\n  },\n  // use web preset by default\n  Ag\n), Ug = (t, e) => {\n  const r = Ur(t, e);\n  if (e) {\n    const { use: n, fallback: o } = t, { use: i, fallback: c } = e;\n    n && i && (r.use = n.concat(i)), o && c && (r.fallback = Ur(o, c));\n  }\n  return r;\n}, Fg = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({}), Vl = \"$inf$\", Hl = zi && window.__SWR_DEVTOOLS_USE__, Pg = Hl ? window.__SWR_DEVTOOLS_USE__ : [], Dg = () => {\n  Hl && (window.__SWR_DEVTOOLS_REACT__ = (react__WEBPACK_IMPORTED_MODULE_0___default()));\n}, Kl = (t) => Kt(t[1]) ? [\n  t[0],\n  t[1],\n  t[2] || {}\n] : [\n  t[0],\n  null,\n  (t[1] === null ? t[2] : t[1]) || {}\n], $g = () => Ur(jg, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Fg)), zg = (t) => (e, r, n) => t(e, r && ((...i) => {\n  const [c] = Ni(e), [, , , f] = nr.get(Ma);\n  if (c.startsWith(Vl))\n    return r(...i);\n  const v = f[c];\n  return Ye(v) ? r(...i) : (delete f[c], v);\n}), n), qg = Pg.concat(zg), Zg = (t) => function(...r) {\n  const n = $g(), [o, i, c] = Kl(r), f = Ug(n, c);\n  let v = t;\n  const { use: x } = f, b = (x || []).concat(qg);\n  for (let S = b.length; S--; )\n    v = b[S](v);\n  return v(o, i || f.fetcher || null, f);\n}, Vg = (t, e, r) => {\n  const n = e[t] || (e[t] = []);\n  return n.push(r), () => {\n    const o = n.indexOf(r);\n    o >= 0 && (n[o] = n[n.length - 1], n.pop());\n  };\n}, Hg = (t, e) => (...r) => {\n  const [n, o, i] = Kl(r), c = (i.use || []).concat(e);\n  return t(n, o, {\n    ...i,\n    use: c\n  });\n};\nDg();\nconst Mo = (react__WEBPACK_IMPORTED_MODULE_0___default().use) || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax\n// and emitting an error.\n// We assume that this is only for the `use(thenable)` case, not `use(context)`.\n// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45\n((t) => {\n  switch (t.status) {\n    case \"pending\":\n      throw t;\n    case \"fulfilled\":\n      return t.value;\n    case \"rejected\":\n      throw t.reason;\n    default:\n      throw t.status = \"pending\", t.then((e) => {\n        t.status = \"fulfilled\", t.value = e;\n      }, (e) => {\n        t.status = \"rejected\", t.reason = e;\n      }), t;\n  }\n}), Co = {\n  dedupe: !0\n}, Kg = (t, e, r) => {\n  const { cache: n, compare: o, suspense: i, fallbackData: c, revalidateOnMount: f, revalidateIfStale: v, refreshInterval: x, refreshWhenHidden: b, refreshWhenOffline: S, keepPreviousData: T } = r, [C, P, B, R] = nr.get(n), [z, K] = Ni(t), Z = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), Q = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(z), V = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e), ee = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(r), G = () => ee.current, N = () => G().isVisible() && G().isOnline(), [O, L, F, d] = kr(n, z), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}).current, u = Ye(c) ? Ye(r.fallback) ? Et : r.fallback[z] : c, h = (Xe, ae) => {\n    for (const ge in s) {\n      const it = ge;\n      if (it === \"data\") {\n        if (!o(Xe[it], ae[it]) && (!Ye(Xe[it]) || !o(k, ae[it])))\n          return !1;\n      } else if (ae[it] !== Xe[it])\n        return !1;\n    }\n    return !0;\n  }, g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const Xe = !z || !e ? !1 : Ye(f) ? G().isPaused() || i ? !1 : v !== !1 : f, ae = (ye) => {\n      const be = Ur(ye);\n      return delete be._k, Xe ? {\n        isValidating: !0,\n        isLoading: !0,\n        ...be\n      } : be;\n    }, ge = O(), it = d(), we = ae(ge), Me = ge === it ? we : ae(it);\n    let ft = we;\n    return [\n      () => {\n        const ye = ae(O());\n        return h(ye, ft) ? (ft.data = ye.data, ft.isLoading = ye.isLoading, ft.isValidating = ye.isValidating, ft.error = ye.error, ft) : (ft = ye, ye);\n      },\n      () => Me\n    ];\n  }, [\n    n,\n    z\n  ]), w = Pl.useSyncExternalStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (Xe) => F(z, (ae, ge) => {\n      h(ge, ae) || Xe();\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      n,\n      z\n    ]\n  ), g[0], g[1]), _ = !Z.current, A = C[z] && C[z].length > 0, p = w.data, a = Ye(p) ? u && ql(u) ? Mo(u) : u : p, l = w.error, M = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(a), k = T ? Ye(p) ? Ye(M.current) ? a : M.current : p : a, $ = A && !Ye(l) ? !1 : _ && !Ye(f) ? f : G().isPaused() ? !1 : i ? Ye(a) ? !1 : v : Ye(a) || v, X = !!(z && e && _ && $), re = Ye(w.isValidating) ? X : w.isValidating, se = Ye(w.isLoading) ? X : w.isLoading, ut = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (Xe) => {\n      const ae = V.current;\n      if (!z || !ae || Q.current || G().isPaused())\n        return !1;\n      let ge, it, we = !0;\n      const Me = Xe || {}, ft = !B[z] || !Me.dedupe, ye = () => Fu ? !Q.current && z === j.current && Z.current : z === j.current, be = {\n        isValidating: !1,\n        isLoading: !1\n      }, xt = () => {\n        L(be);\n      }, Se = () => {\n        const ct = B[z];\n        ct && ct[1] === it && delete B[z];\n      }, ke = {\n        isValidating: !0\n      };\n      Ye(O().data) && (ke.isLoading = !0);\n      try {\n        if (ft && (L(ke), r.loadingTimeout && Ye(O().data) && setTimeout(() => {\n          we && ye() && G().onLoadingSlow(z, r);\n        }, r.loadingTimeout), B[z] = [\n          ae(K),\n          Wo()\n        ]), [ge, it] = B[z], ge = await ge, ft && setTimeout(Se, r.dedupingInterval), !B[z] || B[z][1] !== it)\n          return ft && ye() && G().onDiscarded(z), !1;\n        be.error = Et;\n        const ct = P[z];\n        if (!Ye(ct) && // case 1\n        (it <= ct[0] || // case 2\n        it <= ct[1] || // case 3\n        ct[1] === 0))\n          return xt(), ft && ye() && G().onDiscarded(z), !1;\n        const _e = O().data;\n        be.data = o(_e, ge) ? _e : ge, ft && ye() && G().onSuccess(ge, z, r);\n      } catch (ct) {\n        Se();\n        const _e = G(), { shouldRetryOnError: E } = _e;\n        _e.isPaused() || (be.error = ct, ft && ye() && (_e.onError(ct, z, _e), (E === !0 || Kt(E) && E(ct)) && (!G().revalidateOnFocus || !G().revalidateOnReconnect || N()) && _e.onErrorRetry(ct, z, _e, (m) => {\n          const y = C[z];\n          y && y[0] && y[0](ju, m);\n        }, {\n          retryCount: (Me.retryCount || 0) + 1,\n          dedupe: !0\n        })));\n      }\n      return we = !1, xt(), !0;\n    },\n    // `setState` is immutable, and `eventsCallback`, `fnArg`, and\n    // `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      z,\n      n\n    ]\n  ), xe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    // Use callback to make sure `keyRef.current` returns latest result every time\n    (...Xe) => Zl(n, j.current, ...Xe),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n  if (os(() => {\n    V.current = e, ee.current = r, Ye(p) || (M.current = p);\n  }), os(() => {\n    if (!z) return;\n    const Xe = ut.bind(Et, Co);\n    let ae = 0;\n    G().revalidateOnFocus && (ae = Date.now() + G().focusThrottleInterval);\n    const it = Vg(z, C, (we, Me = {}) => {\n      if (we == Dl) {\n        const ft = Date.now();\n        G().revalidateOnFocus && ft > ae && N() && (ae = ft + G().focusThrottleInterval, Xe());\n      } else if (we == $l)\n        G().revalidateOnReconnect && N() && Xe();\n      else {\n        if (we == zl)\n          return ut();\n        if (we == ju)\n          return ut(Me);\n      }\n    });\n    return Q.current = !1, j.current = z, Z.current = !0, L({\n      _k: K\n    }), $ && (Ye(a) || Oi ? Xe() : Ig(Xe)), () => {\n      Q.current = !0, it();\n    };\n  }, [\n    z\n  ]), os(() => {\n    let Xe;\n    function ae() {\n      const it = Kt(x) ? x(O().data) : x;\n      it && Xe !== -1 && (Xe = setTimeout(ge, it));\n    }\n    function ge() {\n      !O().error && (b || G().isVisible()) && (S || G().isOnline()) ? ut(Co).then(ae) : ae();\n    }\n    return ae(), () => {\n      Xe && (clearTimeout(Xe), Xe = -1);\n    };\n  }, [\n    x,\n    b,\n    S,\n    z\n  ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(k), i && Ye(a) && z) {\n    if (!Fu && Oi)\n      throw new Error(\"Fallback data is required when using Suspense in SSR.\");\n    V.current = e, ee.current = r, Q.current = !1;\n    const Xe = R[z];\n    if (!Ye(Xe)) {\n      const ae = xe(Xe);\n      Mo(ae);\n    }\n    if (Ye(l)) {\n      const ae = ut(Co);\n      Ye(k) || (ae.status = \"fulfilled\", ae.value = !0), Mo(ae);\n    } else\n      throw l;\n  }\n  return {\n    mutate: xe,\n    get data() {\n      return s.data = !0, k;\n    },\n    get error() {\n      return s.error = !0, l;\n    },\n    get isValidating() {\n      return s.isValidating = !0, re;\n    },\n    get isLoading() {\n      return s.isLoading = !0, se;\n    }\n  };\n}, Wg = Zg(Kg), Gg = () => {\n}, Yg = (\n  /*#__NOINLINE__*/\n  Gg()\n), Go = Object, $u = (t) => t === Yg, Jg = (t) => typeof t == \"function\", ts = /* @__PURE__ */ new WeakMap(), So = (t, e) => Go.prototype.toString.call(t) === `[object ${e}]`;\nlet Xg = 0;\nconst Yo = (t) => {\n  const e = typeof t, r = So(t, \"Date\"), n = So(t, \"RegExp\"), o = So(t, \"Object\");\n  let i, c;\n  if (Go(t) === t && !r && !n) {\n    if (i = ts.get(t), i) return i;\n    if (i = ++Xg + \"~\", ts.set(t, i), Array.isArray(t)) {\n      for (i = \"@\", c = 0; c < t.length; c++)\n        i += Yo(t[c]) + \",\";\n      ts.set(t, i);\n    }\n    if (o) {\n      i = \"#\";\n      const f = Go.keys(t).sort();\n      for (; !$u(c = f.pop()); )\n        $u(t[c]) || (i += c + \":\" + Yo(t[c]) + \",\");\n      ts.set(t, i);\n    }\n  } else\n    i = r ? t.toJSON() : e == \"symbol\" ? t.toString() : e == \"string\" ? JSON.stringify(t) : \"\" + t;\n  return i;\n}, Qg = (t) => {\n  if (Jg(t))\n    try {\n      t = t();\n    } catch {\n      t = \"\";\n    }\n  const e = t;\n  return t = typeof t == \"string\" ? t : (Array.isArray(t) ? t.length : t) ? Yo(t) : \"\", [\n    t,\n    e\n  ];\n}, e2 = (t) => Qg(t ? t(0, null) : null)[0], Ao = Promise.resolve(), t2 = (t) => (e, r, n) => {\n  const o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), { cache: i, initialSize: c = 1, revalidateAll: f = !1, persistSize: v = !1, revalidateFirstPage: x = !0, revalidateOnMount: b = !1, parallel: S = !1 } = n, [, , , T] = nr.get(Ma);\n  let C;\n  try {\n    C = e2(e), C && (C = Vl + C);\n  } catch {\n  }\n  const [P, B, R] = kr(i, C), z = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => Ye(P()._l) ? c : P()._l, [\n    i,\n    C,\n    c\n  ]);\n  Pl.useSyncExternalStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (G) => C ? R(C, () => {\n      G();\n    }) : () => {\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      i,\n      C\n    ]\n  ), z, z);\n  const K = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const G = P()._l;\n    return Ye(G) ? c : G;\n  }, [\n    C,\n    c\n  ]), Z = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(K());\n  os(() => {\n    if (!o.current) {\n      o.current = !0;\n      return;\n    }\n    C && B({\n      _l: v ? Z.current : K()\n    });\n  }, [\n    C,\n    i\n  ]);\n  const Q = b && !o.current, j = t(C, async (G) => {\n    const N = P()._i, O = P()._r;\n    B({\n      _r: Et\n    });\n    const L = [], F = K(), [d] = kr(i, G), s = d().data, u = [];\n    let h = null;\n    for (let g = 0; g < F; ++g) {\n      const [w, _] = Ni(e(g, S ? null : h));\n      if (!w)\n        break;\n      const [A, p] = kr(i, w);\n      let a = A().data;\n      const l = f || N || Ye(a) || x && !g && !Ye(s) || Q || s && !Ye(s[g]) && !n.compare(s[g], a);\n      if (r && (typeof O == \"function\" ? O(a, _) : l)) {\n        const M = async () => {\n          if (!(w in T))\n            a = await r(_);\n          else {\n            const $ = T[w];\n            delete T[w], a = await $;\n          }\n          p({\n            data: a,\n            _k: _\n          }), L[g] = a;\n        };\n        S ? u.push(M) : await M();\n      } else\n        L[g] = a;\n      S || (h = a);\n    }\n    return S && await Promise.all(u.map((g) => g())), B({\n      _i: Et\n    }), L;\n  }, n), V = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    // eslint-disable-next-line func-names\n    function(G, N) {\n      const O = typeof N == \"boolean\" ? {\n        revalidate: N\n      } : N || {}, L = O.revalidate !== !1;\n      return C ? (L && (Ye(G) ? B({\n        _i: !0,\n        _r: O.revalidate\n      }) : B({\n        _i: !1,\n        _r: O.revalidate\n      })), arguments.length ? j.mutate(G, {\n        ...O,\n        revalidate: L\n      }) : j.mutate()) : Ao;\n    },\n    // swr.mutate is always the same reference\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      C,\n      i\n    ]\n  ), ee = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (G) => {\n      if (!C) return Ao;\n      const [, N] = kr(i, C);\n      let O;\n      if (Kt(G) ? O = G(K()) : typeof G == \"number\" && (O = G), typeof O != \"number\") return Ao;\n      N({\n        _l: O\n      }), Z.current = O;\n      const L = [], [F] = kr(i, C);\n      let d = null;\n      for (let s = 0; s < O; ++s) {\n        const [u] = Ni(e(s, d)), [h] = kr(i, u), g = u ? h().data : Et;\n        if (Ye(g))\n          return V(F().data);\n        L.push(g), d = g;\n      }\n      return V(L);\n    },\n    // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      C,\n      i,\n      V,\n      K\n    ]\n  );\n  return {\n    size: K(),\n    setSize: ee,\n    mutate: V,\n    get data() {\n      return j.data;\n    },\n    get error() {\n      return j.error;\n    },\n    get isValidating() {\n      return j.isValidating;\n    },\n    get isLoading() {\n      return j.isLoading;\n    }\n  };\n}, r2 = Hg(Wg, t2), n2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"sfmkqcr\"]\n}), i2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"hrldtio\"]\n}), s2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({\n  casts: t,\n  cursor: e\n}) => /* @__PURE__ */ U.jsx(n2, {\n  children: t.map((r, n) => /* @__PURE__ */ U.jsxs((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), {\n    children: [/* @__PURE__ */ U.jsx(Rs, {\n      isEmbed: !1,\n      ...r\n    }), n < t.length - 1 && /* @__PURE__ */ U.jsx(i2, {})]\n  }, r.hash))\n}));\nfunction o2(t) {\n  return t ? t.map((e) => {\n    var n, o, i, c, f;\n    const r = e != null && e.replies && typeof e.replies == \"object\" ? Number(e.replies.count) || 0 : Number(e == null ? void 0 : e.replies) || 0;\n    return {\n      username: ((n = e == null ? void 0 : e.author) == null ? void 0 : n.username) ?? \"\",\n      displayName: ((o = e == null ? void 0 : e.author) == null ? void 0 : o.display_name) ?? \"\",\n      avatarImgUrl: ((i = e == null ? void 0 : e.author) == null ? void 0 : i.pfp_url) ?? \"\",\n      text: (e == null ? void 0 : e.text) ?? \"\",\n      hash: (e == null ? void 0 : e.hash) ?? \"\",\n      reactions: (e == null ? void 0 : e.reactions) ?? [],\n      replies: r,\n      embeds: (e == null ? void 0 : e.embeds) ?? [],\n      frames: (e == null ? void 0 : e.frames) ?? [],\n      renderEmbeds: (e == null ? void 0 : e.renderEmbeds) ?? !0,\n      channel: (e == null ? void 0 : e.channel) ?? \"\",\n      viewerFid: 2,\n      hasPowerBadge: ((c = e == null ? void 0 : e.author) == null ? void 0 : c.power_badge) ?? !1,\n      appAvatarImgUrl: ((f = e == null ? void 0 : e.app) == null ? void 0 : f.pfp_url) ?? \"\",\n      isOwnProfile: !1,\n      allowReactions: !0,\n      renderFrames: !1,\n      timestamp: e.timestamp ?? \"\"\n    };\n  }) : [];\n}\nconst a2 = (t) => yn(t).then(async (e) => await e.json()), u2 = (t, e, r, n, o) => {\n  if (e && (!e.casts || !e.casts.length)) return null;\n  let i = `${gn}/v2/farcaster/feed${r ? \"\" : \"?\"}`;\n  const c = new URLSearchParams();\n  r && (i += `${r}?`), o && (i += `client_id=${o}`), e && (i += `&cursor=${e.next.cursor}`);\n  const f = (v, x) => {\n    x != null && !i.includes(`${v}=`) && c.append(v, String(x));\n  };\n  if (n) {\n    Object.entries(n).forEach(([x, b]) => {\n      const S = x.replace(/([a-z])([A-Z])/g, \"$1_$2\").toLowerCase();\n      f(S, b);\n    });\n    const v = c.toString();\n    v && (i += i.includes(\"?\") ? `&${v}` : `?${v}`);\n  }\n  if (Object.keys(n).length > 1)\n    return i;\n}, uy = ({\n  path: t,\n  ...e\n}) => {\n  var C;\n  const {\n    client_id: r\n  } = lr(), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), {\n    data: f,\n    error: v,\n    size: x,\n    setSize: b,\n    isValidating: S\n  } = r2((P, B) => u2(P, B, t, e, r), a2), T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!f) return [];\n    const P = f.flatMap((R) => (R == null ? void 0 : R.casts) ?? []), B = Array.from(new Set(P.map((R) => R.hash))).map((R) => P.find((z) => z.hash === R));\n    return o2(B);\n  }, [f]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (c.current && c.current.disconnect(), c.current = new IntersectionObserver((P) => {\n    var R, z;\n    const [B] = P;\n    B.isIntersecting && !o && !S && f && ((z = (R = f[f.length - 1]) == null ? void 0 : R.next) != null && z.cursor) && (i(!0), b(x + 1).then(() => i(!1)));\n  }, {\n    rootMargin: \"100px\"\n  }), n.current && c.current.observe(n.current), () => {\n    c.current && c.current.disconnect();\n  }), [n.current, o, S, f, x]), v ? /* @__PURE__ */ U.jsx(\"div\", {\n    children: \"Error fetching feed data\"\n  }) : /* @__PURE__ */ U.jsxs(\"div\", {\n    children: [T.length !== 0 ? /* @__PURE__ */ U.jsx(s2, {\n      casts: T,\n      cursor: \"\"\n    }) : /* @__PURE__ */ U.jsx(\"div\", {\n      children: (C = f == null ? void 0 : f[0]) == null ? void 0 : C.message\n    }), S && /* @__PURE__ */ U.jsxs(\"div\", {\n      style: {\n        display: \"flex\",\n        justifyContent: \"center\",\n        padding: \"10px\"\n      },\n      children: [/* @__PURE__ */ U.jsxs(\"span\", {\n        style: {\n          animation: \"blink 1.5s infinite\"\n        },\n        children: [\"Loading\", /* @__PURE__ */ U.jsx(\"span\", {\n          className: \"dots\",\n          children: \"...\"\n        })]\n      }), /* @__PURE__ */ U.jsx(\"style\", {\n        children: `\n                        @keyframes blink {\n                            0% { opacity: 1; }\n                            50% { opacity: 0; }\n                            100% { opacity: 1; }\n                        }\n                    `\n      })]\n    }), /* @__PURE__ */ U.jsx(\"div\", {\n      ref: n\n    })]\n  });\n}, c2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"button\")({\n  classes: [\"b1bqug8r\"]\n}), l2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"button\")({\n  classes: [\"b1mra45w\"]\n}), zu = \"https://farcaster.xyz\", Wl = /(^|\\s)\\/\\w+/g, Gl = /@\\w+/g, Yl = /((https?:\\/\\/)?([a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})(\\/[^\\s]*)?)/g, qu = new RegExp(`(${Wl.source})|(${Gl.source})|(${Yl.source})`, \"g\"), f2 = (t) => Wl.test(t) ? `${zu}/~/channel${t.trim()}` : Gl.test(t) ? `${zu}/${t.substring(1)}` : Yl.test(t) ? t.startsWith(\"http\") ? t : `http://${t}` : \"\", h2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"a\")({\n  classes: [\"sby9wa2\"]\n}), d2 = (t) => {\n  if (!t) return [];\n  const e = [];\n  let r = 0, n;\n  for (; (n = qu.exec(t)) !== null; ) {\n    const o = n.index;\n    r < o && e.push(t.slice(r, o));\n    const i = f2(n[0]), c = n[0].trim().startsWith(\"/\");\n    e.push(/* @__PURE__ */ U.jsx(h2, {\n      href: i,\n      target: \"_blank\",\n      style: c ? {\n        marginLeft: 3.5\n      } : {},\n      children: n[0].trim()\n    }, o)), r = qu.lastIndex;\n  }\n  return r < t.length && e.push(t.slice(r)), e;\n}, p2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"sdahm58\"]\n}), m2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"mziqyxp\"]\n}), g2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"uz7tpmf\"]\n}), y2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"u1rxlwac\"]\n}), Zu = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"pgc6yqp\"]\n}), v2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"torjf9a\"]\n}), w2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({\n  fid: t,\n  username: e,\n  displayName: r,\n  avatarImgUrl: n,\n  bio: o,\n  followers: i,\n  following: c,\n  hasPowerBadge: f,\n  isFollowing: v,\n  isOwnProfile: x,\n  onCast: b,\n  containerStyles: S\n}) => {\n  const T = d2(o), C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ku(c), [c]), P = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ku(i), [i]), B = () => {\n    window.open(\"https://farcaster.xyz/~/settings\", \"_blank\");\n  }, R = {\n    color: S == null ? void 0 : S.color\n  };\n  return /* @__PURE__ */ U.jsxs(p2, {\n    style: S,\n    children: [x && b && /* @__PURE__ */ U.jsxs(Ht, {\n      alignItems: \"center\",\n      justifyContent: \"space-between\",\n      spacingBottom: \"20px\",\n      children: [/* @__PURE__ */ U.jsxs(y2, {\n        style: S,\n        children: [\"@\", e]\n      }), /* @__PURE__ */ U.jsx(c2, {\n        onClick: b,\n        children: \"Cast\"\n      })]\n    }), /* @__PURE__ */ U.jsxs(Ht, {\n      children: [/* @__PURE__ */ U.jsx(Vt, {\n        spacingRight: \"10px\",\n        children: /* @__PURE__ */ U.jsx(Bs, {\n          src: n ?? Li,\n          loading: \"lazy\",\n          alt: `${r ?? \"Skeleton\"} Avatar`\n        })\n      }), /* @__PURE__ */ U.jsxs(m2, {\n        children: [/* @__PURE__ */ U.jsxs(Ht, {\n          justifyContent: \"space-between\",\n          flexGrow: 1,\n          children: [/* @__PURE__ */ U.jsxs(Ol, {\n            children: [/* @__PURE__ */ U.jsx(Ht, {\n              children: /* @__PURE__ */ U.jsx(\"strong\", {\n                children: r || `!${t}`\n              })\n            }), /* @__PURE__ */ U.jsxs(Ht, {\n              alignItems: \"center\",\n              children: [/* @__PURE__ */ U.jsxs(g2, {\n                style: S,\n                children: [\"@\", e]\n              }), v && /* @__PURE__ */ U.jsx(v2, {\n                style: S,\n                children: \"Follows you\"\n              })]\n            })]\n          }), /* @__PURE__ */ U.jsx(Ht, {\n            children: x && /* @__PURE__ */ U.jsx(l2, {\n              style: S,\n              onClick: B,\n              children: \"Edit Profile\"\n            })\n          })]\n        }), /* @__PURE__ */ U.jsx(Vt, {\n          spacingVertical: \"15px\",\n          children: /* @__PURE__ */ U.jsx(\"div\", {\n            style: S,\n            children: T\n          })\n        }), /* @__PURE__ */ U.jsxs(Ht, {\n          children: [/* @__PURE__ */ U.jsxs(Zu, {\n            children: [/* @__PURE__ */ U.jsx(\"strong\", {\n              style: R,\n              children: C\n            }), \" \", \"Following\"]\n          }), /* @__PURE__ */ U.jsxs(Zu, {\n            children: [/* @__PURE__ */ U.jsx(\"strong\", {\n              style: R,\n              children: P\n            }), \" \", \"Followers\"]\n          })]\n        })]\n      })]\n    })]\n  });\n});\nasync function x2({\n  fid: t,\n  viewerFid: e,\n  clientId: r\n}) {\n  var n;\n  try {\n    let o = `${gn}/v2/farcaster/user/bulk?client_id=${r}&fids=${t}`;\n    e && (o += `&viewer_fid=${e}`);\n    const c = await (await yn(o)).json();\n    return ((n = c == null ? void 0 : c.users) == null ? void 0 : n[0]) ?? null;\n  } catch (o) {\n    return console.error(\"Error fetching user by fid\", o), null;\n  }\n}\nconst cy = ({\n  fid: t,\n  viewerFid: e,\n  containerStyles: r\n}) => {\n  var T;\n  const {\n    client_id: n\n  } = lr(), [o, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [c, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0), [v, x] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), b = (o == null ? void 0 : o.fid) === e;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t && (f(!0), x(null), x2({\n      fid: t,\n      viewerFid: e,\n      clientId: n\n    }).then((C) => {\n      i(C);\n    }).catch((C) => {\n      x(C);\n    }).finally(() => {\n      f(!1);\n    }));\n  }, [t, e]);\n  const S = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n  }, []);\n  return c ? /* @__PURE__ */ U.jsx(\"div\", {\n    children: \"Loading...\"\n  }) : !o || v ? /* @__PURE__ */ U.jsx(\"div\", {\n    children: \"Error fetching user data\"\n  }) : /* @__PURE__ */ U.jsx(w2, {\n    fid: t,\n    username: o.username,\n    displayName: o.display_name,\n    avatarImgUrl: o.pfp_url,\n    bio: o.profile.bio.text,\n    followers: o.follower_count,\n    following: o.following_count,\n    hasPowerBadge: o.power_badge,\n    isOwnProfile: b,\n    isFollowing: (T = o.viewer_context) == null ? void 0 : T.followed_by,\n    onCast: S,\n    containerStyles: r\n  });\n}, b2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"ul\")({\n  classes: [\"d12rx4om\"]\n}), _2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"li\")({\n  classes: [\"lrpm6lp\"]\n}), E2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"img\")({\n  classes: [\"a1e9hg3b\"]\n}), M2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"u1aqay1i\"]\n}), C2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"d1m0njq\"]\n}), S2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"u1lvlbuo\"]\n}), A2 = ({\n  users: t,\n  onSelect: e,\n  customStyles: r = {}\n}) => /* @__PURE__ */ U.jsx(b2, {\n  style: {\n    ...r == null ? void 0 : r.dropdown\n  },\n  children: t.map((n) => /* @__PURE__ */ U.jsxs(_2, {\n    style: {\n      ...r == null ? void 0 : r.listItem\n    },\n    onClick: () => e(n),\n    children: [/* @__PURE__ */ U.jsx(E2, {\n      style: {\n        ...r == null ? void 0 : r.avatar\n      },\n      src: n.pfp_url,\n      alt: n.username\n    }), /* @__PURE__ */ U.jsxs(M2, {\n      style: {\n        ...r.userInfo\n      },\n      children: [/* @__PURE__ */ U.jsx(C2, {\n        children: n.display_name\n      }), /* @__PURE__ */ U.jsxs(S2, {\n        children: [\"@\", n.username]\n      })]\n    })]\n  }, n.fid))\n}), k2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"c9hm20t\"]\n}), I2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"input\")({\n  classes: [\"i80sd8h\"]\n});\nasync function B2({\n  q: t,\n  viewerFid: e,\n  client_id: r\n}) {\n  var n;\n  try {\n    let o = `${gn}/v2/farcaster/user/search?q=${t}&limit=5${e ? `&viewer_fid=${e}` : \"\"}&client_id=${r}`;\n    const c = await (await yn(o)).json();\n    return ((n = c == null ? void 0 : c.result) == null ? void 0 : n.users) || [];\n  } catch (o) {\n    return console.log(\"Error fetching users by query\", o), null;\n  }\n}\nconst ly = ({\n  value: t,\n  onChange: e,\n  style: r = {},\n  placeholder: n = \"Enter username\",\n  disabled: o = !1,\n  viewerFid: i,\n  customStyles: c = {},\n  limit: f = null\n}) => {\n  const {\n    client_id: v\n  } = lr(), [x, b] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [S, T] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [C, P] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), B = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const j = (t == null ? void 0 : t.split(\",\")) || [];\n    if (!j[j.length - 1]) {\n      b(\"\");\n      return;\n    }\n    b(j[j.length - 1].trim());\n  }, [t]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    x !== \"\" && !/^\\d+$/.test(x) ? R(x) : T(!1);\n  }, [x]);\n  const R = async (j) => {\n    const V = await B2({\n      q: j,\n      viewerFid: i,\n      client_id: v\n    });\n    V && (P(V), T(!0));\n  }, z = (j) => {\n    const V = j.target.value;\n    e(V);\n  }, K = (j) => {\n    let V = t.split(\",\");\n    f !== null && V.length >= f ? V[V.length - 1] = j.fid.toString() : V.push(j.fid.toString());\n    const ee = V.join(\",\");\n    e(ee), b(\"\"), T(!1);\n  }, Z = () => {\n    x && isNaN(Number(x)) && T(!0);\n  }, Q = () => {\n    setTimeout(() => T(!1), 200);\n  };\n  return /* @__PURE__ */ U.jsxs(k2, {\n    style: r,\n    children: [/* @__PURE__ */ U.jsx(I2, {\n      ref: B,\n      type: \"text\",\n      value: t,\n      onChange: z,\n      onFocus: Z,\n      onBlur: Q,\n      placeholder: n,\n      disabled: o\n    }), S && /* @__PURE__ */ U.jsx(A2, {\n      users: C,\n      onSelect: K,\n      customStyles: c\n    })]\n  });\n}, R2 = ({\n  color: t = \"#855DCD\"\n}) => /* @__PURE__ */ U.jsxs(\"svg\", {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: \"24\",\n  height: \"24\",\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: t,\n  \"stroke-width\": \"2\",\n  \"stroke-linecap\": \"round\",\n  \"stroke-linejoin\": \"round\",\n  className: \"lucide lucide-search\",\n  children: [/* @__PURE__ */ U.jsx(\"circle\", {\n    cx: \"11\",\n    cy: \"11\",\n    r: \"8\"\n  }), /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"m21 21-4.3-4.3\"\n  })]\n}), T2 = ({\n  color: t = \"#855DCD\"\n}) => /* @__PURE__ */ U.jsx(\"svg\", {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: \"24\",\n  height: \"24\",\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: t,\n  \"stroke-width\": \"2\",\n  \"stroke-linecap\": \"round\",\n  \"stroke-linejoin\": \"round\",\n  className: \"lucide lucide-loader-circle\",\n  children: /* @__PURE__ */ U.jsx(\"path\", {\n    d: \"M21 12a9 9 0 1 1-6.219-8.56\"\n  })\n}), L2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"ig7kcuc\"]\n}), O2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"input\")({\n  classes: [\"sh7z7k6\"]\n}), N2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"s14ai203\"]\n}), j2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"if18nd6\"]\n}), U2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"sd833lb\"]\n}), F2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"ugo586m\"]\n}), P2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"ukwty1d\"]\n}), D2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"u77olmy\"]\n}), $2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"s1xvkxww\"]\n}), z2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"s1f6b1ja\"]\n}), q2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"udiufd8\"]\n}), Z2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"f1b8a2h0\"]\n}), V2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"div\")({\n  classes: [\"l1yq26j0\"]\n}), H2 = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_2__.styled)(\"li\")({\n  classes: [\"s18mk47k\"]\n}), fy = ({\n  width: t,\n  height: e,\n  selectedUsers: r,\n  onSelectUsers: n,\n  ...o\n}) => {\n  const {\n    client_id: i\n  } = lr(), {\n    user: c,\n    isAuthenticated: f\n  } = kl(), [v, x] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [b, S] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [T, C] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), P = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    function j(V) {\n      P.current && !P.current.contains(V.target) && (S([]), x(\"\"));\n    }\n    return document.addEventListener(\"mousedown\", j), () => {\n      document.removeEventListener(\"mousedown\", j);\n    };\n  }, []);\n  const z = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(((j, V) => {\n    let ee;\n    return (...G) => {\n      clearTimeout(ee), ee = setTimeout(() => j(...G), V);\n    };\n  })(async (j, V) => {\n    var ee;\n    if (!j) {\n      S([]);\n      return;\n    }\n    C(!0);\n    try {\n      const N = await (await yn(V)).json();\n      S(((ee = N == null ? void 0 : N.result) == null ? void 0 : ee.users) || []);\n    } catch (G) {\n      console.error(\"Error fetching data:\", G);\n    } finally {\n      C(!1);\n    }\n  }, 500), []), K = (j) => {\n    const V = `${gn}/v2/farcaster/user/search?q=${j.target.value}&client_id=${i}${f ? `&viewer_fid=${c == null ? void 0 : c.fid}` : \"\"})`;\n    x(j.target.value), z(j.target.value, V);\n  }, Z = (j) => {\n    r.some((V) => V.username === j.username) || (n([...r, j]), x(\"\"), S([]));\n  }, Q = (j) => {\n    n(r.filter((V) => V.username !== j));\n  };\n  return /* @__PURE__ */ U.jsxs(L2, {\n    ref: P,\n    style: {\n      width: t\n    },\n    children: [/* @__PURE__ */ U.jsxs(j2, {\n      children: [r.map((j) => /* @__PURE__ */ U.jsxs(U2, {\n        children: [/* @__PURE__ */ U.jsx(Bs, {\n          src: j.pfp_url ?? Li,\n          alt: `${j.username} Avatar`,\n          style: {\n            width: \"24px\",\n            height: \"24px\",\n            borderRadius: \"50%\"\n          }\n        }), /* @__PURE__ */ U.jsx(\"span\", {\n          style: {\n            marginLeft: \"8px\"\n          },\n          children: j.display_name\n        }), /* @__PURE__ */ U.jsx(Ul, {\n          size: 20,\n          onClick: () => Q(j.username)\n        })]\n      }, j.username)), /* @__PURE__ */ U.jsxs($2, {\n        children: [/* @__PURE__ */ U.jsx(z2, {\n          children: /* @__PURE__ */ U.jsx(R2, {\n            color: \"#855DCD\"\n          })\n        }), /* @__PURE__ */ U.jsx(O2, {\n          ...o,\n          value: v,\n          onChange: K,\n          placeholder: \"Type to search users\",\n          style: {\n            width: t || \"100%\",\n            height: e || \"40px\"\n          }\n        })]\n      })]\n    }), T ? /* @__PURE__ */ U.jsx(V2, {\n      children: /* @__PURE__ */ U.jsx(T2, {\n        color: \"#855DCD\"\n      })\n    }) : b.length !== 0 && /* @__PURE__ */ U.jsx(N2, {\n      children: b.map((j) => /* @__PURE__ */ U.jsxs(H2, {\n        onClick: () => Z(j),\n        children: [/* @__PURE__ */ U.jsx(Bs, {\n          src: j.pfp_url ?? Li,\n          alt: `${j.username} Avatar`,\n          style: {\n            width: \"40px\",\n            height: \"40px\",\n            borderRadius: \"50%\"\n          }\n        }), /* @__PURE__ */ U.jsxs(F2, {\n          children: [/* @__PURE__ */ U.jsx(P2, {\n            children: j.display_name\n          }), /* @__PURE__ */ U.jsxs(q2, {\n            children: [/* @__PURE__ */ U.jsxs(D2, {\n              children: [\"@\", j.username]\n            }), j.viewer_context && (j.viewer_context.following || j.viewer_context.followed_by) && /* @__PURE__ */ U.jsx(Z2, {\n              children: j.viewer_context.following && j.viewer_context.followed_by ? \"Following each other\" : j.viewer_context.following ? \"Following\" : j.viewer_context.followed_by ? \"Follows you\" : null\n            })]\n          })]\n        })]\n      }, j.username))\n    })]\n  });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5leW5hci9yZWFjdC9kaXN0L2J1bmRsZS5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDa0Q7QUFDeUo7QUFDbkw7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNCQUFzQix5Q0FBeUM7QUFDL0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsWUFBWSxvQkFBb0IsaUNBQWlDLG9CQUFvQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztB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QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3REFBd0QsRUFBRTtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaURBQWlEO0FBQzNELG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpSEFBaUg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFD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TztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QixLQUFLLGVBQWU7QUFD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QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsT0FBTztBQUM1RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHFCQUFxQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwwQkFBMEI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFtQkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXVyYXYvRGVza3RvcC9jb2RlL2FzdHJvYmFzZS9ub2RlX21vZHVsZXMvQG5leW5hci9yZWFjdC9kaXN0L2J1bmRsZS5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSmwgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgWGwgPSAodCwgZSwgcikgPT4gZSBpbiB0ID8gSmwodCwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogciB9KSA6IHRbZV0gPSByO1xudmFyIGJyID0gKHQsIGUsIHIpID0+IFhsKHQsIHR5cGVvZiBlICE9IFwic3ltYm9sXCIgPyBlICsgXCJcIiA6IGUsIHIpO1xuaW1wb3J0IHsgc3R5bGVkIGFzIHVlIH0gZnJvbSBcIkBwaWdtZW50LWNzcy9yZWFjdFwiO1xuaW1wb3J0IGF0LCB7IHVzZVN0YXRlIGFzIHJ0LCB1c2VDYWxsYmFjayBhcyBfdCwgdXNlRWZmZWN0IGFzIG10LCBjcmVhdGVDb250ZXh0IGFzIEpvLCB1c2VDb250ZXh0IGFzIFhvLCB1c2VNZW1vIGFzIFRyLCB1c2VSZWYgYXMgUnQsIHVzZUxheW91dEVmZmVjdCBhcyBRbCwgdXNlRGVidWdWYWx1ZSBhcyBlZiwgbWVtbyBhcyBWdSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFpzIGZyb20gXCJobHMuanNcIjtcbmNvbnN0IHJyID0ge1xuICB2YXJzOiB7XG4gICAgY29sb3JzOiB7XG4gICAgICBwcmltYXJ5OiBcInZhcigtLWNvbG9ycy1wcmltYXJ5KVwiXG4gICAgfSxcbiAgICB0eXBvZ3JhcGh5OiB7XG4gICAgICBmb250czoge1xuICAgICAgICBiYXNlOiBcInZhcigtLXR5cG9ncmFwaHktZm9udHMtYmFzZSlcIlxuICAgICAgfSxcbiAgICAgIGZvbnRXZWlnaHRzOiB7XG4gICAgICAgIHJlZ3VsYXI6IFwidmFyKC0tdHlwb2dyYXBoeS1mb250V2VpZ2h0cy1yZWd1bGFyKVwiLFxuICAgICAgICBib2xkOiBcInZhcigtLXR5cG9ncmFwaHktZm9udFdlaWdodHMtYm9sZClcIlxuICAgICAgfSxcbiAgICAgIGZvbnRTaXplczoge1xuICAgICAgICBsYXJnZTogXCJ2YXIoLS10eXBvZ3JhcGh5LWZvbnRTaXplcy1sYXJnZSlcIixcbiAgICAgICAgbWVkaXVtOiBcInZhcigtLXR5cG9ncmFwaHktZm9udFNpemVzLW1lZGl1bSlcIixcbiAgICAgICAgc21hbGw6IFwidmFyKC0tdHlwb2dyYXBoeS1mb250U2l6ZXMtc21hbGwpXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhbGV0dGU6IHtcbiAgICAgIGJhY2tncm91bmQ6IFwidmFyKC0tcGFsZXR0ZS1iYWNrZ3JvdW5kKVwiLFxuICAgICAgYm9yZGVyOiBcInZhcigtLXBhbGV0dGUtYm9yZGVyKVwiLFxuICAgICAgdGV4dDogXCJ2YXIoLS1wYWxldHRlLXRleHQpXCIsXG4gICAgICB0ZXh0TXV0ZWQ6IFwidmFyKC0tcGFsZXR0ZS10ZXh0TXV0ZWQpXCJcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBRbyh0KSB7XG4gIHJldHVybiB0ICYmIHQuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgXCJkZWZhdWx0XCIpID8gdC5kZWZhdWx0IDogdDtcbn1cbmZ1bmN0aW9uIGVhKHQpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBcIl9fZXNNb2R1bGVcIikpIHJldHVybiB0O1xuICB2YXIgZSA9IHQuZGVmYXVsdDtcbiAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciByID0gZnVuY3Rpb24gbigpIHtcbiAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgbiA/IFJlZmxlY3QuY29uc3RydWN0KGUsIGFyZ3VtZW50cywgdGhpcy5jb25zdHJ1Y3RvcikgOiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByLnByb3RvdHlwZSA9IGUucHJvdG90eXBlO1xuICB9IGVsc2UgciA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6ICEwXG4gIH0pLCBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgbik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIG4sIG8uZ2V0ID8gbyA6IHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRbbl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCByO1xufVxudmFyIFZzID0geyBleHBvcnRzOiB7fSB9LCBRbiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBDYTtcbmZ1bmN0aW9uIHRmKCkge1xuICBpZiAoQ2EpIHJldHVybiBRbjtcbiAgQ2EgPSAxO1xuICB2YXIgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSwgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgZnVuY3Rpb24gcihuLCBvLCBpKSB7XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIGlmIChpICE9PSB2b2lkIDAgJiYgKGMgPSBcIlwiICsgaSksIG8ua2V5ICE9PSB2b2lkIDAgJiYgKGMgPSBcIlwiICsgby5rZXkpLCBcImtleVwiIGluIG8pIHtcbiAgICAgIGkgPSB7fTtcbiAgICAgIGZvciAodmFyIGYgaW4gbylcbiAgICAgICAgZiAhPT0gXCJrZXlcIiAmJiAoaVtmXSA9IG9bZl0pO1xuICAgIH0gZWxzZSBpID0gbztcbiAgICByZXR1cm4gbyA9IGkucmVmLCB7XG4gICAgICAkJHR5cGVvZjogdCxcbiAgICAgIHR5cGU6IG4sXG4gICAgICBrZXk6IGMsXG4gICAgICByZWY6IG8gIT09IHZvaWQgMCA/IG8gOiBudWxsLFxuICAgICAgcHJvcHM6IGlcbiAgICB9O1xuICB9XG4gIHJldHVybiBRbi5GcmFnbWVudCA9IGUsIFFuLmpzeCA9IHIsIFFuLmpzeHMgPSByLCBRbjtcbn1cbnZhciBTYTtcbmZ1bmN0aW9uIHJmKCkge1xuICByZXR1cm4gU2EgfHwgKFNhID0gMSwgVnMuZXhwb3J0cyA9IHRmKCkpLCBWcy5leHBvcnRzO1xufVxudmFyIFUgPSByZigpO1xubGV0IHRhID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHIsIG4gPSB7fSkge1xuICAgIHN1cGVyKHIsIG4uY2F1c2UgPyB7IGNhdXNlOiBuLmNhdXNlIH0gOiB2b2lkIDApO1xuICAgIGJyKHRoaXMsIFwibmFtZVwiLCBcIkJhc2VFcnJvclwiKTtcbiAgICBicih0aGlzLCBcImNhdXNlXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBuLmNhdXNlO1xuICB9XG59O1xuY2xhc3MgbmYgZXh0ZW5kcyB0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiSW52YWxpZCBkb21haW4gbWFuaWZlc3RcIik7XG4gICAgYnIodGhpcywgXCJuYW1lXCIsIFwiQWRkTWluaUFwcC5JbnZhbGlkRG9tYWluTWFuaWZlc3RcIik7XG4gIH1cbn1cbmxldCBzZiA9IGNsYXNzIGV4dGVuZHMgdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkFkZCBmcmFtZSByZWplY3RlZCBieSB1c2VyXCIpO1xuICAgIGJyKHRoaXMsIFwibmFtZVwiLCBcIkFkZE1pbmlBcHAuUmVqZWN0ZWRCeVVzZXJcIik7XG4gIH1cbn07XG5jbGFzcyBIdSBleHRlbmRzIHRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJTaWduIGluIHJlamVjdGVkIGJ5IHVzZXJcIik7XG4gICAgYnIodGhpcywgXCJuYW1lXCIsIFwiU2lnbkluLlJlamVjdGVkQnlVc2VyXCIpO1xuICB9XG59XG5jb25zdCBBYSA9IFtcbiAgXCJ3YWxsZXQuZ2V0RXRoZXJldW1Qcm92aWRlclwiLFxuICBcIndhbGxldC5nZXRTb2xhbmFQcm92aWRlclwiLFxuICBcImFjdGlvbnMucmVhZHlcIixcbiAgXCJhY3Rpb25zLm9wZW5VcmxcIixcbiAgXCJhY3Rpb25zLmNsb3NlXCIsXG4gIFwiYWN0aW9ucy5zZXRQcmltYXJ5QnV0dG9uXCIsXG4gIFwiYWN0aW9ucy5hZGRNaW5pQXBwXCIsXG4gIFwiYWN0aW9ucy5zaWduSW5cIixcbiAgXCJhY3Rpb25zLnZpZXdDYXN0XCIsXG4gIFwiYWN0aW9ucy52aWV3UHJvZmlsZVwiLFxuICBcImFjdGlvbnMuY29tcG9zZUNhc3RcIixcbiAgXCJhY3Rpb25zLnZpZXdUb2tlblwiLFxuICBcImFjdGlvbnMuc2VuZFRva2VuXCIsXG4gIFwiYWN0aW9ucy5zd2FwVG9rZW5cIixcbiAgXCJoYXB0aWNzLmltcGFjdE9jY3VycmVkXCIsXG4gIFwiaGFwdGljcy5ub3RpZmljYXRpb25PY2N1cnJlZFwiLFxuICBcImhhcHRpY3Muc2VsZWN0aW9uQ2hhbmdlZFwiLFxuICBcImJhY2tcIlxuXTtcbnZhciBudDtcbihmdW5jdGlvbih0KSB7XG4gIHQuYXNzZXJ0RXF1YWwgPSAobykgPT4gbztcbiAgZnVuY3Rpb24gZShvKSB7XG4gIH1cbiAgdC5hc3NlcnRJcyA9IGU7XG4gIGZ1bmN0aW9uIHIobykge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHQuYXNzZXJ0TmV2ZXIgPSByLCB0LmFycmF5VG9FbnVtID0gKG8pID0+IHtcbiAgICBjb25zdCBpID0ge307XG4gICAgZm9yIChjb25zdCBjIG9mIG8pXG4gICAgICBpW2NdID0gYztcbiAgICByZXR1cm4gaTtcbiAgfSwgdC5nZXRWYWxpZEVudW1WYWx1ZXMgPSAobykgPT4ge1xuICAgIGNvbnN0IGkgPSB0Lm9iamVjdEtleXMobykuZmlsdGVyKChmKSA9PiB0eXBlb2Ygb1tvW2ZdXSAhPSBcIm51bWJlclwiKSwgYyA9IHt9O1xuICAgIGZvciAoY29uc3QgZiBvZiBpKVxuICAgICAgY1tmXSA9IG9bZl07XG4gICAgcmV0dXJuIHQub2JqZWN0VmFsdWVzKGMpO1xuICB9LCB0Lm9iamVjdFZhbHVlcyA9IChvKSA9PiB0Lm9iamVjdEtleXMobykubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gb1tpXTtcbiAgfSksIHQub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PSBcImZ1bmN0aW9uXCIgPyAobykgPT4gT2JqZWN0LmtleXMobykgOiAobykgPT4ge1xuICAgIGNvbnN0IGkgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGMgaW4gbylcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBjKSAmJiBpLnB1c2goYyk7XG4gICAgcmV0dXJuIGk7XG4gIH0sIHQuZmluZCA9IChvLCBpKSA9PiB7XG4gICAgZm9yIChjb25zdCBjIG9mIG8pXG4gICAgICBpZiAoaShjKSlcbiAgICAgICAgcmV0dXJuIGM7XG4gIH0sIHQuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT0gXCJmdW5jdGlvblwiID8gKG8pID0+IE51bWJlci5pc0ludGVnZXIobykgOiAobykgPT4gdHlwZW9mIG8gPT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShvKSAmJiBNYXRoLmZsb29yKG8pID09PSBvO1xuICBmdW5jdGlvbiBuKG8sIGkgPSBcIiB8IFwiKSB7XG4gICAgcmV0dXJuIG8ubWFwKChjKSA9PiB0eXBlb2YgYyA9PSBcInN0cmluZ1wiID8gYCcke2N9J2AgOiBjKS5qb2luKGkpO1xuICB9XG4gIHQuam9pblZhbHVlcyA9IG4sIHQuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKG8sIGkpID0+IHR5cGVvZiBpID09IFwiYmlnaW50XCIgPyBpLnRvU3RyaW5nKCkgOiBpO1xufSkobnQgfHwgKG50ID0ge30pKTtcbnZhciBrbztcbihmdW5jdGlvbih0KSB7XG4gIHQubWVyZ2VTaGFwZXMgPSAoZSwgcikgPT4gKHtcbiAgICAuLi5lLFxuICAgIC4uLnJcbiAgICAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxuICB9KTtcbn0pKGtvIHx8IChrbyA9IHt9KSk7XG5jb25zdCBsZSA9IG50LmFycmF5VG9FbnVtKFtcbiAgXCJzdHJpbmdcIixcbiAgXCJuYW5cIixcbiAgXCJudW1iZXJcIixcbiAgXCJpbnRlZ2VyXCIsXG4gIFwiZmxvYXRcIixcbiAgXCJib29sZWFuXCIsXG4gIFwiZGF0ZVwiLFxuICBcImJpZ2ludFwiLFxuICBcInN5bWJvbFwiLFxuICBcImZ1bmN0aW9uXCIsXG4gIFwidW5kZWZpbmVkXCIsXG4gIFwibnVsbFwiLFxuICBcImFycmF5XCIsXG4gIFwib2JqZWN0XCIsXG4gIFwidW5rbm93blwiLFxuICBcInByb21pc2VcIixcbiAgXCJ2b2lkXCIsXG4gIFwibmV2ZXJcIixcbiAgXCJtYXBcIixcbiAgXCJzZXRcIlxuXSksIHByID0gKHQpID0+IHtcbiAgc3dpdGNoICh0eXBlb2YgdCkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBsZS51bmRlZmluZWQ7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGxlLnN0cmluZztcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gaXNOYU4odCkgPyBsZS5uYW4gOiBsZS5udW1iZXI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBsZS5ib29sZWFuO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcmV0dXJuIGxlLmZ1bmN0aW9uO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBsZS5iaWdpbnQ7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIGxlLnN5bWJvbDtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IGxlLmFycmF5IDogdCA9PT0gbnVsbCA/IGxlLm51bGwgOiB0LnRoZW4gJiYgdHlwZW9mIHQudGhlbiA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jYXRjaCAmJiB0eXBlb2YgdC5jYXRjaCA9PSBcImZ1bmN0aW9uXCIgPyBsZS5wcm9taXNlIDogdHlwZW9mIE1hcCA8IFwidVwiICYmIHQgaW5zdGFuY2VvZiBNYXAgPyBsZS5tYXAgOiB0eXBlb2YgU2V0IDwgXCJ1XCIgJiYgdCBpbnN0YW5jZW9mIFNldCA/IGxlLnNldCA6IHR5cGVvZiBEYXRlIDwgXCJ1XCIgJiYgdCBpbnN0YW5jZW9mIERhdGUgPyBsZS5kYXRlIDogbGUub2JqZWN0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbGUudW5rbm93bjtcbiAgfVxufSwgbmUgPSBudC5hcnJheVRvRW51bShbXG4gIFwiaW52YWxpZF90eXBlXCIsXG4gIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gIFwiY3VzdG9tXCIsXG4gIFwiaW52YWxpZF91bmlvblwiLFxuICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gIFwiaW52YWxpZF9kYXRlXCIsXG4gIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgXCJ0b29fc21hbGxcIixcbiAgXCJ0b29fYmlnXCIsXG4gIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgXCJub3RfZmluaXRlXCJcbl0pLCBvZiA9ICh0KSA9PiBKU09OLnN0cmluZ2lmeSh0LCBudWxsLCAyKS5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xuY2xhc3MgWnQgZXh0ZW5kcyBFcnJvciB7XG4gIGdldCBlcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzc3VlcyA9IFtdLCB0aGlzLmFkZElzc3VlID0gKG4pID0+IHtcbiAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBuXTtcbiAgICB9LCB0aGlzLmFkZElzc3VlcyA9IChuID0gW10pID0+IHtcbiAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5uXTtcbiAgICB9O1xuICAgIGNvbnN0IHIgPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgcikgOiB0aGlzLl9fcHJvdG9fXyA9IHIsIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIiwgdGhpcy5pc3N1ZXMgPSBlO1xuICB9XG4gIGZvcm1hdChlKSB7XG4gICAgY29uc3QgciA9IGUgfHwgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIGkubWVzc2FnZTtcbiAgICB9LCBuID0geyBfZXJyb3JzOiBbXSB9LCBvID0gKGkpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBpLmlzc3VlcylcbiAgICAgICAgaWYgKGMuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpXG4gICAgICAgICAgYy51bmlvbkVycm9ycy5tYXAobyk7XG4gICAgICAgIGVsc2UgaWYgKGMuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpXG4gICAgICAgICAgbyhjLnJldHVyblR5cGVFcnJvcik7XG4gICAgICAgIGVsc2UgaWYgKGMuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKVxuICAgICAgICAgIG8oYy5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgIGVsc2UgaWYgKGMucGF0aC5sZW5ndGggPT09IDApXG4gICAgICAgICAgbi5fZXJyb3JzLnB1c2gocihjKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBmID0gbiwgdiA9IDA7XG4gICAgICAgICAgZm9yICg7IHYgPCBjLnBhdGgubGVuZ3RoOyApIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBjLnBhdGhbdl07XG4gICAgICAgICAgICB2ID09PSBjLnBhdGgubGVuZ3RoIC0gMSA/IChmW3hdID0gZlt4XSB8fCB7IF9lcnJvcnM6IFtdIH0sIGZbeF0uX2Vycm9ycy5wdXNoKHIoYykpKSA6IGZbeF0gPSBmW3hdIHx8IHsgX2Vycm9yczogW10gfSwgZiA9IGZbeF0sIHYrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBvKHRoaXMpLCBuO1xuICB9XG4gIHN0YXRpYyBhc3NlcnQoZSkge1xuICAgIGlmICghKGUgaW5zdGFuY2VvZiBadCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke2V9YCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfVxuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIG50Lmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBmbGF0dGVuKGUgPSAocikgPT4gci5tZXNzYWdlKSB7XG4gICAgY29uc3QgciA9IHt9LCBuID0gW107XG4gICAgZm9yIChjb25zdCBvIG9mIHRoaXMuaXNzdWVzKVxuICAgICAgby5wYXRoLmxlbmd0aCA+IDAgPyAocltvLnBhdGhbMF1dID0gcltvLnBhdGhbMF1dIHx8IFtdLCByW28ucGF0aFswXV0ucHVzaChlKG8pKSkgOiBuLnB1c2goZShvKSk7XG4gICAgcmV0dXJuIHsgZm9ybUVycm9yczogbiwgZmllbGRFcnJvcnM6IHIgfTtcbiAgfVxuICBnZXQgZm9ybUVycm9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gIH1cbn1cblp0LmNyZWF0ZSA9ICh0KSA9PiBuZXcgWnQodCk7XG5jb25zdCBSbiA9ICh0LCBlKSA9PiB7XG4gIGxldCByO1xuICBzd2l0Y2ggKHQuY29kZSkge1xuICAgIGNhc2UgbmUuaW52YWxpZF90eXBlOlxuICAgICAgdC5yZWNlaXZlZCA9PT0gbGUudW5kZWZpbmVkID8gciA9IFwiUmVxdWlyZWRcIiA6IHIgPSBgRXhwZWN0ZWQgJHt0LmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHt0LnJlY2VpdmVkfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5lLmludmFsaWRfbGl0ZXJhbDpcbiAgICAgIHIgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KHQuZXhwZWN0ZWQsIG50Lmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgbmUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICByID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke250LmpvaW5WYWx1ZXModC5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5lLmludmFsaWRfdW5pb246XG4gICAgICByID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5lLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgIHIgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke250LmpvaW5WYWx1ZXModC5vcHRpb25zKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBuZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICByID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHtudC5qb2luVmFsdWVzKHQub3B0aW9ucyl9LCByZWNlaXZlZCAnJHt0LnJlY2VpdmVkfSdgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBuZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgIHIgPSBcIkludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5lLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICByID0gXCJJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5lLmludmFsaWRfZGF0ZTpcbiAgICAgIHIgPSBcIkludmFsaWQgZGF0ZVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBuZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgIHR5cGVvZiB0LnZhbGlkYXRpb24gPT0gXCJvYmplY3RcIiA/IFwiaW5jbHVkZXNcIiBpbiB0LnZhbGlkYXRpb24gPyAociA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke3QudmFsaWRhdGlvbi5pbmNsdWRlc31cImAsIHR5cGVvZiB0LnZhbGlkYXRpb24ucG9zaXRpb24gPT0gXCJudW1iZXJcIiAmJiAociA9IGAke3J9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHt0LnZhbGlkYXRpb24ucG9zaXRpb259YCkpIDogXCJzdGFydHNXaXRoXCIgaW4gdC52YWxpZGF0aW9uID8gciA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke3QudmFsaWRhdGlvbi5zdGFydHNXaXRofVwiYCA6IFwiZW5kc1dpdGhcIiBpbiB0LnZhbGlkYXRpb24gPyByID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke3QudmFsaWRhdGlvbi5lbmRzV2l0aH1cImAgOiBudC5hc3NlcnROZXZlcih0LnZhbGlkYXRpb24pIDogdC52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIgPyByID0gYEludmFsaWQgJHt0LnZhbGlkYXRpb259YCA6IHIgPSBcIkludmFsaWRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgbmUudG9vX3NtYWxsOlxuICAgICAgdC50eXBlID09PSBcImFycmF5XCIgPyByID0gYEFycmF5IG11c3QgY29udGFpbiAke3QuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHQuaW5jbHVzaXZlID8gXCJhdCBsZWFzdFwiIDogXCJtb3JlIHRoYW5cIn0gJHt0Lm1pbmltdW19IGVsZW1lbnQocylgIDogdC50eXBlID09PSBcInN0cmluZ1wiID8gciA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7dC5leGFjdCA/IFwiZXhhY3RseVwiIDogdC5pbmNsdXNpdmUgPyBcImF0IGxlYXN0XCIgOiBcIm92ZXJcIn0gJHt0Lm1pbmltdW19IGNoYXJhY3RlcihzKWAgOiB0LnR5cGUgPT09IFwibnVtYmVyXCIgPyByID0gYE51bWJlciBtdXN0IGJlICR7dC5leGFjdCA/IFwiZXhhY3RseSBlcXVhbCB0byBcIiA6IHQuaW5jbHVzaXZlID8gXCJncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gXCIgOiBcImdyZWF0ZXIgdGhhbiBcIn0ke3QubWluaW11bX1gIDogdC50eXBlID09PSBcImRhdGVcIiA/IHIgPSBgRGF0ZSBtdXN0IGJlICR7dC5leGFjdCA/IFwiZXhhY3RseSBlcXVhbCB0byBcIiA6IHQuaW5jbHVzaXZlID8gXCJncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gXCIgOiBcImdyZWF0ZXIgdGhhbiBcIn0ke25ldyBEYXRlKE51bWJlcih0Lm1pbmltdW0pKX1gIDogciA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBuZS50b29fYmlnOlxuICAgICAgdC50eXBlID09PSBcImFycmF5XCIgPyByID0gYEFycmF5IG11c3QgY29udGFpbiAke3QuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHQuaW5jbHVzaXZlID8gXCJhdCBtb3N0XCIgOiBcImxlc3MgdGhhblwifSAke3QubWF4aW11bX0gZWxlbWVudChzKWAgOiB0LnR5cGUgPT09IFwic3RyaW5nXCIgPyByID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHt0LmV4YWN0ID8gXCJleGFjdGx5XCIgOiB0LmluY2x1c2l2ZSA/IFwiYXQgbW9zdFwiIDogXCJ1bmRlclwifSAke3QubWF4aW11bX0gY2hhcmFjdGVyKHMpYCA6IHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHIgPSBgTnVtYmVyIG11c3QgYmUgJHt0LmV4YWN0ID8gXCJleGFjdGx5XCIgOiB0LmluY2x1c2l2ZSA/IFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvXCIgOiBcImxlc3MgdGhhblwifSAke3QubWF4aW11bX1gIDogdC50eXBlID09PSBcImJpZ2ludFwiID8gciA9IGBCaWdJbnQgbXVzdCBiZSAke3QuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHQuaW5jbHVzaXZlID8gXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG9cIiA6IFwibGVzcyB0aGFuXCJ9ICR7dC5tYXhpbXVtfWAgOiB0LnR5cGUgPT09IFwiZGF0ZVwiID8gciA9IGBEYXRlIG11c3QgYmUgJHt0LmV4YWN0ID8gXCJleGFjdGx5XCIgOiB0LmluY2x1c2l2ZSA/IFwic21hbGxlciB0aGFuIG9yIGVxdWFsIHRvXCIgOiBcInNtYWxsZXIgdGhhblwifSAke25ldyBEYXRlKE51bWJlcih0Lm1heGltdW0pKX1gIDogciA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBuZS5jdXN0b206XG4gICAgICByID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5lLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgciA9IFwiSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBuZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICByID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHt0Lm11bHRpcGxlT2Z9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgbmUubm90X2Zpbml0ZTpcbiAgICAgIHIgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHIgPSBlLmRlZmF1bHRFcnJvciwgbnQuYXNzZXJ0TmV2ZXIodCk7XG4gIH1cbiAgcmV0dXJuIHsgbWVzc2FnZTogciB9O1xufTtcbmxldCBLdSA9IFJuO1xuZnVuY3Rpb24gYWYodCkge1xuICBLdSA9IHQ7XG59XG5mdW5jdGlvbiBhcygpIHtcbiAgcmV0dXJuIEt1O1xufVxuY29uc3QgdXMgPSAodCkgPT4ge1xuICBjb25zdCB7IGRhdGE6IGUsIHBhdGg6IHIsIGVycm9yTWFwczogbiwgaXNzdWVEYXRhOiBvIH0gPSB0LCBpID0gWy4uLnIsIC4uLm8ucGF0aCB8fCBbXV0sIGMgPSB7XG4gICAgLi4ubyxcbiAgICBwYXRoOiBpXG4gIH07XG4gIGlmIChvLm1lc3NhZ2UgIT09IHZvaWQgMClcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubyxcbiAgICAgIHBhdGg6IGksXG4gICAgICBtZXNzYWdlOiBvLm1lc3NhZ2VcbiAgICB9O1xuICBsZXQgZiA9IFwiXCI7XG4gIGNvbnN0IHYgPSBuLmZpbHRlcigoeCkgPT4gISF4KS5zbGljZSgpLnJldmVyc2UoKTtcbiAgZm9yIChjb25zdCB4IG9mIHYpXG4gICAgZiA9IHgoYywgeyBkYXRhOiBlLCBkZWZhdWx0RXJyb3I6IGYgfSkubWVzc2FnZTtcbiAgcmV0dXJuIHtcbiAgICAuLi5vLFxuICAgIHBhdGg6IGksXG4gICAgbWVzc2FnZTogZlxuICB9O1xufSwgdWYgPSBbXTtcbmZ1bmN0aW9uIG9lKHQsIGUpIHtcbiAgY29uc3QgciA9IGFzKCksIG4gPSB1cyh7XG4gICAgaXNzdWVEYXRhOiBlLFxuICAgIGRhdGE6IHQuZGF0YSxcbiAgICBwYXRoOiB0LnBhdGgsXG4gICAgZXJyb3JNYXBzOiBbXG4gICAgICB0LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAvLyBjb250ZXh0dWFsIGVycm9yIG1hcCBpcyBmaXJzdCBwcmlvcml0eVxuICAgICAgdC5zY2hlbWFFcnJvck1hcCxcbiAgICAgIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgIHIsXG4gICAgICAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgIHIgPT09IFJuID8gdm9pZCAwIDogUm5cbiAgICAgIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgXS5maWx0ZXIoKG8pID0+ICEhbylcbiAgfSk7XG4gIHQuY29tbW9uLmlzc3Vlcy5wdXNoKG4pO1xufVxuY2xhc3MgTHQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICB9XG4gIGRpcnR5KCkge1xuICAgIHRoaXMudmFsdWUgPT09IFwidmFsaWRcIiAmJiAodGhpcy52YWx1ZSA9IFwiZGlydHlcIik7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIgJiYgKHRoaXMudmFsdWUgPSBcImFib3J0ZWRcIik7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXJyYXkoZSwgcikge1xuICAgIGNvbnN0IG4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IG8gb2Ygcikge1xuICAgICAgaWYgKG8uc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIEFlO1xuICAgICAgby5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiBlLmRpcnR5KCksIG4ucHVzaChvLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBlLnZhbHVlLCB2YWx1ZTogbiB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKGUsIHIpIHtcbiAgICBjb25zdCBuID0gW107XG4gICAgZm9yIChjb25zdCBvIG9mIHIpIHtcbiAgICAgIGNvbnN0IGkgPSBhd2FpdCBvLmtleSwgYyA9IGF3YWl0IG8udmFsdWU7XG4gICAgICBuLnB1c2goe1xuICAgICAgICBrZXk6IGksXG4gICAgICAgIHZhbHVlOiBjXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEx0Lm1lcmdlT2JqZWN0U3luYyhlLCBuKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKGUsIHIpIHtcbiAgICBjb25zdCBuID0ge307XG4gICAgZm9yIChjb25zdCBvIG9mIHIpIHtcbiAgICAgIGNvbnN0IHsga2V5OiBpLCB2YWx1ZTogYyB9ID0gbztcbiAgICAgIGlmIChpLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgYy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gQWU7XG4gICAgICBpLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIGUuZGlydHkoKSwgYy5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiBlLmRpcnR5KCksIGkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiYgKHR5cGVvZiBjLnZhbHVlIDwgXCJ1XCIgfHwgby5hbHdheXNTZXQpICYmIChuW2kudmFsdWVdID0gYy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogZS52YWx1ZSwgdmFsdWU6IG4gfTtcbiAgfVxufVxuY29uc3QgQWUgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdHVzOiBcImFib3J0ZWRcIlxufSksIENuID0gKHQpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZTogdCB9KSwganQgPSAodCkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiB0IH0pLCBJbyA9ICh0KSA9PiB0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIsIEJvID0gKHQpID0+IHQuc3RhdHVzID09PSBcImRpcnR5XCIsIHVuID0gKHQpID0+IHQuc3RhdHVzID09PSBcInZhbGlkXCIsIG9pID0gKHQpID0+IHR5cGVvZiBQcm9taXNlIDwgXCJ1XCIgJiYgdCBpbnN0YW5jZW9mIFByb21pc2U7XG5mdW5jdGlvbiBjcyh0LCBlLCByLCBuKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyB0ICE9PSBlIHx8ICEwIDogIWUuaGFzKHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gZS5nZXQodCk7XG59XG5mdW5jdGlvbiBXdSh0LCBlLCByLCBuLCBvKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyB0ICE9PSBlIHx8ICEwIDogIWUuaGFzKHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBlLnNldCh0LCByKSwgcjtcbn1cbnZhciB2ZTtcbihmdW5jdGlvbih0KSB7XG4gIHQuZXJyVG9PYmogPSAoZSkgPT4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogZSB9IDogZSB8fCB7fSwgdC50b1N0cmluZyA9IChlKSA9PiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUubWVzc2FnZTtcbn0pKHZlIHx8ICh2ZSA9IHt9KSk7XG52YXIgdGksIHJpO1xuY2xhc3Mgc3Ige1xuICBjb25zdHJ1Y3RvcihlLCByLCBuLCBvKSB7XG4gICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdLCB0aGlzLnBhcmVudCA9IGUsIHRoaXMuZGF0YSA9IHIsIHRoaXMuX3BhdGggPSBuLCB0aGlzLl9rZXkgPSBvO1xuICB9XG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCB8fCAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KSA6IHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpKSwgdGhpcy5fY2FjaGVkUGF0aDtcbiAgfVxufVxuY29uc3Qga2EgPSAodCwgZSkgPT4ge1xuICBpZiAodW4oZSkpXG4gICAgcmV0dXJuIHsgc3VjY2VzczogITAsIGRhdGE6IGUudmFsdWUgfTtcbiAgaWYgKCF0LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6ICExLFxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgY29uc3QgciA9IG5ldyBadCh0LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yID0gciwgdGhpcy5fZXJyb3I7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIFRlKHQpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgeyBlcnJvck1hcDogZSwgaW52YWxpZF90eXBlX2Vycm9yOiByLCByZXF1aXJlZF9lcnJvcjogbiwgZGVzY3JpcHRpb246IG8gfSA9IHQ7XG4gIGlmIChlICYmIChyIHx8IG4pKVxuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgcmV0dXJuIGUgPyB7IGVycm9yTWFwOiBlLCBkZXNjcmlwdGlvbjogbyB9IDogeyBlcnJvck1hcDogKGMsIGYpID0+IHtcbiAgICB2YXIgdiwgeDtcbiAgICBjb25zdCB7IG1lc3NhZ2U6IGIgfSA9IHQ7XG4gICAgcmV0dXJuIGMuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIiA/IHsgbWVzc2FnZTogYiA/PyBmLmRlZmF1bHRFcnJvciB9IDogdHlwZW9mIGYuZGF0YSA+IFwidVwiID8geyBtZXNzYWdlOiAodiA9IGIgPz8gbikgIT09IG51bGwgJiYgdiAhPT0gdm9pZCAwID8gdiA6IGYuZGVmYXVsdEVycm9yIH0gOiBjLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIgPyB7IG1lc3NhZ2U6IGYuZGVmYXVsdEVycm9yIH0gOiB7IG1lc3NhZ2U6ICh4ID0gYiA/PyByKSAhPT0gbnVsbCAmJiB4ICE9PSB2b2lkIDAgPyB4IDogZi5kZWZhdWx0RXJyb3IgfTtcbiAgfSwgZGVzY3JpcHRpb246IG8gfTtcbn1cbmNsYXNzIEplIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gIH1cbiAgX2dldFR5cGUoZSkge1xuICAgIHJldHVybiBwcihlLmRhdGEpO1xuICB9XG4gIF9nZXRPclJldHVybkN0eChlLCByKSB7XG4gICAgcmV0dXJuIHIgfHwge1xuICAgICAgY29tbW9uOiBlLnBhcmVudC5jb21tb24sXG4gICAgICBkYXRhOiBlLmRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBwcihlLmRhdGEpLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhdGg6IGUucGF0aCxcbiAgICAgIHBhcmVudDogZS5wYXJlbnRcbiAgICB9O1xuICB9XG4gIF9wcm9jZXNzSW5wdXRQYXJhbXMoZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IG5ldyBMdCgpLFxuICAgICAgY3R4OiB7XG4gICAgICAgIGNvbW1vbjogZS5wYXJlbnQuY29tbW9uLFxuICAgICAgICBkYXRhOiBlLmRhdGEsXG4gICAgICAgIHBhcnNlZFR5cGU6IHByKGUuZGF0YSksXG4gICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgIHBhdGg6IGUucGF0aCxcbiAgICAgICAgcGFyZW50OiBlLnBhcmVudFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX3BhcnNlU3luYyhlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX3BhcnNlKGUpO1xuICAgIGlmIChvaShyKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgIHJldHVybiByO1xuICB9XG4gIF9wYXJzZUFzeW5jKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5fcGFyc2UoZSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyKTtcbiAgfVxuICBwYXJzZShlLCByKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc2FmZVBhcnNlKGUsIHIpO1xuICAgIGlmIChuLnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gbi5kYXRhO1xuICAgIHRocm93IG4uZXJyb3I7XG4gIH1cbiAgc2FmZVBhcnNlKGUsIHIpIHtcbiAgICB2YXIgbjtcbiAgICBjb25zdCBvID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAobiA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYXN5bmMpICE9PSBudWxsICYmIG4gIT09IHZvaWQgMCA/IG4gOiAhMSxcbiAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiByID09IG51bGwgPyB2b2lkIDAgOiByLmVycm9yTWFwXG4gICAgICB9LFxuICAgICAgcGF0aDogKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIucGF0aCkgfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YTogZSxcbiAgICAgIHBhcnNlZFR5cGU6IHByKGUpXG4gICAgfSwgaSA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGE6IGUsIHBhdGg6IG8ucGF0aCwgcGFyZW50OiBvIH0pO1xuICAgIHJldHVybiBrYShvLCBpKTtcbiAgfVxuICBcIn52YWxpZGF0ZVwiKGUpIHtcbiAgICB2YXIgciwgbjtcbiAgICBjb25zdCBvID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmNcbiAgICAgIH0sXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBkYXRhOiBlLFxuICAgICAgcGFyc2VkVHlwZTogcHIoZSlcbiAgICB9O1xuICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhOiBlLCBwYXRoOiBbXSwgcGFyZW50OiBvIH0pO1xuICAgICAgICByZXR1cm4gdW4oaSkgPyB7XG4gICAgICAgICAgdmFsdWU6IGkudmFsdWVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBpc3N1ZXM6IG8uY29tbW9uLmlzc3Vlc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICAhKChuID0gKHIgPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLm1lc3NhZ2UpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwKSAmJiBuLmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikgJiYgKHRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMgPSAhMCksIG8uY29tbW9uID0ge1xuICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgYXN5bmM6ICEwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhOiBlLCBwYXRoOiBbXSwgcGFyZW50OiBvIH0pLnRoZW4oKGkpID0+IHVuKGkpID8ge1xuICAgICAgdmFsdWU6IGkudmFsdWVcbiAgICB9IDoge1xuICAgICAgaXNzdWVzOiBvLmNvbW1vbi5pc3N1ZXNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwYXJzZUFzeW5jKGUsIHIpIHtcbiAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhlLCByKTtcbiAgICBpZiAobi5zdWNjZXNzKVxuICAgICAgcmV0dXJuIG4uZGF0YTtcbiAgICB0aHJvdyBuLmVycm9yO1xuICB9XG4gIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGUsIHIpIHtcbiAgICBjb25zdCBuID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogciA9PSBudWxsID8gdm9pZCAwIDogci5lcnJvck1hcCxcbiAgICAgICAgYXN5bmM6ICEwXG4gICAgICB9LFxuICAgICAgcGF0aDogKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIucGF0aCkgfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YTogZSxcbiAgICAgIHBhcnNlZFR5cGU6IHByKGUpXG4gICAgfSwgbyA9IHRoaXMuX3BhcnNlKHsgZGF0YTogZSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSksIGkgPSBhd2FpdCAob2kobykgPyBvIDogUHJvbWlzZS5yZXNvbHZlKG8pKTtcbiAgICByZXR1cm4ga2EobiwgaSk7XG4gIH1cbiAgcmVmaW5lKGUsIHIpIHtcbiAgICBjb25zdCBuID0gKG8pID0+IHR5cGVvZiByID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHIgPiBcInVcIiA/IHsgbWVzc2FnZTogciB9IDogdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gcihvKSA6IHI7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKG8sIGkpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBlKG8pLCBmID0gKCkgPT4gaS5hZGRJc3N1ZSh7XG4gICAgICAgIGNvZGU6IG5lLmN1c3RvbSxcbiAgICAgICAgLi4ubihvKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIFByb21pc2UgPCBcInVcIiAmJiBjIGluc3RhbmNlb2YgUHJvbWlzZSA/IGMudGhlbigodikgPT4gdiA/ICEwIDogKGYoKSwgITEpKSA6IGMgPyAhMCA6IChmKCksICExKTtcbiAgICB9KTtcbiAgfVxuICByZWZpbmVtZW50KGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgobiwgbykgPT4gZShuKSA/ICEwIDogKG8uYWRkSXNzdWUodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gcihuLCBvKSA6IHIpLCAhMSkpO1xuICB9XG4gIF9yZWZpbmVtZW50KGUpIHtcbiAgICByZXR1cm4gbmV3IFl0KHtcbiAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgIHR5cGVOYW1lOiBDZS5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50OiBlIH1cbiAgICB9KTtcbiAgfVxuICBzdXBlclJlZmluZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoZSk7XG4gIH1cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYywgdGhpcy5fZGVmID0gZSwgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKSwgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpLCB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKSwgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKSwgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpLCB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyksIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpLCB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpLCB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpLCB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKSwgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKSwgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyksIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyksIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKSwgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpLCB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpLCB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKSwgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKSwgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKSwgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyksIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyksIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpLCB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKSwgdGhpc1tcIn5zdGFuZGFyZFwiXSA9IHtcbiAgICAgIHZlcnNpb246IDEsXG4gICAgICB2ZW5kb3I6IFwiem9kXCIsXG4gICAgICB2YWxpZGF0ZTogKHIpID0+IHRoaXNbXCJ+dmFsaWRhdGVcIl0ocilcbiAgICB9O1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiBpci5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsYWJsZSgpIHtcbiAgICByZXR1cm4ganIuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gIH1cbiAgbnVsbGlzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gIH1cbiAgYXJyYXkoKSB7XG4gICAgcmV0dXJuIEd0LmNyZWF0ZSh0aGlzKTtcbiAgfVxuICBwcm9taXNlKCkge1xuICAgIHJldHVybiBMbi5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBvcihlKSB7XG4gICAgcmV0dXJuIGxpLmNyZWF0ZShbdGhpcywgZV0sIHRoaXMuX2RlZik7XG4gIH1cbiAgYW5kKGUpIHtcbiAgICByZXR1cm4gZmkuY3JlYXRlKHRoaXMsIGUsIHRoaXMuX2RlZik7XG4gIH1cbiAgdHJhbnNmb3JtKGUpIHtcbiAgICByZXR1cm4gbmV3IFl0KHtcbiAgICAgIC4uLlRlKHRoaXMuX2RlZiksXG4gICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICB0eXBlTmFtZTogQ2UuWm9kRWZmZWN0cyxcbiAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm06IGUgfVxuICAgIH0pO1xuICB9XG4gIGRlZmF1bHQoZSkge1xuICAgIGNvbnN0IHIgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogKCkgPT4gZTtcbiAgICByZXR1cm4gbmV3IGdpKHtcbiAgICAgIC4uLlRlKHRoaXMuX2RlZiksXG4gICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICBkZWZhdWx0VmFsdWU6IHIsXG4gICAgICB0eXBlTmFtZTogQ2UuWm9kRGVmYXVsdFxuICAgIH0pO1xuICB9XG4gIGJyYW5kKCkge1xuICAgIHJldHVybiBuZXcgcmEoe1xuICAgICAgdHlwZU5hbWU6IENlLlpvZEJyYW5kZWQsXG4gICAgICB0eXBlOiB0aGlzLFxuICAgICAgLi4uVGUodGhpcy5fZGVmKVxuICAgIH0pO1xuICB9XG4gIGNhdGNoKGUpIHtcbiAgICBjb25zdCByID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSA6ICgpID0+IGU7XG4gICAgcmV0dXJuIG5ldyB5aSh7XG4gICAgICAuLi5UZSh0aGlzLl9kZWYpLFxuICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgY2F0Y2hWYWx1ZTogcixcbiAgICAgIHR5cGVOYW1lOiBDZS5ab2RDYXRjaFxuICAgIH0pO1xuICB9XG4gIGRlc2NyaWJlKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IHIoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZGVzY3JpcHRpb246IGVcbiAgICB9KTtcbiAgfVxuICBwaXBlKGUpIHtcbiAgICByZXR1cm4gamkuY3JlYXRlKHRoaXMsIGUpO1xuICB9XG4gIHJlYWRvbmx5KCkge1xuICAgIHJldHVybiB2aS5jcmVhdGUodGhpcyk7XG4gIH1cbiAgaXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2Uodm9pZCAwKS5zdWNjZXNzO1xuICB9XG4gIGlzTnVsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gIH1cbn1cbmNvbnN0IGNmID0gL15jW15cXHMtXXs4LH0kL2ksIGxmID0gL15bMC05YS16XSskLywgZmYgPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kL2ksIGhmID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2ksIGRmID0gL15bYS16MC05Xy1dezIxfSQvaSwgcGYgPSAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvLCBtZiA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC8sIGdmID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaSwgeWYgPSBcIl4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskXCI7XG5sZXQgSHM7XG5jb25zdCB2ZiA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC8sIHdmID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC8sIHhmID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC8sIGJmID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLywgX2YgPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC8sIEVmID0gL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvLCBHdSA9IFwiKChcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oKDBbMTM1NzhdfDFbMDJdKS0oMFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXGR8MlswLThdKSkpXCIsIE1mID0gbmV3IFJlZ0V4cChgXiR7R3V9JGApO1xuZnVuY3Rpb24gWXUodCkge1xuICBsZXQgZSA9IFwiKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQ6WzAtNV1cXFxcZFwiO1xuICByZXR1cm4gdC5wcmVjaXNpb24gPyBlID0gYCR7ZX1cXFxcLlxcXFxkeyR7dC5wcmVjaXNpb259fWAgOiB0LnByZWNpc2lvbiA9PSBudWxsICYmIChlID0gYCR7ZX0oXFxcXC5cXFxcZCspP2ApLCBlO1xufVxuZnVuY3Rpb24gQ2YodCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7WXUodCl9JGApO1xufVxuZnVuY3Rpb24gSnUodCkge1xuICBsZXQgZSA9IGAke0d1fVQke1l1KHQpfWA7XG4gIGNvbnN0IHIgPSBbXTtcbiAgcmV0dXJuIHIucHVzaCh0LmxvY2FsID8gXCJaP1wiIDogXCJaXCIpLCB0Lm9mZnNldCAmJiByLnB1c2goXCIoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlcIiksIGUgPSBgJHtlfSgke3Iuam9pbihcInxcIil9KWAsIG5ldyBSZWdFeHAoYF4ke2V9JGApO1xufVxuZnVuY3Rpb24gU2YodCwgZSkge1xuICByZXR1cm4gISEoKGUgPT09IFwidjRcIiB8fCAhZSkgJiYgdmYudGVzdCh0KSB8fCAoZSA9PT0gXCJ2NlwiIHx8ICFlKSAmJiB4Zi50ZXN0KHQpKTtcbn1cbmZ1bmN0aW9uIEFmKHQsIGUpIHtcbiAgaWYgKCFwZi50ZXN0KHQpKVxuICAgIHJldHVybiAhMTtcbiAgdHJ5IHtcbiAgICBjb25zdCBbcl0gPSB0LnNwbGl0KFwiLlwiKSwgbiA9IHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIikucGFkRW5kKHIubGVuZ3RoICsgKDQgLSByLmxlbmd0aCAlIDQpICUgNCwgXCI9XCIpLCBvID0gSlNPTi5wYXJzZShhdG9iKG4pKTtcbiAgICByZXR1cm4gISh0eXBlb2YgbyAhPSBcIm9iamVjdFwiIHx8IG8gPT09IG51bGwgfHwgIW8udHlwIHx8ICFvLmFsZyB8fCBlICYmIG8uYWxnICE9PSBlKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBrZih0LCBlKSB7XG4gIHJldHVybiAhISgoZSA9PT0gXCJ2NFwiIHx8ICFlKSAmJiB3Zi50ZXN0KHQpIHx8IChlID09PSBcInY2XCIgfHwgIWUpICYmIGJmLnRlc3QodCkpO1xufVxuY2xhc3MgV3QgZXh0ZW5kcyBKZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UgJiYgKGUuZGF0YSA9IFN0cmluZyhlLmRhdGEpKSwgdGhpcy5fZ2V0VHlwZShlKSAhPT0gbGUuc3RyaW5nKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gb2UoaSwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBsZS5zdHJpbmcsXG4gICAgICAgIHJlY2VpdmVkOiBpLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBBZTtcbiAgICB9XG4gICAgY29uc3QgbiA9IG5ldyBMdCgpO1xuICAgIGxldCBvO1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgaWYgKGkua2luZCA9PT0gXCJtaW5cIilcbiAgICAgICAgZS5kYXRhLmxlbmd0aCA8IGkudmFsdWUgJiYgKG8gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBvKSwgb2Uobywge1xuICAgICAgICAgIGNvZGU6IG5lLnRvb19zbWFsbCxcbiAgICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBleGFjdDogITEsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcIm1heFwiKVxuICAgICAgICBlLmRhdGEubGVuZ3RoID4gaS52YWx1ZSAmJiAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgICAgY29kZTogbmUudG9vX2JpZyxcbiAgICAgICAgICBtYXhpbXVtOiBpLnZhbHVlLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBleGFjdDogITEsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgIGNvbnN0IGMgPSBlLmRhdGEubGVuZ3RoID4gaS52YWx1ZSwgZiA9IGUuZGF0YS5sZW5ndGggPCBpLnZhbHVlO1xuICAgICAgICAoYyB8fCBmKSAmJiAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBjID8gb2Uobywge1xuICAgICAgICAgIGNvZGU6IG5lLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogaS52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgICAgZXhhY3Q6ICEwLFxuICAgICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgICB9KSA6IGYgJiYgb2Uobywge1xuICAgICAgICAgIGNvZGU6IG5lLnRvb19zbWFsbCxcbiAgICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBleGFjdDogITAsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgfSBlbHNlIGlmIChpLmtpbmQgPT09IFwiZW1haWxcIilcbiAgICAgICAgZ2YudGVzdChlLmRhdGEpIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcImVtb2ppXCIpXG4gICAgICAgIEhzIHx8IChIcyA9IG5ldyBSZWdFeHAoeWYsIFwidVwiKSksIEhzLnRlc3QoZS5kYXRhKSB8fCAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgIGNvZGU6IG5lLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgICB9KSwgbi5kaXJ0eSgpKTtcbiAgICAgIGVsc2UgaWYgKGkua2luZCA9PT0gXCJ1dWlkXCIpXG4gICAgICAgIGhmLnRlc3QoZS5kYXRhKSB8fCAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcIm5hbm9pZFwiKVxuICAgICAgICBkZi50ZXN0KGUuZGF0YSkgfHwgKG8gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBvKSwgb2Uobywge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcImN1aWRcIilcbiAgICAgICAgY2YudGVzdChlLmRhdGEpIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChpLmtpbmQgPT09IFwiY3VpZDJcIilcbiAgICAgICAgbGYudGVzdChlLmRhdGEpIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcInVsaWRcIilcbiAgICAgICAgZmYudGVzdChlLmRhdGEpIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChpLmtpbmQgPT09IFwidXJsXCIpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IFVSTChlLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgICAgIH0pLCBuLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaS5raW5kID09PSBcInJlZ2V4XCIgPyAoaS5yZWdleC5sYXN0SW5kZXggPSAwLCBpLnJlZ2V4LnRlc3QoZS5kYXRhKSB8fCAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgIHZhbGlkYXRpb246IFwicmVnZXhcIixcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkpIDogaS5raW5kID09PSBcInRyaW1cIiA/IGUuZGF0YSA9IGUuZGF0YS50cmltKCkgOiBpLmtpbmQgPT09IFwiaW5jbHVkZXNcIiA/IGUuZGF0YS5pbmNsdWRlcyhpLnZhbHVlLCBpLnBvc2l0aW9uKSB8fCAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBpLnZhbHVlLCBwb3NpdGlvbjogaS5wb3NpdGlvbiB9LFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBuLmRpcnR5KCkpIDogaS5raW5kID09PSBcInRvTG93ZXJDYXNlXCIgPyBlLmRhdGEgPSBlLmRhdGEudG9Mb3dlckNhc2UoKSA6IGkua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiID8gZS5kYXRhID0gZS5kYXRhLnRvVXBwZXJDYXNlKCkgOiBpLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiID8gZS5kYXRhLnN0YXJ0c1dpdGgoaS52YWx1ZSkgfHwgKG8gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBvKSwgb2Uobywge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBpLnZhbHVlIH0sXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiZW5kc1dpdGhcIiA/IGUuZGF0YS5lbmRzV2l0aChpLnZhbHVlKSB8fCAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBpLnZhbHVlIH0sXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiZGF0ZXRpbWVcIiA/IEp1KGkpLnRlc3QoZS5kYXRhKSB8fCAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiZGF0ZVwiID8gTWYudGVzdChlLmRhdGEpIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZVwiLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBuLmRpcnR5KCkpIDogaS5raW5kID09PSBcInRpbWVcIiA/IENmKGkpLnRlc3QoZS5kYXRhKSB8fCAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICB9KSwgbi5kaXJ0eSgpKSA6IGkua2luZCA9PT0gXCJkdXJhdGlvblwiID8gbWYudGVzdChlLmRhdGEpIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICB9KSwgbi5kaXJ0eSgpKSA6IGkua2luZCA9PT0gXCJpcFwiID8gU2YoZS5kYXRhLCBpLnZlcnNpb24pIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICB9KSwgbi5kaXJ0eSgpKSA6IGkua2luZCA9PT0gXCJqd3RcIiA/IEFmKGUuZGF0YSwgaS5hbGcpIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiY2lkclwiID8ga2YoZS5kYXRhLCBpLnZlcnNpb24pIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfc3RyaW5nLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBuLmRpcnR5KCkpIDogaS5raW5kID09PSBcImJhc2U2NFwiID8gX2YudGVzdChlLmRhdGEpIHx8IChvID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbyksIG9lKG8sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjRcIixcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIgPyBFZi50ZXN0KGUuZGF0YSkgfHwgKG8gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBvKSwgb2Uobywge1xuICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NHVybFwiLFxuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICB9KSwgbi5kaXJ0eSgpKSA6IG50LmFzc2VydE5ldmVyKGkpO1xuICAgIHJldHVybiB7IHN0YXR1czogbi52YWx1ZSwgdmFsdWU6IGUuZGF0YSB9O1xuICB9XG4gIF9yZWdleChlLCByLCBuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCgobykgPT4gZS50ZXN0KG8pLCB7XG4gICAgICB2YWxpZGF0aW9uOiByLFxuICAgICAgY29kZTogbmUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAuLi52ZS5lcnJUb09iaihuKVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhlKSB7XG4gICAgcmV0dXJuIG5ldyBXdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIGVtYWlsKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLnZlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIHVybChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4udmUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgZW1vamkoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4udmUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgdXVpZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLnZlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIG5hbm9pZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4udmUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgY3VpZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLnZlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGN1aWQyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLnZlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIHVsaWQoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi52ZS5lcnJUb09iaihlKSB9KTtcbiAgfVxuICBiYXNlNjQoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLnZlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGJhc2U2NHVybChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAuLi52ZS5lcnJUb09iaihlKVxuICAgIH0pO1xuICB9XG4gIGp3dChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4udmUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgaXAoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4udmUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgY2lkcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjaWRyXCIsIC4uLnZlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGRhdGV0aW1lKGUpIHtcbiAgICB2YXIgciwgbjtcbiAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgIG9mZnNldDogITEsXG4gICAgICBsb2NhbDogITEsXG4gICAgICBtZXNzYWdlOiBlXG4gICAgfSkgOiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICBwcmVjaXNpb246IHR5cGVvZiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5wcmVjaXNpb24pID4gXCJ1XCIgPyBudWxsIDogZSA9PSBudWxsID8gdm9pZCAwIDogZS5wcmVjaXNpb24sXG4gICAgICBvZmZzZXQ6IChyID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5vZmZzZXQpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiAhMSxcbiAgICAgIGxvY2FsOiAobiA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUubG9jYWwpICE9PSBudWxsICYmIG4gIT09IHZvaWQgMCA/IG4gOiAhMSxcbiAgICAgIC4uLnZlLmVyclRvT2JqKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUubWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBkYXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZTogZSB9KTtcbiAgfVxuICB0aW1lKGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgbWVzc2FnZTogZVxuICAgIH0pIDogdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICBwcmVjaXNpb246IHR5cGVvZiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5wcmVjaXNpb24pID4gXCJ1XCIgPyBudWxsIDogZSA9PSBudWxsID8gdm9pZCAwIDogZS5wcmVjaXNpb24sXG4gICAgICAuLi52ZS5lcnJUb09iaihlID09IG51bGwgPyB2b2lkIDAgOiBlLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZHVyYXRpb24oZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZHVyYXRpb25cIiwgLi4udmUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgcmVnZXgoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICByZWdleDogZSxcbiAgICAgIC4uLnZlLmVyclRvT2JqKHIpXG4gICAgfSk7XG4gIH1cbiAgaW5jbHVkZXMoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICB2YWx1ZTogZSxcbiAgICAgIHBvc2l0aW9uOiByID09IG51bGwgPyB2b2lkIDAgOiByLnBvc2l0aW9uLFxuICAgICAgLi4udmUuZXJyVG9PYmoociA9PSBudWxsID8gdm9pZCAwIDogci5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIHN0YXJ0c1dpdGgoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgLi4udmUuZXJyVG9PYmoocilcbiAgICB9KTtcbiAgfVxuICBlbmRzV2l0aChlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgLi4udmUuZXJyVG9PYmoocilcbiAgICB9KTtcbiAgfVxuICBtaW4oZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICAuLi52ZS5lcnJUb09iaihyKVxuICAgIH0pO1xuICB9XG4gIG1heChlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogZSxcbiAgICAgIC4uLnZlLmVyclRvT2JqKHIpXG4gICAgfSk7XG4gIH1cbiAgbGVuZ3RoKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgLi4udmUuZXJyVG9PYmoocilcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBgLm1pbigxKWBcbiAgICovXG4gIG5vbmVtcHR5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oMSwgdmUuZXJyVG9PYmooZSkpO1xuICB9XG4gIHRyaW0oKSB7XG4gICAgcmV0dXJuIG5ldyBXdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidHJpbVwiIH1dXG4gICAgfSk7XG4gIH1cbiAgdG9Mb3dlckNhc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBXdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XVxuICAgIH0pO1xuICB9XG4gIHRvVXBwZXJDYXNlKCkge1xuICAgIHJldHVybiBuZXcgV3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgfVxuICBnZXQgaXNEYXRlKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImRhdGVcIik7XG4gIH1cbiAgZ2V0IGlzVGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIGdldCBpc0R1cmF0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICB9XG4gIGdldCBpc0VtYWlsKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImVtYWlsXCIpO1xuICB9XG4gIGdldCBpc1VSTCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ1cmxcIik7XG4gIH1cbiAgZ2V0IGlzRW1vamkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiZW1vamlcIik7XG4gIH1cbiAgZ2V0IGlzVVVJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ1dWlkXCIpO1xuICB9XG4gIGdldCBpc05BTk9JRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJjdWlkXCIpO1xuICB9XG4gIGdldCBpc0NVSUQyKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImN1aWQyXCIpO1xuICB9XG4gIGdldCBpc1VMSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgfVxuICBnZXQgaXNJUCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJpcFwiKTtcbiAgfVxuICBnZXQgaXNDSURSKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImNpZHJcIik7XG4gIH1cbiAgZ2V0IGlzQmFzZTY0KCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgfVxuICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICB9XG4gIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgci5raW5kID09PSBcIm1pblwiICYmIChlID09PSBudWxsIHx8IHIudmFsdWUgPiBlKSAmJiAoZSA9IHIudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgci5raW5kID09PSBcIm1heFwiICYmIChlID09PSBudWxsIHx8IHIudmFsdWUgPCBlKSAmJiAoZSA9IHIudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG59XG5XdC5jcmVhdGUgPSAodCkgPT4ge1xuICB2YXIgZTtcbiAgcmV0dXJuIG5ldyBXdCh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogQ2UuWm9kU3RyaW5nLFxuICAgIGNvZXJjZTogKGUgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmNvZXJjZSkgIT09IG51bGwgJiYgZSAhPT0gdm9pZCAwID8gZSA6ICExLFxuICAgIC4uLlRlKHQpXG4gIH0pO1xufTtcbmZ1bmN0aW9uIElmKHQsIGUpIHtcbiAgY29uc3QgciA9ICh0LnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgbiA9IChlLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgbyA9IHIgPiBuID8gciA6IG4sIGkgPSBwYXJzZUludCh0LnRvRml4ZWQobykucmVwbGFjZShcIi5cIiwgXCJcIikpLCBjID0gcGFyc2VJbnQoZS50b0ZpeGVkKG8pLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgcmV0dXJuIGkgJSBjIC8gTWF0aC5wb3coMTAsIG8pO1xufVxuY2xhc3MgTHIgZXh0ZW5kcyBKZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMubWluID0gdGhpcy5ndGUsIHRoaXMubWF4ID0gdGhpcy5sdGUsIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlICYmIChlLmRhdGEgPSBOdW1iZXIoZS5kYXRhKSksIHRoaXMuX2dldFR5cGUoZSkgIT09IGxlLm51bWJlcikge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIG9lKGksIHtcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbGUubnVtYmVyLFxuICAgICAgICByZWNlaXZlZDogaS5wYXJzZWRUeXBlXG4gICAgICB9KSwgQWU7XG4gICAgfVxuICAgIGxldCBuO1xuICAgIGNvbnN0IG8gPSBuZXcgTHQoKTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIGkua2luZCA9PT0gXCJpbnRcIiA/IG50LmlzSW50ZWdlcihlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIG9lKG4sIHtcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG8uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwibWluXCIgPyAoaS5pbmNsdXNpdmUgPyBlLmRhdGEgPCBpLnZhbHVlIDogZS5kYXRhIDw9IGkudmFsdWUpICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIG9lKG4sIHtcbiAgICAgICAgY29kZTogbmUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBpbmNsdXNpdmU6IGkuaW5jbHVzaXZlLFxuICAgICAgICBleGFjdDogITEsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG8uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwibWF4XCIgPyAoaS5pbmNsdXNpdmUgPyBlLmRhdGEgPiBpLnZhbHVlIDogZS5kYXRhID49IGkudmFsdWUpICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIG9lKG4sIHtcbiAgICAgICAgY29kZTogbmUudG9vX2JpZyxcbiAgICAgICAgbWF4aW11bTogaS52YWx1ZSxcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgaW5jbHVzaXZlOiBpLmluY2x1c2l2ZSxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBvLmRpcnR5KCkpIDogaS5raW5kID09PSBcIm11bHRpcGxlT2ZcIiA/IElmKGUuZGF0YSwgaS52YWx1ZSkgIT09IDAgJiYgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgb2Uobiwge1xuICAgICAgICBjb2RlOiBuZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgIG11bHRpcGxlT2Y6IGkudmFsdWUsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG8uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiZmluaXRlXCIgPyBOdW1iZXIuaXNGaW5pdGUoZS5kYXRhKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLm5vdF9maW5pdGUsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG8uZGlydHkoKSkgOiBudC5hc3NlcnROZXZlcihpKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IG8udmFsdWUsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxuICBndGUoZSwgcikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICEwLCB2ZS50b1N0cmluZyhyKSk7XG4gIH1cbiAgZ3QoZSwgcikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICExLCB2ZS50b1N0cmluZyhyKSk7XG4gIH1cbiAgbHRlKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCAhMCwgdmUudG9TdHJpbmcocikpO1xuICB9XG4gIGx0KGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCAhMSwgdmUudG9TdHJpbmcocikpO1xuICB9XG4gIHNldExpbWl0KGUsIHIsIG4sIG8pIHtcbiAgICByZXR1cm4gbmV3IExyKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZDogZSxcbiAgICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgICBpbmNsdXNpdmU6IG4sXG4gICAgICAgICAgbWVzc2FnZTogdmUudG9TdHJpbmcobylcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhlKSB7XG4gICAgcmV0dXJuIG5ldyBMcih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIGludChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICBtZXNzYWdlOiB2ZS50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIHBvc2l0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgaW5jbHVzaXZlOiAhMSxcbiAgICAgIG1lc3NhZ2U6IHZlLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbmVnYXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6ICExLFxuICAgICAgbWVzc2FnZTogdmUudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiB2ZS50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIG5vbm5lZ2F0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIG1lc3NhZ2U6IHZlLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZihlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICBtZXNzYWdlOiB2ZS50b1N0cmluZyhyKVxuICAgIH0pO1xuICB9XG4gIGZpbml0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICBtZXNzYWdlOiB2ZS50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIHNhZmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgIG1lc3NhZ2U6IHZlLnRvU3RyaW5nKGUpXG4gICAgfSkuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogdmUudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBnZXQgbWluVmFsdWUoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgci5raW5kID09PSBcIm1pblwiICYmIChlID09PSBudWxsIHx8IHIudmFsdWUgPiBlKSAmJiAoZSA9IHIudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBtYXhWYWx1ZSgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCByIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICByLmtpbmQgPT09IFwibWF4XCIgJiYgKGUgPT09IG51bGwgfHwgci52YWx1ZSA8IGUpICYmIChlID0gci52YWx1ZSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IGlzSW50KCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImludFwiIHx8IGUua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgbnQuaXNJbnRlZ2VyKGUudmFsdWUpKTtcbiAgfVxuICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgbGV0IGUgPSBudWxsLCByID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKG4ua2luZCA9PT0gXCJmaW5pdGVcIiB8fCBuLmtpbmQgPT09IFwiaW50XCIgfHwgbi5raW5kID09PSBcIm11bHRpcGxlT2ZcIilcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgbi5raW5kID09PSBcIm1pblwiID8gKHIgPT09IG51bGwgfHwgbi52YWx1ZSA+IHIpICYmIChyID0gbi52YWx1ZSkgOiBuLmtpbmQgPT09IFwibWF4XCIgJiYgKGUgPT09IG51bGwgfHwgbi52YWx1ZSA8IGUpICYmIChlID0gbi52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocikgJiYgTnVtYmVyLmlzRmluaXRlKGUpO1xuICB9XG59XG5Mci5jcmVhdGUgPSAodCkgPT4gbmV3IExyKHtcbiAgY2hlY2tzOiBbXSxcbiAgdHlwZU5hbWU6IENlLlpvZE51bWJlcixcbiAgY29lcmNlOiAodCA9PSBudWxsID8gdm9pZCAwIDogdC5jb2VyY2UpIHx8ICExLFxuICAuLi5UZSh0KVxufSk7XG5jbGFzcyBPciBleHRlbmRzIEplIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5taW4gPSB0aGlzLmd0ZSwgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgZS5kYXRhID0gQmlnSW50KGUuZGF0YSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChlKTtcbiAgICAgIH1cbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbGUuYmlnaW50KVxuICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChlKTtcbiAgICBsZXQgbjtcbiAgICBjb25zdCBvID0gbmV3IEx0KCk7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICBpLmtpbmQgPT09IFwibWluXCIgPyAoaS5pbmNsdXNpdmUgPyBlLmRhdGEgPCBpLnZhbHVlIDogZS5kYXRhIDw9IGkudmFsdWUpICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIG9lKG4sIHtcbiAgICAgICAgY29kZTogbmUudG9vX3NtYWxsLFxuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICBpbmNsdXNpdmU6IGkuaW5jbHVzaXZlLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBvLmRpcnR5KCkpIDogaS5raW5kID09PSBcIm1heFwiID8gKGkuaW5jbHVzaXZlID8gZS5kYXRhID4gaS52YWx1ZSA6IGUuZGF0YSA+PSBpLnZhbHVlKSAmJiAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLnRvb19iaWcsXG4gICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgIG1heGltdW06IGkudmFsdWUsXG4gICAgICAgIGluY2x1c2l2ZTogaS5pbmNsdXNpdmUsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG8uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiID8gZS5kYXRhICUgaS52YWx1ZSAhPT0gQmlnSW50KDApICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIG9lKG4sIHtcbiAgICAgICAgY29kZTogbmUubm90X211bHRpcGxlX29mLFxuICAgICAgICBtdWx0aXBsZU9mOiBpLnZhbHVlLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBvLmRpcnR5KCkpIDogbnQuYXNzZXJ0TmV2ZXIoaSk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBvLnZhbHVlLCB2YWx1ZTogZS5kYXRhIH07XG4gIH1cbiAgX2dldEludmFsaWRJbnB1dChlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgIHJldHVybiBvZShyLCB7XG4gICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGUsXG4gICAgICBleHBlY3RlZDogbGUuYmlnaW50LFxuICAgICAgcmVjZWl2ZWQ6IHIucGFyc2VkVHlwZVxuICAgIH0pLCBBZTtcbiAgfVxuICBndGUoZSwgcikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICEwLCB2ZS50b1N0cmluZyhyKSk7XG4gIH1cbiAgZ3QoZSwgcikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICExLCB2ZS50b1N0cmluZyhyKSk7XG4gIH1cbiAgbHRlKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCAhMCwgdmUudG9TdHJpbmcocikpO1xuICB9XG4gIGx0KGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCAhMSwgdmUudG9TdHJpbmcocikpO1xuICB9XG4gIHNldExpbWl0KGUsIHIsIG4sIG8pIHtcbiAgICByZXR1cm4gbmV3IE9yKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZDogZSxcbiAgICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgICBpbmNsdXNpdmU6IG4sXG4gICAgICAgICAgbWVzc2FnZTogdmUudG9TdHJpbmcobylcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhlKSB7XG4gICAgcmV0dXJuIG5ldyBPcih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIHBvc2l0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6ICExLFxuICAgICAgbWVzc2FnZTogdmUudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiAhMSxcbiAgICAgIG1lc3NhZ2U6IHZlLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbm9ucG9zaXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiB2ZS50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIG5vbm5lZ2F0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgbWVzc2FnZTogdmUudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBtdWx0aXBsZU9mKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICB2YWx1ZTogZSxcbiAgICAgIG1lc3NhZ2U6IHZlLnRvU3RyaW5nKHIpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIHIua2luZCA9PT0gXCJtaW5cIiAmJiAoZSA9PT0gbnVsbCB8fCByLnZhbHVlID4gZSkgJiYgKGUgPSByLnZhbHVlKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgci5raW5kID09PSBcIm1heFwiICYmIChlID09PSBudWxsIHx8IHIudmFsdWUgPCBlKSAmJiAoZSA9IHIudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG59XG5Pci5jcmVhdGUgPSAodCkgPT4ge1xuICB2YXIgZTtcbiAgcmV0dXJuIG5ldyBPcih7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogQ2UuWm9kQmlnSW50LFxuICAgIGNvZXJjZTogKGUgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmNvZXJjZSkgIT09IG51bGwgJiYgZSAhPT0gdm9pZCAwID8gZSA6ICExLFxuICAgIC4uLlRlKHQpXG4gIH0pO1xufTtcbmNsYXNzIGFpIGV4dGVuZHMgSmUge1xuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlICYmIChlLmRhdGEgPSAhIWUuZGF0YSksIHRoaXMuX2dldFR5cGUoZSkgIT09IGxlLmJvb2xlYW4pIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLmJvb2xlYW4sXG4gICAgICAgIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBBZTtcbiAgICB9XG4gICAgcmV0dXJuIGp0KGUuZGF0YSk7XG4gIH1cbn1cbmFpLmNyZWF0ZSA9ICh0KSA9PiBuZXcgYWkoe1xuICB0eXBlTmFtZTogQ2UuWm9kQm9vbGVhbixcbiAgY29lcmNlOiAodCA9PSBudWxsID8gdm9pZCAwIDogdC5jb2VyY2UpIHx8ICExLFxuICAuLi5UZSh0KVxufSk7XG5jbGFzcyBjbiBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSAmJiAoZS5kYXRhID0gbmV3IERhdGUoZS5kYXRhKSksIHRoaXMuX2dldFR5cGUoZSkgIT09IGxlLmRhdGUpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBvZShpLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLmRhdGUsXG4gICAgICAgIHJlY2VpdmVkOiBpLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBBZTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGUuZGF0YS5nZXRUaW1lKCkpKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gb2UoaSwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX2RhdGVcbiAgICAgIH0pLCBBZTtcbiAgICB9XG4gICAgY29uc3QgbiA9IG5ldyBMdCgpO1xuICAgIGxldCBvO1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgaS5raW5kID09PSBcIm1pblwiID8gZS5kYXRhLmdldFRpbWUoKSA8IGkudmFsdWUgJiYgKG8gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBvKSwgb2Uobywge1xuICAgICAgICBjb2RlOiBuZS50b29fc21hbGwsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZSxcbiAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICB0eXBlOiBcImRhdGVcIlxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwibWF4XCIgPyBlLmRhdGEuZ2V0VGltZSgpID4gaS52YWx1ZSAmJiAobyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG8pLCBvZShvLCB7XG4gICAgICAgIGNvZGU6IG5lLnRvb19iaWcsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZSxcbiAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICBtYXhpbXVtOiBpLnZhbHVlLFxuICAgICAgICB0eXBlOiBcImRhdGVcIlxuICAgICAgfSksIG4uZGlydHkoKSkgOiBudC5hc3NlcnROZXZlcihpKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBuLnZhbHVlLFxuICAgICAgdmFsdWU6IG5ldyBEYXRlKGUuZGF0YS5nZXRUaW1lKCkpXG4gICAgfTtcbiAgfVxuICBfYWRkQ2hlY2soZSkge1xuICAgIHJldHVybiBuZXcgY24oe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgZV1cbiAgICB9KTtcbiAgfVxuICBtaW4oZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogdmUudG9TdHJpbmcocilcbiAgICB9KTtcbiAgfVxuICBtYXgoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogdmUudG9TdHJpbmcocilcbiAgICB9KTtcbiAgfVxuICBnZXQgbWluRGF0ZSgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCByIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICByLmtpbmQgPT09IFwibWluXCIgJiYgKGUgPT09IG51bGwgfHwgci52YWx1ZSA+IGUpICYmIChlID0gci52YWx1ZSk7XG4gICAgcmV0dXJuIGUgIT0gbnVsbCA/IG5ldyBEYXRlKGUpIDogbnVsbDtcbiAgfVxuICBnZXQgbWF4RGF0ZSgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCByIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICByLmtpbmQgPT09IFwibWF4XCIgJiYgKGUgPT09IG51bGwgfHwgci52YWx1ZSA8IGUpICYmIChlID0gci52YWx1ZSk7XG4gICAgcmV0dXJuIGUgIT0gbnVsbCA/IG5ldyBEYXRlKGUpIDogbnVsbDtcbiAgfVxufVxuY24uY3JlYXRlID0gKHQpID0+IG5ldyBjbih7XG4gIGNoZWNrczogW10sXG4gIGNvZXJjZTogKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY29lcmNlKSB8fCAhMSxcbiAgdHlwZU5hbWU6IENlLlpvZERhdGUsXG4gIC4uLlRlKHQpXG59KTtcbmNsYXNzIGxzIGV4dGVuZHMgSmUge1xuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBsZS5zeW1ib2wpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLnN5bWJvbCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIH1cbiAgICByZXR1cm4ganQoZS5kYXRhKTtcbiAgfVxufVxubHMuY3JlYXRlID0gKHQpID0+IG5ldyBscyh7XG4gIHR5cGVOYW1lOiBDZS5ab2RTeW1ib2wsXG4gIC4uLlRlKHQpXG59KTtcbmNsYXNzIHVpIGV4dGVuZHMgSmUge1xuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBsZS51bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLnVuZGVmaW5lZCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIH1cbiAgICByZXR1cm4ganQoZS5kYXRhKTtcbiAgfVxufVxudWkuY3JlYXRlID0gKHQpID0+IG5ldyB1aSh7XG4gIHR5cGVOYW1lOiBDZS5ab2RVbmRlZmluZWQsXG4gIC4uLlRlKHQpXG59KTtcbmNsYXNzIGNpIGV4dGVuZHMgSmUge1xuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBsZS5udWxsKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gb2Uobiwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBsZS5udWxsLFxuICAgICAgICByZWNlaXZlZDogbi5wYXJzZWRUeXBlXG4gICAgICB9KSwgQWU7XG4gICAgfVxuICAgIHJldHVybiBqdChlLmRhdGEpO1xuICB9XG59XG5jaS5jcmVhdGUgPSAodCkgPT4gbmV3IGNpKHtcbiAgdHlwZU5hbWU6IENlLlpvZE51bGwsXG4gIC4uLlRlKHQpXG59KTtcbmNsYXNzIFRuIGV4dGVuZHMgSmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLl9hbnkgPSAhMDtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIHJldHVybiBqdChlLmRhdGEpO1xuICB9XG59XG5Ubi5jcmVhdGUgPSAodCkgPT4gbmV3IFRuKHtcbiAgdHlwZU5hbWU6IENlLlpvZEFueSxcbiAgLi4uVGUodClcbn0pO1xuY2xhc3MgYW4gZXh0ZW5kcyBKZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuX3Vua25vd24gPSAhMDtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIHJldHVybiBqdChlLmRhdGEpO1xuICB9XG59XG5hbi5jcmVhdGUgPSAodCkgPT4gbmV3IGFuKHtcbiAgdHlwZU5hbWU6IENlLlpvZFVua25vd24sXG4gIC4uLlRlKHQpXG59KTtcbmNsYXNzIHhyIGV4dGVuZHMgSmUge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICByZXR1cm4gb2Uociwge1xuICAgICAgY29kZTogbmUuaW52YWxpZF90eXBlLFxuICAgICAgZXhwZWN0ZWQ6IGxlLm5ldmVyLFxuICAgICAgcmVjZWl2ZWQ6IHIucGFyc2VkVHlwZVxuICAgIH0pLCBBZTtcbiAgfVxufVxueHIuY3JlYXRlID0gKHQpID0+IG5ldyB4cih7XG4gIHR5cGVOYW1lOiBDZS5ab2ROZXZlcixcbiAgLi4uVGUodClcbn0pO1xuY2xhc3MgZnMgZXh0ZW5kcyBKZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoZSkgIT09IGxlLnVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIG9lKG4sIHtcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbGUudm9pZCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIH1cbiAgICByZXR1cm4ganQoZS5kYXRhKTtcbiAgfVxufVxuZnMuY3JlYXRlID0gKHQpID0+IG5ldyBmcyh7XG4gIHR5cGVOYW1lOiBDZS5ab2RWb2lkLFxuICAuLi5UZSh0KVxufSk7XG5jbGFzcyBHdCBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogciwgc3RhdHVzOiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIG8gPSB0aGlzLl9kZWY7XG4gICAgaWYgKHIucGFyc2VkVHlwZSAhPT0gbGUuYXJyYXkpXG4gICAgICByZXR1cm4gb2Uociwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBsZS5hcnJheSxcbiAgICAgICAgcmVjZWl2ZWQ6IHIucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIGlmIChvLmV4YWN0TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjID0gci5kYXRhLmxlbmd0aCA+IG8uZXhhY3RMZW5ndGgudmFsdWUsIGYgPSByLmRhdGEubGVuZ3RoIDwgby5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgIChjIHx8IGYpICYmIChvZShyLCB7XG4gICAgICAgIGNvZGU6IGMgPyBuZS50b29fYmlnIDogbmUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiBmID8gby5leGFjdExlbmd0aC52YWx1ZSA6IHZvaWQgMCxcbiAgICAgICAgbWF4aW11bTogYyA/IG8uZXhhY3RMZW5ndGgudmFsdWUgOiB2b2lkIDAsXG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgZXhhY3Q6ICEwLFxuICAgICAgICBtZXNzYWdlOiBvLmV4YWN0TGVuZ3RoLm1lc3NhZ2VcbiAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgIH1cbiAgICBpZiAoby5taW5MZW5ndGggIT09IG51bGwgJiYgci5kYXRhLmxlbmd0aCA8IG8ubWluTGVuZ3RoLnZhbHVlICYmIChvZShyLCB7XG4gICAgICBjb2RlOiBuZS50b29fc21hbGwsXG4gICAgICBtaW5pbXVtOiBvLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBleGFjdDogITEsXG4gICAgICBtZXNzYWdlOiBvLm1pbkxlbmd0aC5tZXNzYWdlXG4gICAgfSksIG4uZGlydHkoKSksIG8ubWF4TGVuZ3RoICE9PSBudWxsICYmIHIuZGF0YS5sZW5ndGggPiBvLm1heExlbmd0aC52YWx1ZSAmJiAob2Uociwge1xuICAgICAgY29kZTogbmUudG9vX2JpZyxcbiAgICAgIG1heGltdW06IG8ubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIGV4YWN0OiAhMSxcbiAgICAgIG1lc3NhZ2U6IG8ubWF4TGVuZ3RoLm1lc3NhZ2VcbiAgICB9KSwgbi5kaXJ0eSgpKSwgci5jb21tb24uYXN5bmMpXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLnIuZGF0YV0ubWFwKChjLCBmKSA9PiBvLnR5cGUuX3BhcnNlQXN5bmMobmV3IHNyKHIsIGMsIHIucGF0aCwgZikpKSkudGhlbigoYykgPT4gTHQubWVyZ2VBcnJheShuLCBjKSk7XG4gICAgY29uc3QgaSA9IFsuLi5yLmRhdGFdLm1hcCgoYywgZikgPT4gby50eXBlLl9wYXJzZVN5bmMobmV3IHNyKHIsIGMsIHIucGF0aCwgZikpKTtcbiAgICByZXR1cm4gTHQubWVyZ2VBcnJheShuLCBpKTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgbWluKGUsIHIpIHtcbiAgICByZXR1cm4gbmV3IEd0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogZSwgbWVzc2FnZTogdmUudG9TdHJpbmcocikgfVxuICAgIH0pO1xuICB9XG4gIG1heChlLCByKSB7XG4gICAgcmV0dXJuIG5ldyBHdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IHZlLnRvU3RyaW5nKHIpIH1cbiAgICB9KTtcbiAgfVxuICBsZW5ndGgoZSwgcikge1xuICAgIHJldHVybiBuZXcgR3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IHZlLnRvU3RyaW5nKHIpIH1cbiAgICB9KTtcbiAgfVxuICBub25lbXB0eShlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIGUpO1xuICB9XG59XG5HdC5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IEd0KHtcbiAgdHlwZTogdCxcbiAgbWluTGVuZ3RoOiBudWxsLFxuICBtYXhMZW5ndGg6IG51bGwsXG4gIGV4YWN0TGVuZ3RoOiBudWxsLFxuICB0eXBlTmFtZTogQ2UuWm9kQXJyYXksXG4gIC4uLlRlKGUpXG59KTtcbmZ1bmN0aW9uIEVuKHQpIHtcbiAgaWYgKHQgaW5zdGFuY2VvZiBodCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgaW4gdC5zaGFwZSkge1xuICAgICAgY29uc3QgbiA9IHQuc2hhcGVbcl07XG4gICAgICBlW3JdID0gaXIuY3JlYXRlKEVuKG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBodCh7XG4gICAgICAuLi50Ll9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gZVxuICAgIH0pO1xuICB9IGVsc2UgcmV0dXJuIHQgaW5zdGFuY2VvZiBHdCA/IG5ldyBHdCh7XG4gICAgLi4udC5fZGVmLFxuICAgIHR5cGU6IEVuKHQuZWxlbWVudClcbiAgfSkgOiB0IGluc3RhbmNlb2YgaXIgPyBpci5jcmVhdGUoRW4odC51bndyYXAoKSkpIDogdCBpbnN0YW5jZW9mIGpyID8ganIuY3JlYXRlKEVuKHQudW53cmFwKCkpKSA6IHQgaW5zdGFuY2VvZiBvciA/IG9yLmNyZWF0ZSh0Lml0ZW1zLm1hcCgoZSkgPT4gRW4oZSkpKSA6IHQ7XG59XG5jbGFzcyBodCBleHRlbmRzIEplIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fY2FjaGVkID0gbnVsbCwgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoLCB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgfVxuICBfZ2V0Q2FjaGVkKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9kZWYuc2hhcGUoKSwgciA9IG50Lm9iamVjdEtleXMoZSk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZCA9IHsgc2hhcGU6IGUsIGtleXM6IHIgfTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBsZS5vYmplY3QpIHtcbiAgICAgIGNvbnN0IHggPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBvZSh4LCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IHgucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIH1cbiAgICBjb25zdCB7IHN0YXR1czogbiwgY3R4OiBvIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIHsgc2hhcGU6IGksIGtleXM6IGMgfSA9IHRoaXMuX2dldENhY2hlZCgpLCBmID0gW107XG4gICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgeHIgJiYgdGhpcy5fZGVmLnVua25vd25LZXlzID09PSBcInN0cmlwXCIpKVxuICAgICAgZm9yIChjb25zdCB4IGluIG8uZGF0YSlcbiAgICAgICAgYy5pbmNsdWRlcyh4KSB8fCBmLnB1c2goeCk7XG4gICAgY29uc3QgdiA9IFtdO1xuICAgIGZvciAoY29uc3QgeCBvZiBjKSB7XG4gICAgICBjb25zdCBiID0gaVt4XSwgUyA9IG8uZGF0YVt4XTtcbiAgICAgIHYucHVzaCh7XG4gICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IHggfSxcbiAgICAgICAgdmFsdWU6IGIuX3BhcnNlKG5ldyBzcihvLCBTLCBvLnBhdGgsIHgpKSxcbiAgICAgICAgYWx3YXlzU2V0OiB4IGluIG8uZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiB4cikge1xuICAgICAgY29uc3QgeCA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgIGlmICh4ID09PSBcInBhc3N0aHJvdWdoXCIpXG4gICAgICAgIGZvciAoY29uc3QgYiBvZiBmKVxuICAgICAgICAgIHYucHVzaCh7XG4gICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBiIH0sXG4gICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IG8uZGF0YVtiXSB9XG4gICAgICAgICAgfSk7XG4gICAgICBlbHNlIGlmICh4ID09PSBcInN0cmljdFwiKVxuICAgICAgICBmLmxlbmd0aCA+IDAgJiYgKG9lKG8sIHtcbiAgICAgICAgICBjb2RlOiBuZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICBrZXlzOiBmXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoeCAhPT0gXCJzdHJpcFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB4ID0gdGhpcy5fZGVmLmNhdGNoYWxsO1xuICAgICAgZm9yIChjb25zdCBiIG9mIGYpIHtcbiAgICAgICAgY29uc3QgUyA9IG8uZGF0YVtiXTtcbiAgICAgICAgdi5wdXNoKHtcbiAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBiIH0sXG4gICAgICAgICAgdmFsdWU6IHguX3BhcnNlKFxuICAgICAgICAgICAgbmV3IHNyKG8sIFMsIG8ucGF0aCwgYilcbiAgICAgICAgICAgIC8vLCBjdHguY2hpbGQoa2V5KSwgdmFsdWUsIGdldFBhcnNlZFR5cGUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBhbHdheXNTZXQ6IGIgaW4gby5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gby5jb21tb24uYXN5bmMgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHggPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiB2KSB7XG4gICAgICAgIGNvbnN0IFMgPSBhd2FpdCBiLmtleSwgVCA9IGF3YWl0IGIudmFsdWU7XG4gICAgICAgIHgucHVzaCh7XG4gICAgICAgICAga2V5OiBTLFxuICAgICAgICAgIHZhbHVlOiBULFxuICAgICAgICAgIGFsd2F5c1NldDogYi5hbHdheXNTZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9KS50aGVuKCh4KSA9PiBMdC5tZXJnZU9iamVjdFN5bmMobiwgeCkpIDogTHQubWVyZ2VPYmplY3RTeW5jKG4sIHYpO1xuICB9XG4gIGdldCBzaGFwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gIH1cbiAgc3RyaWN0KGUpIHtcbiAgICByZXR1cm4gdmUuZXJyVG9PYmosIG5ldyBodCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgIC4uLmUgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgZXJyb3JNYXA6IChyLCBuKSA9PiB7XG4gICAgICAgICAgdmFyIG8sIGksIGMsIGY7XG4gICAgICAgICAgY29uc3QgdiA9IChjID0gKGkgPSAobyA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGkuY2FsbChvLCByLCBuKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBjICE9PSB2b2lkIDAgPyBjIDogbi5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHIuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiID8ge1xuICAgICAgICAgICAgbWVzc2FnZTogKGYgPSB2ZS5lcnJUb09iaihlKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBmICE9PSB2b2lkIDAgPyBmIDogdlxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICBtZXNzYWdlOiB2XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSA6IHt9XG4gICAgfSk7XG4gIH1cbiAgc3RyaXAoKSB7XG4gICAgcmV0dXJuIG5ldyBodCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiXG4gICAgfSk7XG4gIH1cbiAgcGFzc3Rocm91Z2goKSB7XG4gICAgcmV0dXJuIG5ldyBodCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiXG4gICAgfSk7XG4gIH1cbiAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXG4gIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAvLyAgICk6IFpvZE9iamVjdDxcbiAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxuICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAvLyAgID4gPT4ge1xuICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgICAuLi5kZWYsXG4gIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgLy8gICAgICAgfSksXG4gIC8vICAgICB9KSBhcyBhbnk7XG4gIC8vICAgfTtcbiAgZXh0ZW5kKGUpIHtcbiAgICByZXR1cm4gbmV3IGh0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgLi4uZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxuICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICovXG4gIG1lcmdlKGUpIHtcbiAgICByZXR1cm4gbmV3IGh0KHtcbiAgICAgIHVua25vd25LZXlzOiBlLl9kZWYudW5rbm93bktleXMsXG4gICAgICBjYXRjaGFsbDogZS5fZGVmLmNhdGNoYWxsLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5lLl9kZWYuc2hhcGUoKVxuICAgICAgfSksXG4gICAgICB0eXBlTmFtZTogQ2UuWm9kT2JqZWN0XG4gICAgfSk7XG4gIH1cbiAgLy8gbWVyZ2U8XG4gIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXG4gIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgLy8gICAgICAgOiBuZXZlcjtcbiAgLy8gICB9LFxuICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xuICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gIC8vICAgICAgID8gSW5wdXRba11cbiAgLy8gICAgICAgOiBuZXZlcjtcbiAgLy8gICB9XG4gIC8vID4oXG4gIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgLy8gKTogWm9kT2JqZWN0PFxuICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcbiAgLy8gICBOZXdPdXRwdXQsXG4gIC8vICAgTmV3SW5wdXRcbiAgLy8gPiB7XG4gIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAvLyAgICAgc2hhcGU6ICgpID0+XG4gIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAvLyAgIH0pIGFzIGFueTtcbiAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAvLyB9XG4gIHNldEtleShlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtlXTogciB9KTtcbiAgfVxuICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXG4gIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgLy8gWm9kT2JqZWN0PFxuICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxuICAvLyA+IHtcbiAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcbiAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gIC8vICAgLy8gKTtcbiAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gIC8vICAgICBzaGFwZTogKCkgPT5cbiAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC8vICAgfSkgYXMgYW55O1xuICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gIC8vIH1cbiAgY2F0Y2hhbGwoZSkge1xuICAgIHJldHVybiBuZXcgaHQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2F0Y2hhbGw6IGVcbiAgICB9KTtcbiAgfVxuICBwaWNrKGUpIHtcbiAgICBjb25zdCByID0ge307XG4gICAgcmV0dXJuIG50Lm9iamVjdEtleXMoZSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgZVtuXSAmJiB0aGlzLnNoYXBlW25dICYmIChyW25dID0gdGhpcy5zaGFwZVtuXSk7XG4gICAgfSksIG5ldyBodCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gclxuICAgIH0pO1xuICB9XG4gIG9taXQoZSkge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICByZXR1cm4gbnQub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBlW25dIHx8IChyW25dID0gdGhpcy5zaGFwZVtuXSk7XG4gICAgfSksIG5ldyBodCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZGVlcFBhcnRpYWwoKSB7XG4gICAgcmV0dXJuIEVuKHRoaXMpO1xuICB9XG4gIHBhcnRpYWwoZSkge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICByZXR1cm4gbnQub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCBvID0gdGhpcy5zaGFwZVtuXTtcbiAgICAgIGUgJiYgIWVbbl0gPyByW25dID0gbyA6IHJbbl0gPSBvLm9wdGlvbmFsKCk7XG4gICAgfSksIG5ldyBodCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gclxuICAgIH0pO1xuICB9XG4gIHJlcXVpcmVkKGUpIHtcbiAgICBjb25zdCByID0ge307XG4gICAgcmV0dXJuIG50Lm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgaWYgKGUgJiYgIWVbbl0pXG4gICAgICAgIHJbbl0gPSB0aGlzLnNoYXBlW25dO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5zaGFwZVtuXTtcbiAgICAgICAgZm9yICg7IGkgaW5zdGFuY2VvZiBpcjsgKVxuICAgICAgICAgIGkgPSBpLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICByW25dID0gaTtcbiAgICAgIH1cbiAgICB9KSwgbmV3IGh0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiByXG4gICAgfSk7XG4gIH1cbiAga2V5b2YoKSB7XG4gICAgcmV0dXJuIFh1KG50Lm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICB9XG59XG5odC5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IGh0KHtcbiAgc2hhcGU6ICgpID0+IHQsXG4gIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gIGNhdGNoYWxsOiB4ci5jcmVhdGUoKSxcbiAgdHlwZU5hbWU6IENlLlpvZE9iamVjdCxcbiAgLi4uVGUoZSlcbn0pO1xuaHQuc3RyaWN0Q3JlYXRlID0gKHQsIGUpID0+IG5ldyBodCh7XG4gIHNoYXBlOiAoKSA9PiB0LFxuICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgY2F0Y2hhbGw6IHhyLmNyZWF0ZSgpLFxuICB0eXBlTmFtZTogQ2UuWm9kT2JqZWN0LFxuICAuLi5UZShlKVxufSk7XG5odC5sYXp5Y3JlYXRlID0gKHQsIGUpID0+IG5ldyBodCh7XG4gIHNoYXBlOiB0LFxuICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICBjYXRjaGFsbDogeHIuY3JlYXRlKCksXG4gIHR5cGVOYW1lOiBDZS5ab2RPYmplY3QsXG4gIC4uLlRlKGUpXG59KTtcbmNsYXNzIGxpIGV4dGVuZHMgSmUge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgY3R4OiByIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIG4gPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICBmdW5jdGlvbiBvKGkpIHtcbiAgICAgIGZvciAoY29uc3QgZiBvZiBpKVxuICAgICAgICBpZiAoZi5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgcmV0dXJuIGYucmVzdWx0O1xuICAgICAgZm9yIChjb25zdCBmIG9mIGkpXG4gICAgICAgIGlmIChmLnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICByZXR1cm4gci5jb21tb24uaXNzdWVzLnB1c2goLi4uZi5jdHguY29tbW9uLmlzc3VlcyksIGYucmVzdWx0O1xuICAgICAgY29uc3QgYyA9IGkubWFwKChmKSA9PiBuZXcgWnQoZi5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgcmV0dXJuIG9lKHIsIHtcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF91bmlvbixcbiAgICAgICAgdW5pb25FcnJvcnM6IGNcbiAgICAgIH0pLCBBZTtcbiAgICB9XG4gICAgaWYgKHIuY29tbW9uLmFzeW5jKVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG4ubWFwKGFzeW5jIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSB7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgIC4uLnIuY29tbW9uLFxuICAgICAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiBhd2FpdCBpLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGN0eDogY1xuICAgICAgICB9O1xuICAgICAgfSkpLnRoZW4obyk7XG4gICAge1xuICAgICAgbGV0IGk7XG4gICAgICBjb25zdCBjID0gW107XG4gICAgICBmb3IgKGNvbnN0IHYgb2Ygbikge1xuICAgICAgICBjb25zdCB4ID0ge1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAuLi5yLmNvbW1vbixcbiAgICAgICAgICAgIGlzc3VlczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICB9LCBiID0gdi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiByLmRhdGEsXG4gICAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICAgIHBhcmVudDogeFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGIuc3RhdHVzID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIGIuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWkgJiYgKGkgPSB7IHJlc3VsdDogYiwgY3R4OiB4IH0pLCB4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoICYmIGMucHVzaCh4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGkpXG4gICAgICAgIHJldHVybiByLmNvbW1vbi5pc3N1ZXMucHVzaCguLi5pLmN0eC5jb21tb24uaXNzdWVzKSwgaS5yZXN1bHQ7XG4gICAgICBjb25zdCBmID0gYy5tYXAoKHYpID0+IG5ldyBadCh2KSk7XG4gICAgICByZXR1cm4gb2Uociwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICB1bmlvbkVycm9yczogZlxuICAgICAgfSksIEFlO1xuICAgIH1cbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbn1cbmxpLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgbGkoe1xuICBvcHRpb25zOiB0LFxuICB0eXBlTmFtZTogQ2UuWm9kVW5pb24sXG4gIC4uLlRlKGUpXG59KTtcbmNvbnN0IGRyID0gKHQpID0+IHQgaW5zdGFuY2VvZiBkaSA/IGRyKHQuc2NoZW1hKSA6IHQgaW5zdGFuY2VvZiBZdCA/IGRyKHQuaW5uZXJUeXBlKCkpIDogdCBpbnN0YW5jZW9mIHBpID8gW3QudmFsdWVdIDogdCBpbnN0YW5jZW9mIE5yID8gdC5vcHRpb25zIDogdCBpbnN0YW5jZW9mIG1pID8gbnQub2JqZWN0VmFsdWVzKHQuZW51bSkgOiB0IGluc3RhbmNlb2YgZ2kgPyBkcih0Ll9kZWYuaW5uZXJUeXBlKSA6IHQgaW5zdGFuY2VvZiB1aSA/IFt2b2lkIDBdIDogdCBpbnN0YW5jZW9mIGNpID8gW251bGxdIDogdCBpbnN0YW5jZW9mIGlyID8gW3ZvaWQgMCwgLi4uZHIodC51bndyYXAoKSldIDogdCBpbnN0YW5jZW9mIGpyID8gW251bGwsIC4uLmRyKHQudW53cmFwKCkpXSA6IHQgaW5zdGFuY2VvZiByYSB8fCB0IGluc3RhbmNlb2YgdmkgPyBkcih0LnVud3JhcCgpKSA6IHQgaW5zdGFuY2VvZiB5aSA/IGRyKHQuX2RlZi5pbm5lclR5cGUpIDogW107XG5jbGFzcyBUcyBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChyLnBhcnNlZFR5cGUgIT09IGxlLm9iamVjdClcbiAgICAgIHJldHVybiBvZShyLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IHIucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIGNvbnN0IG4gPSB0aGlzLmRpc2NyaW1pbmF0b3IsIG8gPSByLmRhdGFbbl0sIGkgPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KG8pO1xuICAgIHJldHVybiBpID8gci5jb21tb24uYXN5bmMgPyBpLl9wYXJzZUFzeW5jKHtcbiAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgIHBhcmVudDogclxuICAgIH0pIDogaS5fcGFyc2VTeW5jKHtcbiAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgIHBhcmVudDogclxuICAgIH0pIDogKG9lKHIsIHtcbiAgICAgIGNvZGU6IG5lLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgIG9wdGlvbnM6IEFycmF5LmZyb20odGhpcy5vcHRpb25zTWFwLmtleXMoKSksXG4gICAgICBwYXRoOiBbbl1cbiAgICB9KSwgQWUpO1xuICB9XG4gIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbiAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoZSwgciwgbikge1xuICAgIGNvbnN0IG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgaSBvZiByKSB7XG4gICAgICBjb25zdCBjID0gZHIoaS5zaGFwZVtlXSk7XG4gICAgICBpZiAoIWMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZX1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgZm9yIChjb25zdCBmIG9mIGMpIHtcbiAgICAgICAgaWYgKG8uaGFzKGYpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlzY3JpbWluYXRvciBwcm9wZXJ0eSAke1N0cmluZyhlKX0gaGFzIGR1cGxpY2F0ZSB2YWx1ZSAke1N0cmluZyhmKX1gKTtcbiAgICAgICAgby5zZXQoZiwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHMoe1xuICAgICAgdHlwZU5hbWU6IENlLlpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICAgIGRpc2NyaW1pbmF0b3I6IGUsXG4gICAgICBvcHRpb25zOiByLFxuICAgICAgb3B0aW9uc01hcDogbyxcbiAgICAgIC4uLlRlKG4pXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFJvKHQsIGUpIHtcbiAgY29uc3QgciA9IHByKHQpLCBuID0gcHIoZSk7XG4gIGlmICh0ID09PSBlKVxuICAgIHJldHVybiB7IHZhbGlkOiAhMCwgZGF0YTogdCB9O1xuICBpZiAociA9PT0gbGUub2JqZWN0ICYmIG4gPT09IGxlLm9iamVjdCkge1xuICAgIGNvbnN0IG8gPSBudC5vYmplY3RLZXlzKGUpLCBpID0gbnQub2JqZWN0S2V5cyh0KS5maWx0ZXIoKGYpID0+IG8uaW5kZXhPZihmKSAhPT0gLTEpLCBjID0geyAuLi50LCAuLi5lIH07XG4gICAgZm9yIChjb25zdCBmIG9mIGkpIHtcbiAgICAgIGNvbnN0IHYgPSBSbyh0W2ZdLCBlW2ZdKTtcbiAgICAgIGlmICghdi52YWxpZClcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6ICExIH07XG4gICAgICBjW2ZdID0gdi5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogITAsIGRhdGE6IGMgfTtcbiAgfSBlbHNlIGlmIChyID09PSBsZS5hcnJheSAmJiBuID09PSBsZS5hcnJheSkge1xuICAgIGlmICh0Lmxlbmd0aCAhPT0gZS5sZW5ndGgpXG4gICAgICByZXR1cm4geyB2YWxpZDogITEgfTtcbiAgICBjb25zdCBvID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gdFtpXSwgZiA9IGVbaV0sIHYgPSBSbyhjLCBmKTtcbiAgICAgIGlmICghdi52YWxpZClcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6ICExIH07XG4gICAgICBvLnB1c2godi5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6ICEwLCBkYXRhOiBvIH07XG4gIH0gZWxzZSByZXR1cm4gciA9PT0gbGUuZGF0ZSAmJiBuID09PSBsZS5kYXRlICYmICt0ID09ICtlID8geyB2YWxpZDogITAsIGRhdGE6IHQgfSA6IHsgdmFsaWQ6ICExIH07XG59XG5jbGFzcyBmaSBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IHN0YXR1czogciwgY3R4OiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIG8gPSAoaSwgYykgPT4ge1xuICAgICAgaWYgKElvKGkpIHx8IElvKGMpKVxuICAgICAgICByZXR1cm4gQWU7XG4gICAgICBjb25zdCBmID0gUm8oaS52YWx1ZSwgYy52YWx1ZSk7XG4gICAgICByZXR1cm4gZi52YWxpZCA/ICgoQm8oaSkgfHwgQm8oYykpICYmIHIuZGlydHkoKSwgeyBzdGF0dXM6IHIudmFsdWUsIHZhbHVlOiBmLmRhdGEgfSkgOiAob2Uobiwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1xuICAgICAgfSksIEFlKTtcbiAgICB9O1xuICAgIHJldHVybiBuLmNvbW1vbi5hc3luYyA/IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgZGF0YTogbi5kYXRhLFxuICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgIHBhcmVudDogblxuICAgICAgfSksXG4gICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICBkYXRhOiBuLmRhdGEsXG4gICAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgICAgcGFyZW50OiBuXG4gICAgICB9KVxuICAgIF0pLnRoZW4oKFtpLCBjXSkgPT4gbyhpLCBjKSkgOiBvKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgZGF0YTogbi5kYXRhLFxuICAgICAgcGF0aDogbi5wYXRoLFxuICAgICAgcGFyZW50OiBuXG4gICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgIGRhdGE6IG4uZGF0YSxcbiAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgIHBhcmVudDogblxuICAgIH0pKTtcbiAgfVxufVxuZmkuY3JlYXRlID0gKHQsIGUsIHIpID0+IG5ldyBmaSh7XG4gIGxlZnQ6IHQsXG4gIHJpZ2h0OiBlLFxuICB0eXBlTmFtZTogQ2UuWm9kSW50ZXJzZWN0aW9uLFxuICAuLi5UZShyKVxufSk7XG5jbGFzcyBvciBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IHN0YXR1czogciwgY3R4OiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSk7XG4gICAgaWYgKG4ucGFyc2VkVHlwZSAhPT0gbGUuYXJyYXkpXG4gICAgICByZXR1cm4gb2Uobiwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBsZS5hcnJheSxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIGlmIChuLmRhdGEubGVuZ3RoIDwgdGhpcy5fZGVmLml0ZW1zLmxlbmd0aClcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLnRvb19zbWFsbCxcbiAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICB0eXBlOiBcImFycmF5XCJcbiAgICAgIH0pLCBBZTtcbiAgICAhdGhpcy5fZGVmLnJlc3QgJiYgbi5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGggJiYgKG9lKG4sIHtcbiAgICAgIGNvZGU6IG5lLnRvb19iaWcsXG4gICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIGV4YWN0OiAhMSxcbiAgICAgIHR5cGU6IFwiYXJyYXlcIlxuICAgIH0pLCByLmRpcnR5KCkpO1xuICAgIGNvbnN0IGkgPSBbLi4ubi5kYXRhXS5tYXAoKGMsIGYpID0+IHtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLl9kZWYuaXRlbXNbZl0gfHwgdGhpcy5fZGVmLnJlc3Q7XG4gICAgICByZXR1cm4gdiA/IHYuX3BhcnNlKG5ldyBzcihuLCBjLCBuLnBhdGgsIGYpKSA6IG51bGw7XG4gICAgfSkuZmlsdGVyKChjKSA9PiAhIWMpO1xuICAgIHJldHVybiBuLmNvbW1vbi5hc3luYyA/IFByb21pc2UuYWxsKGkpLnRoZW4oKGMpID0+IEx0Lm1lcmdlQXJyYXkociwgYykpIDogTHQubWVyZ2VBcnJheShyLCBpKTtcbiAgfVxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pdGVtcztcbiAgfVxuICByZXN0KGUpIHtcbiAgICByZXR1cm4gbmV3IG9yKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHJlc3Q6IGVcbiAgICB9KTtcbiAgfVxufVxub3IuY3JlYXRlID0gKHQsIGUpID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICByZXR1cm4gbmV3IG9yKHtcbiAgICBpdGVtczogdCxcbiAgICB0eXBlTmFtZTogQ2UuWm9kVHVwbGUsXG4gICAgcmVzdDogbnVsbCxcbiAgICAuLi5UZShlKVxuICB9KTtcbn07XG5jbGFzcyBoaSBleHRlbmRzIEplIHtcbiAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gIH1cbiAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHIsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IGxlLm9iamVjdClcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIGNvbnN0IG8gPSBbXSwgaSA9IHRoaXMuX2RlZi5rZXlUeXBlLCBjID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICBmb3IgKGNvbnN0IGYgaW4gbi5kYXRhKVxuICAgICAgby5wdXNoKHtcbiAgICAgICAga2V5OiBpLl9wYXJzZShuZXcgc3IobiwgZiwgbi5wYXRoLCBmKSksXG4gICAgICAgIHZhbHVlOiBjLl9wYXJzZShuZXcgc3Iobiwgbi5kYXRhW2ZdLCBuLnBhdGgsIGYpKSxcbiAgICAgICAgYWx3YXlzU2V0OiBmIGluIG4uZGF0YVxuICAgICAgfSk7XG4gICAgcmV0dXJuIG4uY29tbW9uLmFzeW5jID8gTHQubWVyZ2VPYmplY3RBc3luYyhyLCBvKSA6IEx0Lm1lcmdlT2JqZWN0U3luYyhyLCBvKTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGUsIHIsIG4pIHtcbiAgICByZXR1cm4gciBpbnN0YW5jZW9mIEplID8gbmV3IGhpKHtcbiAgICAgIGtleVR5cGU6IGUsXG4gICAgICB2YWx1ZVR5cGU6IHIsXG4gICAgICB0eXBlTmFtZTogQ2UuWm9kUmVjb3JkLFxuICAgICAgLi4uVGUobilcbiAgICB9KSA6IG5ldyBoaSh7XG4gICAgICBrZXlUeXBlOiBXdC5jcmVhdGUoKSxcbiAgICAgIHZhbHVlVHlwZTogZSxcbiAgICAgIHR5cGVOYW1lOiBDZS5ab2RSZWNvcmQsXG4gICAgICAuLi5UZShyKVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBocyBleHRlbmRzIEplIHtcbiAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gIH1cbiAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHIsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IGxlLm1hcClcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLm1hcCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIGNvbnN0IG8gPSB0aGlzLl9kZWYua2V5VHlwZSwgaSA9IHRoaXMuX2RlZi52YWx1ZVR5cGUsIGMgPSBbLi4ubi5kYXRhLmVudHJpZXMoKV0ubWFwKChbZiwgdl0sIHgpID0+ICh7XG4gICAgICBrZXk6IG8uX3BhcnNlKG5ldyBzcihuLCBmLCBuLnBhdGgsIFt4LCBcImtleVwiXSkpLFxuICAgICAgdmFsdWU6IGkuX3BhcnNlKG5ldyBzcihuLCB2LCBuLnBhdGgsIFt4LCBcInZhbHVlXCJdKSlcbiAgICB9KSk7XG4gICAgaWYgKG4uY29tbW9uLmFzeW5jKSB7XG4gICAgICBjb25zdCBmID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIGMpIHtcbiAgICAgICAgICBjb25zdCB4ID0gYXdhaXQgdi5rZXksIGIgPSBhd2FpdCB2LnZhbHVlO1xuICAgICAgICAgIGlmICh4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgYi5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuIEFlO1xuICAgICAgICAgICh4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IGIuc3RhdHVzID09PSBcImRpcnR5XCIpICYmIHIuZGlydHkoKSwgZi5zZXQoeC52YWx1ZSwgYi52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiByLnZhbHVlLCB2YWx1ZTogZiB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGYgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCB2IG9mIGMpIHtcbiAgICAgICAgY29uc3QgeCA9IHYua2V5LCBiID0gdi52YWx1ZTtcbiAgICAgICAgaWYgKHguc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCBiLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIEFlO1xuICAgICAgICAoeC5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCBiLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSAmJiByLmRpcnR5KCksIGYuc2V0KHgudmFsdWUsIGIudmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiByLnZhbHVlLCB2YWx1ZTogZiB9O1xuICAgIH1cbiAgfVxufVxuaHMuY3JlYXRlID0gKHQsIGUsIHIpID0+IG5ldyBocyh7XG4gIHZhbHVlVHlwZTogZSxcbiAga2V5VHlwZTogdCxcbiAgdHlwZU5hbWU6IENlLlpvZE1hcCxcbiAgLi4uVGUocilcbn0pO1xuY2xhc3MgbG4gZXh0ZW5kcyBKZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHIsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IGxlLnNldClcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGxlLnNldCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIGNvbnN0IG8gPSB0aGlzLl9kZWY7XG4gICAgby5taW5TaXplICE9PSBudWxsICYmIG4uZGF0YS5zaXplIDwgby5taW5TaXplLnZhbHVlICYmIChvZShuLCB7XG4gICAgICBjb2RlOiBuZS50b29fc21hbGwsXG4gICAgICBtaW5pbXVtOiBvLm1pblNpemUudmFsdWUsXG4gICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIGV4YWN0OiAhMSxcbiAgICAgIG1lc3NhZ2U6IG8ubWluU2l6ZS5tZXNzYWdlXG4gICAgfSksIHIuZGlydHkoKSksIG8ubWF4U2l6ZSAhPT0gbnVsbCAmJiBuLmRhdGEuc2l6ZSA+IG8ubWF4U2l6ZS52YWx1ZSAmJiAob2Uobiwge1xuICAgICAgY29kZTogbmUudG9vX2JpZyxcbiAgICAgIG1heGltdW06IG8ubWF4U2l6ZS52YWx1ZSxcbiAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgZXhhY3Q6ICExLFxuICAgICAgbWVzc2FnZTogby5tYXhTaXplLm1lc3NhZ2VcbiAgICB9KSwgci5kaXJ0eSgpKTtcbiAgICBjb25zdCBpID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICBmdW5jdGlvbiBjKHYpIHtcbiAgICAgIGNvbnN0IHggPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBiIG9mIHYpIHtcbiAgICAgICAgaWYgKGIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICByZXR1cm4gQWU7XG4gICAgICAgIGIuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgci5kaXJ0eSgpLCB4LmFkZChiLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogci52YWx1ZSwgdmFsdWU6IHggfTtcbiAgICB9XG4gICAgY29uc3QgZiA9IFsuLi5uLmRhdGEudmFsdWVzKCldLm1hcCgodiwgeCkgPT4gaS5fcGFyc2UobmV3IHNyKG4sIHYsIG4ucGF0aCwgeCkpKTtcbiAgICByZXR1cm4gbi5jb21tb24uYXN5bmMgPyBQcm9taXNlLmFsbChmKS50aGVuKCh2KSA9PiBjKHYpKSA6IGMoZik7XG4gIH1cbiAgbWluKGUsIHIpIHtcbiAgICByZXR1cm4gbmV3IGxuKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1pblNpemU6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IHZlLnRvU3RyaW5nKHIpIH1cbiAgICB9KTtcbiAgfVxuICBtYXgoZSwgcikge1xuICAgIHJldHVybiBuZXcgbG4oe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgbWF4U2l6ZTogeyB2YWx1ZTogZSwgbWVzc2FnZTogdmUudG9TdHJpbmcocikgfVxuICAgIH0pO1xuICB9XG4gIHNpemUoZSwgcikge1xuICAgIHJldHVybiB0aGlzLm1pbihlLCByKS5tYXgoZSwgcik7XG4gIH1cbiAgbm9uZW1wdHkoZSkge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBlKTtcbiAgfVxufVxubG4uY3JlYXRlID0gKHQsIGUpID0+IG5ldyBsbih7XG4gIHZhbHVlVHlwZTogdCxcbiAgbWluU2l6ZTogbnVsbCxcbiAgbWF4U2l6ZTogbnVsbCxcbiAgdHlwZU5hbWU6IENlLlpvZFNldCxcbiAgLi4uVGUoZSlcbn0pO1xuY2xhc3Mga24gZXh0ZW5kcyBKZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgY3R4OiByIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSk7XG4gICAgaWYgKHIucGFyc2VkVHlwZSAhPT0gbGUuZnVuY3Rpb24pXG4gICAgICByZXR1cm4gb2Uociwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBsZS5mdW5jdGlvbixcbiAgICAgICAgcmVjZWl2ZWQ6IHIucGFyc2VkVHlwZVxuICAgICAgfSksIEFlO1xuICAgIGZ1bmN0aW9uIG4oZiwgdikge1xuICAgICAgcmV0dXJuIHVzKHtcbiAgICAgICAgZGF0YTogZixcbiAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICByLmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgci5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICBhcygpLFxuICAgICAgICAgIFJuXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICBhcmd1bWVudHNFcnJvcjogdlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbyhmLCB2KSB7XG4gICAgICByZXR1cm4gdXMoe1xuICAgICAgICBkYXRhOiBmLFxuICAgICAgICBwYXRoOiByLnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgIHIuY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICByLnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgIGFzKCksXG4gICAgICAgICAgUm5cbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IG5lLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiB2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpID0geyBlcnJvck1hcDogci5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH0sIGMgPSByLmRhdGE7XG4gICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgTG4pIHtcbiAgICAgIGNvbnN0IGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIGp0KGFzeW5jIGZ1bmN0aW9uKC4uLnYpIHtcbiAgICAgICAgY29uc3QgeCA9IG5ldyBadChbXSksIGIgPSBhd2FpdCBmLl9kZWYuYXJncy5wYXJzZUFzeW5jKHYsIGkpLmNhdGNoKChDKSA9PiB7XG4gICAgICAgICAgdGhyb3cgeC5hZGRJc3N1ZShuKHYsIEMpKSwgeDtcbiAgICAgICAgfSksIFMgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGMsIHRoaXMsIGIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgZi5fZGVmLnJldHVybnMuX2RlZi50eXBlLnBhcnNlQXN5bmMoUywgaSkuY2F0Y2goKEMpID0+IHtcbiAgICAgICAgICB0aHJvdyB4LmFkZElzc3VlKG8oUywgQykpLCB4O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmID0gdGhpcztcbiAgICAgIHJldHVybiBqdChmdW5jdGlvbiguLi52KSB7XG4gICAgICAgIGNvbnN0IHggPSBmLl9kZWYuYXJncy5zYWZlUGFyc2UodiwgaSk7XG4gICAgICAgIGlmICgheC5zdWNjZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBadChbbih2LCB4LmVycm9yKV0pO1xuICAgICAgICBjb25zdCBiID0gUmVmbGVjdC5hcHBseShjLCB0aGlzLCB4LmRhdGEpLCBTID0gZi5fZGVmLnJldHVybnMuc2FmZVBhcnNlKGIsIGkpO1xuICAgICAgICBpZiAoIVMuc3VjY2VzcylcbiAgICAgICAgICB0aHJvdyBuZXcgWnQoW28oYiwgUy5lcnJvcildKTtcbiAgICAgICAgcmV0dXJuIFMuZGF0YTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcbiAgfVxuICByZXR1cm5UeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYucmV0dXJucztcbiAgfVxuICBhcmdzKC4uLmUpIHtcbiAgICByZXR1cm4gbmV3IGtuKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGFyZ3M6IG9yLmNyZWF0ZShlKS5yZXN0KGFuLmNyZWF0ZSgpKVxuICAgIH0pO1xuICB9XG4gIHJldHVybnMoZSkge1xuICAgIHJldHVybiBuZXcga24oe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgcmV0dXJuczogZVxuICAgIH0pO1xuICB9XG4gIGltcGxlbWVudChlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoZSk7XG4gIH1cbiAgc3RyaWN0SW1wbGVtZW50KGUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZShlKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGUsIHIsIG4pIHtcbiAgICByZXR1cm4gbmV3IGtuKHtcbiAgICAgIGFyZ3M6IGUgfHwgb3IuY3JlYXRlKFtdKS5yZXN0KGFuLmNyZWF0ZSgpKSxcbiAgICAgIHJldHVybnM6IHIgfHwgYW4uY3JlYXRlKCksXG4gICAgICB0eXBlTmFtZTogQ2UuWm9kRnVuY3Rpb24sXG4gICAgICAuLi5UZShuKVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBkaSBleHRlbmRzIEplIHtcbiAgZ2V0IHNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBjdHg6IHIgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKTtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpLl9wYXJzZSh7IGRhdGE6IHIuZGF0YSwgcGF0aDogci5wYXRoLCBwYXJlbnQ6IHIgfSk7XG4gIH1cbn1cbmRpLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgZGkoe1xuICBnZXR0ZXI6IHQsXG4gIHR5cGVOYW1lOiBDZS5ab2RMYXp5LFxuICAuLi5UZShlKVxufSk7XG5jbGFzcyBwaSBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAoZS5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBvZShyLCB7XG4gICAgICAgIHJlY2VpdmVkOiByLmRhdGEsXG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfbGl0ZXJhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZVxuICAgICAgfSksIEFlO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGUuZGF0YSB9O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlO1xuICB9XG59XG5waS5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IHBpKHtcbiAgdmFsdWU6IHQsXG4gIHR5cGVOYW1lOiBDZS5ab2RMaXRlcmFsLFxuICAuLi5UZShlKVxufSk7XG5mdW5jdGlvbiBYdSh0LCBlKSB7XG4gIHJldHVybiBuZXcgTnIoe1xuICAgIHZhbHVlczogdCxcbiAgICB0eXBlTmFtZTogQ2UuWm9kRW51bSxcbiAgICAuLi5UZShlKVxuICB9KTtcbn1cbmNsYXNzIE5yIGV4dGVuZHMgSmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aS5zZXQodGhpcywgdm9pZCAwKTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0eXBlb2YgZS5kYXRhICE9IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKSwgbiA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICByZXR1cm4gb2Uociwge1xuICAgICAgICBleHBlY3RlZDogbnQuam9pblZhbHVlcyhuKSxcbiAgICAgICAgcmVjZWl2ZWQ6IHIucGFyc2VkVHlwZSxcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF90eXBlXG4gICAgICB9KSwgQWU7XG4gICAgfVxuICAgIGlmIChjcyh0aGlzLCB0aSkgfHwgV3UodGhpcywgdGksIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcykpLCAhY3ModGhpcywgdGkpLmhhcyhlLmRhdGEpKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSksIG4gPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgcmV0dXJuIG9lKHIsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IHIuZGF0YSxcbiAgICAgICAgY29kZTogbmUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBuXG4gICAgICB9KSwgQWU7XG4gICAgfVxuICAgIHJldHVybiBqdChlLmRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fZGVmLnZhbHVlcylcbiAgICAgIGVbcl0gPSByO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBWYWx1ZXMoKSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYudmFsdWVzKVxuICAgICAgZVtyXSA9IHI7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IEVudW0oKSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYudmFsdWVzKVxuICAgICAgZVtyXSA9IHI7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZXh0cmFjdChlLCByID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIE5yLmNyZWF0ZShlLCB7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAuLi5yXG4gICAgfSk7XG4gIH1cbiAgZXhjbHVkZShlLCByID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIE5yLmNyZWF0ZSh0aGlzLm9wdGlvbnMuZmlsdGVyKChuKSA9PiAhZS5pbmNsdWRlcyhuKSksIHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIC4uLnJcbiAgICB9KTtcbiAgfVxufVxudGkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbk5yLmNyZWF0ZSA9IFh1O1xuY2xhc3MgbWkgZXh0ZW5kcyBKZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHJpLnNldCh0aGlzLCB2b2lkIDApO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgciA9IG50LmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSwgbiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IGxlLnN0cmluZyAmJiBuLnBhcnNlZFR5cGUgIT09IGxlLm51bWJlcikge1xuICAgICAgY29uc3QgbyA9IG50Lm9iamVjdFZhbHVlcyhyKTtcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIGV4cGVjdGVkOiBudC5qb2luVmFsdWVzKG8pLFxuICAgICAgICByZWNlaXZlZDogbi5wYXJzZWRUeXBlLFxuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGVcbiAgICAgIH0pLCBBZTtcbiAgICB9XG4gICAgaWYgKGNzKHRoaXMsIHJpKSB8fCBXdSh0aGlzLCByaSwgbmV3IFNldChudC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcykpKSwgIWNzKHRoaXMsIHJpKS5oYXMoZS5kYXRhKSkge1xuICAgICAgY29uc3QgbyA9IG50Lm9iamVjdFZhbHVlcyhyKTtcbiAgICAgIHJldHVybiBvZShuLCB7XG4gICAgICAgIHJlY2VpdmVkOiBuLmRhdGEsXG4gICAgICAgIGNvZGU6IG5lLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgb3B0aW9uczogb1xuICAgICAgfSksIEFlO1xuICAgIH1cbiAgICByZXR1cm4ganQoZS5kYXRhKTtcbiAgfVxuICBnZXQgZW51bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgfVxufVxucmkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbm1pLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgbWkoe1xuICB2YWx1ZXM6IHQsXG4gIHR5cGVOYW1lOiBDZS5ab2ROYXRpdmVFbnVtLFxuICAuLi5UZShlKVxufSk7XG5jbGFzcyBMbiBleHRlbmRzIEplIHtcbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgY3R4OiByIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSk7XG4gICAgaWYgKHIucGFyc2VkVHlwZSAhPT0gbGUucHJvbWlzZSAmJiByLmNvbW1vbi5hc3luYyA9PT0gITEpXG4gICAgICByZXR1cm4gb2Uociwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBsZS5wcm9taXNlLFxuICAgICAgICByZWNlaXZlZDogci5wYXJzZWRUeXBlXG4gICAgICB9KSwgQWU7XG4gICAgY29uc3QgbiA9IHIucGFyc2VkVHlwZSA9PT0gbGUucHJvbWlzZSA/IHIuZGF0YSA6IFByb21pc2UucmVzb2x2ZShyLmRhdGEpO1xuICAgIHJldHVybiBqdChuLnRoZW4oKG8pID0+IHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMobywge1xuICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgZXJyb3JNYXA6IHIuY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcFxuICAgIH0pKSk7XG4gIH1cbn1cbkxuLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgTG4oe1xuICB0eXBlOiB0LFxuICB0eXBlTmFtZTogQ2UuWm9kUHJvbWlzZSxcbiAgLi4uVGUoZSlcbn0pO1xuY2xhc3MgWXQgZXh0ZW5kcyBKZSB7XG4gIGlubmVyVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgfVxuICBzb3VyY2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IENlLlpvZEVmZmVjdHMgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKSA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IHN0YXR1czogciwgY3R4OiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIG8gPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGwsIGkgPSB7XG4gICAgICBhZGRJc3N1ZTogKGMpID0+IHtcbiAgICAgICAgb2UobiwgYyksIGMuZmF0YWwgPyByLmFib3J0KCkgOiByLmRpcnR5KCk7XG4gICAgICB9LFxuICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBuLnBhdGg7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaS5hZGRJc3N1ZSA9IGkuYWRkSXNzdWUuYmluZChpKSwgby50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgY29uc3QgYyA9IG8udHJhbnNmb3JtKG4uZGF0YSwgaSk7XG4gICAgICBpZiAobi5jb21tb24uYXN5bmMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYykudGhlbihhc3luYyAoZikgPT4ge1xuICAgICAgICAgIGlmIChyLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiBBZTtcbiAgICAgICAgICBjb25zdCB2ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICBkYXRhOiBmLFxuICAgICAgICAgICAgcGF0aDogbi5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBuXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHYuc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IEFlIDogdi5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCByLnZhbHVlID09PSBcImRpcnR5XCIgPyBDbih2LnZhbHVlKSA6IHY7XG4gICAgICAgIH0pO1xuICAgICAge1xuICAgICAgICBpZiAoci52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIEFlO1xuICAgICAgICBjb25zdCBmID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBjLFxuICAgICAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyBBZSA6IGYuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgci52YWx1ZSA9PT0gXCJkaXJ0eVwiID8gQ24oZi52YWx1ZSkgOiBmO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoby50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgY29uc3QgYyA9IChmKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBvLnJlZmluZW1lbnQoZiwgaSk7XG4gICAgICAgIGlmIChuLmNvbW1vbi5hc3luYylcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpO1xuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgcmVmaW5lbWVudCBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfTtcbiAgICAgIGlmIChuLmNvbW1vbi5hc3luYyA9PT0gITEpIHtcbiAgICAgICAgY29uc3QgZiA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogbi5kYXRhLFxuICAgICAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyBBZSA6IChmLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIHIuZGlydHkoKSwgYyhmLnZhbHVlKSwgeyBzdGF0dXM6IHIudmFsdWUsIHZhbHVlOiBmLnZhbHVlIH0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogbi5kYXRhLCBwYXRoOiBuLnBhdGgsIHBhcmVudDogbiB9KS50aGVuKChmKSA9PiBmLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyBBZSA6IChmLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIHIuZGlydHkoKSwgYyhmLnZhbHVlKS50aGVuKCgpID0+ICh7IHN0YXR1czogci52YWx1ZSwgdmFsdWU6IGYudmFsdWUgfSkpKSk7XG4gICAgfVxuICAgIGlmIChvLnR5cGUgPT09IFwidHJhbnNmb3JtXCIpXG4gICAgICBpZiAobi5jb21tb24uYXN5bmMgPT09ICExKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IG4uZGF0YSxcbiAgICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBuXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXVuKGMpKVxuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICBjb25zdCBmID0gby50cmFuc2Zvcm0oYy52YWx1ZSwgaSk7XG4gICAgICAgIGlmIChmIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiByLnZhbHVlLCB2YWx1ZTogZiB9O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogbi5kYXRhLCBwYXRoOiBuLnBhdGgsIHBhcmVudDogbiB9KS50aGVuKChjKSA9PiB1bihjKSA/IFByb21pc2UucmVzb2x2ZShvLnRyYW5zZm9ybShjLnZhbHVlLCBpKSkudGhlbigoZikgPT4gKHsgc3RhdHVzOiByLnZhbHVlLCB2YWx1ZTogZiB9KSkgOiBjKTtcbiAgICBudC5hc3NlcnROZXZlcihvKTtcbiAgfVxufVxuWXQuY3JlYXRlID0gKHQsIGUsIHIpID0+IG5ldyBZdCh7XG4gIHNjaGVtYTogdCxcbiAgdHlwZU5hbWU6IENlLlpvZEVmZmVjdHMsXG4gIGVmZmVjdDogZSxcbiAgLi4uVGUocilcbn0pO1xuWXQuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAodCwgZSwgcikgPT4gbmV3IFl0KHtcbiAgc2NoZW1hOiBlLFxuICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogdCB9LFxuICB0eXBlTmFtZTogQ2UuWm9kRWZmZWN0cyxcbiAgLi4uVGUocilcbn0pO1xuY2xhc3MgaXIgZXh0ZW5kcyBKZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFR5cGUoZSkgPT09IGxlLnVuZGVmaW5lZCA/IGp0KHZvaWQgMCkgOiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShlKTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn1cbmlyLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgaXIoe1xuICBpbm5lclR5cGU6IHQsXG4gIHR5cGVOYW1lOiBDZS5ab2RPcHRpb25hbCxcbiAgLi4uVGUoZSlcbn0pO1xuY2xhc3MganIgZXh0ZW5kcyBKZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFR5cGUoZSkgPT09IGxlLm51bGwgPyBqdChudWxsKSA6IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGUpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufVxuanIuY3JlYXRlID0gKHQsIGUpID0+IG5ldyBqcih7XG4gIGlubmVyVHlwZTogdCxcbiAgdHlwZU5hbWU6IENlLlpvZE51bGxhYmxlLFxuICAuLi5UZShlKVxufSk7XG5jbGFzcyBnaSBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGxldCBuID0gci5kYXRhO1xuICAgIHJldHVybiByLnBhcnNlZFR5cGUgPT09IGxlLnVuZGVmaW5lZCAmJiAobiA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKSksIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGE6IG4sXG4gICAgICBwYXRoOiByLnBhdGgsXG4gICAgICBwYXJlbnQ6IHJcbiAgICB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59XG5naS5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IGdpKHtcbiAgaW5uZXJUeXBlOiB0LFxuICB0eXBlTmFtZTogQ2UuWm9kRGVmYXVsdCxcbiAgZGVmYXVsdFZhbHVlOiB0eXBlb2YgZS5kZWZhdWx0ID09IFwiZnVuY3Rpb25cIiA/IGUuZGVmYXVsdCA6ICgpID0+IGUuZGVmYXVsdCxcbiAgLi4uVGUoZSlcbn0pO1xuY2xhc3MgeWkgZXh0ZW5kcyBKZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBjdHg6IHIgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSwgbiA9IHtcbiAgICAgIC4uLnIsXG4gICAgICBjb21tb246IHtcbiAgICAgICAgLi4uci5jb21tb24sXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH1cbiAgICB9LCBvID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YTogbi5kYXRhLFxuICAgICAgcGF0aDogbi5wYXRoLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIC4uLm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2kobykgPyBvLnRoZW4oKGkpID0+ICh7XG4gICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgIHZhbHVlOiBpLnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gaS52YWx1ZSA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgWnQobi5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXQ6IG4uZGF0YVxuICAgICAgfSlcbiAgICB9KSkgOiB7XG4gICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgIHZhbHVlOiBvLnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gby52YWx1ZSA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgWnQobi5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXQ6IG4uZGF0YVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHJlbW92ZUNhdGNoKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59XG55aS5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IHlpKHtcbiAgaW5uZXJUeXBlOiB0LFxuICB0eXBlTmFtZTogQ2UuWm9kQ2F0Y2gsXG4gIGNhdGNoVmFsdWU6IHR5cGVvZiBlLmNhdGNoID09IFwiZnVuY3Rpb25cIiA/IGUuY2F0Y2ggOiAoKSA9PiBlLmNhdGNoLFxuICAuLi5UZShlKVxufSk7XG5jbGFzcyBkcyBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbGUubmFuKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gb2Uobiwge1xuICAgICAgICBjb2RlOiBuZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBsZS5uYW4sXG4gICAgICAgIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBBZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxufVxuZHMuY3JlYXRlID0gKHQpID0+IG5ldyBkcyh7XG4gIHR5cGVOYW1lOiBDZS5ab2ROYU4sXG4gIC4uLlRlKHQpXG59KTtcbmNvbnN0IEJmID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuY2xhc3MgcmEgZXh0ZW5kcyBKZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBjdHg6IHIgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSwgbiA9IHIuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGE6IG4sXG4gICAgICBwYXRoOiByLnBhdGgsXG4gICAgICBwYXJlbnQ6IHJcbiAgICB9KTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICB9XG59XG5jbGFzcyBqaSBleHRlbmRzIEplIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IHN0YXR1czogciwgY3R4OiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSk7XG4gICAgaWYgKG4uY29tbW9uLmFzeW5jKVxuICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IG4uZGF0YSxcbiAgICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiID8gQWUgOiBpLnN0YXR1cyA9PT0gXCJkaXJ0eVwiID8gKHIuZGlydHkoKSwgQ24oaS52YWx1ZSkpIDogdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgZGF0YTogaS52YWx1ZSxcbiAgICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBuXG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICB7XG4gICAgICBjb25zdCBvID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICBkYXRhOiBuLmRhdGEsXG4gICAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgICAgcGFyZW50OiBuXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyBBZSA6IG8uc3RhdHVzID09PSBcImRpcnR5XCIgPyAoci5kaXJ0eSgpLCB7XG4gICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICB2YWx1ZTogby52YWx1ZVxuICAgICAgfSkgOiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICBkYXRhOiBvLnZhbHVlLFxuICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgIHBhcmVudDogblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoZSwgcikge1xuICAgIHJldHVybiBuZXcgamkoe1xuICAgICAgaW46IGUsXG4gICAgICBvdXQ6IHIsXG4gICAgICB0eXBlTmFtZTogQ2UuWm9kUGlwZWxpbmVcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgdmkgZXh0ZW5kcyBKZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGUpLCBuID0gKG8pID0+ICh1bihvKSAmJiAoby52YWx1ZSA9IE9iamVjdC5mcmVlemUoby52YWx1ZSkpLCBvKTtcbiAgICByZXR1cm4gb2kocikgPyByLnRoZW4oKG8pID0+IG4obykpIDogbihyKTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn1cbnZpLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgdmkoe1xuICBpbm5lclR5cGU6IHQsXG4gIHR5cGVOYW1lOiBDZS5ab2RSZWFkb25seSxcbiAgLi4uVGUoZSlcbn0pO1xuZnVuY3Rpb24gSWEodCwgZSkge1xuICBjb25zdCByID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdChlKSA6IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHQgfSA6IHQ7XG4gIHJldHVybiB0eXBlb2YgciA9PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiByIH0gOiByO1xufVxuZnVuY3Rpb24gUXUodCwgZSA9IHt9LCByKSB7XG4gIHJldHVybiB0ID8gVG4uY3JlYXRlKCkuc3VwZXJSZWZpbmUoKG4sIG8pID0+IHtcbiAgICB2YXIgaSwgYztcbiAgICBjb25zdCBmID0gdChuKTtcbiAgICBpZiAoZiBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICByZXR1cm4gZi50aGVuKCh2KSA9PiB7XG4gICAgICAgIHZhciB4LCBiO1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICBjb25zdCBTID0gSWEoZSwgbiksIFQgPSAoYiA9ICh4ID0gUy5mYXRhbCkgIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwID8geCA6IHIpICE9PSBudWxsICYmIGIgIT09IHZvaWQgMCA/IGIgOiAhMDtcbiAgICAgICAgICBvLmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4uUywgZmF0YWw6IFQgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGlmICghZikge1xuICAgICAgY29uc3QgdiA9IElhKGUsIG4pLCB4ID0gKGMgPSAoaSA9IHYuZmF0YWwpICE9PSBudWxsICYmIGkgIT09IHZvaWQgMCA/IGkgOiByKSAhPT0gbnVsbCAmJiBjICE9PSB2b2lkIDAgPyBjIDogITA7XG4gICAgICBvLmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4udiwgZmF0YWw6IHggfSk7XG4gICAgfVxuICB9KSA6IFRuLmNyZWF0ZSgpO1xufVxuY29uc3QgUmYgPSB7XG4gIG9iamVjdDogaHQubGF6eWNyZWF0ZVxufTtcbnZhciBDZTtcbihmdW5jdGlvbih0KSB7XG4gIHQuWm9kU3RyaW5nID0gXCJab2RTdHJpbmdcIiwgdC5ab2ROdW1iZXIgPSBcIlpvZE51bWJlclwiLCB0LlpvZE5hTiA9IFwiWm9kTmFOXCIsIHQuWm9kQmlnSW50ID0gXCJab2RCaWdJbnRcIiwgdC5ab2RCb29sZWFuID0gXCJab2RCb29sZWFuXCIsIHQuWm9kRGF0ZSA9IFwiWm9kRGF0ZVwiLCB0LlpvZFN5bWJvbCA9IFwiWm9kU3ltYm9sXCIsIHQuWm9kVW5kZWZpbmVkID0gXCJab2RVbmRlZmluZWRcIiwgdC5ab2ROdWxsID0gXCJab2ROdWxsXCIsIHQuWm9kQW55ID0gXCJab2RBbnlcIiwgdC5ab2RVbmtub3duID0gXCJab2RVbmtub3duXCIsIHQuWm9kTmV2ZXIgPSBcIlpvZE5ldmVyXCIsIHQuWm9kVm9pZCA9IFwiWm9kVm9pZFwiLCB0LlpvZEFycmF5ID0gXCJab2RBcnJheVwiLCB0LlpvZE9iamVjdCA9IFwiWm9kT2JqZWN0XCIsIHQuWm9kVW5pb24gPSBcIlpvZFVuaW9uXCIsIHQuWm9kRGlzY3JpbWluYXRlZFVuaW9uID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIiwgdC5ab2RJbnRlcnNlY3Rpb24gPSBcIlpvZEludGVyc2VjdGlvblwiLCB0LlpvZFR1cGxlID0gXCJab2RUdXBsZVwiLCB0LlpvZFJlY29yZCA9IFwiWm9kUmVjb3JkXCIsIHQuWm9kTWFwID0gXCJab2RNYXBcIiwgdC5ab2RTZXQgPSBcIlpvZFNldFwiLCB0LlpvZEZ1bmN0aW9uID0gXCJab2RGdW5jdGlvblwiLCB0LlpvZExhenkgPSBcIlpvZExhenlcIiwgdC5ab2RMaXRlcmFsID0gXCJab2RMaXRlcmFsXCIsIHQuWm9kRW51bSA9IFwiWm9kRW51bVwiLCB0LlpvZEVmZmVjdHMgPSBcIlpvZEVmZmVjdHNcIiwgdC5ab2ROYXRpdmVFbnVtID0gXCJab2ROYXRpdmVFbnVtXCIsIHQuWm9kT3B0aW9uYWwgPSBcIlpvZE9wdGlvbmFsXCIsIHQuWm9kTnVsbGFibGUgPSBcIlpvZE51bGxhYmxlXCIsIHQuWm9kRGVmYXVsdCA9IFwiWm9kRGVmYXVsdFwiLCB0LlpvZENhdGNoID0gXCJab2RDYXRjaFwiLCB0LlpvZFByb21pc2UgPSBcIlpvZFByb21pc2VcIiwgdC5ab2RCcmFuZGVkID0gXCJab2RCcmFuZGVkXCIsIHQuWm9kUGlwZWxpbmUgPSBcIlpvZFBpcGVsaW5lXCIsIHQuWm9kUmVhZG9ubHkgPSBcIlpvZFJlYWRvbmx5XCI7XG59KShDZSB8fCAoQ2UgPSB7fSkpO1xuY29uc3QgVGYgPSAodCwgZSA9IHtcbiAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke3QubmFtZX1gXG59KSA9PiBRdSgocikgPT4gciBpbnN0YW5jZW9mIHQsIGUpLCBlYyA9IFd0LmNyZWF0ZSwgdGMgPSBMci5jcmVhdGUsIExmID0gZHMuY3JlYXRlLCBPZiA9IE9yLmNyZWF0ZSwgcmMgPSBhaS5jcmVhdGUsIE5mID0gY24uY3JlYXRlLCBqZiA9IGxzLmNyZWF0ZSwgVWYgPSB1aS5jcmVhdGUsIEZmID0gY2kuY3JlYXRlLCBQZiA9IFRuLmNyZWF0ZSwgRGYgPSBhbi5jcmVhdGUsICRmID0geHIuY3JlYXRlLCB6ZiA9IGZzLmNyZWF0ZSwgcWYgPSBHdC5jcmVhdGUsIFpmID0gaHQuY3JlYXRlLCBWZiA9IGh0LnN0cmljdENyZWF0ZSwgSGYgPSBsaS5jcmVhdGUsIEtmID0gVHMuY3JlYXRlLCBXZiA9IGZpLmNyZWF0ZSwgR2YgPSBvci5jcmVhdGUsIFlmID0gaGkuY3JlYXRlLCBKZiA9IGhzLmNyZWF0ZSwgWGYgPSBsbi5jcmVhdGUsIFFmID0ga24uY3JlYXRlLCBlMCA9IGRpLmNyZWF0ZSwgdDAgPSBwaS5jcmVhdGUsIHIwID0gTnIuY3JlYXRlLCBuMCA9IG1pLmNyZWF0ZSwgaTAgPSBMbi5jcmVhdGUsIEJhID0gWXQuY3JlYXRlLCBzMCA9IGlyLmNyZWF0ZSwgbzAgPSBqci5jcmVhdGUsIGEwID0gWXQuY3JlYXRlV2l0aFByZXByb2Nlc3MsIHUwID0gamkuY3JlYXRlLCBjMCA9ICgpID0+IGVjKCkub3B0aW9uYWwoKSwgbDAgPSAoKSA9PiB0YygpLm9wdGlvbmFsKCksIGYwID0gKCkgPT4gcmMoKS5vcHRpb25hbCgpLCBoMCA9IHtcbiAgc3RyaW5nOiAodCkgPT4gV3QuY3JlYXRlKHsgLi4udCwgY29lcmNlOiAhMCB9KSxcbiAgbnVtYmVyOiAodCkgPT4gTHIuY3JlYXRlKHsgLi4udCwgY29lcmNlOiAhMCB9KSxcbiAgYm9vbGVhbjogKHQpID0+IGFpLmNyZWF0ZSh7XG4gICAgLi4udCxcbiAgICBjb2VyY2U6ICEwXG4gIH0pLFxuICBiaWdpbnQ6ICh0KSA9PiBPci5jcmVhdGUoeyAuLi50LCBjb2VyY2U6ICEwIH0pLFxuICBkYXRlOiAodCkgPT4gY24uY3JlYXRlKHsgLi4udCwgY29lcmNlOiAhMCB9KVxufSwgZDAgPSBBZTtcbnZhciBwZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZWZhdWx0RXJyb3JNYXA6IFJuLFxuICBzZXRFcnJvck1hcDogYWYsXG4gIGdldEVycm9yTWFwOiBhcyxcbiAgbWFrZUlzc3VlOiB1cyxcbiAgRU1QVFlfUEFUSDogdWYsXG4gIGFkZElzc3VlVG9Db250ZXh0OiBvZSxcbiAgUGFyc2VTdGF0dXM6IEx0LFxuICBJTlZBTElEOiBBZSxcbiAgRElSVFk6IENuLFxuICBPSzoganQsXG4gIGlzQWJvcnRlZDogSW8sXG4gIGlzRGlydHk6IEJvLFxuICBpc1ZhbGlkOiB1bixcbiAgaXNBc3luYzogb2ksXG4gIGdldCB1dGlsKCkge1xuICAgIHJldHVybiBudDtcbiAgfSxcbiAgZ2V0IG9iamVjdFV0aWwoKSB7XG4gICAgcmV0dXJuIGtvO1xuICB9LFxuICBab2RQYXJzZWRUeXBlOiBsZSxcbiAgZ2V0UGFyc2VkVHlwZTogcHIsXG4gIFpvZFR5cGU6IEplLFxuICBkYXRldGltZVJlZ2V4OiBKdSxcbiAgWm9kU3RyaW5nOiBXdCxcbiAgWm9kTnVtYmVyOiBMcixcbiAgWm9kQmlnSW50OiBPcixcbiAgWm9kQm9vbGVhbjogYWksXG4gIFpvZERhdGU6IGNuLFxuICBab2RTeW1ib2w6IGxzLFxuICBab2RVbmRlZmluZWQ6IHVpLFxuICBab2ROdWxsOiBjaSxcbiAgWm9kQW55OiBUbixcbiAgWm9kVW5rbm93bjogYW4sXG4gIFpvZE5ldmVyOiB4cixcbiAgWm9kVm9pZDogZnMsXG4gIFpvZEFycmF5OiBHdCxcbiAgWm9kT2JqZWN0OiBodCxcbiAgWm9kVW5pb246IGxpLFxuICBab2REaXNjcmltaW5hdGVkVW5pb246IFRzLFxuICBab2RJbnRlcnNlY3Rpb246IGZpLFxuICBab2RUdXBsZTogb3IsXG4gIFpvZFJlY29yZDogaGksXG4gIFpvZE1hcDogaHMsXG4gIFpvZFNldDogbG4sXG4gIFpvZEZ1bmN0aW9uOiBrbixcbiAgWm9kTGF6eTogZGksXG4gIFpvZExpdGVyYWw6IHBpLFxuICBab2RFbnVtOiBOcixcbiAgWm9kTmF0aXZlRW51bTogbWksXG4gIFpvZFByb21pc2U6IExuLFxuICBab2RFZmZlY3RzOiBZdCxcbiAgWm9kVHJhbnNmb3JtZXI6IFl0LFxuICBab2RPcHRpb25hbDogaXIsXG4gIFpvZE51bGxhYmxlOiBqcixcbiAgWm9kRGVmYXVsdDogZ2ksXG4gIFpvZENhdGNoOiB5aSxcbiAgWm9kTmFOOiBkcyxcbiAgQlJBTkQ6IEJmLFxuICBab2RCcmFuZGVkOiByYSxcbiAgWm9kUGlwZWxpbmU6IGppLFxuICBab2RSZWFkb25seTogdmksXG4gIGN1c3RvbTogUXUsXG4gIFNjaGVtYTogSmUsXG4gIFpvZFNjaGVtYTogSmUsXG4gIGxhdGU6IFJmLFxuICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKCkge1xuICAgIHJldHVybiBDZTtcbiAgfSxcbiAgY29lcmNlOiBoMCxcbiAgYW55OiBQZixcbiAgYXJyYXk6IHFmLFxuICBiaWdpbnQ6IE9mLFxuICBib29sZWFuOiByYyxcbiAgZGF0ZTogTmYsXG4gIGRpc2NyaW1pbmF0ZWRVbmlvbjogS2YsXG4gIGVmZmVjdDogQmEsXG4gIGVudW06IHIwLFxuICBmdW5jdGlvbjogUWYsXG4gIGluc3RhbmNlb2Y6IFRmLFxuICBpbnRlcnNlY3Rpb246IFdmLFxuICBsYXp5OiBlMCxcbiAgbGl0ZXJhbDogdDAsXG4gIG1hcDogSmYsXG4gIG5hbjogTGYsXG4gIG5hdGl2ZUVudW06IG4wLFxuICBuZXZlcjogJGYsXG4gIG51bGw6IEZmLFxuICBudWxsYWJsZTogbzAsXG4gIG51bWJlcjogdGMsXG4gIG9iamVjdDogWmYsXG4gIG9ib29sZWFuOiBmMCxcbiAgb251bWJlcjogbDAsXG4gIG9wdGlvbmFsOiBzMCxcbiAgb3N0cmluZzogYzAsXG4gIHBpcGVsaW5lOiB1MCxcbiAgcHJlcHJvY2VzczogYTAsXG4gIHByb21pc2U6IGkwLFxuICByZWNvcmQ6IFlmLFxuICBzZXQ6IFhmLFxuICBzdHJpY3RPYmplY3Q6IFZmLFxuICBzdHJpbmc6IGVjLFxuICBzeW1ib2w6IGpmLFxuICB0cmFuc2Zvcm1lcjogQmEsXG4gIHR1cGxlOiBHZixcbiAgdW5kZWZpbmVkOiBVZixcbiAgdW5pb246IEhmLFxuICB1bmtub3duOiBEZixcbiAgdm9pZDogemYsXG4gIE5FVkVSOiBkMCxcbiAgWm9kSXNzdWVDb2RlOiBuZSxcbiAgcXVvdGVsZXNzSnNvbjogb2YsXG4gIFpvZEVycm9yOiBadFxufSk7XG5jb25zdCBwMCA9IC9bQCMkJV4mKis9XFwvXFxcXHx+wqvCu10vLCBtMCA9IC8oIXsyLH18XFw/ezIsfXwtezIsfSkvLCBnMCA9IC9bXFx1ezFGMzAwfS1cXHV7MUY5RkZ9XXxbXFx1ezI3MDJ9LVxcdXsyN0IwfV18W1xcdXsyNjAwfS1cXHV7MjZGRn1dfFtcXHV7MkIwMH0tXFx1ezJCRkZ9XS91LCB2biA9ICh7IG1heDogdCwgbm9TcGFjZXM6IGUgfSA9IHt9KSA9PiAoZSA/IHBlLnN0cmluZygpLm1heCh0ID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkucmVnZXgoL15cXFMqJC8sIFwiU3BhY2VzIGFyZSBub3QgYWxsb3dlZFwiKSA6IHBlLnN0cmluZygpLm1heCh0ID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkpLnJlZmluZSgobikgPT4gIWcwLnRlc3QobiksIHtcbiAgbWVzc2FnZTogXCJFbW9qaXMgYW5kIHN5bWJvbHMgYXJlIG5vdCBhbGxvd2VkXCJcbn0pLnJlZmluZSgobikgPT4gIXAwLnRlc3QobiksIHtcbiAgbWVzc2FnZTogXCJTcGVjaWFsIGNoYXJhY3RlcnMgKEAsICMsICQsICUsIF4sICYsICosICssID0sIC8sIFxcXFwsIHwsIH4sIMKrLCDCuykgYXJlIG5vdCBhbGxvd2VkXCJcbn0pLnJlZmluZSgobikgPT4gIW0wLnRlc3QobiksIHtcbiAgbWVzc2FnZTogXCJSZXBlYXRlZCBwdW5jdHVhdGlvbnMgKCEhLCA/PywgLS0pIGFyZSBub3QgYWxsb3dlZFwiXG59KSwgRHQgPSBwZS5zdHJpbmcoKS51cmwoKS5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIiwgeyBtZXNzYWdlOiBcIk11c3QgYmUgYW4gaHR0cHMgdXJsXCIgfSkubWF4KDEwMjQpLCBuYyA9IHBlLnN0cmluZygpLm1heCgzMiksIGljID0gcGUuc3RyaW5nKCkubWF4KDMyKSwgeTAgPSAvXlstYS16MC05XXszLDh9OlstX2EtekEtWjAtOV17MSwzMn1cXC8oPzpbLWEtejAtOV17Myw4fTpbLS4lYS16QS1aMC05XXsxLDEyOH0oPzpcXC9bLS4lYS16QS1aMC05XXsxLDc4fSk/fG5hdGl2ZSkkLywgdjAgPSBwZS5zdHJpbmcoKS5yZWdleCh5MCwgeyBtZXNzYWdlOiBcIkludmFsaWQgQ0FJUC0xOSBhc3NldCBJRFwiIH0pLCBzYyA9IHBlLnN0cmluZygpLnJlZ2V4KC9eIyhbMC05QS1GXXszfXxbMC05QS1GXXs2fSkkL2ksIHtcbiAgbWVzc2FnZTogXCJJbnZhbGlkIGhleCBjb2xvciBjb2RlLiBJdCBzaG91bGQgYmUgaW4gdGhlIGZvcm1hdCAjUlJHR0JCIG9yICNSR0IuXCJcbn0pLCB3MCA9IHBlLnVuaW9uKFtwZS5saXRlcmFsKFwiMToxXCIpLCBwZS5saXRlcmFsKFwiMzoyXCIpXSksIHgwID0gcGUub2JqZWN0KHtcbiAgaGVhZGVyOiBwZS5zdHJpbmcoKSxcbiAgcGF5bG9hZDogcGUuc3RyaW5nKCksXG4gIHNpZ25hdHVyZTogcGUuc3RyaW5nKClcbn0pO1xucGUub2JqZWN0KHtcbiAgZmlkOiBwZS5udW1iZXIoKSxcbiAgdHlwZTogcGUubGl0ZXJhbChcImFwcF9rZXlcIiksXG4gIGtleTogcGUuc3RyaW5nKCkuc3RhcnRzV2l0aChcIjB4XCIpXG59KTtcbmNvbnN0IGIwID0gcGUub2JqZWN0KHtcbiAgdHlwZTogcGUubGl0ZXJhbChcImxhdW5jaF9mcmFtZVwiKSxcbiAgbmFtZTogbmMsXG4gIHVybDogRHQub3B0aW9uYWwoKSxcbiAgc3BsYXNoSW1hZ2VVcmw6IER0Lm9wdGlvbmFsKCksXG4gIHNwbGFzaEJhY2tncm91bmRDb2xvcjogc2Mub3B0aW9uYWwoKVxufSksIF8wID0gcGUub2JqZWN0KHtcbiAgdHlwZTogcGUubGl0ZXJhbChcInZpZXdfdG9rZW5cIiksXG4gIHRva2VuOiB2MFxufSksIEUwID0gcGUuZGlzY3JpbWluYXRlZFVuaW9uKFwidHlwZVwiLCBbXG4gIGIwLFxuICBfMFxuXSksIE0wID0gcGUub2JqZWN0KHtcbiAgdGl0bGU6IGljLFxuICBhY3Rpb246IEUwXG59KTtcbnBlLm9iamVjdCh7XG4gIHZlcnNpb246IHBlLmxpdGVyYWwoXCJuZXh0XCIpLFxuICBpbWFnZVVybDogRHQsXG4gIGFzcGVjdFJhdGlvOiB3MC5vcHRpb25hbCgpLFxuICBidXR0b246IE0wXG59KTtcbmNvbnN0IG9jID0gcGUub2JqZWN0KHtcbiAgdXJsOiBwZS5zdHJpbmcoKSxcbiAgdG9rZW46IHBlLnN0cmluZygpXG59KTtcbnBlLm9iamVjdCh7XG4gIG5vdGlmaWNhdGlvbklkOiBwZS5zdHJpbmcoKS5tYXgoMTI4KSxcbiAgdGl0bGU6IHBlLnN0cmluZygpLm1heCgzMiksXG4gIGJvZHk6IHBlLnN0cmluZygpLm1heCgxMjgpLFxuICB0YXJnZXRVcmw6IER0LFxuICB0b2tlbnM6IHBlLnN0cmluZygpLmFycmF5KCkubWF4KDEwMClcbn0pO1xucGUub2JqZWN0KHtcbiAgcmVzdWx0OiBwZS5vYmplY3Qoe1xuICAgIHN1Y2Nlc3NmdWxUb2tlbnM6IHBlLmFycmF5KHBlLnN0cmluZygpKSxcbiAgICBpbnZhbGlkVG9rZW5zOiBwZS5hcnJheShwZS5zdHJpbmcoKSksXG4gICAgcmF0ZUxpbWl0ZWRUb2tlbnM6IHBlLmFycmF5KHBlLnN0cmluZygpKVxuICB9KVxufSk7XG5jb25zdCBDMCA9IHBlLm9iamVjdCh7XG4gIGV2ZW50OiBwZS5saXRlcmFsKFwiZnJhbWVfYWRkZWRcIiksXG4gIG5vdGlmaWNhdGlvbkRldGFpbHM6IG9jLm9wdGlvbmFsKClcbn0pLCBTMCA9IHBlLm9iamVjdCh7XG4gIGV2ZW50OiBwZS5saXRlcmFsKFwiZnJhbWVfcmVtb3ZlZFwiKVxufSksIEEwID0gcGUub2JqZWN0KHtcbiAgZXZlbnQ6IHBlLmxpdGVyYWwoXCJub3RpZmljYXRpb25zX2VuYWJsZWRcIiksXG4gIG5vdGlmaWNhdGlvbkRldGFpbHM6IG9jLnJlcXVpcmVkKClcbn0pLCBrMCA9IHBlLm9iamVjdCh7XG4gIGV2ZW50OiBwZS5saXRlcmFsKFwibm90aWZpY2F0aW9uc19kaXNhYmxlZFwiKVxufSk7XG5wZS5kaXNjcmltaW5hdGVkVW5pb24oXCJldmVudFwiLCBbXG4gIEMwLFxuICBTMCxcbiAgQTAsXG4gIGswXG5dKTtcbmNvbnN0IEkwID0gcGUuZW51bShbXG4gIFwiZ2FtZXNcIixcbiAgXCJzb2NpYWxcIixcbiAgXCJmaW5hbmNlXCIsXG4gIFwidXRpbGl0eVwiLFxuICBcInByb2R1Y3Rpdml0eVwiLFxuICBcImhlYWx0aC1maXRuZXNzXCIsXG4gIFwibmV3cy1tZWRpYVwiLFxuICBcIm11c2ljXCIsXG4gIFwic2hvcHBpbmdcIixcbiAgXCJlZHVjYXRpb25cIixcbiAgXCJkZXZlbG9wZXItdG9vbHNcIixcbiAgXCJlbnRlcnRhaW5tZW50XCIsXG4gIFwiYXJ0LWNyZWF0aXZpdHlcIlxuXSksIFJhID0gW1xuICBcImVpcDE1NToxXCIsXG4gIC8vIEV0aGVyZXVtIG1haW5uZXRcbiAgXCJlaXAxNTU6ODQ1M1wiLFxuICAvLyBCYXNlIG1haW5uZXRcbiAgXCJlaXAxNTU6NDIxNjFcIixcbiAgLy8gQXJiaXRydW0gT25lXG4gIFwiZWlwMTU1OjQyMTYxNFwiLFxuICAvLyBBcmJpdHJ1bSBTZXBvbGlhXG4gIFwiZWlwMTU1Ojg0NTMyXCIsXG4gIC8vIEJhc2UgU2Vwb2xpYVxuICBcImVpcDE1NTo2NjY2NjY2NjZcIixcbiAgLy8gRGVnZW5cbiAgXCJlaXAxNTU6MTAwXCIsXG4gIC8vIEdub3Npc1xuICBcImVpcDE1NToxMFwiLFxuICAvLyBPcHRpbWlzbVxuICBcImVpcDE1NToxMTE1NTQyMFwiLFxuICAvLyBPcHRpbWlzbSBTZXBvbGlhXG4gIFwiZWlwMTU1OjEzN1wiLFxuICAvLyBQb2x5Z29uXG4gIFwiZWlwMTU1OjExMTU1MTExXCIsXG4gIC8vIEV0aGVyZXVtIFNlcG9saWFcbiAgXCJlaXAxNTU6Nzc3Nzc3N1wiLFxuICAvLyBab3JhXG4gIFwiZWlwMTU1OjEzMFwiLFxuICAvLyBVbmljaGFpblxuICBcImVpcDE1NToxMDE0M1wiLFxuICAvLyBNb25hZCB0ZXN0bmV0XG4gIFwiZWlwMTU1OjQyMjIwXCIsXG4gIC8vIENlbG9cbiAgXCJzb2xhbmE6NWV5a3Q0VXNGdjhQOE5KZFRSRXBZMXZ6cUtxWkt2ZHBcIlxuICAvLyBTb2xhbmFcbl0sIEIwID0gcGUub2JqZWN0KHtcbiAgLy8gMC4wLjAgYW5kIDAuMC4xIGFyZSBub3QgdGVjaG5pY2FsbHkgcGFydCBvZiB0aGUgc3BlYyBidXQga2VwdCBmb3JcbiAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIG5leHQgc2hvdWxkIGFsd2F5cyByZXNvbHZlIHRvIHRoZSBtb3N0IHJlY2VudFxuICAvLyBzY2hlbWEgdmVyc2lvbi5cbiAgdmVyc2lvbjogcGUudW5pb24oW1xuICAgIHBlLmxpdGVyYWwoXCIwLjAuMFwiKSxcbiAgICBwZS5saXRlcmFsKFwiMC4wLjFcIiksXG4gICAgcGUubGl0ZXJhbChcIjFcIiksXG4gICAgcGUubGl0ZXJhbChcIm5leHRcIilcbiAgXSksXG4gIG5hbWU6IG5jLFxuICBpY29uVXJsOiBEdCxcbiAgaG9tZVVybDogRHQsXG4gIC8qKiBkZXByZWNhdGVkLCBzZXQgb2dJbWFnZVVybCBpbnN0ZWFkICovXG4gIGltYWdlVXJsOiBEdC5vcHRpb25hbCgpLFxuICAvKiogZGVwcmVjYXRlZCwgd2lsbCByZWx5IG9uIGZjOmZyYW1lIG1ldGEgdGFnICovXG4gIGJ1dHRvblRpdGxlOiBpYy5vcHRpb25hbCgpLFxuICBzcGxhc2hJbWFnZVVybDogRHQub3B0aW9uYWwoKSxcbiAgc3BsYXNoQmFja2dyb3VuZENvbG9yOiBzYy5vcHRpb25hbCgpLFxuICB3ZWJob29rVXJsOiBEdC5vcHRpb25hbCgpLFxuICAvKiogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFyY2FzdGVyeHl6L21pbmlhcHBzL2Rpc2N1c3Npb25zLzE5MSAqL1xuICBzdWJ0aXRsZTogdm4oeyBtYXg6IDMwIH0pLm9wdGlvbmFsKCksXG4gIGRlc2NyaXB0aW9uOiB2bih7IG1heDogMTcwIH0pLm9wdGlvbmFsKCksXG4gIHNjcmVlbnNob3RVcmxzOiBwZS5hcnJheShEdCkubWF4KDMpLm9wdGlvbmFsKCksXG4gIHByaW1hcnlDYXRlZ29yeTogSTAub3B0aW9uYWwoKSxcbiAgdGFnczogcGUuYXJyYXkodm4oeyBtYXg6IDIwLCBub1NwYWNlczogITAgfSkpLm1heCg1KS5vcHRpb25hbCgpLFxuICBoZXJvSW1hZ2VVcmw6IER0Lm9wdGlvbmFsKCksXG4gIHRhZ2xpbmU6IHZuKHsgbWF4OiAzMCB9KS5vcHRpb25hbCgpLFxuICBvZ1RpdGxlOiB2bih7IG1heDogMzAgfSkub3B0aW9uYWwoKSxcbiAgb2dEZXNjcmlwdGlvbjogdm4oeyBtYXg6IDEwMCB9KS5vcHRpb25hbCgpLFxuICBvZ0ltYWdlVXJsOiBEdC5vcHRpb25hbCgpLFxuICAvKiogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFyY2FzdGVyeHl6L21pbmlhcHBzL2Rpc2N1c3Npb25zLzIwNCAqL1xuICBub2luZGV4OiBwZS5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgLyoqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFyY2FzdGVyeHl6L21pbmlhcHBzL2Rpc2N1c3Npb25zLzI1NiAqL1xuICByZXF1aXJlZENoYWluczogcGUuYXJyYXkocGUuZW51bShSYSkpLm1heChSYS5sZW5ndGgpLm9wdGlvbmFsKCksXG4gIHJlcXVpcmVkQ2FwYWJpbGl0aWVzOiBwZS5hcnJheShwZS5lbnVtKEFhKSkubWF4KEFhLmxlbmd0aCkub3B0aW9uYWwoKSxcbiAgLyoqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFyY2FzdGVyeHl6L21pbmlhcHBzL2Rpc2N1c3Npb25zLzE1OCAqL1xuICAvKiogRG9jdW1lbnRhdGlvbiB3aWxsIGJlIGFkZGVkIG9uY2UgdGhpcyBmZWF0dXJlIGlzIGZpbmFsaXplZC4gKi9cbiAgY2FzdFNoYXJlVXJsOiBEdC5vcHRpb25hbCgpXG59KS5yZWZpbmUoKHQpID0+IHtcbiAgaWYgKHQuY2FzdFNoYXJlVXJsID09PSB2b2lkIDApXG4gICAgcmV0dXJuICEwO1xuICB0cnkge1xuICAgIGNvbnN0IGUgPSBuZXcgVVJMKHQuaG9tZVVybCkuaG9zdG5hbWUsIHIgPSBuZXcgVVJMKHQuY2FzdFNoYXJlVXJsKS5ob3N0bmFtZTtcbiAgICByZXR1cm4gZSA9PT0gcjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59LCB7XG4gIG1lc3NhZ2U6IFwiY2FzdFNoYXJlVXJsIG11c3QgaGF2ZSB0aGUgc2FtZSBkb21haW4gYXMgaG9tZVVybFwiLFxuICBwYXRoOiBbXCJjYXN0U2hhcmVVcmxcIl1cbn0pO1xucGUub2JqZWN0KHtcbiAgYWNjb3VudEFzc29jaWF0aW9uOiB4MCxcbiAgZnJhbWU6IEIwLm9wdGlvbmFsKClcbn0pO1xudmFyIEtzID0ge30sIGVpID0ge30sIFRhO1xuZnVuY3Rpb24gUjAoKSB7XG4gIGlmIChUYSkgcmV0dXJuIGVpO1xuICBUYSA9IDEsIGVpLmJ5dGVMZW5ndGggPSBmLCBlaS50b0J5dGVBcnJheSA9IHgsIGVpLmZyb21CeXRlQXJyYXkgPSBUO1xuICBmb3IgKHZhciB0ID0gW10sIGUgPSBbXSwgciA9IHR5cGVvZiBVaW50OEFycmF5IDwgXCJ1XCIgPyBVaW50OEFycmF5IDogQXJyYXksIG4gPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIiwgbyA9IDAsIGkgPSBuLmxlbmd0aDsgbyA8IGk7ICsrbylcbiAgICB0W29dID0gbltvXSwgZVtuLmNoYXJDb2RlQXQobyldID0gbztcbiAgZVs0NV0gPSA2MiwgZVs5NV0gPSA2MztcbiAgZnVuY3Rpb24gYyhDKSB7XG4gICAgdmFyIFAgPSBDLmxlbmd0aDtcbiAgICBpZiAoUCAlIDQgPiAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtcbiAgICB2YXIgQiA9IEMuaW5kZXhPZihcIj1cIik7XG4gICAgQiA9PT0gLTEgJiYgKEIgPSBQKTtcbiAgICB2YXIgUiA9IEIgPT09IFAgPyAwIDogNCAtIEIgJSA0O1xuICAgIHJldHVybiBbQiwgUl07XG4gIH1cbiAgZnVuY3Rpb24gZihDKSB7XG4gICAgdmFyIFAgPSBjKEMpLCBCID0gUFswXSwgUiA9IFBbMV07XG4gICAgcmV0dXJuIChCICsgUikgKiAzIC8gNCAtIFI7XG4gIH1cbiAgZnVuY3Rpb24gdihDLCBQLCBCKSB7XG4gICAgcmV0dXJuIChQICsgQikgKiAzIC8gNCAtIEI7XG4gIH1cbiAgZnVuY3Rpb24geChDKSB7XG4gICAgdmFyIFAsIEIgPSBjKEMpLCBSID0gQlswXSwgeiA9IEJbMV0sIEsgPSBuZXcgcih2KEMsIFIsIHopKSwgWiA9IDAsIFEgPSB6ID4gMCA/IFIgLSA0IDogUiwgajtcbiAgICBmb3IgKGogPSAwOyBqIDwgUTsgaiArPSA0KVxuICAgICAgUCA9IGVbQy5jaGFyQ29kZUF0KGopXSA8PCAxOCB8IGVbQy5jaGFyQ29kZUF0KGogKyAxKV0gPDwgMTIgfCBlW0MuY2hhckNvZGVBdChqICsgMildIDw8IDYgfCBlW0MuY2hhckNvZGVBdChqICsgMyldLCBLW1orK10gPSBQID4+IDE2ICYgMjU1LCBLW1orK10gPSBQID4+IDggJiAyNTUsIEtbWisrXSA9IFAgJiAyNTU7XG4gICAgcmV0dXJuIHogPT09IDIgJiYgKFAgPSBlW0MuY2hhckNvZGVBdChqKV0gPDwgMiB8IGVbQy5jaGFyQ29kZUF0KGogKyAxKV0gPj4gNCwgS1taKytdID0gUCAmIDI1NSksIHogPT09IDEgJiYgKFAgPSBlW0MuY2hhckNvZGVBdChqKV0gPDwgMTAgfCBlW0MuY2hhckNvZGVBdChqICsgMSldIDw8IDQgfCBlW0MuY2hhckNvZGVBdChqICsgMildID4+IDIsIEtbWisrXSA9IFAgPj4gOCAmIDI1NSwgS1taKytdID0gUCAmIDI1NSksIEs7XG4gIH1cbiAgZnVuY3Rpb24gYihDKSB7XG4gICAgcmV0dXJuIHRbQyA+PiAxOCAmIDYzXSArIHRbQyA+PiAxMiAmIDYzXSArIHRbQyA+PiA2ICYgNjNdICsgdFtDICYgNjNdO1xuICB9XG4gIGZ1bmN0aW9uIFMoQywgUCwgQikge1xuICAgIGZvciAodmFyIFIsIHogPSBbXSwgSyA9IFA7IEsgPCBCOyBLICs9IDMpXG4gICAgICBSID0gKENbS10gPDwgMTYgJiAxNjcxMTY4MCkgKyAoQ1tLICsgMV0gPDwgOCAmIDY1MjgwKSArIChDW0sgKyAyXSAmIDI1NSksIHoucHVzaChiKFIpKTtcbiAgICByZXR1cm4gei5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIFQoQykge1xuICAgIGZvciAodmFyIFAsIEIgPSBDLmxlbmd0aCwgUiA9IEIgJSAzLCB6ID0gW10sIEsgPSAxNjM4MywgWiA9IDAsIFEgPSBCIC0gUjsgWiA8IFE7IFogKz0gSylcbiAgICAgIHoucHVzaChTKEMsIFosIFogKyBLID4gUSA/IFEgOiBaICsgSykpO1xuICAgIHJldHVybiBSID09PSAxID8gKFAgPSBDW0IgLSAxXSwgei5wdXNoKFxuICAgICAgdFtQID4+IDJdICsgdFtQIDw8IDQgJiA2M10gKyBcIj09XCJcbiAgICApKSA6IFIgPT09IDIgJiYgKFAgPSAoQ1tCIC0gMl0gPDwgOCkgKyBDW0IgLSAxXSwgei5wdXNoKFxuICAgICAgdFtQID4+IDEwXSArIHRbUCA+PiA0ICYgNjNdICsgdFtQIDw8IDIgJiA2M10gKyBcIj1cIlxuICAgICkpLCB6LmpvaW4oXCJcIik7XG4gIH1cbiAgcmV0dXJuIGVpO1xufVxudmFyIHFpID0ge307XG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xudmFyIExhO1xuZnVuY3Rpb24gVDAoKSB7XG4gIHJldHVybiBMYSB8fCAoTGEgPSAxLCBxaS5yZWFkID0gZnVuY3Rpb24odCwgZSwgciwgbiwgbykge1xuICAgIHZhciBpLCBjLCBmID0gbyAqIDggLSBuIC0gMSwgdiA9ICgxIDw8IGYpIC0gMSwgeCA9IHYgPj4gMSwgYiA9IC03LCBTID0gciA/IG8gLSAxIDogMCwgVCA9IHIgPyAtMSA6IDEsIEMgPSB0W2UgKyBTXTtcbiAgICBmb3IgKFMgKz0gVCwgaSA9IEMgJiAoMSA8PCAtYikgLSAxLCBDID4+PSAtYiwgYiArPSBmOyBiID4gMDsgaSA9IGkgKiAyNTYgKyB0W2UgKyBTXSwgUyArPSBULCBiIC09IDgpXG4gICAgICA7XG4gICAgZm9yIChjID0gaSAmICgxIDw8IC1iKSAtIDEsIGkgPj49IC1iLCBiICs9IG47IGIgPiAwOyBjID0gYyAqIDI1NiArIHRbZSArIFNdLCBTICs9IFQsIGIgLT0gOClcbiAgICAgIDtcbiAgICBpZiAoaSA9PT0gMClcbiAgICAgIGkgPSAxIC0geDtcbiAgICBlbHNlIHtcbiAgICAgIGlmIChpID09PSB2KVxuICAgICAgICByZXR1cm4gYyA/IE5hTiA6IChDID8gLTEgOiAxKSAqICgxIC8gMCk7XG4gICAgICBjID0gYyArIE1hdGgucG93KDIsIG4pLCBpID0gaSAtIHg7XG4gICAgfVxuICAgIHJldHVybiAoQyA/IC0xIDogMSkgKiBjICogTWF0aC5wb3coMiwgaSAtIG4pO1xuICB9LCBxaS53cml0ZSA9IGZ1bmN0aW9uKHQsIGUsIHIsIG4sIG8sIGkpIHtcbiAgICB2YXIgYywgZiwgdiwgeCA9IGkgKiA4IC0gbyAtIDEsIGIgPSAoMSA8PCB4KSAtIDEsIFMgPSBiID4+IDEsIFQgPSBvID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCwgQyA9IG4gPyAwIDogaSAtIDEsIFAgPSBuID8gMSA6IC0xLCBCID0gZSA8IDAgfHwgZSA9PT0gMCAmJiAxIC8gZSA8IDAgPyAxIDogMDtcbiAgICBmb3IgKGUgPSBNYXRoLmFicyhlKSwgaXNOYU4oZSkgfHwgZSA9PT0gMSAvIDAgPyAoZiA9IGlzTmFOKGUpID8gMSA6IDAsIGMgPSBiKSA6IChjID0gTWF0aC5mbG9vcihNYXRoLmxvZyhlKSAvIE1hdGguTE4yKSwgZSAqICh2ID0gTWF0aC5wb3coMiwgLWMpKSA8IDEgJiYgKGMtLSwgdiAqPSAyKSwgYyArIFMgPj0gMSA/IGUgKz0gVCAvIHYgOiBlICs9IFQgKiBNYXRoLnBvdygyLCAxIC0gUyksIGUgKiB2ID49IDIgJiYgKGMrKywgdiAvPSAyKSwgYyArIFMgPj0gYiA/IChmID0gMCwgYyA9IGIpIDogYyArIFMgPj0gMSA/IChmID0gKGUgKiB2IC0gMSkgKiBNYXRoLnBvdygyLCBvKSwgYyA9IGMgKyBTKSA6IChmID0gZSAqIE1hdGgucG93KDIsIFMgLSAxKSAqIE1hdGgucG93KDIsIG8pLCBjID0gMCkpOyBvID49IDg7IHRbciArIENdID0gZiAmIDI1NSwgQyArPSBQLCBmIC89IDI1NiwgbyAtPSA4KVxuICAgICAgO1xuICAgIGZvciAoYyA9IGMgPDwgbyB8IGYsIHggKz0gbzsgeCA+IDA7IHRbciArIENdID0gYyAmIDI1NSwgQyArPSBQLCBjIC89IDI1NiwgeCAtPSA4KVxuICAgICAgO1xuICAgIHRbciArIEMgLSBQXSB8PSBCICogMTI4O1xuICB9KSwgcWk7XG59XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbnZhciBPYTtcbmZ1bmN0aW9uIG5hKCkge1xuICByZXR1cm4gT2EgfHwgKE9hID0gMSwgZnVuY3Rpb24odCkge1xuICAgIGNvbnN0IGUgPSBSMCgpLCByID0gVDAoKSwgbiA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuZm9yID09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKSA6IG51bGw7XG4gICAgdC5CdWZmZXIgPSBmLCB0LlNsb3dCdWZmZXIgPSBLLCB0LklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG4gICAgY29uc3QgbyA9IDIxNDc0ODM2NDc7XG4gICAgdC5rTWF4TGVuZ3RoID0gbywgZi5UWVBFRF9BUlJBWV9TVVBQT1JUID0gaSgpLCAhZi5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlIDwgXCJ1XCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT0gXCJmdW5jdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiXG4gICAgKTtcbiAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgRSA9IG5ldyBVaW50OEFycmF5KDEpLCBtID0geyBmb286IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiA0MjtcbiAgICAgICAgfSB9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKG0sIFVpbnQ4QXJyYXkucHJvdG90eXBlKSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKEUsIG0pLCBFLmZvbygpID09PSA0MjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZi5pc0J1ZmZlcih0aGlzKSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgICB9XG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZi5pc0J1ZmZlcih0aGlzKSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGMoRSkge1xuICAgICAgaWYgKEUgPiBvKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIEUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyk7XG4gICAgICBjb25zdCBtID0gbmV3IFVpbnQ4QXJyYXkoRSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKG0sIGYucHJvdG90eXBlKSwgbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZihFLCBtLCB5KSB7XG4gICAgICBpZiAodHlwZW9mIEUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAodHlwZW9mIG0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBTKEUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHYoRSwgbSwgeSk7XG4gICAgfVxuICAgIGYucG9vbFNpemUgPSA4MTkyO1xuICAgIGZ1bmN0aW9uIHYoRSwgbSwgeSkge1xuICAgICAgaWYgKHR5cGVvZiBFID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBUKEUsIG0pO1xuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhFKSlcbiAgICAgICAgcmV0dXJuIFAoRSk7XG4gICAgICBpZiAoRSA9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIgKyB0eXBlb2YgRVxuICAgICAgICApO1xuICAgICAgaWYgKHh0KEUsIEFycmF5QnVmZmVyKSB8fCBFICYmIHh0KEUuYnVmZmVyLCBBcnJheUJ1ZmZlcikgfHwgdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIDwgXCJ1XCIgJiYgKHh0KEUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fCBFICYmIHh0KEUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKVxuICAgICAgICByZXR1cm4gQihFLCBtLCB5KTtcbiAgICAgIGlmICh0eXBlb2YgRSA9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgICAgKTtcbiAgICAgIGNvbnN0IEkgPSBFLnZhbHVlT2YgJiYgRS52YWx1ZU9mKCk7XG4gICAgICBpZiAoSSAhPSBudWxsICYmIEkgIT09IEUpXG4gICAgICAgIHJldHVybiBmLmZyb20oSSwgbSwgeSk7XG4gICAgICBjb25zdCBxID0gUihFKTtcbiAgICAgIGlmIChxKSByZXR1cm4gcTtcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiYgdHlwZW9mIEVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBmLmZyb20oRVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLCBtLCB5KTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIgKyB0eXBlb2YgRVxuICAgICAgKTtcbiAgICB9XG4gICAgZi5mcm9tID0gZnVuY3Rpb24oRSwgbSwgeSkge1xuICAgICAgcmV0dXJuIHYoRSwgbSwgeSk7XG4gICAgfSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKGYucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSksIE9iamVjdC5zZXRQcm90b3R5cGVPZihmLCBVaW50OEFycmF5KTtcbiAgICBmdW5jdGlvbiB4KEUpIHtcbiAgICAgIGlmICh0eXBlb2YgRSAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7XG4gICAgICBpZiAoRSA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgRSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYihFLCBtLCB5KSB7XG4gICAgICByZXR1cm4geChFKSwgRSA8PSAwID8gYyhFKSA6IG0gIT09IHZvaWQgMCA/IHR5cGVvZiB5ID09IFwic3RyaW5nXCIgPyBjKEUpLmZpbGwobSwgeSkgOiBjKEUpLmZpbGwobSkgOiBjKEUpO1xuICAgIH1cbiAgICBmLmFsbG9jID0gZnVuY3Rpb24oRSwgbSwgeSkge1xuICAgICAgcmV0dXJuIGIoRSwgbSwgeSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBTKEUpIHtcbiAgICAgIHJldHVybiB4KEUpLCBjKEUgPCAwID8gMCA6IHooRSkgfCAwKTtcbiAgICB9XG4gICAgZi5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uKEUpIHtcbiAgICAgIHJldHVybiBTKEUpO1xuICAgIH0sIGYuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24oRSkge1xuICAgICAgcmV0dXJuIFMoRSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBUKEUsIG0pIHtcbiAgICAgIGlmICgodHlwZW9mIG0gIT0gXCJzdHJpbmdcIiB8fCBtID09PSBcIlwiKSAmJiAobSA9IFwidXRmOFwiKSwgIWYuaXNFbmNvZGluZyhtKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgbSk7XG4gICAgICBjb25zdCB5ID0gWihFLCBtKSB8IDA7XG4gICAgICBsZXQgSSA9IGMoeSk7XG4gICAgICBjb25zdCBxID0gSS53cml0ZShFLCBtKTtcbiAgICAgIHJldHVybiBxICE9PSB5ICYmIChJID0gSS5zbGljZSgwLCBxKSksIEk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEMoRSkge1xuICAgICAgY29uc3QgbSA9IEUubGVuZ3RoIDwgMCA/IDAgOiB6KEUubGVuZ3RoKSB8IDAsIHkgPSBjKG0pO1xuICAgICAgZm9yIChsZXQgSSA9IDA7IEkgPCBtOyBJICs9IDEpXG4gICAgICAgIHlbSV0gPSBFW0ldICYgMjU1O1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFAoRSkge1xuICAgICAgaWYgKHh0KEUsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIGNvbnN0IG0gPSBuZXcgVWludDhBcnJheShFKTtcbiAgICAgICAgcmV0dXJuIEIobS5idWZmZXIsIG0uYnl0ZU9mZnNldCwgbS5ieXRlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDKEUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCKEUsIG0sIHkpIHtcbiAgICAgIGlmIChtIDwgMCB8fCBFLmJ5dGVMZW5ndGggPCBtKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTtcbiAgICAgIGlmIChFLmJ5dGVMZW5ndGggPCBtICsgKHkgfHwgMCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpO1xuICAgICAgbGV0IEk7XG4gICAgICByZXR1cm4gbSA9PT0gdm9pZCAwICYmIHkgPT09IHZvaWQgMCA/IEkgPSBuZXcgVWludDhBcnJheShFKSA6IHkgPT09IHZvaWQgMCA/IEkgPSBuZXcgVWludDhBcnJheShFLCBtKSA6IEkgPSBuZXcgVWludDhBcnJheShFLCBtLCB5KSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKEksIGYucHJvdG90eXBlKSwgSTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUihFKSB7XG4gICAgICBpZiAoZi5pc0J1ZmZlcihFKSkge1xuICAgICAgICBjb25zdCBtID0geihFLmxlbmd0aCkgfCAwLCB5ID0gYyhtKTtcbiAgICAgICAgcmV0dXJuIHkubGVuZ3RoID09PSAwIHx8IEUuY29weSh5LCAwLCAwLCBtKSwgeTtcbiAgICAgIH1cbiAgICAgIGlmIChFLmxlbmd0aCAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gdHlwZW9mIEUubGVuZ3RoICE9IFwibnVtYmVyXCIgfHwgU2UoRS5sZW5ndGgpID8gYygwKSA6IEMoRSk7XG4gICAgICBpZiAoRS50eXBlID09PSBcIkJ1ZmZlclwiICYmIEFycmF5LmlzQXJyYXkoRS5kYXRhKSlcbiAgICAgICAgcmV0dXJuIEMoRS5kYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24geihFKSB7XG4gICAgICBpZiAoRSA+PSBvKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIiArIG8udG9TdHJpbmcoMTYpICsgXCIgYnl0ZXNcIik7XG4gICAgICByZXR1cm4gRSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEsoRSkge1xuICAgICAgcmV0dXJuICtFICE9IEUgJiYgKEUgPSAwKSwgZi5hbGxvYygrRSk7XG4gICAgfVxuICAgIGYuaXNCdWZmZXIgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gbSAhPSBudWxsICYmIG0uX2lzQnVmZmVyID09PSAhMCAmJiBtICE9PSBmLnByb3RvdHlwZTtcbiAgICB9LCBmLmNvbXBhcmUgPSBmdW5jdGlvbihtLCB5KSB7XG4gICAgICBpZiAoeHQobSwgVWludDhBcnJheSkgJiYgKG0gPSBmLmZyb20obSwgbS5vZmZzZXQsIG0uYnl0ZUxlbmd0aCkpLCB4dCh5LCBVaW50OEFycmF5KSAmJiAoeSA9IGYuZnJvbSh5LCB5Lm9mZnNldCwgeS5ieXRlTGVuZ3RoKSksICFmLmlzQnVmZmVyKG0pIHx8ICFmLmlzQnVmZmVyKHkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgICAgICApO1xuICAgICAgaWYgKG0gPT09IHkpIHJldHVybiAwO1xuICAgICAgbGV0IEkgPSBtLmxlbmd0aCwgcSA9IHkubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgSCA9IDAsIFcgPSBNYXRoLm1pbihJLCBxKTsgSCA8IFc7ICsrSClcbiAgICAgICAgaWYgKG1bSF0gIT09IHlbSF0pIHtcbiAgICAgICAgICBJID0gbVtIXSwgcSA9IHlbSF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBJIDwgcSA/IC0xIDogcSA8IEkgPyAxIDogMDtcbiAgICB9LCBmLmlzRW5jb2RpbmcgPSBmdW5jdGlvbihtKSB7XG4gICAgICBzd2l0Y2ggKFN0cmluZyhtKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LCBmLmNvbmNhdCA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgICBpZiAobS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBmLmFsbG9jKDApO1xuICAgICAgbGV0IEk7XG4gICAgICBpZiAoeSA9PT0gdm9pZCAwKVxuICAgICAgICBmb3IgKHkgPSAwLCBJID0gMDsgSSA8IG0ubGVuZ3RoOyArK0kpXG4gICAgICAgICAgeSArPSBtW0ldLmxlbmd0aDtcbiAgICAgIGNvbnN0IHEgPSBmLmFsbG9jVW5zYWZlKHkpO1xuICAgICAgbGV0IEggPSAwO1xuICAgICAgZm9yIChJID0gMDsgSSA8IG0ubGVuZ3RoOyArK0kpIHtcbiAgICAgICAgbGV0IFcgPSBtW0ldO1xuICAgICAgICBpZiAoeHQoVywgVWludDhBcnJheSkpXG4gICAgICAgICAgSCArIFcubGVuZ3RoID4gcS5sZW5ndGggPyAoZi5pc0J1ZmZlcihXKSB8fCAoVyA9IGYuZnJvbShXKSksIFcuY29weShxLCBIKSkgOiBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICAgIHEsXG4gICAgICAgICAgICBXLFxuICAgICAgICAgICAgSFxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgaWYgKGYuaXNCdWZmZXIoVykpXG4gICAgICAgICAgVy5jb3B5KHEsIEgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgICAgIEggKz0gVy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFooRSwgbSkge1xuICAgICAgaWYgKGYuaXNCdWZmZXIoRSkpXG4gICAgICAgIHJldHVybiBFLmxlbmd0aDtcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoRSkgfHwgeHQoRSwgQXJyYXlCdWZmZXIpKVxuICAgICAgICByZXR1cm4gRS5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKHR5cGVvZiBFICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgRVxuICAgICAgICApO1xuICAgICAgY29uc3QgeSA9IEUubGVuZ3RoLCBJID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSAhMDtcbiAgICAgIGlmICghSSAmJiB5ID09PSAwKSByZXR1cm4gMDtcbiAgICAgIGxldCBxID0gITE7XG4gICAgICBmb3IgKDsgOyApXG4gICAgICAgIHN3aXRjaCAobSkge1xuICAgICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICAgIGNhc2UgXCJsYXRpbjFcIjpcbiAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgICAgcmV0dXJuIHdlKEUpLmxlbmd0aDtcbiAgICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICByZXR1cm4geSAqIDI7XG4gICAgICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICAgICAgcmV0dXJuIHkgPj4+IDE7XG4gICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgcmV0dXJuIHllKEUpLmxlbmd0aDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHEpXG4gICAgICAgICAgICAgIHJldHVybiBJID8gLTEgOiB3ZShFKS5sZW5ndGg7XG4gICAgICAgICAgICBtID0gKFwiXCIgKyBtKS50b0xvd2VyQ2FzZSgpLCBxID0gITA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZi5ieXRlTGVuZ3RoID0gWjtcbiAgICBmdW5jdGlvbiBRKEUsIG0sIHkpIHtcbiAgICAgIGxldCBJID0gITE7XG4gICAgICBpZiAoKG0gPT09IHZvaWQgMCB8fCBtIDwgMCkgJiYgKG0gPSAwKSwgbSA+IHRoaXMubGVuZ3RoIHx8ICgoeSA9PT0gdm9pZCAwIHx8IHkgPiB0aGlzLmxlbmd0aCkgJiYgKHkgPSB0aGlzLmxlbmd0aCksIHkgPD0gMCkgfHwgKHkgPj4+PSAwLCBtID4+Pj0gMCwgeSA8PSBtKSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBmb3IgKEUgfHwgKEUgPSBcInV0ZjhcIik7IDsgKVxuICAgICAgICBzd2l0Y2ggKEUpIHtcbiAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICByZXR1cm4gXyh0aGlzLCBtLCB5KTtcbiAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgICAgcmV0dXJuIHModGhpcywgbSwgeSk7XG4gICAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgICByZXR1cm4gZyh0aGlzLCBtLCB5KTtcbiAgICAgICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgcmV0dXJuIHcodGhpcywgbSwgeSk7XG4gICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgcmV0dXJuIGQodGhpcywgbSwgeSk7XG4gICAgICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIEEodGhpcywgbSwgeSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChJKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIgKyBFKTtcbiAgICAgICAgICAgIEUgPSAoRSArIFwiXCIpLnRvTG93ZXJDYXNlKCksIEkgPSAhMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmLnByb3RvdHlwZS5faXNCdWZmZXIgPSAhMDtcbiAgICBmdW5jdGlvbiBqKEUsIG0sIHkpIHtcbiAgICAgIGNvbnN0IEkgPSBFW21dO1xuICAgICAgRVttXSA9IEVbeV0sIEVbeV0gPSBJO1xuICAgIH1cbiAgICBmLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLmxlbmd0aDtcbiAgICAgIGlmIChtICUgMiAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgbTsgeSArPSAyKVxuICAgICAgICBqKHRoaXMsIHksIHkgKyAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGYucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbSA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKG0gJSA0ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBtOyB5ICs9IDQpXG4gICAgICAgIGoodGhpcywgeSwgeSArIDMpLCBqKHRoaXMsIHkgKyAxLCB5ICsgMik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLmxlbmd0aDtcbiAgICAgIGlmIChtICUgOCAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgbTsgeSArPSA4KVxuICAgICAgICBqKHRoaXMsIHksIHkgKyA3KSwgaih0aGlzLCB5ICsgMSwgeSArIDYpLCBqKHRoaXMsIHkgKyAyLCB5ICsgNSksIGoodGhpcywgeSArIDMsIHkgKyA0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtID0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gbSA9PT0gMCA/IFwiXCIgOiBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gcyh0aGlzLCAwLCBtKSA6IFEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCBmLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IGYucHJvdG90eXBlLnRvU3RyaW5nLCBmLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihtKSB7XG4gICAgICBpZiAoIWYuaXNCdWZmZXIobSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICAgICAgcmV0dXJuIHRoaXMgPT09IG0gPyAhMCA6IGYuY29tcGFyZSh0aGlzLCBtKSA9PT0gMDtcbiAgICB9LCBmLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbSA9IFwiXCI7XG4gICAgICBjb25zdCB5ID0gdC5JTlNQRUNUX01BWF9CWVRFUztcbiAgICAgIHJldHVybiBtID0gdGhpcy50b1N0cmluZyhcImhleFwiLCAwLCB5KS5yZXBsYWNlKC8oLnsyfSkvZywgXCIkMSBcIikudHJpbSgpLCB0aGlzLmxlbmd0aCA+IHkgJiYgKG0gKz0gXCIgLi4uIFwiKSwgXCI8QnVmZmVyIFwiICsgbSArIFwiPlwiO1xuICAgIH0sIG4gJiYgKGYucHJvdG90eXBlW25dID0gZi5wcm90b3R5cGUuaW5zcGVjdCksIGYucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihtLCB5LCBJLCBxLCBIKSB7XG4gICAgICBpZiAoeHQobSwgVWludDhBcnJheSkgJiYgKG0gPSBmLmZyb20obSwgbS5vZmZzZXQsIG0uYnl0ZUxlbmd0aCkpLCAhZi5pc0J1ZmZlcihtKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIG1cbiAgICAgICAgKTtcbiAgICAgIGlmICh5ID09PSB2b2lkIDAgJiYgKHkgPSAwKSwgSSA9PT0gdm9pZCAwICYmIChJID0gbSA/IG0ubGVuZ3RoIDogMCksIHEgPT09IHZvaWQgMCAmJiAocSA9IDApLCBIID09PSB2b2lkIDAgJiYgKEggPSB0aGlzLmxlbmd0aCksIHkgPCAwIHx8IEkgPiBtLmxlbmd0aCB8fCBxIDwgMCB8fCBIID4gdGhpcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpO1xuICAgICAgaWYgKHEgPj0gSCAmJiB5ID49IEkpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgaWYgKHEgPj0gSClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHkgPj0gSSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeSA+Pj49IDAsIEkgPj4+PSAwLCBxID4+Pj0gMCwgSCA+Pj49IDAsIHRoaXMgPT09IG0pIHJldHVybiAwO1xuICAgICAgbGV0IFcgPSBIIC0gcSwgQmUgPSBJIC0geTtcbiAgICAgIGNvbnN0IG1lID0gTWF0aC5taW4oVywgQmUpLCBkZSA9IHRoaXMuc2xpY2UocSwgSCksIG90ID0gbS5zbGljZSh5LCBJKTtcbiAgICAgIGZvciAobGV0IGNlID0gMDsgY2UgPCBtZTsgKytjZSlcbiAgICAgICAgaWYgKGRlW2NlXSAhPT0gb3RbY2VdKSB7XG4gICAgICAgICAgVyA9IGRlW2NlXSwgQmUgPSBvdFtjZV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBXIDwgQmUgPyAtMSA6IEJlIDwgVyA/IDEgOiAwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gVihFLCBtLCB5LCBJLCBxKSB7XG4gICAgICBpZiAoRS5sZW5ndGggPT09IDApIHJldHVybiAtMTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PSBcInN0cmluZ1wiID8gKEkgPSB5LCB5ID0gMCkgOiB5ID4gMjE0NzQ4MzY0NyA/IHkgPSAyMTQ3NDgzNjQ3IDogeSA8IC0yMTQ3NDgzNjQ4ICYmICh5ID0gLTIxNDc0ODM2NDgpLCB5ID0gK3ksIFNlKHkpICYmICh5ID0gcSA/IDAgOiBFLmxlbmd0aCAtIDEpLCB5IDwgMCAmJiAoeSA9IEUubGVuZ3RoICsgeSksIHkgPj0gRS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHEpIHJldHVybiAtMTtcbiAgICAgICAgeSA9IEUubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeSA8IDApXG4gICAgICAgIGlmIChxKSB5ID0gMDtcbiAgICAgICAgZWxzZSByZXR1cm4gLTE7XG4gICAgICBpZiAodHlwZW9mIG0gPT0gXCJzdHJpbmdcIiAmJiAobSA9IGYuZnJvbShtLCBJKSksIGYuaXNCdWZmZXIobSkpXG4gICAgICAgIHJldHVybiBtLmxlbmd0aCA9PT0gMCA/IC0xIDogZWUoRSwgbSwgeSwgSSwgcSk7XG4gICAgICBpZiAodHlwZW9mIG0gPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIG0gPSBtICYgMjU1LCB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PSBcImZ1bmN0aW9uXCIgPyBxID8gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKEUsIG0sIHkpIDogVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChFLCBtLCB5KSA6IGVlKEUsIFttXSwgeSwgSSwgcSk7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlZShFLCBtLCB5LCBJLCBxKSB7XG4gICAgICBsZXQgSCA9IDEsIFcgPSBFLmxlbmd0aCwgQmUgPSBtLmxlbmd0aDtcbiAgICAgIGlmIChJICE9PSB2b2lkIDAgJiYgKEkgPSBTdHJpbmcoSSkudG9Mb3dlckNhc2UoKSwgSSA9PT0gXCJ1Y3MyXCIgfHwgSSA9PT0gXCJ1Y3MtMlwiIHx8IEkgPT09IFwidXRmMTZsZVwiIHx8IEkgPT09IFwidXRmLTE2bGVcIikpIHtcbiAgICAgICAgaWYgKEUubGVuZ3RoIDwgMiB8fCBtLmxlbmd0aCA8IDIpXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBIID0gMiwgVyAvPSAyLCBCZSAvPSAyLCB5IC89IDI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtZShvdCwgY2UpIHtcbiAgICAgICAgcmV0dXJuIEggPT09IDEgPyBvdFtjZV0gOiBvdC5yZWFkVUludDE2QkUoY2UgKiBIKTtcbiAgICAgIH1cbiAgICAgIGxldCBkZTtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIGxldCBvdCA9IC0xO1xuICAgICAgICBmb3IgKGRlID0geTsgZGUgPCBXOyBkZSsrKVxuICAgICAgICAgIGlmIChtZShFLCBkZSkgPT09IG1lKG0sIG90ID09PSAtMSA/IDAgOiBkZSAtIG90KSkge1xuICAgICAgICAgICAgaWYgKG90ID09PSAtMSAmJiAob3QgPSBkZSksIGRlIC0gb3QgKyAxID09PSBCZSkgcmV0dXJuIG90ICogSDtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIG90ICE9PSAtMSAmJiAoZGUgLT0gZGUgLSBvdCksIG90ID0gLTE7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yICh5ICsgQmUgPiBXICYmICh5ID0gVyAtIEJlKSwgZGUgPSB5OyBkZSA+PSAwOyBkZS0tKSB7XG4gICAgICAgICAgbGV0IG90ID0gITA7XG4gICAgICAgICAgZm9yIChsZXQgY2UgPSAwOyBjZSA8IEJlOyBjZSsrKVxuICAgICAgICAgICAgaWYgKG1lKEUsIGRlICsgY2UpICE9PSBtZShtLCBjZSkpIHtcbiAgICAgICAgICAgICAgb3QgPSAhMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG90KSByZXR1cm4gZGU7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZi5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbihtLCB5LCBJKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKG0sIHksIEkpICE9PSAtMTtcbiAgICB9LCBmLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24obSwgeSwgSSkge1xuICAgICAgcmV0dXJuIFYodGhpcywgbSwgeSwgSSwgITApO1xuICAgIH0sIGYucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24obSwgeSwgSSkge1xuICAgICAgcmV0dXJuIFYodGhpcywgbSwgeSwgSSwgITEpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gRyhFLCBtLCB5LCBJKSB7XG4gICAgICB5ID0gTnVtYmVyKHkpIHx8IDA7XG4gICAgICBjb25zdCBxID0gRS5sZW5ndGggLSB5O1xuICAgICAgSSA/IChJID0gTnVtYmVyKEkpLCBJID4gcSAmJiAoSSA9IHEpKSA6IEkgPSBxO1xuICAgICAgY29uc3QgSCA9IG0ubGVuZ3RoO1xuICAgICAgSSA+IEggLyAyICYmIChJID0gSCAvIDIpO1xuICAgICAgbGV0IFc7XG4gICAgICBmb3IgKFcgPSAwOyBXIDwgSTsgKytXKSB7XG4gICAgICAgIGNvbnN0IEJlID0gcGFyc2VJbnQobS5zdWJzdHIoVyAqIDIsIDIpLCAxNik7XG4gICAgICAgIGlmIChTZShCZSkpIHJldHVybiBXO1xuICAgICAgICBFW3kgKyBXXSA9IEJlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE4oRSwgbSwgeSwgSSkge1xuICAgICAgcmV0dXJuIGJlKHdlKG0sIEUubGVuZ3RoIC0geSksIEUsIHksIEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPKEUsIG0sIHksIEkpIHtcbiAgICAgIHJldHVybiBiZShNZShtKSwgRSwgeSwgSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEwoRSwgbSwgeSwgSSkge1xuICAgICAgcmV0dXJuIGJlKHllKG0pLCBFLCB5LCBJKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRihFLCBtLCB5LCBJKSB7XG4gICAgICByZXR1cm4gYmUoZnQobSwgRS5sZW5ndGggLSB5KSwgRSwgeSwgSSk7XG4gICAgfVxuICAgIGYucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24obSwgeSwgSSwgcSkge1xuICAgICAgaWYgKHkgPT09IHZvaWQgMClcbiAgICAgICAgcSA9IFwidXRmOFwiLCBJID0gdGhpcy5sZW5ndGgsIHkgPSAwO1xuICAgICAgZWxzZSBpZiAoSSA9PT0gdm9pZCAwICYmIHR5cGVvZiB5ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHEgPSB5LCBJID0gdGhpcy5sZW5ndGgsIHkgPSAwO1xuICAgICAgZWxzZSBpZiAoaXNGaW5pdGUoeSkpXG4gICAgICAgIHkgPSB5ID4+PiAwLCBpc0Zpbml0ZShJKSA/IChJID0gSSA+Pj4gMCwgcSA9PT0gdm9pZCAwICYmIChxID0gXCJ1dGY4XCIpKSA6IChxID0gSSwgSSA9IHZvaWQgMCk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCJcbiAgICAgICAgKTtcbiAgICAgIGNvbnN0IEggPSB0aGlzLmxlbmd0aCAtIHk7XG4gICAgICBpZiAoKEkgPT09IHZvaWQgMCB8fCBJID4gSCkgJiYgKEkgPSBIKSwgbS5sZW5ndGggPiAwICYmIChJIDwgMCB8fCB5IDwgMCkgfHwgeSA+IHRoaXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO1xuICAgICAgcSB8fCAocSA9IFwidXRmOFwiKTtcbiAgICAgIGxldCBXID0gITE7XG4gICAgICBmb3IgKDsgOyApXG4gICAgICAgIHN3aXRjaCAocSkge1xuICAgICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICAgIHJldHVybiBHKHRoaXMsIG0sIHksIEkpO1xuICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICByZXR1cm4gTih0aGlzLCBtLCB5LCBJKTtcbiAgICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgcmV0dXJuIE8odGhpcywgbSwgeSwgSSk7XG4gICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgcmV0dXJuIEwodGhpcywgbSwgeSwgSSk7XG4gICAgICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIEYodGhpcywgbSwgeSwgSSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChXKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIgKyBxKTtcbiAgICAgICAgICAgIHEgPSAoXCJcIiArIHEpLnRvTG93ZXJDYXNlKCksIFcgPSAhMDtcbiAgICAgICAgfVxuICAgIH0sIGYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJCdWZmZXJcIixcbiAgICAgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gZChFLCBtLCB5KSB7XG4gICAgICByZXR1cm4gbSA9PT0gMCAmJiB5ID09PSBFLmxlbmd0aCA/IGUuZnJvbUJ5dGVBcnJheShFKSA6IGUuZnJvbUJ5dGVBcnJheShFLnNsaWNlKG0sIHkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcyhFLCBtLCB5KSB7XG4gICAgICB5ID0gTWF0aC5taW4oRS5sZW5ndGgsIHkpO1xuICAgICAgY29uc3QgSSA9IFtdO1xuICAgICAgbGV0IHEgPSBtO1xuICAgICAgZm9yICg7IHEgPCB5OyApIHtcbiAgICAgICAgY29uc3QgSCA9IEVbcV07XG4gICAgICAgIGxldCBXID0gbnVsbCwgQmUgPSBIID4gMjM5ID8gNCA6IEggPiAyMjMgPyAzIDogSCA+IDE5MSA/IDIgOiAxO1xuICAgICAgICBpZiAocSArIEJlIDw9IHkpIHtcbiAgICAgICAgICBsZXQgbWUsIGRlLCBvdCwgY2U7XG4gICAgICAgICAgc3dpdGNoIChCZSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBIIDwgMTI4ICYmIChXID0gSCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBtZSA9IEVbcSArIDFdLCAobWUgJiAxOTIpID09PSAxMjggJiYgKGNlID0gKEggJiAzMSkgPDwgNiB8IG1lICYgNjMsIGNlID4gMTI3ICYmIChXID0gY2UpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG1lID0gRVtxICsgMV0sIGRlID0gRVtxICsgMl0sIChtZSAmIDE5MikgPT09IDEyOCAmJiAoZGUgJiAxOTIpID09PSAxMjggJiYgKGNlID0gKEggJiAxNSkgPDwgMTIgfCAobWUgJiA2MykgPDwgNiB8IGRlICYgNjMsIGNlID4gMjA0NyAmJiAoY2UgPCA1NTI5NiB8fCBjZSA+IDU3MzQzKSAmJiAoVyA9IGNlKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBtZSA9IEVbcSArIDFdLCBkZSA9IEVbcSArIDJdLCBvdCA9IEVbcSArIDNdLCAobWUgJiAxOTIpID09PSAxMjggJiYgKGRlICYgMTkyKSA9PT0gMTI4ICYmIChvdCAmIDE5MikgPT09IDEyOCAmJiAoY2UgPSAoSCAmIDE1KSA8PCAxOCB8IChtZSAmIDYzKSA8PCAxMiB8IChkZSAmIDYzKSA8PCA2IHwgb3QgJiA2MywgY2UgPiA2NTUzNSAmJiBjZSA8IDExMTQxMTIgJiYgKFcgPSBjZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBXID09PSBudWxsID8gKFcgPSA2NTUzMywgQmUgPSAxKSA6IFcgPiA2NTUzNSAmJiAoVyAtPSA2NTUzNiwgSS5wdXNoKFcgPj4+IDEwICYgMTAyMyB8IDU1Mjk2KSwgVyA9IDU2MzIwIHwgVyAmIDEwMjMpLCBJLnB1c2goVyksIHEgKz0gQmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaChJKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IDQwOTY7XG4gICAgZnVuY3Rpb24gaChFKSB7XG4gICAgICBjb25zdCBtID0gRS5sZW5ndGg7XG4gICAgICBpZiAobSA8PSB1KVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIEUpO1xuICAgICAgbGV0IHkgPSBcIlwiLCBJID0gMDtcbiAgICAgIGZvciAoOyBJIDwgbTsgKVxuICAgICAgICB5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICAgICAgU3RyaW5nLFxuICAgICAgICAgIEUuc2xpY2UoSSwgSSArPSB1KVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGcoRSwgbSwgeSkge1xuICAgICAgbGV0IEkgPSBcIlwiO1xuICAgICAgeSA9IE1hdGgubWluKEUubGVuZ3RoLCB5KTtcbiAgICAgIGZvciAobGV0IHEgPSBtOyBxIDwgeTsgKytxKVxuICAgICAgICBJICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoRVtxXSAmIDEyNyk7XG4gICAgICByZXR1cm4gSTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdyhFLCBtLCB5KSB7XG4gICAgICBsZXQgSSA9IFwiXCI7XG4gICAgICB5ID0gTWF0aC5taW4oRS5sZW5ndGgsIHkpO1xuICAgICAgZm9yIChsZXQgcSA9IG07IHEgPCB5OyArK3EpXG4gICAgICAgIEkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShFW3FdKTtcbiAgICAgIHJldHVybiBJO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKEUsIG0sIHkpIHtcbiAgICAgIGNvbnN0IEkgPSBFLmxlbmd0aDtcbiAgICAgICghbSB8fCBtIDwgMCkgJiYgKG0gPSAwKSwgKCF5IHx8IHkgPCAwIHx8IHkgPiBJKSAmJiAoeSA9IEkpO1xuICAgICAgbGV0IHEgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgSCA9IG07IEggPCB5OyArK0gpXG4gICAgICAgIHEgKz0ga2VbRVtIXV07XG4gICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQShFLCBtLCB5KSB7XG4gICAgICBjb25zdCBJID0gRS5zbGljZShtLCB5KTtcbiAgICAgIGxldCBxID0gXCJcIjtcbiAgICAgIGZvciAobGV0IEggPSAwOyBIIDwgSS5sZW5ndGggLSAxOyBIICs9IDIpXG4gICAgICAgIHEgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShJW0hdICsgSVtIICsgMV0gKiAyNTYpO1xuICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGYucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24obSwgeSkge1xuICAgICAgY29uc3QgSSA9IHRoaXMubGVuZ3RoO1xuICAgICAgbSA9IH5+bSwgeSA9IHkgPT09IHZvaWQgMCA/IEkgOiB+fnksIG0gPCAwID8gKG0gKz0gSSwgbSA8IDAgJiYgKG0gPSAwKSkgOiBtID4gSSAmJiAobSA9IEkpLCB5IDwgMCA/ICh5ICs9IEksIHkgPCAwICYmICh5ID0gMCkpIDogeSA+IEkgJiYgKHkgPSBJKSwgeSA8IG0gJiYgKHkgPSBtKTtcbiAgICAgIGNvbnN0IHEgPSB0aGlzLnN1YmFycmF5KG0sIHkpO1xuICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihxLCBmLnByb3RvdHlwZSksIHE7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwKEUsIG0sIHkpIHtcbiAgICAgIGlmIChFICUgMSAhPT0gMCB8fCBFIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7XG4gICAgICBpZiAoRSArIG0gPiB5KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7XG4gICAgfVxuICAgIGYucHJvdG90eXBlLnJlYWRVaW50TEUgPSBmLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24obSwgeSwgSSkge1xuICAgICAgbSA9IG0gPj4+IDAsIHkgPSB5ID4+PiAwLCBJIHx8IHAobSwgeSwgdGhpcy5sZW5ndGgpO1xuICAgICAgbGV0IHEgPSB0aGlzW21dLCBIID0gMSwgVyA9IDA7XG4gICAgICBmb3IgKDsgKytXIDwgeSAmJiAoSCAqPSAyNTYpOyApXG4gICAgICAgIHEgKz0gdGhpc1ttICsgV10gKiBIO1xuICAgICAgcmV0dXJuIHE7XG4gICAgfSwgZi5wcm90b3R5cGUucmVhZFVpbnRCRSA9IGYucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbihtLCB5LCBJKSB7XG4gICAgICBtID0gbSA+Pj4gMCwgeSA9IHkgPj4+IDAsIEkgfHwgcChtLCB5LCB0aGlzLmxlbmd0aCk7XG4gICAgICBsZXQgcSA9IHRoaXNbbSArIC0teV0sIEggPSAxO1xuICAgICAgZm9yICg7IHkgPiAwICYmIChIICo9IDI1Nik7IClcbiAgICAgICAgcSArPSB0aGlzW20gKyAtLXldICogSDtcbiAgICAgIHJldHVybiBxO1xuICAgIH0sIGYucHJvdG90eXBlLnJlYWRVaW50OCA9IGYucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIHJldHVybiBtID0gbSA+Pj4gMCwgeSB8fCBwKG0sIDEsIHRoaXMubGVuZ3RoKSwgdGhpc1ttXTtcbiAgICB9LCBmLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPSBmLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbihtLCB5KSB7XG4gICAgICByZXR1cm4gbSA9IG0gPj4+IDAsIHkgfHwgcChtLCAyLCB0aGlzLmxlbmd0aCksIHRoaXNbbV0gfCB0aGlzW20gKyAxXSA8PCA4O1xuICAgIH0sIGYucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9IGYucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIHJldHVybiBtID0gbSA+Pj4gMCwgeSB8fCBwKG0sIDIsIHRoaXMubGVuZ3RoKSwgdGhpc1ttXSA8PCA4IHwgdGhpc1ttICsgMV07XG4gICAgfSwgZi5wcm90b3R5cGUucmVhZFVpbnQzMkxFID0gZi5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24obSwgeSkge1xuICAgICAgcmV0dXJuIG0gPSBtID4+PiAwLCB5IHx8IHAobSwgNCwgdGhpcy5sZW5ndGgpLCAodGhpc1ttXSB8IHRoaXNbbSArIDFdIDw8IDggfCB0aGlzW20gKyAyXSA8PCAxNikgKyB0aGlzW20gKyAzXSAqIDE2Nzc3MjE2O1xuICAgIH0sIGYucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9IGYucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIHJldHVybiBtID0gbSA+Pj4gMCwgeSB8fCBwKG0sIDQsIHRoaXMubGVuZ3RoKSwgdGhpc1ttXSAqIDE2Nzc3MjE2ICsgKHRoaXNbbSArIDFdIDw8IDE2IHwgdGhpc1ttICsgMl0gPDwgOCB8IHRoaXNbbSArIDNdKTtcbiAgICB9LCBmLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBjdChmdW5jdGlvbihtKSB7XG4gICAgICBtID0gbSA+Pj4gMCwgWGUobSwgXCJvZmZzZXRcIik7XG4gICAgICBjb25zdCB5ID0gdGhpc1ttXSwgSSA9IHRoaXNbbSArIDddO1xuICAgICAgKHkgPT09IHZvaWQgMCB8fCBJID09PSB2b2lkIDApICYmIGFlKG0sIHRoaXMubGVuZ3RoIC0gOCk7XG4gICAgICBjb25zdCBxID0geSArIHRoaXNbKyttXSAqIDIgKiogOCArIHRoaXNbKyttXSAqIDIgKiogMTYgKyB0aGlzWysrbV0gKiAyICoqIDI0LCBIID0gdGhpc1srK21dICsgdGhpc1srK21dICogMiAqKiA4ICsgdGhpc1srK21dICogMiAqKiAxNiArIEkgKiAyICoqIDI0O1xuICAgICAgcmV0dXJuIEJpZ0ludChxKSArIChCaWdJbnQoSCkgPDwgQmlnSW50KDMyKSk7XG4gICAgfSksIGYucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGN0KGZ1bmN0aW9uKG0pIHtcbiAgICAgIG0gPSBtID4+PiAwLCBYZShtLCBcIm9mZnNldFwiKTtcbiAgICAgIGNvbnN0IHkgPSB0aGlzW21dLCBJID0gdGhpc1ttICsgN107XG4gICAgICAoeSA9PT0gdm9pZCAwIHx8IEkgPT09IHZvaWQgMCkgJiYgYWUobSwgdGhpcy5sZW5ndGggLSA4KTtcbiAgICAgIGNvbnN0IHEgPSB5ICogMiAqKiAyNCArIHRoaXNbKyttXSAqIDIgKiogMTYgKyB0aGlzWysrbV0gKiAyICoqIDggKyB0aGlzWysrbV0sIEggPSB0aGlzWysrbV0gKiAyICoqIDI0ICsgdGhpc1srK21dICogMiAqKiAxNiArIHRoaXNbKyttXSAqIDIgKiogOCArIEk7XG4gICAgICByZXR1cm4gKEJpZ0ludChxKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChIKTtcbiAgICB9KSwgZi5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24obSwgeSwgSSkge1xuICAgICAgbSA9IG0gPj4+IDAsIHkgPSB5ID4+PiAwLCBJIHx8IHAobSwgeSwgdGhpcy5sZW5ndGgpO1xuICAgICAgbGV0IHEgPSB0aGlzW21dLCBIID0gMSwgVyA9IDA7XG4gICAgICBmb3IgKDsgKytXIDwgeSAmJiAoSCAqPSAyNTYpOyApXG4gICAgICAgIHEgKz0gdGhpc1ttICsgV10gKiBIO1xuICAgICAgcmV0dXJuIEggKj0gMTI4LCBxID49IEggJiYgKHEgLT0gTWF0aC5wb3coMiwgOCAqIHkpKSwgcTtcbiAgICB9LCBmLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbihtLCB5LCBJKSB7XG4gICAgICBtID0gbSA+Pj4gMCwgeSA9IHkgPj4+IDAsIEkgfHwgcChtLCB5LCB0aGlzLmxlbmd0aCk7XG4gICAgICBsZXQgcSA9IHksIEggPSAxLCBXID0gdGhpc1ttICsgLS1xXTtcbiAgICAgIGZvciAoOyBxID4gMCAmJiAoSCAqPSAyNTYpOyApXG4gICAgICAgIFcgKz0gdGhpc1ttICsgLS1xXSAqIEg7XG4gICAgICByZXR1cm4gSCAqPSAxMjgsIFcgPj0gSCAmJiAoVyAtPSBNYXRoLnBvdygyLCA4ICogeSkpLCBXO1xuICAgIH0sIGYucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24obSwgeSkge1xuICAgICAgcmV0dXJuIG0gPSBtID4+PiAwLCB5IHx8IHAobSwgMSwgdGhpcy5sZW5ndGgpLCB0aGlzW21dICYgMTI4ID8gKDI1NSAtIHRoaXNbbV0gKyAxKSAqIC0xIDogdGhpc1ttXTtcbiAgICB9LCBmLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIG0gPSBtID4+PiAwLCB5IHx8IHAobSwgMiwgdGhpcy5sZW5ndGgpO1xuICAgICAgY29uc3QgSSA9IHRoaXNbbV0gfCB0aGlzW20gKyAxXSA8PCA4O1xuICAgICAgcmV0dXJuIEkgJiAzMjc2OCA/IEkgfCA0Mjk0OTAxNzYwIDogSTtcbiAgICB9LCBmLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIG0gPSBtID4+PiAwLCB5IHx8IHAobSwgMiwgdGhpcy5sZW5ndGgpO1xuICAgICAgY29uc3QgSSA9IHRoaXNbbSArIDFdIHwgdGhpc1ttXSA8PCA4O1xuICAgICAgcmV0dXJuIEkgJiAzMjc2OCA/IEkgfCA0Mjk0OTAxNzYwIDogSTtcbiAgICB9LCBmLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIHJldHVybiBtID0gbSA+Pj4gMCwgeSB8fCBwKG0sIDQsIHRoaXMubGVuZ3RoKSwgdGhpc1ttXSB8IHRoaXNbbSArIDFdIDw8IDggfCB0aGlzW20gKyAyXSA8PCAxNiB8IHRoaXNbbSArIDNdIDw8IDI0O1xuICAgIH0sIGYucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24obSwgeSkge1xuICAgICAgcmV0dXJuIG0gPSBtID4+PiAwLCB5IHx8IHAobSwgNCwgdGhpcy5sZW5ndGgpLCB0aGlzW21dIDw8IDI0IHwgdGhpc1ttICsgMV0gPDwgMTYgfCB0aGlzW20gKyAyXSA8PCA4IHwgdGhpc1ttICsgM107XG4gICAgfSwgZi5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBjdChmdW5jdGlvbihtKSB7XG4gICAgICBtID0gbSA+Pj4gMCwgWGUobSwgXCJvZmZzZXRcIik7XG4gICAgICBjb25zdCB5ID0gdGhpc1ttXSwgSSA9IHRoaXNbbSArIDddO1xuICAgICAgKHkgPT09IHZvaWQgMCB8fCBJID09PSB2b2lkIDApICYmIGFlKG0sIHRoaXMubGVuZ3RoIC0gOCk7XG4gICAgICBjb25zdCBxID0gdGhpc1ttICsgNF0gKyB0aGlzW20gKyA1XSAqIDIgKiogOCArIHRoaXNbbSArIDZdICogMiAqKiAxNiArIChJIDw8IDI0KTtcbiAgICAgIHJldHVybiAoQmlnSW50KHEpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KHkgKyB0aGlzWysrbV0gKiAyICoqIDggKyB0aGlzWysrbV0gKiAyICoqIDE2ICsgdGhpc1srK21dICogMiAqKiAyNCk7XG4gICAgfSksIGYucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gY3QoZnVuY3Rpb24obSkge1xuICAgICAgbSA9IG0gPj4+IDAsIFhlKG0sIFwib2Zmc2V0XCIpO1xuICAgICAgY29uc3QgeSA9IHRoaXNbbV0sIEkgPSB0aGlzW20gKyA3XTtcbiAgICAgICh5ID09PSB2b2lkIDAgfHwgSSA9PT0gdm9pZCAwKSAmJiBhZShtLCB0aGlzLmxlbmd0aCAtIDgpO1xuICAgICAgY29uc3QgcSA9ICh5IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgICB0aGlzWysrbV0gKiAyICoqIDE2ICsgdGhpc1srK21dICogMiAqKiA4ICsgdGhpc1srK21dO1xuICAgICAgcmV0dXJuIChCaWdJbnQocSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQodGhpc1srK21dICogMiAqKiAyNCArIHRoaXNbKyttXSAqIDIgKiogMTYgKyB0aGlzWysrbV0gKiAyICoqIDggKyBJKTtcbiAgICB9KSwgZi5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbihtLCB5KSB7XG4gICAgICByZXR1cm4gbSA9IG0gPj4+IDAsIHkgfHwgcChtLCA0LCB0aGlzLmxlbmd0aCksIHIucmVhZCh0aGlzLCBtLCAhMCwgMjMsIDQpO1xuICAgIH0sIGYucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24obSwgeSkge1xuICAgICAgcmV0dXJuIG0gPSBtID4+PiAwLCB5IHx8IHAobSwgNCwgdGhpcy5sZW5ndGgpLCByLnJlYWQodGhpcywgbSwgITEsIDIzLCA0KTtcbiAgICB9LCBmLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihtLCB5KSB7XG4gICAgICByZXR1cm4gbSA9IG0gPj4+IDAsIHkgfHwgcChtLCA4LCB0aGlzLmxlbmd0aCksIHIucmVhZCh0aGlzLCBtLCAhMCwgNTIsIDgpO1xuICAgIH0sIGYucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIHJldHVybiBtID0gbSA+Pj4gMCwgeSB8fCBwKG0sIDgsIHRoaXMubGVuZ3RoKSwgci5yZWFkKHRoaXMsIG0sICExLCA1MiwgOCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhKEUsIG0sIHksIEksIHEsIEgpIHtcbiAgICAgIGlmICghZi5pc0J1ZmZlcihFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgICBpZiAobSA+IHEgfHwgbSA8IEgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgICAgaWYgKHkgKyBJID4gRS5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgIH1cbiAgICBmLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9IGYucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24obSwgeSwgSSwgcSkge1xuICAgICAgaWYgKG0gPSArbSwgeSA9IHkgPj4+IDAsIEkgPSBJID4+PiAwLCAhcSkge1xuICAgICAgICBjb25zdCBCZSA9IE1hdGgucG93KDIsIDggKiBJKSAtIDE7XG4gICAgICAgIGEodGhpcywgbSwgeSwgSSwgQmUsIDApO1xuICAgICAgfVxuICAgICAgbGV0IEggPSAxLCBXID0gMDtcbiAgICAgIGZvciAodGhpc1t5XSA9IG0gJiAyNTU7ICsrVyA8IEkgJiYgKEggKj0gMjU2KTsgKVxuICAgICAgICB0aGlzW3kgKyBXXSA9IG0gLyBIICYgMjU1O1xuICAgICAgcmV0dXJuIHkgKyBJO1xuICAgIH0sIGYucHJvdG90eXBlLndyaXRlVWludEJFID0gZi5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbihtLCB5LCBJLCBxKSB7XG4gICAgICBpZiAobSA9ICttLCB5ID0geSA+Pj4gMCwgSSA9IEkgPj4+IDAsICFxKSB7XG4gICAgICAgIGNvbnN0IEJlID0gTWF0aC5wb3coMiwgOCAqIEkpIC0gMTtcbiAgICAgICAgYSh0aGlzLCBtLCB5LCBJLCBCZSwgMCk7XG4gICAgICB9XG4gICAgICBsZXQgSCA9IEkgLSAxLCBXID0gMTtcbiAgICAgIGZvciAodGhpc1t5ICsgSF0gPSBtICYgMjU1OyAtLUggPj0gMCAmJiAoVyAqPSAyNTYpOyApXG4gICAgICAgIHRoaXNbeSArIEhdID0gbSAvIFcgJiAyNTU7XG4gICAgICByZXR1cm4geSArIEk7XG4gICAgfSwgZi5wcm90b3R5cGUud3JpdGVVaW50OCA9IGYucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbihtLCB5LCBJKSB7XG4gICAgICByZXR1cm4gbSA9ICttLCB5ID0geSA+Pj4gMCwgSSB8fCBhKHRoaXMsIG0sIHksIDEsIDI1NSwgMCksIHRoaXNbeV0gPSBtICYgMjU1LCB5ICsgMTtcbiAgICB9LCBmLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID0gZi5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uKG0sIHksIEkpIHtcbiAgICAgIHJldHVybiBtID0gK20sIHkgPSB5ID4+PiAwLCBJIHx8IGEodGhpcywgbSwgeSwgMiwgNjU1MzUsIDApLCB0aGlzW3ldID0gbSAmIDI1NSwgdGhpc1t5ICsgMV0gPSBtID4+PiA4LCB5ICsgMjtcbiAgICB9LCBmLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID0gZi5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKG0sIHksIEkpIHtcbiAgICAgIHJldHVybiBtID0gK20sIHkgPSB5ID4+PiAwLCBJIHx8IGEodGhpcywgbSwgeSwgMiwgNjU1MzUsIDApLCB0aGlzW3ldID0gbSA+Pj4gOCwgdGhpc1t5ICsgMV0gPSBtICYgMjU1LCB5ICsgMjtcbiAgICB9LCBmLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID0gZi5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uKG0sIHksIEkpIHtcbiAgICAgIHJldHVybiBtID0gK20sIHkgPSB5ID4+PiAwLCBJIHx8IGEodGhpcywgbSwgeSwgNCwgNDI5NDk2NzI5NSwgMCksIHRoaXNbeSArIDNdID0gbSA+Pj4gMjQsIHRoaXNbeSArIDJdID0gbSA+Pj4gMTYsIHRoaXNbeSArIDFdID0gbSA+Pj4gOCwgdGhpc1t5XSA9IG0gJiAyNTUsIHkgKyA0O1xuICAgIH0sIGYucHJvdG90eXBlLndyaXRlVWludDMyQkUgPSBmLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24obSwgeSwgSSkge1xuICAgICAgcmV0dXJuIG0gPSArbSwgeSA9IHkgPj4+IDAsIEkgfHwgYSh0aGlzLCBtLCB5LCA0LCA0Mjk0OTY3Mjk1LCAwKSwgdGhpc1t5XSA9IG0gPj4+IDI0LCB0aGlzW3kgKyAxXSA9IG0gPj4+IDE2LCB0aGlzW3kgKyAyXSA9IG0gPj4+IDgsIHRoaXNbeSArIDNdID0gbSAmIDI1NSwgeSArIDQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsKEUsIG0sIHksIEksIHEpIHtcbiAgICAgIEllKG0sIEksIHEsIEUsIHksIDcpO1xuICAgICAgbGV0IEggPSBOdW1iZXIobSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgICBFW3krK10gPSBILCBIID0gSCA+PiA4LCBFW3krK10gPSBILCBIID0gSCA+PiA4LCBFW3krK10gPSBILCBIID0gSCA+PiA4LCBFW3krK10gPSBIO1xuICAgICAgbGV0IFcgPSBOdW1iZXIobSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDQyOTQ5NjcyOTUpKTtcbiAgICAgIHJldHVybiBFW3krK10gPSBXLCBXID0gVyA+PiA4LCBFW3krK10gPSBXLCBXID0gVyA+PiA4LCBFW3krK10gPSBXLCBXID0gVyA+PiA4LCBFW3krK10gPSBXLCB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBNKEUsIG0sIHksIEksIHEpIHtcbiAgICAgIEllKG0sIEksIHEsIEUsIHksIDcpO1xuICAgICAgbGV0IEggPSBOdW1iZXIobSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgICBFW3kgKyA3XSA9IEgsIEggPSBIID4+IDgsIEVbeSArIDZdID0gSCwgSCA9IEggPj4gOCwgRVt5ICsgNV0gPSBILCBIID0gSCA+PiA4LCBFW3kgKyA0XSA9IEg7XG4gICAgICBsZXQgVyA9IE51bWJlcihtID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpO1xuICAgICAgcmV0dXJuIEVbeSArIDNdID0gVywgVyA9IFcgPj4gOCwgRVt5ICsgMl0gPSBXLCBXID0gVyA+PiA4LCBFW3kgKyAxXSA9IFcsIFcgPSBXID4+IDgsIEVbeV0gPSBXLCB5ICsgODtcbiAgICB9XG4gICAgZi5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGN0KGZ1bmN0aW9uKG0sIHkgPSAwKSB7XG4gICAgICByZXR1cm4gbCh0aGlzLCBtLCB5LCBCaWdJbnQoMCksIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKSk7XG4gICAgfSksIGYucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBjdChmdW5jdGlvbihtLCB5ID0gMCkge1xuICAgICAgcmV0dXJuIE0odGhpcywgbSwgeSwgQmlnSW50KDApLCBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIikpO1xuICAgIH0pLCBmLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24obSwgeSwgSSwgcSkge1xuICAgICAgaWYgKG0gPSArbSwgeSA9IHkgPj4+IDAsICFxKSB7XG4gICAgICAgIGNvbnN0IG1lID0gTWF0aC5wb3coMiwgOCAqIEkgLSAxKTtcbiAgICAgICAgYSh0aGlzLCBtLCB5LCBJLCBtZSAtIDEsIC1tZSk7XG4gICAgICB9XG4gICAgICBsZXQgSCA9IDAsIFcgPSAxLCBCZSA9IDA7XG4gICAgICBmb3IgKHRoaXNbeV0gPSBtICYgMjU1OyArK0ggPCBJICYmIChXICo9IDI1Nik7IClcbiAgICAgICAgbSA8IDAgJiYgQmUgPT09IDAgJiYgdGhpc1t5ICsgSCAtIDFdICE9PSAwICYmIChCZSA9IDEpLCB0aGlzW3kgKyBIXSA9IChtIC8gVyA+PiAwKSAtIEJlICYgMjU1O1xuICAgICAgcmV0dXJuIHkgKyBJO1xuICAgIH0sIGYucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbihtLCB5LCBJLCBxKSB7XG4gICAgICBpZiAobSA9ICttLCB5ID0geSA+Pj4gMCwgIXEpIHtcbiAgICAgICAgY29uc3QgbWUgPSBNYXRoLnBvdygyLCA4ICogSSAtIDEpO1xuICAgICAgICBhKHRoaXMsIG0sIHksIEksIG1lIC0gMSwgLW1lKTtcbiAgICAgIH1cbiAgICAgIGxldCBIID0gSSAtIDEsIFcgPSAxLCBCZSA9IDA7XG4gICAgICBmb3IgKHRoaXNbeSArIEhdID0gbSAmIDI1NTsgLS1IID49IDAgJiYgKFcgKj0gMjU2KTsgKVxuICAgICAgICBtIDwgMCAmJiBCZSA9PT0gMCAmJiB0aGlzW3kgKyBIICsgMV0gIT09IDAgJiYgKEJlID0gMSksIHRoaXNbeSArIEhdID0gKG0gLyBXID4+IDApIC0gQmUgJiAyNTU7XG4gICAgICByZXR1cm4geSArIEk7XG4gICAgfSwgZi5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24obSwgeSwgSSkge1xuICAgICAgcmV0dXJuIG0gPSArbSwgeSA9IHkgPj4+IDAsIEkgfHwgYSh0aGlzLCBtLCB5LCAxLCAxMjcsIC0xMjgpLCBtIDwgMCAmJiAobSA9IDI1NSArIG0gKyAxKSwgdGhpc1t5XSA9IG0gJiAyNTUsIHkgKyAxO1xuICAgIH0sIGYucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uKG0sIHksIEkpIHtcbiAgICAgIHJldHVybiBtID0gK20sIHkgPSB5ID4+PiAwLCBJIHx8IGEodGhpcywgbSwgeSwgMiwgMzI3NjcsIC0zMjc2OCksIHRoaXNbeV0gPSBtICYgMjU1LCB0aGlzW3kgKyAxXSA9IG0gPj4+IDgsIHkgKyAyO1xuICAgIH0sIGYucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKG0sIHksIEkpIHtcbiAgICAgIHJldHVybiBtID0gK20sIHkgPSB5ID4+PiAwLCBJIHx8IGEodGhpcywgbSwgeSwgMiwgMzI3NjcsIC0zMjc2OCksIHRoaXNbeV0gPSBtID4+PiA4LCB0aGlzW3kgKyAxXSA9IG0gJiAyNTUsIHkgKyAyO1xuICAgIH0sIGYucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKG0sIHksIEkpIHtcbiAgICAgIHJldHVybiBtID0gK20sIHkgPSB5ID4+PiAwLCBJIHx8IGEodGhpcywgbSwgeSwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpLCB0aGlzW3ldID0gbSAmIDI1NSwgdGhpc1t5ICsgMV0gPSBtID4+PiA4LCB0aGlzW3kgKyAyXSA9IG0gPj4+IDE2LCB0aGlzW3kgKyAzXSA9IG0gPj4+IDI0LCB5ICsgNDtcbiAgICB9LCBmLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbihtLCB5LCBJKSB7XG4gICAgICByZXR1cm4gbSA9ICttLCB5ID0geSA+Pj4gMCwgSSB8fCBhKHRoaXMsIG0sIHksIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KSwgbSA8IDAgJiYgKG0gPSA0Mjk0OTY3Mjk1ICsgbSArIDEpLCB0aGlzW3ldID0gbSA+Pj4gMjQsIHRoaXNbeSArIDFdID0gbSA+Pj4gMTYsIHRoaXNbeSArIDJdID0gbSA+Pj4gOCwgdGhpc1t5ICsgM10gPSBtICYgMjU1LCB5ICsgNDtcbiAgICB9LCBmLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBjdChmdW5jdGlvbihtLCB5ID0gMCkge1xuICAgICAgcmV0dXJuIGwodGhpcywgbSwgeSwgLUJpZ0ludChcIjB4ODAwMDAwMDAwMDAwMDAwMFwiKSwgQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpKTtcbiAgICB9KSwgZi5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gY3QoZnVuY3Rpb24obSwgeSA9IDApIHtcbiAgICAgIHJldHVybiBNKHRoaXMsIG0sIHksIC1CaWdJbnQoXCIweDgwMDAwMDAwMDAwMDAwMDBcIiksIEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZlwiKSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gayhFLCBtLCB5LCBJLCBxLCBIKSB7XG4gICAgICBpZiAoeSArIEkgPiBFLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBpZiAoeSA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkKEUsIG0sIHksIEksIHEpIHtcbiAgICAgIHJldHVybiBtID0gK20sIHkgPSB5ID4+PiAwLCBxIHx8IGsoRSwgbSwgeSwgNCksIHIud3JpdGUoRSwgbSwgeSwgSSwgMjMsIDQpLCB5ICsgNDtcbiAgICB9XG4gICAgZi5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24obSwgeSwgSSkge1xuICAgICAgcmV0dXJuICQodGhpcywgbSwgeSwgITAsIEkpO1xuICAgIH0sIGYucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uKG0sIHksIEkpIHtcbiAgICAgIHJldHVybiAkKHRoaXMsIG0sIHksICExLCBJKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFgoRSwgbSwgeSwgSSwgcSkge1xuICAgICAgcmV0dXJuIG0gPSArbSwgeSA9IHkgPj4+IDAsIHEgfHwgayhFLCBtLCB5LCA4KSwgci53cml0ZShFLCBtLCB5LCBJLCA1MiwgOCksIHkgKyA4O1xuICAgIH1cbiAgICBmLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24obSwgeSwgSSkge1xuICAgICAgcmV0dXJuIFgodGhpcywgbSwgeSwgITAsIEkpO1xuICAgIH0sIGYucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbihtLCB5LCBJKSB7XG4gICAgICByZXR1cm4gWCh0aGlzLCBtLCB5LCAhMSwgSSk7XG4gICAgfSwgZi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKG0sIHksIEksIHEpIHtcbiAgICAgIGlmICghZi5pc0J1ZmZlcihtKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtcbiAgICAgIGlmIChJIHx8IChJID0gMCksICFxICYmIHEgIT09IDAgJiYgKHEgPSB0aGlzLmxlbmd0aCksIHkgPj0gbS5sZW5ndGggJiYgKHkgPSBtLmxlbmd0aCksIHkgfHwgKHkgPSAwKSwgcSA+IDAgJiYgcSA8IEkgJiYgKHEgPSBJKSwgcSA9PT0gSSB8fCBtLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICBpZiAoeSA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIGlmIChJIDwgMCB8fCBJID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGlmIChxIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIHEgPiB0aGlzLmxlbmd0aCAmJiAocSA9IHRoaXMubGVuZ3RoKSwgbS5sZW5ndGggLSB5IDwgcSAtIEkgJiYgKHEgPSBtLmxlbmd0aCAtIHkgKyBJKTtcbiAgICAgIGNvbnN0IEggPSBxIC0gSTtcbiAgICAgIHJldHVybiB0aGlzID09PSBtICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuY29weVdpdGhpbih5LCBJLCBxKSA6IFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICBtLFxuICAgICAgICB0aGlzLnN1YmFycmF5KEksIHEpLFxuICAgICAgICB5XG4gICAgICApLCBIO1xuICAgIH0sIGYucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbihtLCB5LCBJLCBxKSB7XG4gICAgICBpZiAodHlwZW9mIG0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIHkgPT0gXCJzdHJpbmdcIiA/IChxID0geSwgeSA9IDAsIEkgPSB0aGlzLmxlbmd0aCkgOiB0eXBlb2YgSSA9PSBcInN0cmluZ1wiICYmIChxID0gSSwgSSA9IHRoaXMubGVuZ3RoKSwgcSAhPT0gdm9pZCAwICYmIHR5cGVvZiBxICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIGlmICh0eXBlb2YgcSA9PSBcInN0cmluZ1wiICYmICFmLmlzRW5jb2RpbmcocSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgcSk7XG4gICAgICAgIGlmIChtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IFcgPSBtLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgKHEgPT09IFwidXRmOFwiICYmIFcgPCAxMjggfHwgcSA9PT0gXCJsYXRpbjFcIikgJiYgKG0gPSBXKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHR5cGVvZiBtID09IFwibnVtYmVyXCIgPyBtID0gbSAmIDI1NSA6IHR5cGVvZiBtID09IFwiYm9vbGVhblwiICYmIChtID0gTnVtYmVyKG0pKTtcbiAgICAgIGlmICh5IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHkgfHwgdGhpcy5sZW5ndGggPCBJKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtcbiAgICAgIGlmIChJIDw9IHkpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgeSA9IHkgPj4+IDAsIEkgPSBJID09PSB2b2lkIDAgPyB0aGlzLmxlbmd0aCA6IEkgPj4+IDAsIG0gfHwgKG0gPSAwKTtcbiAgICAgIGxldCBIO1xuICAgICAgaWYgKHR5cGVvZiBtID09IFwibnVtYmVyXCIpXG4gICAgICAgIGZvciAoSCA9IHk7IEggPCBJOyArK0gpXG4gICAgICAgICAgdGhpc1tIXSA9IG07XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgVyA9IGYuaXNCdWZmZXIobSkgPyBtIDogZi5mcm9tKG0sIHEpLCBCZSA9IFcubGVuZ3RoO1xuICAgICAgICBpZiAoQmUgPT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIG0gKyAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyk7XG4gICAgICAgIGZvciAoSCA9IDA7IEggPCBJIC0geTsgKytIKVxuICAgICAgICAgIHRoaXNbSCArIHldID0gV1tIICUgQmVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBjb25zdCByZSA9IHt9O1xuICAgIGZ1bmN0aW9uIHNlKEUsIG0sIHkpIHtcbiAgICAgIHJlW0VdID0gY2xhc3MgZXh0ZW5kcyB5IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgc3VwZXIoKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH0pLCB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske0V9XWAsIHRoaXMuc3RhY2ssIGRlbGV0ZSB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNvZGUoKSB7XG4gICAgICAgICAgcmV0dXJuIEU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IGNvZGUocSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IHEsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtFfV06ICR7dGhpcy5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHNlKFxuICAgICAgXCJFUlJfQlVGRkVSX09VVF9PRl9CT1VORFNcIixcbiAgICAgIGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgcmV0dXJuIEUgPyBgJHtFfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgIDogXCJBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzXCI7XG4gICAgICB9LFxuICAgICAgUmFuZ2VFcnJvclxuICAgICksIHNlKFxuICAgICAgXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLFxuICAgICAgZnVuY3Rpb24oRSwgbSkge1xuICAgICAgICByZXR1cm4gYFRoZSBcIiR7RX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIG19YDtcbiAgICAgIH0sXG4gICAgICBUeXBlRXJyb3JcbiAgICApLCBzZShcbiAgICAgIFwiRVJSX09VVF9PRl9SQU5HRVwiLFxuICAgICAgZnVuY3Rpb24oRSwgbSwgeSkge1xuICAgICAgICBsZXQgSSA9IGBUaGUgdmFsdWUgb2YgXCIke0V9XCIgaXMgb3V0IG9mIHJhbmdlLmAsIHEgPSB5O1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih5KSAmJiBNYXRoLmFicyh5KSA+IDIgKiogMzIgPyBxID0gdXQoU3RyaW5nKHkpKSA6IHR5cGVvZiB5ID09IFwiYmlnaW50XCIgJiYgKHEgPSBTdHJpbmcoeSksICh5ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgeSA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSAmJiAocSA9IHV0KHEpKSwgcSArPSBcIm5cIiksIEkgKz0gYCBJdCBtdXN0IGJlICR7bX0uIFJlY2VpdmVkICR7cX1gLCBJO1xuICAgICAgfSxcbiAgICAgIFJhbmdlRXJyb3JcbiAgICApO1xuICAgIGZ1bmN0aW9uIHV0KEUpIHtcbiAgICAgIGxldCBtID0gXCJcIiwgeSA9IEUubGVuZ3RoO1xuICAgICAgY29uc3QgSSA9IEVbMF0gPT09IFwiLVwiID8gMSA6IDA7XG4gICAgICBmb3IgKDsgeSA+PSBJICsgNDsgeSAtPSAzKVxuICAgICAgICBtID0gYF8ke0Uuc2xpY2UoeSAtIDMsIHkpfSR7bX1gO1xuICAgICAgcmV0dXJuIGAke0Uuc2xpY2UoMCwgeSl9JHttfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhlKEUsIG0sIHkpIHtcbiAgICAgIFhlKG0sIFwib2Zmc2V0XCIpLCAoRVttXSA9PT0gdm9pZCAwIHx8IEVbbSArIHldID09PSB2b2lkIDApICYmIGFlKG0sIEUubGVuZ3RoIC0gKHkgKyAxKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEllKEUsIG0sIHksIEksIHEsIEgpIHtcbiAgICAgIGlmIChFID4geSB8fCBFIDwgbSkge1xuICAgICAgICBjb25zdCBXID0gdHlwZW9mIG0gPT0gXCJiaWdpbnRcIiA/IFwiblwiIDogXCJcIjtcbiAgICAgICAgbGV0IEJlO1xuICAgICAgICB0aHJvdyBtID09PSAwIHx8IG0gPT09IEJpZ0ludCgwKSA/IEJlID0gYD49IDAke1d9IGFuZCA8IDIke1d9ICoqICR7KEggKyAxKSAqIDh9JHtXfWAgOiBCZSA9IGA+PSAtKDIke1d9ICoqICR7KEggKyAxKSAqIDggLSAxfSR7V30pIGFuZCA8IDIgKiogJHsoSCArIDEpICogOCAtIDF9JHtXfWAsIG5ldyByZS5FUlJfT1VUX09GX1JBTkdFKFwidmFsdWVcIiwgQmUsIEUpO1xuICAgICAgfVxuICAgICAgeGUoSSwgcSwgSCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFhlKEUsIG0pIHtcbiAgICAgIGlmICh0eXBlb2YgRSAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgcmUuRVJSX0lOVkFMSURfQVJHX1RZUEUobSwgXCJudW1iZXJcIiwgRSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFlKEUsIG0sIHkpIHtcbiAgICAgIHRocm93IE1hdGguZmxvb3IoRSkgIT09IEUgPyAoWGUoRSwgeSksIG5ldyByZS5FUlJfT1VUX09GX1JBTkdFKFwib2Zmc2V0XCIsIFwiYW4gaW50ZWdlclwiLCBFKSkgOiBtIDwgMCA/IG5ldyByZS5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKSA6IG5ldyByZS5FUlJfT1VUX09GX1JBTkdFKFxuICAgICAgICBcIm9mZnNldFwiLFxuICAgICAgICBgPj0gMCBhbmQgPD0gJHttfWAsXG4gICAgICAgIEVcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGdlID0gL1teKy8wLTlBLVphLXotX10vZztcbiAgICBmdW5jdGlvbiBpdChFKSB7XG4gICAgICBpZiAoRSA9IEUuc3BsaXQoXCI9XCIpWzBdLCBFID0gRS50cmltKCkucmVwbGFjZShnZSwgXCJcIiksIEUubGVuZ3RoIDwgMikgcmV0dXJuIFwiXCI7XG4gICAgICBmb3IgKDsgRS5sZW5ndGggJSA0ICE9PSAwOyApXG4gICAgICAgIEUgPSBFICsgXCI9XCI7XG4gICAgICByZXR1cm4gRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2UoRSwgbSkge1xuICAgICAgbSA9IG0gfHwgMSAvIDA7XG4gICAgICBsZXQgeTtcbiAgICAgIGNvbnN0IEkgPSBFLmxlbmd0aDtcbiAgICAgIGxldCBxID0gbnVsbDtcbiAgICAgIGNvbnN0IEggPSBbXTtcbiAgICAgIGZvciAobGV0IFcgPSAwOyBXIDwgSTsgKytXKSB7XG4gICAgICAgIGlmICh5ID0gRS5jaGFyQ29kZUF0KFcpLCB5ID4gNTUyOTUgJiYgeSA8IDU3MzQ0KSB7XG4gICAgICAgICAgaWYgKCFxKSB7XG4gICAgICAgICAgICBpZiAoeSA+IDU2MzE5KSB7XG4gICAgICAgICAgICAgIChtIC09IDMpID4gLTEgJiYgSC5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVyArIDEgPT09IEkpIHtcbiAgICAgICAgICAgICAgKG0gLT0gMykgPiAtMSAmJiBILnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcSA9IHk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHkgPCA1NjMyMCkge1xuICAgICAgICAgICAgKG0gLT0gMykgPiAtMSAmJiBILnB1c2goMjM5LCAxOTEsIDE4OSksIHEgPSB5O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHkgPSAocSAtIDU1Mjk2IDw8IDEwIHwgeSAtIDU2MzIwKSArIDY1NTM2O1xuICAgICAgICB9IGVsc2UgcSAmJiAobSAtPSAzKSA+IC0xICYmIEgucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgaWYgKHEgPSBudWxsLCB5IDwgMTI4KSB7XG4gICAgICAgICAgaWYgKChtIC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgSC5wdXNoKHkpO1xuICAgICAgICB9IGVsc2UgaWYgKHkgPCAyMDQ4KSB7XG4gICAgICAgICAgaWYgKChtIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgSC5wdXNoKFxuICAgICAgICAgICAgeSA+PiA2IHwgMTkyLFxuICAgICAgICAgICAgeSAmIDYzIHwgMTI4XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh5IDwgNjU1MzYpIHtcbiAgICAgICAgICBpZiAoKG0gLT0gMykgPCAwKSBicmVhaztcbiAgICAgICAgICBILnB1c2goXG4gICAgICAgICAgICB5ID4+IDEyIHwgMjI0LFxuICAgICAgICAgICAgeSA+PiA2ICYgNjMgfCAxMjgsXG4gICAgICAgICAgICB5ICYgNjMgfCAxMjhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHkgPCAxMTE0MTEyKSB7XG4gICAgICAgICAgaWYgKChtIC09IDQpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgSC5wdXNoKFxuICAgICAgICAgICAgeSA+PiAxOCB8IDI0MCxcbiAgICAgICAgICAgIHkgPj4gMTIgJiA2MyB8IDEyOCxcbiAgICAgICAgICAgIHkgPj4gNiAmIDYzIHwgMTI4LFxuICAgICAgICAgICAgeSAmIDYzIHwgMTI4XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1lKEUpIHtcbiAgICAgIGNvbnN0IG0gPSBbXTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgRS5sZW5ndGg7ICsreSlcbiAgICAgICAgbS5wdXNoKEUuY2hhckNvZGVBdCh5KSAmIDI1NSk7XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnQoRSwgbSkge1xuICAgICAgbGV0IHksIEksIHE7XG4gICAgICBjb25zdCBIID0gW107XG4gICAgICBmb3IgKGxldCBXID0gMDsgVyA8IEUubGVuZ3RoICYmICEoKG0gLT0gMikgPCAwKTsgKytXKVxuICAgICAgICB5ID0gRS5jaGFyQ29kZUF0KFcpLCBJID0geSA+PiA4LCBxID0geSAlIDI1NiwgSC5wdXNoKHEpLCBILnB1c2goSSk7XG4gICAgICByZXR1cm4gSDtcbiAgICB9XG4gICAgZnVuY3Rpb24geWUoRSkge1xuICAgICAgcmV0dXJuIGUudG9CeXRlQXJyYXkoaXQoRSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZShFLCBtLCB5LCBJKSB7XG4gICAgICBsZXQgcTtcbiAgICAgIGZvciAocSA9IDA7IHEgPCBJICYmICEocSArIHkgPj0gbS5sZW5ndGggfHwgcSA+PSBFLmxlbmd0aCk7ICsrcSlcbiAgICAgICAgbVtxICsgeV0gPSBFW3FdO1xuICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHh0KEUsIG0pIHtcbiAgICAgIHJldHVybiBFIGluc3RhbmNlb2YgbSB8fCBFICE9IG51bGwgJiYgRS5jb25zdHJ1Y3RvciAhPSBudWxsICYmIEUuY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmIEUuY29uc3RydWN0b3IubmFtZSA9PT0gbS5uYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZShFKSB7XG4gICAgICByZXR1cm4gRSAhPT0gRTtcbiAgICB9XG4gICAgY29uc3Qga2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IEUgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIiwgbSA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCAxNjsgKyt5KSB7XG4gICAgICAgIGNvbnN0IEkgPSB5ICogMTY7XG4gICAgICAgIGZvciAobGV0IHEgPSAwOyBxIDwgMTY7ICsrcSlcbiAgICAgICAgICBtW0kgKyBxXSA9IEVbeV0gKyBFW3FdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG07XG4gICAgfSgpO1xuICAgIGZ1bmN0aW9uIGN0KEUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgQmlnSW50ID4gXCJ1XCIgPyBfZSA6IEU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICB9KEtzKSksIEtzO1xufVxudmFyIGV0ID0gbmEoKTtcbmNvbnN0IHduID0gdHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHZvaWQgMDtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmZ1bmN0aW9uIGlhKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5QnVmZmVyLmlzVmlldyh0KSAmJiB0LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVWludDhBcnJheVwiO1xufVxuZnVuY3Rpb24gVG8odCkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpIHx8IHQgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCBcIiArIHQpO1xufVxuZnVuY3Rpb24gYXIodCwgLi4uZSkge1xuICBpZiAoIWlhKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG4gIGlmIChlLmxlbmd0aCA+IDAgJiYgIWUuaW5jbHVkZXModC5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoIFwiICsgZSArIFwiLCBnb3QgbGVuZ3RoPVwiICsgdC5sZW5ndGgpO1xufVxuZnVuY3Rpb24gTDAodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0LmNyZWF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy5jcmVhdGVIYXNoZXJcIik7XG4gIFRvKHQub3V0cHV0TGVuKSwgVG8odC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBwcyh0LCBlID0gITApIHtcbiAgaWYgKHQuZGVzdHJveWVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkXCIpO1xuICBpZiAoZSAmJiB0LmZpbmlzaGVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XG59XG5mdW5jdGlvbiBPMCh0LCBlKSB7XG4gIGFyKHQpO1xuICBjb25zdCByID0gZS5vdXRwdXRMZW47XG4gIGlmICh0Lmxlbmd0aCA8IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgXCIgKyByKTtcbn1cbmZ1bmN0aW9uIE9uKC4uLnQpIHtcbiAgZm9yIChsZXQgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKVxuICAgIHRbZV0uZmlsbCgwKTtcbn1cbmZ1bmN0aW9uIFdzKHQpIHtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpO1xufVxuZnVuY3Rpb24gUXQodCwgZSkge1xuICByZXR1cm4gdCA8PCAzMiAtIGUgfCB0ID4+PiBlO1xufVxuY29uc3QgYWMgPSAvKiBAdHMtaWdub3JlICovIHR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09IFwiZnVuY3Rpb25cIiwgTjAgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh0LCBlKSA9PiBlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuZnVuY3Rpb24gTm4odCkge1xuICBpZiAoYXIodCksIGFjKVxuICAgIHJldHVybiB0LnRvSGV4KCk7XG4gIGxldCBlID0gXCJcIjtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIGUgKz0gTjBbdFtyXV07XG4gIHJldHVybiBlO1xufVxuY29uc3QgZnIgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIE5hKHQpIHtcbiAgaWYgKHQgPj0gZnIuXzAgJiYgdCA8PSBmci5fOSlcbiAgICByZXR1cm4gdCAtIGZyLl8wO1xuICBpZiAodCA+PSBmci5BICYmIHQgPD0gZnIuRilcbiAgICByZXR1cm4gdCAtIChmci5BIC0gMTApO1xuICBpZiAodCA+PSBmci5hICYmIHQgPD0gZnIuZilcbiAgICByZXR1cm4gdCAtIChmci5hIC0gMTApO1xufVxuZnVuY3Rpb24gc2EodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgXCIgKyB0eXBlb2YgdCk7XG4gIGlmIChhYylcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KHQpO1xuICBjb25zdCBlID0gdC5sZW5ndGgsIHIgPSBlIC8gMjtcbiAgaWYgKGUgJSAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoIFwiICsgZSk7XG4gIGNvbnN0IG4gPSBuZXcgVWludDhBcnJheShyKTtcbiAgZm9yIChsZXQgbyA9IDAsIGkgPSAwOyBvIDwgcjsgbysrLCBpICs9IDIpIHtcbiAgICBjb25zdCBjID0gTmEodC5jaGFyQ29kZUF0KGkpKSwgZiA9IE5hKHQuY2hhckNvZGVBdChpICsgMSkpO1xuICAgIGlmIChjID09PSB2b2lkIDAgfHwgZiA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB2ID0gdFtpXSArIHRbaSArIDFdO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgdiArICdcIiBhdCBpbmRleCAnICsgaSk7XG4gICAgfVxuICAgIG5bb10gPSBjICogMTYgKyBmO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gajAodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgZXhwZWN0ZWRcIik7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodCkpO1xufVxuZnVuY3Rpb24gb2EodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IGowKHQpKSwgYXIodCksIHQ7XG59XG5mdW5jdGlvbiB2ciguLi50KSB7XG4gIGxldCBlID0gMDtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgbyA9IHRbbl07XG4gICAgYXIobyksIGUgKz0gby5sZW5ndGg7XG4gIH1cbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGUpO1xuICBmb3IgKGxldCBuID0gMCwgbyA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgaSA9IHRbbl07XG4gICAgci5zZXQoaSwgbyksIG8gKz0gaS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5sZXQgdWMgPSBjbGFzcyB7XG59O1xuZnVuY3Rpb24gY2ModCkge1xuICBjb25zdCBlID0gKG4pID0+IHQoKS51cGRhdGUob2EobikpLmRpZ2VzdCgpLCByID0gdCgpO1xuICByZXR1cm4gZS5vdXRwdXRMZW4gPSByLm91dHB1dExlbiwgZS5ibG9ja0xlbiA9IHIuYmxvY2tMZW4sIGUuY3JlYXRlID0gKCkgPT4gdCgpLCBlO1xufVxuZnVuY3Rpb24gbGModCA9IDMyKSB7XG4gIGlmICh3biAmJiB0eXBlb2Ygd24uZ2V0UmFuZG9tVmFsdWVzID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gd24uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHQpKTtcbiAgaWYgKHduICYmIHR5cGVvZiB3bi5yYW5kb21CeXRlcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh3bi5yYW5kb21CeXRlcyh0KSk7XG4gIHRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkXCIpO1xufVxuZnVuY3Rpb24gVTAodCwgZSwgciwgbikge1xuICBpZiAodHlwZW9mIHQuc2V0QmlnVWludDY0ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gdC5zZXRCaWdVaW50NjQoZSwgciwgbik7XG4gIGNvbnN0IG8gPSBCaWdJbnQoMzIpLCBpID0gQmlnSW50KDQyOTQ5NjcyOTUpLCBjID0gTnVtYmVyKHIgPj4gbyAmIGkpLCBmID0gTnVtYmVyKHIgJiBpKSwgdiA9IG4gPyA0IDogMCwgeCA9IG4gPyAwIDogNDtcbiAgdC5zZXRVaW50MzIoZSArIHYsIGMsIG4pLCB0LnNldFVpbnQzMihlICsgeCwgZiwgbik7XG59XG5mdW5jdGlvbiBGMCh0LCBlLCByKSB7XG4gIHJldHVybiB0ICYgZSBeIH50ICYgcjtcbn1cbmZ1bmN0aW9uIFAwKHQsIGUsIHIpIHtcbiAgcmV0dXJuIHQgJiBlIF4gdCAmIHIgXiBlICYgcjtcbn1cbmxldCBmYyA9IGNsYXNzIGV4dGVuZHMgdWMge1xuICBjb25zdHJ1Y3RvcihlLCByLCBuLCBvKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5maW5pc2hlZCA9ICExLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMucG9zID0gMCwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgdGhpcy5ibG9ja0xlbiA9IGUsIHRoaXMub3V0cHV0TGVuID0gciwgdGhpcy5wYWRPZmZzZXQgPSBuLCB0aGlzLmlzTEUgPSBvLCB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGUpLCB0aGlzLnZpZXcgPSBXcyh0aGlzLmJ1ZmZlcik7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICBwcyh0aGlzKSwgZSA9IG9hKGUpLCBhcihlKTtcbiAgICBjb25zdCB7IHZpZXc6IHIsIGJ1ZmZlcjogbiwgYmxvY2tMZW46IG8gfSA9IHRoaXMsIGkgPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGk7ICkge1xuICAgICAgY29uc3QgZiA9IE1hdGgubWluKG8gLSB0aGlzLnBvcywgaSAtIGMpO1xuICAgICAgaWYgKGYgPT09IG8pIHtcbiAgICAgICAgY29uc3QgdiA9IFdzKGUpO1xuICAgICAgICBmb3IgKDsgbyA8PSBpIC0gYzsgYyArPSBvKVxuICAgICAgICAgIHRoaXMucHJvY2Vzcyh2LCBjKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuLnNldChlLnN1YmFycmF5KGMsIGMgKyBmKSwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSBmLCBjICs9IGYsIHRoaXMucG9zID09PSBvICYmICh0aGlzLnByb2Nlc3MociwgMCksIHRoaXMucG9zID0gMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCArPSBlLmxlbmd0aCwgdGhpcy5yb3VuZENsZWFuKCksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgcHModGhpcyksIE8wKGUsIHRoaXMpLCB0aGlzLmZpbmlzaGVkID0gITA7XG4gICAgY29uc3QgeyBidWZmZXI6IHIsIHZpZXc6IG4sIGJsb2NrTGVuOiBvLCBpc0xFOiBpIH0gPSB0aGlzO1xuICAgIGxldCB7IHBvczogYyB9ID0gdGhpcztcbiAgICByW2MrK10gPSAxMjgsIE9uKHRoaXMuYnVmZmVyLnN1YmFycmF5KGMpKSwgdGhpcy5wYWRPZmZzZXQgPiBvIC0gYyAmJiAodGhpcy5wcm9jZXNzKG4sIDApLCBjID0gMCk7XG4gICAgZm9yIChsZXQgUyA9IGM7IFMgPCBvOyBTKyspXG4gICAgICByW1NdID0gMDtcbiAgICBVMChuLCBvIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGkpLCB0aGlzLnByb2Nlc3MobiwgMCk7XG4gICAgY29uc3QgZiA9IFdzKGUpLCB2ID0gdGhpcy5vdXRwdXRMZW47XG4gICAgaWYgKHYgJSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdFwiKTtcbiAgICBjb25zdCB4ID0gdiAvIDQsIGIgPSB0aGlzLmdldCgpO1xuICAgIGlmICh4ID4gYi5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlXCIpO1xuICAgIGZvciAobGV0IFMgPSAwOyBTIDwgeDsgUysrKVxuICAgICAgZi5zZXRVaW50MzIoNCAqIFMsIGJbU10sIGkpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogZSwgb3V0cHV0TGVuOiByIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhlKTtcbiAgICBjb25zdCBuID0gZS5zbGljZSgwLCByKTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCksIG47XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpLCBlLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuOiByLCBidWZmZXI6IG4sIGxlbmd0aDogbywgZmluaXNoZWQ6IGksIGRlc3Ryb3llZDogYywgcG9zOiBmIH0gPSB0aGlzO1xuICAgIHJldHVybiBlLmRlc3Ryb3llZCA9IGMsIGUuZmluaXNoZWQgPSBpLCBlLmxlbmd0aCA9IG8sIGUucG9zID0gZiwgbyAlIHIgJiYgZS5idWZmZXIuc2V0KG4pLCBlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgfVxufTtcbmNvbnN0IF9yID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAxNzc5MDMzNzAzLFxuICAzMTQ0MTM0Mjc3LFxuICAxMDEzOTA0MjQyLFxuICAyNzczNDgwNzYyLFxuICAxMzU5ODkzMTE5LFxuICAyNjAwODIyOTI0LFxuICA1Mjg3MzQ2MzUsXG4gIDE1NDE0NTkyMjVcbl0pLCBTdCA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgMTc3OTAzMzcwMyxcbiAgNDA4OTIzNTcyMCxcbiAgMzE0NDEzNDI3NyxcbiAgMjIyNzg3MzU5NSxcbiAgMTAxMzkwNDI0MixcbiAgNDI3MTE3NTcyMyxcbiAgMjc3MzQ4MDc2MixcbiAgMTU5NTc1MDEyOSxcbiAgMTM1OTg5MzExOSxcbiAgMjkxNzU2NTEzNyxcbiAgMjYwMDgyMjkyNCxcbiAgNzI1NTExMTk5LFxuICA1Mjg3MzQ2MzUsXG4gIDQyMTUzODk1NDcsXG4gIDE1NDE0NTkyMjUsXG4gIDMyNzAzMzIwOVxuXSksIFppID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSksIGphID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG5mdW5jdGlvbiBEMCh0LCBlID0gITEpIHtcbiAgcmV0dXJuIGUgPyB7IGg6IE51bWJlcih0ICYgWmkpLCBsOiBOdW1iZXIodCA+PiBqYSAmIFppKSB9IDogeyBoOiBOdW1iZXIodCA+PiBqYSAmIFppKSB8IDAsIGw6IE51bWJlcih0ICYgWmkpIHwgMCB9O1xufVxuZnVuY3Rpb24gJDAodCwgZSA9ICExKSB7XG4gIGNvbnN0IHIgPSB0Lmxlbmd0aDtcbiAgbGV0IG4gPSBuZXcgVWludDMyQXJyYXkociksIG8gPSBuZXcgVWludDMyQXJyYXkocik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgY29uc3QgeyBoOiBjLCBsOiBmIH0gPSBEMCh0W2ldLCBlKTtcbiAgICBbbltpXSwgb1tpXV0gPSBbYywgZl07XG4gIH1cbiAgcmV0dXJuIFtuLCBvXTtcbn1cbmNvbnN0IFVhID0gKHQsIGUsIHIpID0+IHQgPj4+IHIsIEZhID0gKHQsIGUsIHIpID0+IHQgPDwgMzIgLSByIHwgZSA+Pj4gciwgeG4gPSAodCwgZSwgcikgPT4gdCA+Pj4gciB8IGUgPDwgMzIgLSByLCBibiA9ICh0LCBlLCByKSA9PiB0IDw8IDMyIC0gciB8IGUgPj4+IHIsIFZpID0gKHQsIGUsIHIpID0+IHQgPDwgNjQgLSByIHwgZSA+Pj4gciAtIDMyLCBIaSA9ICh0LCBlLCByKSA9PiB0ID4+PiByIC0gMzIgfCBlIDw8IDY0IC0gcjtcbmZ1bmN0aW9uIGhyKHQsIGUsIHIsIG4pIHtcbiAgY29uc3QgbyA9IChlID4+PiAwKSArIChuID4+PiAwKTtcbiAgcmV0dXJuIHsgaDogdCArIHIgKyAobyAvIDIgKiogMzIgfCAwKSB8IDAsIGw6IG8gfCAwIH07XG59XG5jb25zdCB6MCA9ICh0LCBlLCByKSA9PiAodCA+Pj4gMCkgKyAoZSA+Pj4gMCkgKyAociA+Pj4gMCksIHEwID0gKHQsIGUsIHIsIG4pID0+IGUgKyByICsgbiArICh0IC8gMiAqKiAzMiB8IDApIHwgMCwgWjAgPSAodCwgZSwgciwgbikgPT4gKHQgPj4+IDApICsgKGUgPj4+IDApICsgKHIgPj4+IDApICsgKG4gPj4+IDApLCBWMCA9ICh0LCBlLCByLCBuLCBvKSA9PiBlICsgciArIG4gKyBvICsgKHQgLyAyICoqIDMyIHwgMCkgfCAwLCBIMCA9ICh0LCBlLCByLCBuLCBvKSA9PiAodCA+Pj4gMCkgKyAoZSA+Pj4gMCkgKyAociA+Pj4gMCkgKyAobiA+Pj4gMCkgKyAobyA+Pj4gMCksIEswID0gKHQsIGUsIHIsIG4sIG8sIGkpID0+IGUgKyByICsgbiArIG8gKyBpICsgKHQgLyAyICoqIDMyIHwgMCkgfCAwLCBXMCA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgMTExNjM1MjQwOCxcbiAgMTg5OTQ0NzQ0MSxcbiAgMzA0OTMyMzQ3MSxcbiAgMzkyMTAwOTU3MyxcbiAgOTYxOTg3MTYzLFxuICAxNTA4OTcwOTkzLFxuICAyNDUzNjM1NzQ4LFxuICAyODcwNzYzMjIxLFxuICAzNjI0MzgxMDgwLFxuICAzMTA1OTg0MDEsXG4gIDYwNzIyNTI3OCxcbiAgMTQyNjg4MTk4NyxcbiAgMTkyNTA3ODM4OCxcbiAgMjE2MjA3ODIwNixcbiAgMjYxNDg4ODEwMyxcbiAgMzI0ODIyMjU4MCxcbiAgMzgzNTM5MDQwMSxcbiAgNDAyMjIyNDc3NCxcbiAgMjY0MzQ3MDc4LFxuICA2MDQ4MDc2MjgsXG4gIDc3MDI1NTk4MyxcbiAgMTI0OTE1MDEyMixcbiAgMTU1NTA4MTY5MixcbiAgMTk5NjA2NDk4NixcbiAgMjU1NDIyMDg4MixcbiAgMjgyMTgzNDM0OSxcbiAgMjk1Mjk5NjgwOCxcbiAgMzIxMDMxMzY3MSxcbiAgMzMzNjU3MTg5MSxcbiAgMzU4NDUyODcxMSxcbiAgMTEzOTI2OTkzLFxuICAzMzgyNDE4OTUsXG4gIDY2NjMwNzIwNSxcbiAgNzczNTI5OTEyLFxuICAxMjk0NzU3MzcyLFxuICAxMzk2MTgyMjkxLFxuICAxNjk1MTgzNzAwLFxuICAxOTg2NjYxMDUxLFxuICAyMTc3MDI2MzUwLFxuICAyNDU2OTU2MDM3LFxuICAyNzMwNDg1OTIxLFxuICAyODIwMzAyNDExLFxuICAzMjU5NzMwODAwLFxuICAzMzQ1NzY0NzcxLFxuICAzNTE2MDY1ODE3LFxuICAzNjAwMzUyODA0LFxuICA0MDk0NTcxOTA5LFxuICAyNzU0MjMzNDQsXG4gIDQzMDIyNzczNCxcbiAgNTA2OTQ4NjE2LFxuICA2NTkwNjA1NTYsXG4gIDg4Mzk5Nzg3NyxcbiAgOTU4MTM5NTcxLFxuICAxMzIyODIyMjE4LFxuICAxNTM3MDAyMDYzLFxuICAxNzQ3ODczNzc5LFxuICAxOTU1NTYyMjIyLFxuICAyMDI0MTA0ODE1LFxuICAyMjI3NzMwNDUyLFxuICAyMzYxODUyNDI0LFxuICAyNDI4NDM2NDc0LFxuICAyNzU2NzM0MTg3LFxuICAzMjA0MDMxNDc5LFxuICAzMzI5MzI1Mjk4XG5dKSwgRXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmxldCBHMCA9IGNsYXNzIGV4dGVuZHMgZmMge1xuICBjb25zdHJ1Y3RvcihlID0gMzIpIHtcbiAgICBzdXBlcig2NCwgZSwgOCwgITEpLCB0aGlzLkEgPSBfclswXSB8IDAsIHRoaXMuQiA9IF9yWzFdIHwgMCwgdGhpcy5DID0gX3JbMl0gfCAwLCB0aGlzLkQgPSBfclszXSB8IDAsIHRoaXMuRSA9IF9yWzRdIHwgMCwgdGhpcy5GID0gX3JbNV0gfCAwLCB0aGlzLkcgPSBfcls2XSB8IDAsIHRoaXMuSCA9IF9yWzddIHwgMDtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBOiBlLCBCOiByLCBDOiBuLCBEOiBvLCBFOiBpLCBGOiBjLCBHOiBmLCBIOiB2IH0gPSB0aGlzO1xuICAgIHJldHVybiBbZSwgciwgbiwgbywgaSwgYywgZiwgdl07XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHNldChlLCByLCBuLCBvLCBpLCBjLCBmLCB2KSB7XG4gICAgdGhpcy5BID0gZSB8IDAsIHRoaXMuQiA9IHIgfCAwLCB0aGlzLkMgPSBuIHwgMCwgdGhpcy5EID0gbyB8IDAsIHRoaXMuRSA9IGkgfCAwLCB0aGlzLkYgPSBjIHwgMCwgdGhpcy5HID0gZiB8IDAsIHRoaXMuSCA9IHYgfCAwO1xuICB9XG4gIHByb2Nlc3MoZSwgcikge1xuICAgIGZvciAobGV0IFMgPSAwOyBTIDwgMTY7IFMrKywgciArPSA0KVxuICAgICAgRXJbU10gPSBlLmdldFVpbnQzMihyLCAhMSk7XG4gICAgZm9yIChsZXQgUyA9IDE2OyBTIDwgNjQ7IFMrKykge1xuICAgICAgY29uc3QgVCA9IEVyW1MgLSAxNV0sIEMgPSBFcltTIC0gMl0sIFAgPSBRdChULCA3KSBeIFF0KFQsIDE4KSBeIFQgPj4+IDMsIEIgPSBRdChDLCAxNykgXiBRdChDLCAxOSkgXiBDID4+PiAxMDtcbiAgICAgIEVyW1NdID0gQiArIEVyW1MgLSA3XSArIFAgKyBFcltTIC0gMTZdIHwgMDtcbiAgICB9XG4gICAgbGV0IHsgQTogbiwgQjogbywgQzogaSwgRDogYywgRTogZiwgRjogdiwgRzogeCwgSDogYiB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBTID0gMDsgUyA8IDY0OyBTKyspIHtcbiAgICAgIGNvbnN0IFQgPSBRdChmLCA2KSBeIFF0KGYsIDExKSBeIFF0KGYsIDI1KSwgQyA9IGIgKyBUICsgRjAoZiwgdiwgeCkgKyBXMFtTXSArIEVyW1NdIHwgMCwgQiA9IChRdChuLCAyKSBeIFF0KG4sIDEzKSBeIFF0KG4sIDIyKSkgKyBQMChuLCBvLCBpKSB8IDA7XG4gICAgICBiID0geCwgeCA9IHYsIHYgPSBmLCBmID0gYyArIEMgfCAwLCBjID0gaSwgaSA9IG8sIG8gPSBuLCBuID0gQyArIEIgfCAwO1xuICAgIH1cbiAgICBuID0gbiArIHRoaXMuQSB8IDAsIG8gPSBvICsgdGhpcy5CIHwgMCwgaSA9IGkgKyB0aGlzLkMgfCAwLCBjID0gYyArIHRoaXMuRCB8IDAsIGYgPSBmICsgdGhpcy5FIHwgMCwgdiA9IHYgKyB0aGlzLkYgfCAwLCB4ID0geCArIHRoaXMuRyB8IDAsIGIgPSBiICsgdGhpcy5IIHwgMCwgdGhpcy5zZXQobiwgbywgaSwgYywgZiwgdiwgeCwgYik7XG4gIH1cbiAgcm91bmRDbGVhbigpIHtcbiAgICBPbihFcik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKSwgT24odGhpcy5idWZmZXIpO1xuICB9XG59O1xuY29uc3QgaGMgPSAkMChbXG4gIFwiMHg0MjhhMmY5OGQ3MjhhZTIyXCIsXG4gIFwiMHg3MTM3NDQ5MTIzZWY2NWNkXCIsXG4gIFwiMHhiNWMwZmJjZmVjNGQzYjJmXCIsXG4gIFwiMHhlOWI1ZGJhNTgxODlkYmJjXCIsXG4gIFwiMHgzOTU2YzI1YmYzNDhiNTM4XCIsXG4gIFwiMHg1OWYxMTFmMWI2MDVkMDE5XCIsXG4gIFwiMHg5MjNmODJhNGFmMTk0ZjliXCIsXG4gIFwiMHhhYjFjNWVkNWRhNmQ4MTE4XCIsXG4gIFwiMHhkODA3YWE5OGEzMDMwMjQyXCIsXG4gIFwiMHgxMjgzNWIwMTQ1NzA2ZmJlXCIsXG4gIFwiMHgyNDMxODViZTRlZTRiMjhjXCIsXG4gIFwiMHg1NTBjN2RjM2Q1ZmZiNGUyXCIsXG4gIFwiMHg3MmJlNWQ3NGYyN2I4OTZmXCIsXG4gIFwiMHg4MGRlYjFmZTNiMTY5NmIxXCIsXG4gIFwiMHg5YmRjMDZhNzI1YzcxMjM1XCIsXG4gIFwiMHhjMTliZjE3NGNmNjkyNjk0XCIsXG4gIFwiMHhlNDliNjljMTllZjE0YWQyXCIsXG4gIFwiMHhlZmJlNDc4NjM4NGYyNWUzXCIsXG4gIFwiMHgwZmMxOWRjNjhiOGNkNWI1XCIsXG4gIFwiMHgyNDBjYTFjYzc3YWM5YzY1XCIsXG4gIFwiMHgyZGU5MmM2ZjU5MmIwMjc1XCIsXG4gIFwiMHg0YTc0ODRhYTZlYTZlNDgzXCIsXG4gIFwiMHg1Y2IwYTlkY2JkNDFmYmQ0XCIsXG4gIFwiMHg3NmY5ODhkYTgzMTE1M2I1XCIsXG4gIFwiMHg5ODNlNTE1MmVlNjZkZmFiXCIsXG4gIFwiMHhhODMxYzY2ZDJkYjQzMjEwXCIsXG4gIFwiMHhiMDAzMjdjODk4ZmIyMTNmXCIsXG4gIFwiMHhiZjU5N2ZjN2JlZWYwZWU0XCIsXG4gIFwiMHhjNmUwMGJmMzNkYTg4ZmMyXCIsXG4gIFwiMHhkNWE3OTE0NzkzMGFhNzI1XCIsXG4gIFwiMHgwNmNhNjM1MWUwMDM4MjZmXCIsXG4gIFwiMHgxNDI5Mjk2NzBhMGU2ZTcwXCIsXG4gIFwiMHgyN2I3MGE4NTQ2ZDIyZmZjXCIsXG4gIFwiMHgyZTFiMjEzODVjMjZjOTI2XCIsXG4gIFwiMHg0ZDJjNmRmYzVhYzQyYWVkXCIsXG4gIFwiMHg1MzM4MGQxMzlkOTViM2RmXCIsXG4gIFwiMHg2NTBhNzM1NDhiYWY2M2RlXCIsXG4gIFwiMHg3NjZhMGFiYjNjNzdiMmE4XCIsXG4gIFwiMHg4MWMyYzkyZTQ3ZWRhZWU2XCIsXG4gIFwiMHg5MjcyMmM4NTE0ODIzNTNiXCIsXG4gIFwiMHhhMmJmZThhMTRjZjEwMzY0XCIsXG4gIFwiMHhhODFhNjY0YmJjNDIzMDAxXCIsXG4gIFwiMHhjMjRiOGI3MGQwZjg5NzkxXCIsXG4gIFwiMHhjNzZjNTFhMzA2NTRiZTMwXCIsXG4gIFwiMHhkMTkyZTgxOWQ2ZWY1MjE4XCIsXG4gIFwiMHhkNjk5MDYyNDU1NjVhOTEwXCIsXG4gIFwiMHhmNDBlMzU4NTU3NzEyMDJhXCIsXG4gIFwiMHgxMDZhYTA3MDMyYmJkMWI4XCIsXG4gIFwiMHgxOWE0YzExNmI4ZDJkMGM4XCIsXG4gIFwiMHgxZTM3NmMwODUxNDFhYjUzXCIsXG4gIFwiMHgyNzQ4Nzc0Y2RmOGVlYjk5XCIsXG4gIFwiMHgzNGIwYmNiNWUxOWI0OGE4XCIsXG4gIFwiMHgzOTFjMGNiM2M1Yzk1YTYzXCIsXG4gIFwiMHg0ZWQ4YWE0YWUzNDE4YWNiXCIsXG4gIFwiMHg1YjljY2E0Zjc3NjNlMzczXCIsXG4gIFwiMHg2ODJlNmZmM2Q2YjJiOGEzXCIsXG4gIFwiMHg3NDhmODJlZTVkZWZiMmZjXCIsXG4gIFwiMHg3OGE1NjM2ZjQzMTcyZjYwXCIsXG4gIFwiMHg4NGM4NzgxNGExZjBhYjcyXCIsXG4gIFwiMHg4Y2M3MDIwODFhNjQzOWVjXCIsXG4gIFwiMHg5MGJlZmZmYTIzNjMxZTI4XCIsXG4gIFwiMHhhNDUwNmNlYmRlODJiZGU5XCIsXG4gIFwiMHhiZWY5YTNmN2IyYzY3OTE1XCIsXG4gIFwiMHhjNjcxNzhmMmUzNzI1MzJiXCIsXG4gIFwiMHhjYTI3M2VjZWVhMjY2MTljXCIsXG4gIFwiMHhkMTg2YjhjNzIxYzBjMjA3XCIsXG4gIFwiMHhlYWRhN2RkNmNkZTBlYjFlXCIsXG4gIFwiMHhmNTdkNGY3ZmVlNmVkMTc4XCIsXG4gIFwiMHgwNmYwNjdhYTcyMTc2ZmJhXCIsXG4gIFwiMHgwYTYzN2RjNWEyYzg5OGE2XCIsXG4gIFwiMHgxMTNmOTgwNGJlZjkwZGFlXCIsXG4gIFwiMHgxYjcxMGIzNTEzMWM0NzFiXCIsXG4gIFwiMHgyOGRiNzdmNTIzMDQ3ZDg0XCIsXG4gIFwiMHgzMmNhYWI3YjQwYzcyNDkzXCIsXG4gIFwiMHgzYzllYmUwYTE1YzliZWJjXCIsXG4gIFwiMHg0MzFkNjdjNDljMTAwZDRjXCIsXG4gIFwiMHg0Y2M1ZDRiZWNiM2U0MmI2XCIsXG4gIFwiMHg1OTdmMjk5Y2ZjNjU3ZTJhXCIsXG4gIFwiMHg1ZmNiNmZhYjNhZDZmYWVjXCIsXG4gIFwiMHg2YzQ0MTk4YzRhNDc1ODE3XCJcbl0ubWFwKCh0KSA9PiBCaWdJbnQodCkpKSwgWTAgPSBoY1swXSwgSjAgPSBoY1sxXSwgTXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKSwgQ3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNsYXNzIFgwIGV4dGVuZHMgZmMge1xuICBjb25zdHJ1Y3RvcihlID0gNjQpIHtcbiAgICBzdXBlcigxMjgsIGUsIDE2LCAhMSksIHRoaXMuQWggPSBTdFswXSB8IDAsIHRoaXMuQWwgPSBTdFsxXSB8IDAsIHRoaXMuQmggPSBTdFsyXSB8IDAsIHRoaXMuQmwgPSBTdFszXSB8IDAsIHRoaXMuQ2ggPSBTdFs0XSB8IDAsIHRoaXMuQ2wgPSBTdFs1XSB8IDAsIHRoaXMuRGggPSBTdFs2XSB8IDAsIHRoaXMuRGwgPSBTdFs3XSB8IDAsIHRoaXMuRWggPSBTdFs4XSB8IDAsIHRoaXMuRWwgPSBTdFs5XSB8IDAsIHRoaXMuRmggPSBTdFsxMF0gfCAwLCB0aGlzLkZsID0gU3RbMTFdIHwgMCwgdGhpcy5HaCA9IFN0WzEyXSB8IDAsIHRoaXMuR2wgPSBTdFsxM10gfCAwLCB0aGlzLkhoID0gU3RbMTRdIHwgMCwgdGhpcy5IbCA9IFN0WzE1XSB8IDA7XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGdldCgpIHtcbiAgICBjb25zdCB7IEFoOiBlLCBBbDogciwgQmg6IG4sIEJsOiBvLCBDaDogaSwgQ2w6IGMsIERoOiBmLCBEbDogdiwgRWg6IHgsIEVsOiBiLCBGaDogUywgRmw6IFQsIEdoOiBDLCBHbDogUCwgSGg6IEIsIEhsOiBSIH0gPSB0aGlzO1xuICAgIHJldHVybiBbZSwgciwgbiwgbywgaSwgYywgZiwgdiwgeCwgYiwgUywgVCwgQywgUCwgQiwgUl07XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHNldChlLCByLCBuLCBvLCBpLCBjLCBmLCB2LCB4LCBiLCBTLCBULCBDLCBQLCBCLCBSKSB7XG4gICAgdGhpcy5BaCA9IGUgfCAwLCB0aGlzLkFsID0gciB8IDAsIHRoaXMuQmggPSBuIHwgMCwgdGhpcy5CbCA9IG8gfCAwLCB0aGlzLkNoID0gaSB8IDAsIHRoaXMuQ2wgPSBjIHwgMCwgdGhpcy5EaCA9IGYgfCAwLCB0aGlzLkRsID0gdiB8IDAsIHRoaXMuRWggPSB4IHwgMCwgdGhpcy5FbCA9IGIgfCAwLCB0aGlzLkZoID0gUyB8IDAsIHRoaXMuRmwgPSBUIHwgMCwgdGhpcy5HaCA9IEMgfCAwLCB0aGlzLkdsID0gUCB8IDAsIHRoaXMuSGggPSBCIHwgMCwgdGhpcy5IbCA9IFIgfCAwO1xuICB9XG4gIHByb2Nlc3MoZSwgcikge1xuICAgIGZvciAobGV0IFogPSAwOyBaIDwgMTY7IForKywgciArPSA0KVxuICAgICAgTXJbWl0gPSBlLmdldFVpbnQzMihyKSwgQ3JbWl0gPSBlLmdldFVpbnQzMihyICs9IDQpO1xuICAgIGZvciAobGV0IFogPSAxNjsgWiA8IDgwOyBaKyspIHtcbiAgICAgIGNvbnN0IFEgPSBNcltaIC0gMTVdIHwgMCwgaiA9IENyW1ogLSAxNV0gfCAwLCBWID0geG4oUSwgaiwgMSkgXiB4bihRLCBqLCA4KSBeIFVhKFEsIGosIDcpLCBlZSA9IGJuKFEsIGosIDEpIF4gYm4oUSwgaiwgOCkgXiBGYShRLCBqLCA3KSwgRyA9IE1yW1ogLSAyXSB8IDAsIE4gPSBDcltaIC0gMl0gfCAwLCBPID0geG4oRywgTiwgMTkpIF4gVmkoRywgTiwgNjEpIF4gVWEoRywgTiwgNiksIEwgPSBibihHLCBOLCAxOSkgXiBIaShHLCBOLCA2MSkgXiBGYShHLCBOLCA2KSwgRiA9IFowKGVlLCBMLCBDcltaIC0gN10sIENyW1ogLSAxNl0pLCBkID0gVjAoRiwgViwgTywgTXJbWiAtIDddLCBNcltaIC0gMTZdKTtcbiAgICAgIE1yW1pdID0gZCB8IDAsIENyW1pdID0gRiB8IDA7XG4gICAgfVxuICAgIGxldCB7IEFoOiBuLCBBbDogbywgQmg6IGksIEJsOiBjLCBDaDogZiwgQ2w6IHYsIERoOiB4LCBEbDogYiwgRWg6IFMsIEVsOiBULCBGaDogQywgRmw6IFAsIEdoOiBCLCBHbDogUiwgSGg6IHosIEhsOiBLIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IFogPSAwOyBaIDwgODA7IForKykge1xuICAgICAgY29uc3QgUSA9IHhuKFMsIFQsIDE0KSBeIHhuKFMsIFQsIDE4KSBeIFZpKFMsIFQsIDQxKSwgaiA9IGJuKFMsIFQsIDE0KSBeIGJuKFMsIFQsIDE4KSBeIEhpKFMsIFQsIDQxKSwgViA9IFMgJiBDIF4gflMgJiBCLCBlZSA9IFQgJiBQIF4gflQgJiBSLCBHID0gSDAoSywgaiwgZWUsIEowW1pdLCBDcltaXSksIE4gPSBLMChHLCB6LCBRLCBWLCBZMFtaXSwgTXJbWl0pLCBPID0gRyB8IDAsIEwgPSB4bihuLCBvLCAyOCkgXiBWaShuLCBvLCAzNCkgXiBWaShuLCBvLCAzOSksIEYgPSBibihuLCBvLCAyOCkgXiBIaShuLCBvLCAzNCkgXiBIaShuLCBvLCAzOSksIGQgPSBuICYgaSBeIG4gJiBmIF4gaSAmIGYsIHMgPSBvICYgYyBeIG8gJiB2IF4gYyAmIHY7XG4gICAgICB6ID0gQiB8IDAsIEsgPSBSIHwgMCwgQiA9IEMgfCAwLCBSID0gUCB8IDAsIEMgPSBTIHwgMCwgUCA9IFQgfCAwLCB7IGg6IFMsIGw6IFQgfSA9IGhyKHggfCAwLCBiIHwgMCwgTiB8IDAsIE8gfCAwKSwgeCA9IGYgfCAwLCBiID0gdiB8IDAsIGYgPSBpIHwgMCwgdiA9IGMgfCAwLCBpID0gbiB8IDAsIGMgPSBvIHwgMDtcbiAgICAgIGNvbnN0IHUgPSB6MChPLCBGLCBzKTtcbiAgICAgIG4gPSBxMCh1LCBOLCBMLCBkKSwgbyA9IHUgfCAwO1xuICAgIH1cbiAgICAoeyBoOiBuLCBsOiBvIH0gPSBocih0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIG4gfCAwLCBvIHwgMCkpLCB7IGg6IGksIGw6IGMgfSA9IGhyKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgaSB8IDAsIGMgfCAwKSwgeyBoOiBmLCBsOiB2IH0gPSBocih0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIGYgfCAwLCB2IHwgMCksIHsgaDogeCwgbDogYiB9ID0gaHIodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCB4IHwgMCwgYiB8IDApLCB7IGg6IFMsIGw6IFQgfSA9IGhyKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgUyB8IDAsIFQgfCAwKSwgeyBoOiBDLCBsOiBQIH0gPSBocih0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEMgfCAwLCBQIHwgMCksIHsgaDogQiwgbDogUiB9ID0gaHIodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBCIHwgMCwgUiB8IDApLCB7IGg6IHosIGw6IEsgfSA9IGhyKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgeiB8IDAsIEsgfCAwKSwgdGhpcy5zZXQobiwgbywgaSwgYywgZiwgdiwgeCwgYiwgUywgVCwgQywgUCwgQiwgUiwgeiwgSyk7XG4gIH1cbiAgcm91bmRDbGVhbigpIHtcbiAgICBPbihNciwgQ3IpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgT24odGhpcy5idWZmZXIpLCB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgfVxufVxuY29uc3QgUTAgPSAvKiBAX19QVVJFX18gKi8gY2MoKCkgPT4gbmV3IEcwKCkpLCBlaCA9IC8qIEBfX1BVUkVfXyAqLyBjYygoKSA9PiBuZXcgWDAoKSk7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBhYSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCksIExvID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmZ1bmN0aW9uIGZuKHQsIGUpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwiYm9vbGVhblwiKVxuICAgIHRocm93IG5ldyBFcnJvcih0ICsgXCIgYm9vbGVhbiBleHBlY3RlZCwgZ290IFwiICsgZSk7XG59XG5mdW5jdGlvbiBLaSh0KSB7XG4gIGNvbnN0IGUgPSB0LnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGUubGVuZ3RoICYgMSA/IFwiMFwiICsgZSA6IGU7XG59XG5mdW5jdGlvbiBkYyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBcIiArIHR5cGVvZiB0KTtcbiAgcmV0dXJuIHQgPT09IFwiXCIgPyBhYSA6IEJpZ0ludChcIjB4XCIgKyB0KTtcbn1cbmZ1bmN0aW9uIExzKHQpIHtcbiAgcmV0dXJuIGRjKE5uKHQpKTtcbn1cbmZ1bmN0aW9uIHdpKHQpIHtcbiAgcmV0dXJuIGFyKHQpLCBkYyhObihVaW50OEFycmF5LmZyb20odCkucmV2ZXJzZSgpKSk7XG59XG5mdW5jdGlvbiB1YSh0LCBlKSB7XG4gIHJldHVybiBzYSh0LnRvU3RyaW5nKDE2KS5wYWRTdGFydChlICogMiwgXCIwXCIpKTtcbn1cbmZ1bmN0aW9uIE9zKHQsIGUpIHtcbiAgcmV0dXJuIHVhKHQsIGUpLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHZ0KHQsIGUsIHIpIHtcbiAgbGV0IG47XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgIHRyeSB7XG4gICAgICBuID0gc2EoZSk7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQgKyBcIiBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY2F1c2U6IFwiICsgaSk7XG4gICAgfVxuICBlbHNlIGlmIChpYShlKSlcbiAgICBuID0gVWludDhBcnJheS5mcm9tKGUpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKHQgKyBcIiBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheVwiKTtcbiAgY29uc3QgbyA9IG4ubGVuZ3RoO1xuICBpZiAodHlwZW9mIHIgPT0gXCJudW1iZXJcIiAmJiBvICE9PSByKVxuICAgIHRocm93IG5ldyBFcnJvcih0ICsgXCIgb2YgbGVuZ3RoIFwiICsgciArIFwiIGV4cGVjdGVkLCBnb3QgXCIgKyBvKTtcbiAgcmV0dXJuIG47XG59XG5jb25zdCBHcyA9ICh0KSA9PiB0eXBlb2YgdCA9PSBcImJpZ2ludFwiICYmIGFhIDw9IHQ7XG5mdW5jdGlvbiB0aCh0LCBlLCByKSB7XG4gIHJldHVybiBHcyh0KSAmJiBHcyhlKSAmJiBHcyhyKSAmJiBlIDw9IHQgJiYgdCA8IHI7XG59XG5mdW5jdGlvbiBTbih0LCBlLCByLCBuKSB7XG4gIGlmICghdGgoZSwgciwgbikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgdmFsaWQgXCIgKyB0ICsgXCI6IFwiICsgciArIFwiIDw9IG4gPCBcIiArIG4gKyBcIiwgZ290IFwiICsgZSk7XG59XG5mdW5jdGlvbiByaCh0KSB7XG4gIGxldCBlO1xuICBmb3IgKGUgPSAwOyB0ID4gYWE7IHQgPj49IExvLCBlICs9IDEpXG4gICAgO1xuICByZXR1cm4gZTtcbn1cbmNvbnN0IE5zID0gKHQpID0+IChMbyA8PCBCaWdJbnQodCkpIC0gTG87XG5mdW5jdGlvbiBuaCh0LCBlLCByKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcIm51bWJlclwiIHx8IHQgPCAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhhc2hMZW4gbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIgfHwgZSA8IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgaWYgKHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICBjb25zdCBuID0gKEMpID0+IG5ldyBVaW50OEFycmF5KEMpLCBvID0gKEMpID0+IFVpbnQ4QXJyYXkub2YoQyk7XG4gIGxldCBpID0gbih0KSwgYyA9IG4odCksIGYgPSAwO1xuICBjb25zdCB2ID0gKCkgPT4ge1xuICAgIGkuZmlsbCgxKSwgYy5maWxsKDApLCBmID0gMDtcbiAgfSwgeCA9ICguLi5DKSA9PiByKGMsIGksIC4uLkMpLCBiID0gKEMgPSBuKDApKSA9PiB7XG4gICAgYyA9IHgobygwKSwgQyksIGkgPSB4KCksIEMubGVuZ3RoICE9PSAwICYmIChjID0geChvKDEpLCBDKSwgaSA9IHgoKSk7XG4gIH0sIFMgPSAoKSA9PiB7XG4gICAgaWYgKGYrKyA+PSAxZTMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkcmJnOiB0cmllZCAxMDAwIHZhbHVlc1wiKTtcbiAgICBsZXQgQyA9IDA7XG4gICAgY29uc3QgUCA9IFtdO1xuICAgIGZvciAoOyBDIDwgZTsgKSB7XG4gICAgICBpID0geCgpO1xuICAgICAgY29uc3QgQiA9IGkuc2xpY2UoKTtcbiAgICAgIFAucHVzaChCKSwgQyArPSBpLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHZyKC4uLlApO1xuICB9O1xuICByZXR1cm4gKEMsIFApID0+IHtcbiAgICB2KCksIGIoQyk7XG4gICAgbGV0IEI7XG4gICAgZm9yICg7ICEoQiA9IFAoUygpKSk7IClcbiAgICAgIGIoKTtcbiAgICByZXR1cm4gdigpLCBCO1xuICB9O1xufVxuZnVuY3Rpb24gVWkodCwgZSwgciA9IHt9KSB7XG4gIGlmICghdCB8fCB0eXBlb2YgdCAhPSBcIm9iamVjdFwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHZhbGlkIG9wdGlvbnMgb2JqZWN0XCIpO1xuICBmdW5jdGlvbiBuKG8sIGksIGMpIHtcbiAgICBjb25zdCBmID0gdFtvXTtcbiAgICBpZiAoYyAmJiBmID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdiA9IHR5cGVvZiBmO1xuICAgIGlmICh2ICE9PSBpIHx8IGYgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmFtIFwiJHtvfVwiIGlzIGludmFsaWQ6IGV4cGVjdGVkICR7aX0sIGdvdCAke3Z9YCk7XG4gIH1cbiAgT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW28sIGldKSA9PiBuKG8sIGksICExKSksIE9iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goKFtvLCBpXSkgPT4gbihvLCBpLCAhMCkpO1xufVxuZnVuY3Rpb24gbXModCkge1xuICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiAociwgLi4ubikgPT4ge1xuICAgIGNvbnN0IG8gPSBlLmdldChyKTtcbiAgICBpZiAobyAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG87XG4gICAgY29uc3QgaSA9IHQociwgLi4ubik7XG4gICAgcmV0dXJuIGUuc2V0KHIsIGkpLCBpO1xuICB9O1xufVxuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgRnQgPSBCaWdJbnQoMCksIEN0ID0gQmlnSW50KDEpLCBzbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiksIGloID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKSwgcGMgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDQpLCBtYyA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNSksIGdjID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KTtcbmZ1bmN0aW9uIHd0KHQsIGUpIHtcbiAgY29uc3QgciA9IHQgJSBlO1xuICByZXR1cm4gciA+PSBGdCA/IHIgOiBlICsgcjtcbn1cbmZ1bmN0aW9uIHB0KHQsIGUsIHIpIHtcbiAgbGV0IG4gPSB0O1xuICBmb3IgKDsgZS0tID4gRnQ7IClcbiAgICBuICo9IG4sIG4gJT0gcjtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBQYSh0LCBlKSB7XG4gIGlmICh0ID09PSBGdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlcnQ6IGV4cGVjdGVkIG5vbi16ZXJvIG51bWJlclwiKTtcbiAgaWYgKGUgPD0gRnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBtb2R1bHVzLCBnb3QgXCIgKyBlKTtcbiAgbGV0IHIgPSB3dCh0LCBlKSwgbiA9IGUsIG8gPSBGdCwgaSA9IEN0O1xuICBmb3IgKDsgciAhPT0gRnQ7ICkge1xuICAgIGNvbnN0IGYgPSBuIC8gciwgdiA9IG4gJSByLCB4ID0gbyAtIGkgKiBmO1xuICAgIG4gPSByLCByID0gdiwgbyA9IGksIGkgPSB4O1xuICB9XG4gIGlmIChuICE9PSBDdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlcnQ6IGRvZXMgbm90IGV4aXN0XCIpO1xuICByZXR1cm4gd3QobywgZSk7XG59XG5mdW5jdGlvbiB5Yyh0LCBlKSB7XG4gIGNvbnN0IHIgPSAodC5PUkRFUiArIEN0KSAvIHBjLCBuID0gdC5wb3coZSwgcik7XG4gIGlmICghdC5lcWwodC5zcXIobiksIGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHNoKHQsIGUpIHtcbiAgY29uc3QgciA9ICh0Lk9SREVSIC0gbWMpIC8gZ2MsIG4gPSB0Lm11bChlLCBzbiksIG8gPSB0LnBvdyhuLCByKSwgaSA9IHQubXVsKGUsIG8pLCBjID0gdC5tdWwodC5tdWwoaSwgc24pLCBvKSwgZiA9IHQubXVsKGksIHQuc3ViKGMsIHQuT05FKSk7XG4gIGlmICghdC5lcWwodC5zcXIoZiksIGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICByZXR1cm4gZjtcbn1cbmZ1bmN0aW9uIG9oKHQpIHtcbiAgaWYgKHQgPCBCaWdJbnQoMykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3FydCBpcyBub3QgZGVmaW5lZCBmb3Igc21hbGwgZmllbGRcIik7XG4gIGxldCBlID0gdCAtIEN0LCByID0gMDtcbiAgZm9yICg7IGUgJSBzbiA9PT0gRnQ7IClcbiAgICBlIC89IHNuLCByKys7XG4gIGxldCBuID0gc247XG4gIGNvbnN0IG8gPSAkbih0KTtcbiAgZm9yICg7IERhKG8sIG4pID09PSAxOyApXG4gICAgaWYgKG4rKyA+IDFlMylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290OiBwcm9iYWJseSBub24tcHJpbWUgUFwiKTtcbiAgaWYgKHIgPT09IDEpXG4gICAgcmV0dXJuIHljO1xuICBsZXQgaSA9IG8ucG93KG4sIGUpO1xuICBjb25zdCBjID0gKGUgKyBDdCkgLyBzbjtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYsIHgpIHtcbiAgICBpZiAodi5pczAoeCkpXG4gICAgICByZXR1cm4geDtcbiAgICBpZiAoRGEodiwgeCkgIT09IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcbiAgICBsZXQgYiA9IHIsIFMgPSB2Lm11bCh2Lk9ORSwgaSksIFQgPSB2LnBvdyh4LCBlKSwgQyA9IHYucG93KHgsIGMpO1xuICAgIGZvciAoOyAhdi5lcWwoVCwgdi5PTkUpOyApIHtcbiAgICAgIGlmICh2LmlzMChUKSlcbiAgICAgICAgcmV0dXJuIHYuWkVSTztcbiAgICAgIGxldCBQID0gMSwgQiA9IHYuc3FyKFQpO1xuICAgICAgZm9yICg7ICF2LmVxbChCLCB2Lk9ORSk7IClcbiAgICAgICAgaWYgKFArKywgQiA9IHYuc3FyKEIpLCBQID09PSBiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICAgICAgY29uc3QgUiA9IEN0IDw8IEJpZ0ludChiIC0gUCAtIDEpLCB6ID0gdi5wb3coUywgUik7XG4gICAgICBiID0gUCwgUyA9IHYuc3FyKHopLCBUID0gdi5tdWwoVCwgUyksIEMgPSB2Lm11bChDLCB6KTtcbiAgICB9XG4gICAgcmV0dXJuIEM7XG4gIH07XG59XG5mdW5jdGlvbiBhaCh0KSB7XG4gIHJldHVybiB0ICUgcGMgPT09IGloID8geWMgOiB0ICUgZ2MgPT09IG1jID8gc2ggOiBvaCh0KTtcbn1cbmNvbnN0IHVoID0gKHQsIGUpID0+ICh3dCh0LCBlKSAmIEN0KSA9PT0gQ3QsIGNoID0gW1xuICBcImNyZWF0ZVwiLFxuICBcImlzVmFsaWRcIixcbiAgXCJpczBcIixcbiAgXCJuZWdcIixcbiAgXCJpbnZcIixcbiAgXCJzcXJ0XCIsXG4gIFwic3FyXCIsXG4gIFwiZXFsXCIsXG4gIFwiYWRkXCIsXG4gIFwic3ViXCIsXG4gIFwibXVsXCIsXG4gIFwicG93XCIsXG4gIFwiZGl2XCIsXG4gIFwiYWRkTlwiLFxuICBcInN1Yk5cIixcbiAgXCJtdWxOXCIsXG4gIFwic3FyTlwiXG5dO1xuZnVuY3Rpb24gbGgodCkge1xuICBjb25zdCBlID0ge1xuICAgIE9SREVSOiBcImJpZ2ludFwiLFxuICAgIE1BU0s6IFwiYmlnaW50XCIsXG4gICAgQllURVM6IFwibnVtYmVyXCIsXG4gICAgQklUUzogXCJudW1iZXJcIlxuICB9LCByID0gY2gucmVkdWNlKChuLCBvKSA9PiAobltvXSA9IFwiZnVuY3Rpb25cIiwgbiksIGUpO1xuICByZXR1cm4gVWkodCwgciksIHQ7XG59XG5mdW5jdGlvbiBmaCh0LCBlLCByKSB7XG4gIGlmIChyIDwgRnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkXCIpO1xuICBpZiAociA9PT0gRnQpXG4gICAgcmV0dXJuIHQuT05FO1xuICBpZiAociA9PT0gQ3QpXG4gICAgcmV0dXJuIGU7XG4gIGxldCBuID0gdC5PTkUsIG8gPSBlO1xuICBmb3IgKDsgciA+IEZ0OyApXG4gICAgciAmIEN0ICYmIChuID0gdC5tdWwobiwgbykpLCBvID0gdC5zcXIobyksIHIgPj49IEN0O1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHZjKHQsIGUsIHIgPSAhMSkge1xuICBjb25zdCBuID0gbmV3IEFycmF5KGUubGVuZ3RoKS5maWxsKHIgPyB0LlpFUk8gOiB2b2lkIDApLCBvID0gZS5yZWR1Y2UoKGMsIGYsIHYpID0+IHQuaXMwKGYpID8gYyA6IChuW3ZdID0gYywgdC5tdWwoYywgZikpLCB0Lk9ORSksIGkgPSB0LmludihvKTtcbiAgcmV0dXJuIGUucmVkdWNlUmlnaHQoKGMsIGYsIHYpID0+IHQuaXMwKGYpID8gYyA6IChuW3ZdID0gdC5tdWwoYywgblt2XSksIHQubXVsKGMsIGYpKSwgaSksIG47XG59XG5mdW5jdGlvbiBEYSh0LCBlKSB7XG4gIGNvbnN0IHIgPSAodC5PUkRFUiAtIEN0KSAvIHNuLCBuID0gdC5wb3coZSwgciksIG8gPSB0LmVxbChuLCB0Lk9ORSksIGkgPSB0LmVxbChuLCB0LlpFUk8pLCBjID0gdC5lcWwobiwgdC5uZWcodC5PTkUpKTtcbiAgaWYgKCFvICYmICFpICYmICFjKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTGVnZW5kcmUgc3ltYm9sIHJlc3VsdFwiKTtcbiAgcmV0dXJuIG8gPyAxIDogaSA/IDAgOiAtMTtcbn1cbmZ1bmN0aW9uIGhoKHQsIGUpIHtcbiAgZSAhPT0gdm9pZCAwICYmIFRvKGUpO1xuICBjb25zdCByID0gZSAhPT0gdm9pZCAwID8gZSA6IHQudG9TdHJpbmcoMikubGVuZ3RoLCBuID0gTWF0aC5jZWlsKHIgLyA4KTtcbiAgcmV0dXJuIHsgbkJpdExlbmd0aDogciwgbkJ5dGVMZW5ndGg6IG4gfTtcbn1cbmZ1bmN0aW9uICRuKHQsIGUsIHIgPSAhMSwgbiA9IHt9KSB7XG4gIGlmICh0IDw9IEZ0KVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290IFwiICsgdCk7XG4gIGxldCBvLCBpO1xuICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9IG51bGwpIHtcbiAgICBpZiAobi5zcXJ0IHx8IHIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3Qgc3BlY2lmeSBvcHRzIGluIHR3byBhcmd1bWVudHNcIik7XG4gICAgY29uc3QgYiA9IGU7XG4gICAgYi5CSVRTICYmIChvID0gYi5CSVRTKSwgYi5zcXJ0ICYmIChpID0gYi5zcXJ0KSwgdHlwZW9mIGIuaXNMRSA9PSBcImJvb2xlYW5cIiAmJiAociA9IGIuaXNMRSk7XG4gIH0gZWxzZVxuICAgIHR5cGVvZiBlID09IFwibnVtYmVyXCIgJiYgKG8gPSBlKSwgbi5zcXJ0ICYmIChpID0gbi5zcXJ0KTtcbiAgY29uc3QgeyBuQml0TGVuZ3RoOiBjLCBuQnl0ZUxlbmd0aDogZiB9ID0gaGgodCwgbyk7XG4gIGlmIChmID4gMjA0OClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzXCIpO1xuICBsZXQgdjtcbiAgY29uc3QgeCA9IE9iamVjdC5mcmVlemUoe1xuICAgIE9SREVSOiB0LFxuICAgIGlzTEU6IHIsXG4gICAgQklUUzogYyxcbiAgICBCWVRFUzogZixcbiAgICBNQVNLOiBOcyhjKSxcbiAgICBaRVJPOiBGdCxcbiAgICBPTkU6IEN0LFxuICAgIGNyZWF0ZTogKGIpID0+IHd0KGIsIHQpLFxuICAgIGlzVmFsaWQ6IChiKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGIgIT0gXCJiaWdpbnRcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCBcIiArIHR5cGVvZiBiKTtcbiAgICAgIHJldHVybiBGdCA8PSBiICYmIGIgPCB0O1xuICAgIH0sXG4gICAgaXMwOiAoYikgPT4gYiA9PT0gRnQsXG4gICAgLy8gaXMgdmFsaWQgYW5kIGludmVydGlibGVcbiAgICBpc1ZhbGlkTm90MDogKGIpID0+ICF4LmlzMChiKSAmJiB4LmlzVmFsaWQoYiksXG4gICAgaXNPZGQ6IChiKSA9PiAoYiAmIEN0KSA9PT0gQ3QsXG4gICAgbmVnOiAoYikgPT4gd3QoLWIsIHQpLFxuICAgIGVxbDogKGIsIFMpID0+IGIgPT09IFMsXG4gICAgc3FyOiAoYikgPT4gd3QoYiAqIGIsIHQpLFxuICAgIGFkZDogKGIsIFMpID0+IHd0KGIgKyBTLCB0KSxcbiAgICBzdWI6IChiLCBTKSA9PiB3dChiIC0gUywgdCksXG4gICAgbXVsOiAoYiwgUykgPT4gd3QoYiAqIFMsIHQpLFxuICAgIHBvdzogKGIsIFMpID0+IGZoKHgsIGIsIFMpLFxuICAgIGRpdjogKGIsIFMpID0+IHd0KGIgKiBQYShTLCB0KSwgdCksXG4gICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgc3FyTjogKGIpID0+IGIgKiBiLFxuICAgIGFkZE46IChiLCBTKSA9PiBiICsgUyxcbiAgICBzdWJOOiAoYiwgUykgPT4gYiAtIFMsXG4gICAgbXVsTjogKGIsIFMpID0+IGIgKiBTLFxuICAgIGludjogKGIpID0+IFBhKGIsIHQpLFxuICAgIHNxcnQ6IGkgfHwgKChiKSA9PiAodiB8fCAodiA9IGFoKHQpKSwgdih4LCBiKSkpLFxuICAgIHRvQnl0ZXM6IChiKSA9PiByID8gT3MoYiwgZikgOiB1YShiLCBmKSxcbiAgICBmcm9tQnl0ZXM6IChiKSA9PiB7XG4gICAgICBpZiAoYi5sZW5ndGggIT09IGYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgXCIgKyBmICsgXCIgYnl0ZXMsIGdvdCBcIiArIGIubGVuZ3RoKTtcbiAgICAgIHJldHVybiByID8gd2koYikgOiBMcyhiKTtcbiAgICB9LFxuICAgIC8vIFRPRE86IHdlIGRvbid0IG5lZWQgaXQgaGVyZSwgbW92ZSBvdXQgdG8gc2VwYXJhdGUgZm5cbiAgICBpbnZlcnRCYXRjaDogKGIpID0+IHZjKHgsIGIpLFxuICAgIC8vIFdlIGNhbid0IG1vdmUgdGhpcyBvdXQgYmVjYXVzZSBGcDYsIEZwMTIgaW1wbGVtZW50IGl0XG4gICAgLy8gYW5kIGl0J3MgdW5jbGVhciB3aGF0IHRvIHJldHVybiBpbiB0aGVyZS5cbiAgICBjbW92OiAoYiwgUywgVCkgPT4gVCA/IFMgOiBiXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh4KTtcbn1cbmZ1bmN0aW9uIHdjKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiYmlnaW50XCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnRcIik7XG4gIGNvbnN0IGUgPSB0LnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGguY2VpbChlIC8gOCk7XG59XG5mdW5jdGlvbiB4Yyh0KSB7XG4gIGNvbnN0IGUgPSB3Yyh0KTtcbiAgcmV0dXJuIGUgKyBNYXRoLmNlaWwoZSAvIDIpO1xufVxuZnVuY3Rpb24gZGgodCwgZSwgciA9ICExKSB7XG4gIGNvbnN0IG4gPSB0Lmxlbmd0aCwgbyA9IHdjKGUpLCBpID0geGMoZSk7XG4gIGlmIChuIDwgMTYgfHwgbiA8IGkgfHwgbiA+IDEwMjQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgXCIgKyBpICsgXCItMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290IFwiICsgbik7XG4gIGNvbnN0IGMgPSByID8gd2kodCkgOiBMcyh0KSwgZiA9IHd0KGMsIGUgLSBDdCkgKyBDdDtcbiAgcmV0dXJuIHIgPyBPcyhmLCBvKSA6IHVhKGYsIG8pO1xufVxuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3Qgam4gPSBCaWdJbnQoMCksIG9uID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gbmkodCwgZSkge1xuICBjb25zdCByID0gZS5uZWdhdGUoKTtcbiAgcmV0dXJuIHQgPyByIDogZTtcbn1cbmZ1bmN0aW9uIGJjKHQsIGUsIHIpIHtcbiAgY29uc3QgbiA9IGUgPT09IFwicHpcIiA/IChjKSA9PiBjLnB6IDogKGMpID0+IGMuZXosIG8gPSB2Yyh0LkZwLCByLm1hcChuKSk7XG4gIHJldHVybiByLm1hcCgoYywgZikgPT4gYy50b0FmZmluZShvW2ZdKSkubWFwKHQuZnJvbUFmZmluZSk7XG59XG5mdW5jdGlvbiBfYyh0LCBlKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodCkgfHwgdCA8PSAwIHx8IHQgPiBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi5cIiArIGUgKyBcIl0sIGdvdCBXPVwiICsgdCk7XG59XG5mdW5jdGlvbiBZcyh0LCBlKSB7XG4gIF9jKHQsIGUpO1xuICBjb25zdCByID0gTWF0aC5jZWlsKGUgLyB0KSArIDEsIG4gPSAyICoqICh0IC0gMSksIG8gPSAyICoqIHQsIGkgPSBOcyh0KSwgYyA9IEJpZ0ludCh0KTtcbiAgcmV0dXJuIHsgd2luZG93czogciwgd2luZG93U2l6ZTogbiwgbWFzazogaSwgbWF4TnVtYmVyOiBvLCBzaGlmdEJ5OiBjIH07XG59XG5mdW5jdGlvbiAkYSh0LCBlLCByKSB7XG4gIGNvbnN0IHsgd2luZG93U2l6ZTogbiwgbWFzazogbywgbWF4TnVtYmVyOiBpLCBzaGlmdEJ5OiBjIH0gPSByO1xuICBsZXQgZiA9IE51bWJlcih0ICYgbyksIHYgPSB0ID4+IGM7XG4gIGYgPiBuICYmIChmIC09IGksIHYgKz0gb24pO1xuICBjb25zdCB4ID0gZSAqIG4sIGIgPSB4ICsgTWF0aC5hYnMoZikgLSAxLCBTID0gZiA9PT0gMCwgVCA9IGYgPCAwLCBDID0gZSAlIDIgIT09IDA7XG4gIHJldHVybiB7IG5leHROOiB2LCBvZmZzZXQ6IGIsIGlzWmVybzogUywgaXNOZWc6IFQsIGlzTmVnRjogQywgb2Zmc2V0RjogeCB9O1xufVxuZnVuY3Rpb24gcGgodCwgZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgZXhwZWN0ZWRcIik7XG4gIHQuZm9yRWFjaCgociwgbikgPT4ge1xuICAgIGlmICghKHIgaW5zdGFuY2VvZiBlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgYXQgaW5kZXggXCIgKyBuKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtaCh0LCBlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkXCIpO1xuICB0LmZvckVhY2goKHIsIG4pID0+IHtcbiAgICBpZiAoIWUuaXNWYWxpZChyKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2NhbGFyIGF0IGluZGV4IFwiICsgbik7XG4gIH0pO1xufVxuY29uc3QgSnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgRWMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIFhzKHQpIHtcbiAgcmV0dXJuIEVjLmdldCh0KSB8fCAxO1xufVxuZnVuY3Rpb24gemEodCkge1xuICBpZiAodCAhPT0gam4pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB3TkFGXCIpO1xufVxuZnVuY3Rpb24gTWModCwgZSkge1xuICByZXR1cm4ge1xuICAgIGNvbnN0VGltZU5lZ2F0ZTogbmksXG4gICAgaGFzUHJlY29tcHV0ZXMocikge1xuICAgICAgcmV0dXJuIFhzKHIpICE9PSAxO1xuICAgIH0sXG4gICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgdW5zYWZlTGFkZGVyKHIsIG4sIG8gPSB0LlpFUk8pIHtcbiAgICAgIGxldCBpID0gcjtcbiAgICAgIGZvciAoOyBuID4gam47IClcbiAgICAgICAgbiAmIG9uICYmIChvID0gby5hZGQoaSkpLCBpID0gaS5kb3VibGUoKSwgbiA+Pj0gb247XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICogQHBhcmFtIGVsbSBQb2ludCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAqL1xuICAgIHByZWNvbXB1dGVXaW5kb3cociwgbikge1xuICAgICAgY29uc3QgeyB3aW5kb3dzOiBvLCB3aW5kb3dTaXplOiBpIH0gPSBZcyhuLCBlKSwgYyA9IFtdO1xuICAgICAgbGV0IGYgPSByLCB2ID0gZjtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbzsgeCsrKSB7XG4gICAgICAgIHYgPSBmLCBjLnB1c2godik7XG4gICAgICAgIGZvciAobGV0IGIgPSAxOyBiIDwgaTsgYisrKVxuICAgICAgICAgIHYgPSB2LmFkZChmKSwgYy5wdXNoKHYpO1xuICAgICAgICBmID0gdi5kb3VibGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAqL1xuICAgIHdOQUYociwgbiwgbykge1xuICAgICAgbGV0IGkgPSB0LlpFUk8sIGMgPSB0LkJBU0U7XG4gICAgICBjb25zdCBmID0gWXMociwgZSk7XG4gICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IGYud2luZG93czsgdisrKSB7XG4gICAgICAgIGNvbnN0IHsgbmV4dE46IHgsIG9mZnNldDogYiwgaXNaZXJvOiBTLCBpc05lZzogVCwgaXNOZWdGOiBDLCBvZmZzZXRGOiBQIH0gPSAkYShvLCB2LCBmKTtcbiAgICAgICAgbyA9IHgsIFMgPyBjID0gYy5hZGQobmkoQywgbltQXSkpIDogaSA9IGkuYWRkKG5pKFQsIG5bYl0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB6YShvKSwgeyBwOiBpLCBmOiBjIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGVjIHVuc2FmZSAobm9uIGNvbnN0LXRpbWUpIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgKiBAcGFyYW0gYWNjIGFjY3VtdWxhdG9yIHBvaW50IHRvIGFkZCByZXN1bHQgb2YgbXVsdGlwbGljYXRpb25cbiAgICAgKiBAcmV0dXJucyBwb2ludFxuICAgICAqL1xuICAgIHdOQUZVbnNhZmUociwgbiwgbywgaSA9IHQuWkVSTykge1xuICAgICAgY29uc3QgYyA9IFlzKHIsIGUpO1xuICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCBjLndpbmRvd3MgJiYgbyAhPT0gam47IGYrKykge1xuICAgICAgICBjb25zdCB7IG5leHROOiB2LCBvZmZzZXQ6IHgsIGlzWmVybzogYiwgaXNOZWc6IFMgfSA9ICRhKG8sIGYsIGMpO1xuICAgICAgICBpZiAobyA9IHYsICFiKSB7XG4gICAgICAgICAgY29uc3QgVCA9IG5beF07XG4gICAgICAgICAgaSA9IGkuYWRkKFMgPyBULm5lZ2F0ZSgpIDogVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB6YShvKSwgaTtcbiAgICB9LFxuICAgIGdldFByZWNvbXB1dGVzKHIsIG4sIG8pIHtcbiAgICAgIGxldCBpID0gSnMuZ2V0KG4pO1xuICAgICAgcmV0dXJuIGkgfHwgKGkgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3cobiwgciksIHIgIT09IDEgJiYgKHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiAmJiAoaSA9IG8oaSkpLCBKcy5zZXQobiwgaSkpKSwgaTtcbiAgICB9LFxuICAgIHdOQUZDYWNoZWQociwgbiwgbykge1xuICAgICAgY29uc3QgaSA9IFhzKHIpO1xuICAgICAgcmV0dXJuIHRoaXMud05BRihpLCB0aGlzLmdldFByZWNvbXB1dGVzKGksIHIsIG8pLCBuKTtcbiAgICB9LFxuICAgIHdOQUZDYWNoZWRVbnNhZmUociwgbiwgbywgaSkge1xuICAgICAgY29uc3QgYyA9IFhzKHIpO1xuICAgICAgcmV0dXJuIGMgPT09IDEgPyB0aGlzLnVuc2FmZUxhZGRlcihyLCBuLCBpKSA6IHRoaXMud05BRlVuc2FmZShjLCB0aGlzLmdldFByZWNvbXB1dGVzKGMsIHIsIG8pLCBuLCBpKTtcbiAgICB9LFxuICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgIHNldFdpbmRvd1NpemUociwgbikge1xuICAgICAgX2MobiwgZSksIEVjLnNldChyLCBuKSwgSnMuZGVsZXRlKHIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdoKHQsIGUsIHIsIG4pIHtcbiAgbGV0IG8gPSBlLCBpID0gdC5aRVJPLCBjID0gdC5aRVJPO1xuICBmb3IgKDsgciA+IGpuIHx8IG4gPiBqbjsgKVxuICAgIHIgJiBvbiAmJiAoaSA9IGkuYWRkKG8pKSwgbiAmIG9uICYmIChjID0gYy5hZGQobykpLCBvID0gby5kb3VibGUoKSwgciA+Pj0gb24sIG4gPj49IG9uO1xuICByZXR1cm4geyBwMTogaSwgcDI6IGMgfTtcbn1cbmZ1bmN0aW9uIENjKHQsIGUsIHIsIG4pIHtcbiAgcGgociwgdCksIG1oKG4sIGUpO1xuICBjb25zdCBvID0gci5sZW5ndGgsIGkgPSBuLmxlbmd0aDtcbiAgaWYgKG8gIT09IGkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXlzIG9mIHBvaW50cyBhbmQgc2NhbGFycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoXCIpO1xuICBjb25zdCBjID0gdC5aRVJPLCBmID0gcmgoQmlnSW50KG8pKTtcbiAgbGV0IHYgPSAxO1xuICBmID4gMTIgPyB2ID0gZiAtIDMgOiBmID4gNCA/IHYgPSBmIC0gMiA6IGYgPiAwICYmICh2ID0gMik7XG4gIGNvbnN0IHggPSBOcyh2KSwgYiA9IG5ldyBBcnJheShOdW1iZXIoeCkgKyAxKS5maWxsKGMpLCBTID0gTWF0aC5mbG9vcigoZS5CSVRTIC0gMSkgLyB2KSAqIHY7XG4gIGxldCBUID0gYztcbiAgZm9yIChsZXQgQyA9IFM7IEMgPj0gMDsgQyAtPSB2KSB7XG4gICAgYi5maWxsKGMpO1xuICAgIGZvciAobGV0IEIgPSAwOyBCIDwgaTsgQisrKSB7XG4gICAgICBjb25zdCBSID0gbltCXSwgeiA9IE51bWJlcihSID4+IEJpZ0ludChDKSAmIHgpO1xuICAgICAgYlt6XSA9IGJbel0uYWRkKHJbQl0pO1xuICAgIH1cbiAgICBsZXQgUCA9IGM7XG4gICAgZm9yIChsZXQgQiA9IGIubGVuZ3RoIC0gMSwgUiA9IGM7IEIgPiAwOyBCLS0pXG4gICAgICBSID0gUi5hZGQoYltCXSksIFAgPSBQLmFkZChSKTtcbiAgICBpZiAoVCA9IFQuYWRkKFApLCBDICE9PSAwKVxuICAgICAgZm9yIChsZXQgQiA9IDA7IEIgPCB2OyBCKyspXG4gICAgICAgIFQgPSBULmRvdWJsZSgpO1xuICB9XG4gIHJldHVybiBUO1xufVxuZnVuY3Rpb24gcWEodCwgZSkge1xuICBpZiAoZSkge1xuICAgIGlmIChlLk9SREVSICE9PSB0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQuT1JERVIgbXVzdCBtYXRjaCBvcmRlcjogRnAgPT0gcCwgRm4gPT0gblwiKTtcbiAgICByZXR1cm4gbGgoZSksIGU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAkbih0KTtcbn1cbmZ1bmN0aW9uIFNjKHQsIGUsIHIgPSB7fSkge1xuICBpZiAoIWUgfHwgdHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHZhbGlkICR7dH0gQ1VSVkUgb2JqZWN0YCk7XG4gIGZvciAoY29uc3QgZiBvZiBbXCJwXCIsIFwiblwiLCBcImhcIl0pIHtcbiAgICBjb25zdCB2ID0gZVtmXTtcbiAgICBpZiAoISh0eXBlb2YgdiA9PSBcImJpZ2ludFwiICYmIHYgPiBqbikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENVUlZFLiR7Zn0gbXVzdCBiZSBwb3NpdGl2ZSBiaWdpbnRgKTtcbiAgfVxuICBjb25zdCBuID0gcWEoZS5wLCByLkZwKSwgbyA9IHFhKGUubiwgci5GbiksIGMgPSBbXCJHeFwiLCBcIkd5XCIsIFwiYVwiLCB0ID09PSBcIndlaWVyc3RyYXNzXCIgPyBcImJcIiA6IFwiZFwiXTtcbiAgZm9yIChjb25zdCBmIG9mIGMpXG4gICAgaWYgKCFuLmlzVmFsaWQoZVtmXSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENVUlZFLiR7Zn0gbXVzdCBiZSB2YWxpZCBmaWVsZCBlbGVtZW50IG9mIENVUlZFLkZwYCk7XG4gIHJldHVybiB7IEZwOiBuLCBGbjogbyB9O1xufVxuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgdHIgPSBCaWdJbnQoMCksIE90ID0gQmlnSW50KDEpLCBRcyA9IEJpZ0ludCgyKSwgeWggPSBCaWdJbnQoOCksIHZoID0geyB6aXAyMTU6ICEwIH07XG5mdW5jdGlvbiB3aCh0LCBlLCByLCBuKSB7XG4gIGNvbnN0IG8gPSB0LnNxcihyKSwgaSA9IHQuc3FyKG4pLCBjID0gdC5hZGQodC5tdWwoZS5hLCBvKSwgaSksIGYgPSB0LmFkZCh0Lk9ORSwgdC5tdWwoZS5kLCB0Lm11bChvLCBpKSkpO1xuICByZXR1cm4gdC5lcWwoYywgZik7XG59XG5mdW5jdGlvbiB4aCh0LCBlID0ge30pIHtcbiAgY29uc3QgeyBGcDogciwgRm46IG4gfSA9IFNjKFwiZWR3YXJkc1wiLCB0LCBlKSwgeyBoOiBvLCBuOiBpIH0gPSB0O1xuICBVaShlLCB7fSwgeyB1dlJhdGlvOiBcImZ1bmN0aW9uXCIgfSk7XG4gIGNvbnN0IGMgPSBRcyA8PCBCaWdJbnQobi5CWVRFUyAqIDgpIC0gT3QsIGYgPSAoQikgPT4gci5jcmVhdGUoQiksIHYgPSBlLnV2UmF0aW8gfHwgKChCLCBSKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6ICEwLCB2YWx1ZTogci5zcXJ0KHIuZGl2KEIsIFIpKSB9O1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogITEsIHZhbHVlOiB0ciB9O1xuICAgIH1cbiAgfSk7XG4gIGlmICghd2gociwgdCwgdC5HeCwgdC5HeSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGN1cnZlIHBhcmFtczogZ2VuZXJhdG9yIHBvaW50XCIpO1xuICBmdW5jdGlvbiB4KEIsIFIsIHogPSAhMSkge1xuICAgIGNvbnN0IEsgPSB6ID8gT3QgOiB0cjtcbiAgICByZXR1cm4gU24oXCJjb29yZGluYXRlIFwiICsgQiwgUiwgSywgYyksIFI7XG4gIH1cbiAgZnVuY3Rpb24gYihCKSB7XG4gICAgaWYgKCEoQiBpbnN0YW5jZW9mIEMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0ZW5kZWRQb2ludCBleHBlY3RlZFwiKTtcbiAgfVxuICBjb25zdCBTID0gbXMoKEIsIFIpID0+IHtcbiAgICBjb25zdCB7IGV4OiB6LCBleTogSywgZXo6IFogfSA9IEIsIFEgPSBCLmlzMCgpO1xuICAgIFIgPT0gbnVsbCAmJiAoUiA9IFEgPyB5aCA6IHIuaW52KFopKTtcbiAgICBjb25zdCBqID0gZih6ICogUiksIFYgPSBmKEsgKiBSKSwgZWUgPSBmKFogKiBSKTtcbiAgICBpZiAoUSlcbiAgICAgIHJldHVybiB7IHg6IHRyLCB5OiBPdCB9O1xuICAgIGlmIChlZSAhPT0gT3QpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZaIHdhcyBpbnZhbGlkXCIpO1xuICAgIHJldHVybiB7IHg6IGosIHk6IFYgfTtcbiAgfSksIFQgPSBtcygoQikgPT4ge1xuICAgIGNvbnN0IHsgYTogUiwgZDogeiB9ID0gdDtcbiAgICBpZiAoQi5pczAoKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogWkVST1wiKTtcbiAgICBjb25zdCB7IGV4OiBLLCBleTogWiwgZXo6IFEsIGV0OiBqIH0gPSBCLCBWID0gZihLICogSyksIGVlID0gZihaICogWiksIEcgPSBmKFEgKiBRKSwgTiA9IGYoRyAqIEcpLCBPID0gZihWICogUiksIEwgPSBmKEcgKiBmKE8gKyBlZSkpLCBGID0gZihOICsgZih6ICogZihWICogZWUpKSk7XG4gICAgaWYgKEwgIT09IEYpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQgKDEpXCIpO1xuICAgIGNvbnN0IGQgPSBmKEsgKiBaKSwgcyA9IGYoUSAqIGopO1xuICAgIGlmIChkICE9PSBzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgyKVwiKTtcbiAgICByZXR1cm4gITA7XG4gIH0pO1xuICBjbGFzcyBDIHtcbiAgICBjb25zdHJ1Y3RvcihSLCB6LCBLLCBaKSB7XG4gICAgICB0aGlzLmV4ID0geChcInhcIiwgUiksIHRoaXMuZXkgPSB4KFwieVwiLCB6KSwgdGhpcy5leiA9IHgoXCJ6XCIsIEssICEwKSwgdGhpcy5ldCA9IHgoXCJ0XCIsIFopLCBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgeCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICB9XG4gICAgZ2V0IHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKFIpIHtcbiAgICAgIGlmIChSIGluc3RhbmNlb2YgQylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5kZWQgcG9pbnQgbm90IGFsbG93ZWRcIik7XG4gICAgICBjb25zdCB7IHg6IHosIHk6IEsgfSA9IFIgfHwge307XG4gICAgICByZXR1cm4geChcInhcIiwgeiksIHgoXCJ5XCIsIEspLCBuZXcgQyh6LCBLLCBPdCwgZih6ICogSykpO1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWihSKSB7XG4gICAgICByZXR1cm4gYmMoQywgXCJlelwiLCBSKTtcbiAgICB9XG4gICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICBzdGF0aWMgbXNtKFIsIHopIHtcbiAgICAgIHJldHVybiBDYyhDLCBuLCBSLCB6KTtcbiAgICB9XG4gICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICBfc2V0V2luZG93U2l6ZShSKSB7XG4gICAgICB0aGlzLnByZWNvbXB1dGUoUik7XG4gICAgfVxuICAgIHByZWNvbXB1dGUoUiA9IDgsIHogPSAhMCkge1xuICAgICAgcmV0dXJuIFAuc2V0V2luZG93U2l6ZSh0aGlzLCBSKSwgeiB8fCB0aGlzLm11bHRpcGx5KFFzKSwgdGhpcztcbiAgICB9XG4gICAgLy8gTm90IHJlcXVpcmVkIGZvciBmcm9tSGV4KCksIHdoaWNoIGFsd2F5cyBjcmVhdGVzIHZhbGlkIHBvaW50cy5cbiAgICAvLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGZyb21BZmZpbmUoKS5cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgIFQodGhpcyk7XG4gICAgfVxuICAgIC8vIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgZXF1YWxzKFIpIHtcbiAgICAgIGIoUik7XG4gICAgICBjb25zdCB7IGV4OiB6LCBleTogSywgZXo6IFogfSA9IHRoaXMsIHsgZXg6IFEsIGV5OiBqLCBlejogViB9ID0gUiwgZWUgPSBmKHogKiBWKSwgRyA9IGYoUSAqIFopLCBOID0gZihLICogViksIE8gPSBmKGogKiBaKTtcbiAgICAgIHJldHVybiBlZSA9PT0gRyAmJiBOID09PSBPO1xuICAgIH1cbiAgICBpczAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcXVhbHMoQy5aRVJPKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgcmV0dXJuIG5ldyBDKGYoLXRoaXMuZXgpLCB0aGlzLmV5LCB0aGlzLmV6LCBmKC10aGlzLmV0KSk7XG4gICAgfVxuICAgIC8vIEZhc3QgYWxnbyBmb3IgZG91YmxpbmcgRXh0ZW5kZWQgUG9pbnQuXG4gICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgICAvLyBDb3N0OiA0TSArIDRTICsgMSphICsgNmFkZCArIDEqMi5cbiAgICBkb3VibGUoKSB7XG4gICAgICBjb25zdCB7IGE6IFIgfSA9IHQsIHsgZXg6IHosIGV5OiBLLCBlejogWiB9ID0gdGhpcywgUSA9IGYoeiAqIHopLCBqID0gZihLICogSyksIFYgPSBmKFFzICogZihaICogWikpLCBlZSA9IGYoUiAqIFEpLCBHID0geiArIEssIE4gPSBmKGYoRyAqIEcpIC0gUSAtIGopLCBPID0gZWUgKyBqLCBMID0gTyAtIFYsIEYgPSBlZSAtIGosIGQgPSBmKE4gKiBMKSwgcyA9IGYoTyAqIEYpLCB1ID0gZihOICogRiksIGggPSBmKEwgKiBPKTtcbiAgICAgIHJldHVybiBuZXcgQyhkLCBzLCBoLCB1KTtcbiAgICB9XG4gICAgLy8gRmFzdCBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMuXG4gICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2RcbiAgICAvLyBDb3N0OiA5TSArIDEqYSArIDEqZCArIDdhZGQuXG4gICAgYWRkKFIpIHtcbiAgICAgIGIoUik7XG4gICAgICBjb25zdCB7IGE6IHosIGQ6IEsgfSA9IHQsIHsgZXg6IFosIGV5OiBRLCBlejogaiwgZXQ6IFYgfSA9IHRoaXMsIHsgZXg6IGVlLCBleTogRywgZXo6IE4sIGV0OiBPIH0gPSBSLCBMID0gZihaICogZWUpLCBGID0gZihRICogRyksIGQgPSBmKFYgKiBLICogTyksIHMgPSBmKGogKiBOKSwgdSA9IGYoKFogKyBRKSAqIChlZSArIEcpIC0gTCAtIEYpLCBoID0gcyAtIGQsIGcgPSBzICsgZCwgdyA9IGYoRiAtIHogKiBMKSwgXyA9IGYodSAqIGgpLCBBID0gZihnICogdyksIHAgPSBmKHUgKiB3KSwgYSA9IGYoaCAqIGcpO1xuICAgICAgcmV0dXJuIG5ldyBDKF8sIEEsIGEsIHApO1xuICAgIH1cbiAgICBzdWJ0cmFjdChSKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoUi5uZWdhdGUoKSk7XG4gICAgfVxuICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgbXVsdGlwbHkoUikge1xuICAgICAgY29uc3QgeiA9IFI7XG4gICAgICBTbihcInNjYWxhclwiLCB6LCBPdCwgaSk7XG4gICAgICBjb25zdCB7IHA6IEssIGY6IFogfSA9IFAud05BRkNhY2hlZCh0aGlzLCB6LCBDLm5vcm1hbGl6ZVopO1xuICAgICAgcmV0dXJuIEMubm9ybWFsaXplWihbSywgWl0pWzBdO1xuICAgIH1cbiAgICAvLyBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgLy8gSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAvLyBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbi5cbiAgICAvLyBEb2VzIE5PVCBhbGxvdyBzY2FsYXJzIGhpZ2hlciB0aGFuIENVUlZFLm4uXG4gICAgLy8gQWNjZXB0cyBvcHRpb25hbCBhY2N1bXVsYXRvciB0byBtZXJnZSB3aXRoIG11bHRpcGx5IChpbXBvcnRhbnQgZm9yIHNwYXJzZSBzY2FsYXJzKVxuICAgIG11bHRpcGx5VW5zYWZlKFIsIHogPSBDLlpFUk8pIHtcbiAgICAgIGNvbnN0IEsgPSBSO1xuICAgICAgcmV0dXJuIFNuKFwic2NhbGFyXCIsIEssIHRyLCBpKSwgSyA9PT0gdHIgPyBDLlpFUk8gOiB0aGlzLmlzMCgpIHx8IEsgPT09IE90ID8gdGhpcyA6IFAud05BRkNhY2hlZFVuc2FmZSh0aGlzLCBLLCBDLm5vcm1hbGl6ZVosIHopO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgcG9pbnQgaXMgb2Ygc21hbGwgb3JkZXIuXG4gICAgLy8gSWYgeW91IGFkZCBzb21ldGhpbmcgdG8gc21hbGwgb3JkZXIgcG9pbnQsIHlvdSB3aWxsIGhhdmUgXCJkaXJ0eVwiXG4gICAgLy8gcG9pbnQgd2l0aCB0b3JzaW9uIGNvbXBvbmVudC5cbiAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGNvZmFjdG9yIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgIGlzU21hbGxPcmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKG8pLmlzMCgpO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGN1cnZlIG9yZGVyIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgIC8vIFJldHVybnMgYGZhbHNlYCBpcyB0aGUgcG9pbnQgaXMgZGlydHkuXG4gICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgIHJldHVybiBQLndOQUZDYWNoZWRVbnNhZmUodGhpcywgaSkuaXMwKCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnRzIEV4dGVuZGVkIHBvaW50IHRvIGRlZmF1bHQgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgIHRvQWZmaW5lKFIpIHtcbiAgICAgIHJldHVybiBTKHRoaXMsIFIpO1xuICAgIH1cbiAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgcmV0dXJuIG8gPT09IE90ID8gdGhpcyA6IHRoaXMubXVsdGlwbHlVbnNhZmUobyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoUiwgeiA9ICExKSB7XG4gICAgICByZXR1cm4gYXIoUiksIHRoaXMuZnJvbUhleChSLCB6KTtcbiAgICB9XG4gICAgLy8gQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAvLyBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgIHN0YXRpYyBmcm9tSGV4KFIsIHogPSAhMSkge1xuICAgICAgY29uc3QgeyBkOiBLLCBhOiBaIH0gPSB0LCBRID0gci5CWVRFUztcbiAgICAgIFIgPSB2dChcInBvaW50SGV4XCIsIFIsIFEpLCBmbihcInppcDIxNVwiLCB6KTtcbiAgICAgIGNvbnN0IGogPSBSLnNsaWNlKCksIFYgPSBSW1EgLSAxXTtcbiAgICAgIGpbUSAtIDFdID0gViAmIC0xMjk7XG4gICAgICBjb25zdCBlZSA9IHdpKGopLCBHID0geiA/IGMgOiByLk9SREVSO1xuICAgICAgU24oXCJwb2ludEhleC55XCIsIGVlLCB0ciwgRyk7XG4gICAgICBjb25zdCBOID0gZihlZSAqIGVlKSwgTyA9IGYoTiAtIE90KSwgTCA9IGYoSyAqIE4gLSBaKTtcbiAgICAgIGxldCB7IGlzVmFsaWQ6IEYsIHZhbHVlOiBkIH0gPSB2KE8sIEwpO1xuICAgICAgaWYgKCFGKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2ludC5mcm9tSGV4OiBpbnZhbGlkIHkgY29vcmRpbmF0ZVwiKTtcbiAgICAgIGNvbnN0IHMgPSAoZCAmIE90KSA9PT0gT3QsIHUgPSAoViAmIDEyOCkgIT09IDA7XG4gICAgICBpZiAoIXogJiYgZCA9PT0gdHIgJiYgdSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9pbnQuZnJvbUhleDogeD0wIGFuZCB4XzA9MVwiKTtcbiAgICAgIHJldHVybiB1ICE9PSBzICYmIChkID0gZigtZCkpLCBDLmZyb21BZmZpbmUoeyB4OiBkLCB5OiBlZSB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlU2NhbGFyKFIpIHtcbiAgICAgIHJldHVybiBDLkJBU0UubXVsdGlwbHkoUik7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICBjb25zdCB7IHg6IFIsIHk6IHogfSA9IHRoaXMudG9BZmZpbmUoKSwgSyA9IE9zKHosIHIuQllURVMpO1xuICAgICAgcmV0dXJuIEtbSy5sZW5ndGggLSAxXSB8PSBSICYgT3QgPyAxMjggOiAwLCBLO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB0b0J5dGVzYCAqL1xuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgcmV0dXJuIE5uKHRoaXMudG9CeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYDxQb2ludCAke3RoaXMuaXMwKCkgPyBcIlpFUk9cIiA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICB9XG4gIH1cbiAgQy5CQVNFID0gbmV3IEModC5HeCwgdC5HeSwgT3QsIGYodC5HeCAqIHQuR3kpKSwgQy5aRVJPID0gbmV3IEModHIsIE90LCBPdCwgdHIpLCBDLkZwID0gciwgQy5GbiA9IG47XG4gIGNvbnN0IFAgPSBNYyhDLCBuLkJZVEVTICogOCk7XG4gIHJldHVybiBDO1xufVxuZnVuY3Rpb24gYmgodCwgZSkge1xuICBVaShlLCB7XG4gICAgaGFzaDogXCJmdW5jdGlvblwiXG4gIH0sIHtcbiAgICBhZGp1c3RTY2FsYXJCeXRlczogXCJmdW5jdGlvblwiLFxuICAgIHJhbmRvbUJ5dGVzOiBcImZ1bmN0aW9uXCIsXG4gICAgZG9tYWluOiBcImZ1bmN0aW9uXCIsXG4gICAgcHJlaGFzaDogXCJmdW5jdGlvblwiLFxuICAgIG1hcFRvQ3VydmU6IFwiZnVuY3Rpb25cIlxuICB9KTtcbiAgY29uc3QgeyBwcmVoYXNoOiByLCBoYXNoOiBuIH0gPSBlLCB7IEJBU0U6IG8sIEZwOiBpLCBGbjogYyB9ID0gdCwgZiA9IGMuT1JERVIsIHYgPSBlLnJhbmRvbUJ5dGVzIHx8IGxjLCB4ID0gZS5hZGp1c3RTY2FsYXJCeXRlcyB8fCAoKGopID0+IGopLCBiID0gZS5kb21haW4gfHwgKChqLCBWLCBlZSkgPT4ge1xuICAgIGlmIChmbihcInBoZmxhZ1wiLCBlZSksIFYubGVuZ3RoIHx8IGVlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dHMvcHJlLWhhc2ggYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgcmV0dXJuIGo7XG4gIH0pO1xuICBmdW5jdGlvbiBTKGopIHtcbiAgICByZXR1cm4gYy5jcmVhdGUoaik7XG4gIH1cbiAgZnVuY3Rpb24gVChqKSB7XG4gICAgcmV0dXJuIFMod2koaikpO1xuICB9XG4gIGZ1bmN0aW9uIEMoaikge1xuICAgIGNvbnN0IFYgPSBpLkJZVEVTO1xuICAgIGogPSB2dChcInByaXZhdGUga2V5XCIsIGosIFYpO1xuICAgIGNvbnN0IGVlID0gdnQoXCJoYXNoZWQgcHJpdmF0ZSBrZXlcIiwgbihqKSwgMiAqIFYpLCBHID0geChlZS5zbGljZSgwLCBWKSksIE4gPSBlZS5zbGljZShWLCAyICogViksIE8gPSBUKEcpO1xuICAgIHJldHVybiB7IGhlYWQ6IEcsIHByZWZpeDogTiwgc2NhbGFyOiBPIH07XG4gIH1cbiAgZnVuY3Rpb24gUChqKSB7XG4gICAgY29uc3QgeyBoZWFkOiBWLCBwcmVmaXg6IGVlLCBzY2FsYXI6IEcgfSA9IEMoaiksIE4gPSBvLm11bHRpcGx5KEcpLCBPID0gTi50b0J5dGVzKCk7XG4gICAgcmV0dXJuIHsgaGVhZDogViwgcHJlZml4OiBlZSwgc2NhbGFyOiBHLCBwb2ludDogTiwgcG9pbnRCeXRlczogTyB9O1xuICB9XG4gIGZ1bmN0aW9uIEIoaikge1xuICAgIHJldHVybiBQKGopLnBvaW50Qnl0ZXM7XG4gIH1cbiAgZnVuY3Rpb24gUihqID0gVWludDhBcnJheS5vZigpLCAuLi5WKSB7XG4gICAgY29uc3QgZWUgPSB2ciguLi5WKTtcbiAgICByZXR1cm4gVChuKGIoZWUsIHZ0KFwiY29udGV4dFwiLCBqKSwgISFyKSkpO1xuICB9XG4gIGZ1bmN0aW9uIHooaiwgViwgZWUgPSB7fSkge1xuICAgIGogPSB2dChcIm1lc3NhZ2VcIiwgaiksIHIgJiYgKGogPSByKGopKTtcbiAgICBjb25zdCB7IHByZWZpeDogRywgc2NhbGFyOiBOLCBwb2ludEJ5dGVzOiBPIH0gPSBQKFYpLCBMID0gUihlZS5jb250ZXh0LCBHLCBqKSwgRiA9IG8ubXVsdGlwbHkoTCkudG9CeXRlcygpLCBkID0gUihlZS5jb250ZXh0LCBGLCBPLCBqKSwgcyA9IFMoTCArIGQgKiBOKTtcbiAgICBTbihcInNpZ25hdHVyZS5zXCIsIHMsIHRyLCBmKTtcbiAgICBjb25zdCB1ID0gaS5CWVRFUywgaCA9IHZyKEYsIE9zKHMsIHUpKTtcbiAgICByZXR1cm4gdnQoXCJyZXN1bHRcIiwgaCwgdSAqIDIpO1xuICB9XG4gIGNvbnN0IEsgPSB2aDtcbiAgZnVuY3Rpb24gWihqLCBWLCBlZSwgRyA9IEspIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IE4sIHppcDIxNTogTyB9ID0gRywgTCA9IGkuQllURVM7XG4gICAgaiA9IHZ0KFwic2lnbmF0dXJlXCIsIGosIDIgKiBMKSwgViA9IHZ0KFwibWVzc2FnZVwiLCBWKSwgZWUgPSB2dChcInB1YmxpY0tleVwiLCBlZSwgTCksIE8gIT09IHZvaWQgMCAmJiBmbihcInppcDIxNVwiLCBPKSwgciAmJiAoViA9IHIoVikpO1xuICAgIGNvbnN0IEYgPSB3aShqLnNsaWNlKEwsIDIgKiBMKSk7XG4gICAgbGV0IGQsIHMsIHU7XG4gICAgdHJ5IHtcbiAgICAgIGQgPSB0LmZyb21IZXgoZWUsIE8pLCBzID0gdC5mcm9tSGV4KGouc2xpY2UoMCwgTCksIE8pLCB1ID0gby5tdWx0aXBseVVuc2FmZShGKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgaWYgKCFPICYmIGQuaXNTbWFsbE9yZGVyKCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgaCA9IFIoTiwgcy50b0J5dGVzKCksIGQudG9CeXRlcygpLCBWKTtcbiAgICByZXR1cm4gcy5hZGQoZC5tdWx0aXBseVVuc2FmZShoKSkuc3VidHJhY3QodSkuY2xlYXJDb2ZhY3RvcigpLmlzMCgpO1xuICB9XG4gIHJldHVybiBvLnByZWNvbXB1dGUoOCksIHsgZ2V0UHVibGljS2V5OiBCLCBzaWduOiB6LCB2ZXJpZnk6IFosIHV0aWxzOiB7XG4gICAgZ2V0RXh0ZW5kZWRQdWJsaWNLZXk6IFAsXG4gICAgLyoqIGVkMjU1MTkgcHJpdiBrZXlzIGFyZSB1bmlmb3JtIDMyYi4gTm8gbmVlZCB0byBjaGVjayBmb3IgbW9kdWxvIGJpYXMsIGxpa2UgaW4gc2VjcDI1NmsxLiAqL1xuICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHYoaS5CWVRFUyksXG4gICAgLyoqXG4gICAgICogV2UncmUgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uICh1c2VkIGluIGdldFB1YmxpY0tleSBldGMpIHdpdGggcHJlY29tcHV0ZWQgQkFTRV9QT0lOVFxuICAgICAqIHZhbHVlcy4gVGhpcyBzbG93cyBkb3duIGZpcnN0IGdldFB1YmxpY0tleSgpIGJ5IG1pbGxpc2Vjb25kcyAoc2VlIFNwZWVkIHNlY3Rpb24pLFxuICAgICAqIGJ1dCBhbGxvd3MgdG8gc3BlZWQtdXAgc3Vic2VxdWVudCBnZXRQdWJsaWNLZXkoKSBjYWxscyB1cCB0byAyMHguXG4gICAgICogQHBhcmFtIHdpbmRvd1NpemUgMiwgNCwgOCwgMTZcbiAgICAgKi9cbiAgICBwcmVjb21wdXRlKGogPSA4LCBWID0gdC5CQVNFKSB7XG4gICAgICByZXR1cm4gVi5wcmVjb21wdXRlKGosICExKTtcbiAgICB9XG4gIH0sIFBvaW50OiB0IH07XG59XG5mdW5jdGlvbiBfaCh0KSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgYTogdC5hLFxuICAgIGQ6IHQuZCxcbiAgICBwOiB0LkZwLk9SREVSLFxuICAgIG46IHQubixcbiAgICBoOiB0LmgsXG4gICAgR3g6IHQuR3gsXG4gICAgR3k6IHQuR3lcbiAgfSwgciA9IHQuRnAsIG4gPSAkbihlLm4sIHQubkJpdExlbmd0aCwgITApLCBvID0geyBGcDogciwgRm46IG4sIHV2UmF0aW86IHQudXZSYXRpbyB9LCBpID0ge1xuICAgIGhhc2g6IHQuaGFzaCxcbiAgICByYW5kb21CeXRlczogdC5yYW5kb21CeXRlcyxcbiAgICBhZGp1c3RTY2FsYXJCeXRlczogdC5hZGp1c3RTY2FsYXJCeXRlcyxcbiAgICBkb21haW46IHQuZG9tYWluLFxuICAgIHByZWhhc2g6IHQucHJlaGFzaCxcbiAgICBtYXBUb0N1cnZlOiB0Lm1hcFRvQ3VydmVcbiAgfTtcbiAgcmV0dXJuIHsgQ1VSVkU6IGUsIGN1cnZlT3B0czogbywgZWRkc2FPcHRzOiBpIH07XG59XG5mdW5jdGlvbiBFaCh0LCBlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBlLCB7IEV4dGVuZGVkUG9pbnQ6IGUuUG9pbnQsIENVUlZFOiB0IH0pO1xufVxuZnVuY3Rpb24gTWgodCkge1xuICBjb25zdCB7IENVUlZFOiBlLCBjdXJ2ZU9wdHM6IHIsIGVkZHNhT3B0czogbiB9ID0gX2godCksIG8gPSB4aChlLCByKSwgaSA9IGJoKG8sIG4pO1xuICByZXR1cm4gRWgodCwgaSk7XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5CaWdJbnQoMCk7XG5jb25zdCBDaCA9IEJpZ0ludCgxKSwgWmEgPSBCaWdJbnQoMik7XG5CaWdJbnQoMyk7XG5jb25zdCBTaCA9IEJpZ0ludCg1KSwgQWggPSBCaWdJbnQoOCksIGpzID0ge1xuICBwOiBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWRcIiksXG4gIG46IEJpZ0ludChcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNGRlZjlkZWEyZjc5Y2Q2NTgxMjYzMWE1Y2Y1ZDNlZFwiKSxcbiAgaDogQWgsXG4gIGE6IEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlY1wiKSxcbiAgZDogQmlnSW50KFwiMHg1MjAzNmNlZTJiNmZmZTczOGNjNzQwNzk3Nzc5ZTg5ODAwNzAwYTRkNDE0MWQ4YWI3NWViNGRjYTEzNTk3OGEzXCIpLFxuICBHeDogQmlnSW50KFwiMHgyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhXCIpLFxuICBHeTogQmlnSW50KFwiMHg2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4XCIpXG59O1xuZnVuY3Rpb24ga2godCkge1xuICBjb25zdCBlID0gQmlnSW50KDEwKSwgciA9IEJpZ0ludCgyMCksIG4gPSBCaWdJbnQoNDApLCBvID0gQmlnSW50KDgwKSwgaSA9IGpzLnAsIGYgPSB0ICogdCAlIGkgKiB0ICUgaSwgdiA9IHB0KGYsIFphLCBpKSAqIGYgJSBpLCB4ID0gcHQodiwgQ2gsIGkpICogdCAlIGksIGIgPSBwdCh4LCBTaCwgaSkgKiB4ICUgaSwgUyA9IHB0KGIsIGUsIGkpICogYiAlIGksIFQgPSBwdChTLCByLCBpKSAqIFMgJSBpLCBDID0gcHQoVCwgbiwgaSkgKiBUICUgaSwgUCA9IHB0KEMsIG8sIGkpICogQyAlIGksIEIgPSBwdChQLCBvLCBpKSAqIEMgJSBpLCBSID0gcHQoQiwgZSwgaSkgKiBiICUgaTtcbiAgcmV0dXJuIHsgcG93X3BfNV84OiBwdChSLCBaYSwgaSkgKiB0ICUgaSwgYjI6IGYgfTtcbn1cbmZ1bmN0aW9uIEloKHQpIHtcbiAgcmV0dXJuIHRbMF0gJj0gMjQ4LCB0WzMxXSAmPSAxMjcsIHRbMzFdIHw9IDY0LCB0O1xufVxuY29uc3QgVmEgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KFwiMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTJcIik7XG5mdW5jdGlvbiBCaCh0LCBlKSB7XG4gIGNvbnN0IHIgPSBqcy5wLCBuID0gd3QoZSAqIGUgKiBlLCByKSwgbyA9IHd0KG4gKiBuICogZSwgciksIGkgPSBraCh0ICogbykucG93X3BfNV84O1xuICBsZXQgYyA9IHd0KHQgKiBuICogaSwgcik7XG4gIGNvbnN0IGYgPSB3dChlICogYyAqIGMsIHIpLCB2ID0gYywgeCA9IHd0KGMgKiBWYSwgciksIGIgPSBmID09PSB0LCBTID0gZiA9PT0gd3QoLXQsIHIpLCBUID0gZiA9PT0gd3QoLXQgKiBWYSwgcik7XG4gIHJldHVybiBiICYmIChjID0gdiksIChTIHx8IFQpICYmIChjID0geCksIHVoKGMsIHIpICYmIChjID0gd3QoLWMsIHIpKSwgeyBpc1ZhbGlkOiBiIHx8IFMsIHZhbHVlOiBjIH07XG59XG5jb25zdCBSaCA9ICRuKGpzLnAsIHZvaWQgMCwgITApLCBUaCA9IHtcbiAgLi4uanMsXG4gIEZwOiBSaCxcbiAgaGFzaDogZWgsXG4gIGFkanVzdFNjYWxhckJ5dGVzOiBJaCxcbiAgLy8gZG9tMlxuICAvLyBSYXRpbyBvZiB1IHRvIHYuIEFsbG93cyB1cyB0byBjb21iaW5lIGludmVyc2lvbiBhbmQgc3F1YXJlIHJvb3QuIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gIC8vIENvbnN0YW50LXRpbWUsIHUv4oiadlxuICB1dlJhdGlvOiBCaFxufSwgRmkgPSBNaChUaCk7XG52YXIgcnMgPSB7IGV4cG9ydHM6IHt9IH07XG5jb25zdCBMaCA9IHt9LCBPaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IExoXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBBYyA9IC8qIEBfX1BVUkVfXyAqLyBlYShPaCk7XG52YXIgTmggPSBycy5leHBvcnRzLCBIYTtcbmZ1bmN0aW9uIGpoKCkge1xuICByZXR1cm4gSGEgfHwgKEhhID0gMSwgZnVuY3Rpb24odCkge1xuICAgIChmdW5jdGlvbihlLCByKSB7XG4gICAgICBmdW5jdGlvbiBuKGQsIHMpIHtcbiAgICAgICAgaWYgKCFkKSB0aHJvdyBuZXcgRXJyb3IocyB8fCBcIkFzc2VydGlvbiBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvKGQsIHMpIHtcbiAgICAgICAgZC5zdXBlcl8gPSBzO1xuICAgICAgICB2YXIgdSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB9O1xuICAgICAgICB1LnByb3RvdHlwZSA9IHMucHJvdG90eXBlLCBkLnByb3RvdHlwZSA9IG5ldyB1KCksIGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGkoZCwgcywgdSkge1xuICAgICAgICBpZiAoaS5pc0JOKGQpKVxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy53b3JkcyA9IG51bGwsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5yZWQgPSBudWxsLCBkICE9PSBudWxsICYmICgocyA9PT0gXCJsZVwiIHx8IHMgPT09IFwiYmVcIikgJiYgKHUgPSBzLCBzID0gMTApLCB0aGlzLl9pbml0KGQgfHwgMCwgcyB8fCAxMCwgdSB8fCBcImJlXCIpKTtcbiAgICAgIH1cbiAgICAgIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlLmV4cG9ydHMgPSBpIDogci5CTiA9IGksIGkuQk4gPSBpLCBpLndvcmRTaXplID0gMjY7XG4gICAgICB2YXIgYztcbiAgICAgIHRyeSB7XG4gICAgICAgIHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2Ygd2luZG93LkJ1ZmZlciA8IFwidVwiID8gYyA9IHdpbmRvdy5CdWZmZXIgOiBjID0gQWMuQnVmZmVyO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBpLmlzQk4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzIGluc3RhbmNlb2YgaSA/ICEwIDogcyAhPT0gbnVsbCAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmIHMuY29uc3RydWN0b3Iud29yZFNpemUgPT09IGkud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShzLndvcmRzKTtcbiAgICAgIH0sIGkubWF4ID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICByZXR1cm4gcy5jbXAodSkgPiAwID8gcyA6IHU7XG4gICAgICB9LCBpLm1pbiA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgcmV0dXJuIHMuY21wKHUpIDwgMCA/IHMgOiB1O1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcyA9PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKHMsIHUsIGgpO1xuICAgICAgICBpZiAodHlwZW9mIHMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KHMsIHUsIGgpO1xuICAgICAgICB1ID09PSBcImhleFwiICYmICh1ID0gMTYpLCBuKHUgPT09ICh1IHwgMCkgJiYgdSA+PSAyICYmIHUgPD0gMzYpLCBzID0gcy50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgXCJcIik7XG4gICAgICAgIHZhciBnID0gMDtcbiAgICAgICAgc1swXSA9PT0gXCItXCIgJiYgKGcrKywgdGhpcy5uZWdhdGl2ZSA9IDEpLCBnIDwgcy5sZW5ndGggJiYgKHUgPT09IDE2ID8gdGhpcy5fcGFyc2VIZXgocywgZywgaCkgOiAodGhpcy5fcGFyc2VCYXNlKHMsIHUsIGcpLCBoID09PSBcImxlXCIgJiYgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCB1LCBoKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIHMgPCAwICYmICh0aGlzLm5lZ2F0aXZlID0gMSwgcyA9IC1zKSwgcyA8IDY3MTA4ODY0ID8gKHRoaXMud29yZHMgPSBbcyAmIDY3MTA4ODYzXSwgdGhpcy5sZW5ndGggPSAxKSA6IHMgPCA0NTAzNTk5NjI3MzcwNDk2ID8gKHRoaXMud29yZHMgPSBbXG4gICAgICAgICAgcyAmIDY3MTA4ODYzLFxuICAgICAgICAgIHMgLyA2NzEwODg2NCAmIDY3MTA4ODYzXG4gICAgICAgIF0sIHRoaXMubGVuZ3RoID0gMikgOiAobihzIDwgOTAwNzE5OTI1NDc0MDk5MiksIHRoaXMud29yZHMgPSBbXG4gICAgICAgICAgcyAmIDY3MTA4ODYzLFxuICAgICAgICAgIHMgLyA2NzEwODg2NCAmIDY3MTA4ODYzLFxuICAgICAgICAgIDFcbiAgICAgICAgXSwgdGhpcy5sZW5ndGggPSAzKSwgaCA9PT0gXCJsZVwiICYmIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgdSwgaCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICBpZiAobih0eXBlb2Ygcy5sZW5ndGggPT0gXCJudW1iZXJcIiksIHMubGVuZ3RoIDw9IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMud29yZHMgPSBbMF0sIHRoaXMubGVuZ3RoID0gMSwgdGhpcztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwocy5sZW5ndGggLyAzKSwgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgdGhpcy5sZW5ndGg7IGcrKylcbiAgICAgICAgICB0aGlzLndvcmRzW2ddID0gMDtcbiAgICAgICAgdmFyIHcsIF8sIEEgPSAwO1xuICAgICAgICBpZiAoaCA9PT0gXCJiZVwiKVxuICAgICAgICAgIGZvciAoZyA9IHMubGVuZ3RoIC0gMSwgdyA9IDA7IGcgPj0gMDsgZyAtPSAzKVxuICAgICAgICAgICAgXyA9IHNbZ10gfCBzW2cgLSAxXSA8PCA4IHwgc1tnIC0gMl0gPDwgMTYsIHRoaXMud29yZHNbd10gfD0gXyA8PCBBICYgNjcxMDg4NjMsIHRoaXMud29yZHNbdyArIDFdID0gXyA+Pj4gMjYgLSBBICYgNjcxMDg4NjMsIEEgKz0gMjQsIEEgPj0gMjYgJiYgKEEgLT0gMjYsIHcrKyk7XG4gICAgICAgIGVsc2UgaWYgKGggPT09IFwibGVcIilcbiAgICAgICAgICBmb3IgKGcgPSAwLCB3ID0gMDsgZyA8IHMubGVuZ3RoOyBnICs9IDMpXG4gICAgICAgICAgICBfID0gc1tnXSB8IHNbZyArIDFdIDw8IDggfCBzW2cgKyAyXSA8PCAxNiwgdGhpcy53b3Jkc1t3XSB8PSBfIDw8IEEgJiA2NzEwODg2MywgdGhpcy53b3Jkc1t3ICsgMV0gPSBfID4+PiAyNiAtIEEgJiA2NzEwODg2MywgQSArPSAyNCwgQSA+PSAyNiAmJiAoQSAtPSAyNiwgdysrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gZihkLCBzKSB7XG4gICAgICAgIHZhciB1ID0gZC5jaGFyQ29kZUF0KHMpO1xuICAgICAgICBpZiAodSA+PSA0OCAmJiB1IDw9IDU3KVxuICAgICAgICAgIHJldHVybiB1IC0gNDg7XG4gICAgICAgIGlmICh1ID49IDY1ICYmIHUgPD0gNzApXG4gICAgICAgICAgcmV0dXJuIHUgLSA1NTtcbiAgICAgICAgaWYgKHUgPj0gOTcgJiYgdSA8PSAxMDIpXG4gICAgICAgICAgcmV0dXJuIHUgLSA4NztcbiAgICAgICAgbighMSwgXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBcIiArIGQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdihkLCBzLCB1KSB7XG4gICAgICAgIHZhciBoID0gZihkLCB1KTtcbiAgICAgICAgcmV0dXJuIHUgLSAxID49IHMgJiYgKGggfD0gZihkLCB1IC0gMSkgPDwgNCksIGg7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChzLmxlbmd0aCAtIHUpIC8gNiksIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IHRoaXMubGVuZ3RoOyBnKyspXG4gICAgICAgICAgdGhpcy53b3Jkc1tnXSA9IDA7XG4gICAgICAgIHZhciB3ID0gMCwgXyA9IDAsIEE7XG4gICAgICAgIGlmIChoID09PSBcImJlXCIpXG4gICAgICAgICAgZm9yIChnID0gcy5sZW5ndGggLSAxOyBnID49IHU7IGcgLT0gMilcbiAgICAgICAgICAgIEEgPSB2KHMsIHUsIGcpIDw8IHcsIHRoaXMud29yZHNbX10gfD0gQSAmIDY3MTA4ODYzLCB3ID49IDE4ID8gKHcgLT0gMTgsIF8gKz0gMSwgdGhpcy53b3Jkc1tfXSB8PSBBID4+PiAyNikgOiB3ICs9IDg7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwID0gcy5sZW5ndGggLSB1O1xuICAgICAgICAgIGZvciAoZyA9IHAgJSAyID09PSAwID8gdSArIDEgOiB1OyBnIDwgcy5sZW5ndGg7IGcgKz0gMilcbiAgICAgICAgICAgIEEgPSB2KHMsIHUsIGcpIDw8IHcsIHRoaXMud29yZHNbX10gfD0gQSAmIDY3MTA4ODYzLCB3ID49IDE4ID8gKHcgLT0gMTgsIF8gKz0gMSwgdGhpcy53b3Jkc1tfXSB8PSBBID4+PiAyNikgOiB3ICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RyaXAoKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiB4KGQsIHMsIHUsIGgpIHtcbiAgICAgICAgZm9yICh2YXIgZyA9IDAsIHcgPSAwLCBfID0gTWF0aC5taW4oZC5sZW5ndGgsIHUpLCBBID0gczsgQSA8IF87IEErKykge1xuICAgICAgICAgIHZhciBwID0gZC5jaGFyQ29kZUF0KEEpIC0gNDg7XG4gICAgICAgICAgZyAqPSBoLCBwID49IDQ5ID8gdyA9IHAgLSA0OSArIDEwIDogcCA+PSAxNyA/IHcgPSBwIC0gMTcgKyAxMCA6IHcgPSBwLCBuKHAgPj0gMCAmJiB3IDwgaCwgXCJJbnZhbGlkIGNoYXJhY3RlclwiKSwgZyArPSB3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uKHMsIHUsIGgpIHtcbiAgICAgICAgdGhpcy53b3JkcyA9IFswXSwgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICBmb3IgKHZhciBnID0gMCwgdyA9IDE7IHcgPD0gNjcxMDg4NjM7IHcgKj0gdSlcbiAgICAgICAgICBnKys7XG4gICAgICAgIGctLSwgdyA9IHcgLyB1IHwgMDtcbiAgICAgICAgZm9yICh2YXIgXyA9IHMubGVuZ3RoIC0gaCwgQSA9IF8gJSBnLCBwID0gTWF0aC5taW4oXywgXyAtIEEpICsgaCwgYSA9IDAsIGwgPSBoOyBsIDwgcDsgbCArPSBnKVxuICAgICAgICAgIGEgPSB4KHMsIGwsIGwgKyBnLCB1KSwgdGhpcy5pbXVsbih3KSwgdGhpcy53b3Jkc1swXSArIGEgPCA2NzEwODg2NCA/IHRoaXMud29yZHNbMF0gKz0gYSA6IHRoaXMuX2lhZGRuKGEpO1xuICAgICAgICBpZiAoQSAhPT0gMCkge1xuICAgICAgICAgIHZhciBNID0gMTtcbiAgICAgICAgICBmb3IgKGEgPSB4KHMsIGwsIHMubGVuZ3RoLCB1KSwgbCA9IDA7IGwgPCBBOyBsKyspXG4gICAgICAgICAgICBNICo9IHU7XG4gICAgICAgICAgdGhpcy5pbXVsbihNKSwgdGhpcy53b3Jkc1swXSArIGEgPCA2NzEwODg2NCA/IHRoaXMud29yZHNbMF0gKz0gYSA6IHRoaXMuX2lhZGRuKGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICBzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCB0aGlzLmxlbmd0aDsgdSsrKVxuICAgICAgICAgIHMud29yZHNbdV0gPSB0aGlzLndvcmRzW3VdO1xuICAgICAgICBzLmxlbmd0aCA9IHRoaXMubGVuZ3RoLCBzLm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZSwgcy5yZWQgPSB0aGlzLnJlZDtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBiKGQsIHMpIHtcbiAgICAgICAgZC53b3JkcyA9IHMud29yZHMsIGQubGVuZ3RoID0gcy5sZW5ndGgsIGQubmVnYXRpdmUgPSBzLm5lZ2F0aXZlLCBkLnJlZCA9IHMucmVkO1xuICAgICAgfVxuICAgICAgaWYgKGkucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24ocykge1xuICAgICAgICBiKHMsIHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgaShudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShzKSwgcztcbiAgICAgIH0sIGkucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGZvciAoOyB0aGlzLmxlbmd0aCA8IHM7IClcbiAgICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICg7IHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDA7IClcbiAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCAmJiAodGhpcy5uZWdhdGl2ZSA9IDApLCB0aGlzO1xuICAgICAgfSwgdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIHR5cGVvZiBTeW1ib2wuZm9yID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpLnByb3RvdHlwZVtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildID0gUztcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgaS5wcm90b3R5cGUuaW5zcGVjdCA9IFM7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgaS5wcm90b3R5cGUuaW5zcGVjdCA9IFM7XG4gICAgICBmdW5jdGlvbiBTKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucmVkID8gXCI8Qk4tUjogXCIgOiBcIjxCTjogXCIpICsgdGhpcy50b1N0cmluZygxNikgKyBcIj5cIjtcbiAgICAgIH1cbiAgICAgIHZhciBUID0gW1xuICAgICAgICBcIlwiLFxuICAgICAgICBcIjBcIixcbiAgICAgICAgXCIwMFwiLFxuICAgICAgICBcIjAwMFwiLFxuICAgICAgICBcIjAwMDBcIixcbiAgICAgICAgXCIwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgXSwgQyA9IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMjUsXG4gICAgICAgIDE2LFxuICAgICAgICAxMixcbiAgICAgICAgMTEsXG4gICAgICAgIDEwLFxuICAgICAgICA5LFxuICAgICAgICA4LFxuICAgICAgICA4LFxuICAgICAgICA3LFxuICAgICAgICA3LFxuICAgICAgICA3LFxuICAgICAgICA3LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1XG4gICAgICBdLCBQID0gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAzMzU1NDQzMixcbiAgICAgICAgNDMwNDY3MjEsXG4gICAgICAgIDE2Nzc3MjE2LFxuICAgICAgICA0ODgyODEyNSxcbiAgICAgICAgNjA0NjYxNzYsXG4gICAgICAgIDQwMzUzNjA3LFxuICAgICAgICAxNjc3NzIxNixcbiAgICAgICAgNDMwNDY3MjEsXG4gICAgICAgIDFlNyxcbiAgICAgICAgMTk0ODcxNzEsXG4gICAgICAgIDM1ODMxODA4LFxuICAgICAgICA2Mjc0ODUxNyxcbiAgICAgICAgNzUyOTUzNixcbiAgICAgICAgMTEzOTA2MjUsXG4gICAgICAgIDE2Nzc3MjE2LFxuICAgICAgICAyNDEzNzU2OSxcbiAgICAgICAgMzQwMTIyMjQsXG4gICAgICAgIDQ3MDQ1ODgxLFxuICAgICAgICA2NGU2LFxuICAgICAgICA0MDg0MTAxLFxuICAgICAgICA1MTUzNjMyLFxuICAgICAgICA2NDM2MzQzLFxuICAgICAgICA3OTYyNjI0LFxuICAgICAgICA5NzY1NjI1LFxuICAgICAgICAxMTg4MTM3NixcbiAgICAgICAgMTQzNDg5MDcsXG4gICAgICAgIDE3MjEwMzY4LFxuICAgICAgICAyMDUxMTE0OSxcbiAgICAgICAgMjQzZTUsXG4gICAgICAgIDI4NjI5MTUxLFxuICAgICAgICAzMzU1NDQzMixcbiAgICAgICAgMzkxMzUzOTMsXG4gICAgICAgIDQ1NDM1NDI0LFxuICAgICAgICA1MjUyMTg3NSxcbiAgICAgICAgNjA0NjYxNzZcbiAgICAgIF07XG4gICAgICBpLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgcyA9IHMgfHwgMTAsIHUgPSB1IHwgMCB8fCAxO1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgaWYgKHMgPT09IDE2IHx8IHMgPT09IFwiaGV4XCIpIHtcbiAgICAgICAgICBoID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHZhciBnID0gMCwgdyA9IDAsIF8gPSAwOyBfIDwgdGhpcy5sZW5ndGg7IF8rKykge1xuICAgICAgICAgICAgdmFyIEEgPSB0aGlzLndvcmRzW19dLCBwID0gKChBIDw8IGcgfCB3KSAmIDE2Nzc3MjE1KS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB3ID0gQSA+Pj4gMjQgLSBnICYgMTY3NzcyMTUsIGcgKz0gMiwgZyA+PSAyNiAmJiAoZyAtPSAyNiwgXy0tKSwgdyAhPT0gMCB8fCBfICE9PSB0aGlzLmxlbmd0aCAtIDEgPyBoID0gVFs2IC0gcC5sZW5ndGhdICsgcCArIGggOiBoID0gcCArIGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodyAhPT0gMCAmJiAoaCA9IHcudG9TdHJpbmcoMTYpICsgaCk7IGgubGVuZ3RoICUgdSAhPT0gMDsgKVxuICAgICAgICAgICAgaCA9IFwiMFwiICsgaDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAoaCA9IFwiLVwiICsgaCksIGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMgPT09IChzIHwgMCkgJiYgcyA+PSAyICYmIHMgPD0gMzYpIHtcbiAgICAgICAgICB2YXIgYSA9IENbc10sIGwgPSBQW3NdO1xuICAgICAgICAgIGggPSBcIlwiO1xuICAgICAgICAgIHZhciBNID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgIGZvciAoTS5uZWdhdGl2ZSA9IDA7ICFNLmlzWmVybygpOyApIHtcbiAgICAgICAgICAgIHZhciBrID0gTS5tb2RybihsKS50b1N0cmluZyhzKTtcbiAgICAgICAgICAgIE0gPSBNLmlkaXZuKGwpLCBNLmlzWmVybygpID8gaCA9IGsgKyBoIDogaCA9IFRbYSAtIGsubGVuZ3RoXSArIGsgKyBoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHRoaXMuaXNaZXJvKCkgJiYgKGggPSBcIjBcIiArIGgpOyBoLmxlbmd0aCAlIHUgIT09IDA7IClcbiAgICAgICAgICAgIGggPSBcIjBcIiArIGg7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgJiYgKGggPSBcIi1cIiArIGgpLCBoO1xuICAgICAgICB9XG4gICAgICAgIG4oITEsIFwiQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNlwiKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy53b3Jkc1swXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAyID8gcyArPSB0aGlzLndvcmRzWzFdICogNjcxMDg4NjQgOiB0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAxID8gcyArPSA0NTAzNTk5NjI3MzcwNDk2ICsgdGhpcy53b3Jkc1sxXSAqIDY3MTA4ODY0IDogdGhpcy5sZW5ndGggPiAyICYmIG4oITEsIFwiTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzXCIpLCB0aGlzLm5lZ2F0aXZlICE9PSAwID8gLXMgOiBzO1xuICAgICAgfSwgaS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2LCAyKTtcbiAgICAgIH0sIGMgJiYgKGkucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShjLCBzLCB1KTtcbiAgICAgIH0pLCBpLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgcywgdSk7XG4gICAgICB9O1xuICAgICAgdmFyIEIgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHJldHVybiBzLmFsbG9jVW5zYWZlID8gcy5hbGxvY1Vuc2FmZSh1KSA6IG5ldyBzKHUpO1xuICAgICAgfTtcbiAgICAgIGkucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICB0aGlzLl9zdHJpcCgpO1xuICAgICAgICB2YXIgZyA9IHRoaXMuYnl0ZUxlbmd0aCgpLCB3ID0gaCB8fCBNYXRoLm1heCgxLCBnKTtcbiAgICAgICAgbihnIDw9IHcsIFwiYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aFwiKSwgbih3ID4gMCwgXCJSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDBcIik7XG4gICAgICAgIHZhciBfID0gQihzLCB3KSwgQSA9IHUgPT09IFwibGVcIiA/IFwiTEVcIiA6IFwiQkVcIjtcbiAgICAgICAgcmV0dXJuIHRoaXNbXCJfdG9BcnJheUxpa2VcIiArIEFdKF8sIGcpLCBfO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3RvQXJyYXlMaWtlTEUgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIGZvciAodmFyIGggPSAwLCBnID0gMCwgdyA9IDAsIF8gPSAwOyB3IDwgdGhpcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciBBID0gdGhpcy53b3Jkc1t3XSA8PCBfIHwgZztcbiAgICAgICAgICBzW2grK10gPSBBICYgMjU1LCBoIDwgcy5sZW5ndGggJiYgKHNbaCsrXSA9IEEgPj4gOCAmIDI1NSksIGggPCBzLmxlbmd0aCAmJiAoc1toKytdID0gQSA+PiAxNiAmIDI1NSksIF8gPT09IDYgPyAoaCA8IHMubGVuZ3RoICYmIChzW2grK10gPSBBID4+IDI0ICYgMjU1KSwgZyA9IDAsIF8gPSAwKSA6IChnID0gQSA+Pj4gMjQsIF8gKz0gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggPCBzLmxlbmd0aClcbiAgICAgICAgICBmb3IgKHNbaCsrXSA9IGc7IGggPCBzLmxlbmd0aDsgKVxuICAgICAgICAgICAgc1toKytdID0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLl90b0FycmF5TGlrZUJFID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBmb3IgKHZhciBoID0gcy5sZW5ndGggLSAxLCBnID0gMCwgdyA9IDAsIF8gPSAwOyB3IDwgdGhpcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciBBID0gdGhpcy53b3Jkc1t3XSA8PCBfIHwgZztcbiAgICAgICAgICBzW2gtLV0gPSBBICYgMjU1LCBoID49IDAgJiYgKHNbaC0tXSA9IEEgPj4gOCAmIDI1NSksIGggPj0gMCAmJiAoc1toLS1dID0gQSA+PiAxNiAmIDI1NSksIF8gPT09IDYgPyAoaCA+PSAwICYmIChzW2gtLV0gPSBBID4+IDI0ICYgMjU1KSwgZyA9IDAsIF8gPSAwKSA6IChnID0gQSA+Pj4gMjQsIF8gKz0gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggPj0gMClcbiAgICAgICAgICBmb3IgKHNbaC0tXSA9IGc7IGggPj0gMDsgKVxuICAgICAgICAgICAgc1toLS1dID0gMDtcbiAgICAgIH0sIE1hdGguY2x6MzIgPyBpLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHMpO1xuICAgICAgfSA6IGkucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1ID0gcywgaCA9IDA7XG4gICAgICAgIHJldHVybiB1ID49IDQwOTYgJiYgKGggKz0gMTMsIHUgPj4+PSAxMyksIHUgPj0gNjQgJiYgKGggKz0gNywgdSA+Pj49IDcpLCB1ID49IDggJiYgKGggKz0gNCwgdSA+Pj49IDQpLCB1ID49IDIgJiYgKGggKz0gMiwgdSA+Pj49IDIpLCBoICsgdTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMgPT09IDApIHJldHVybiAyNjtcbiAgICAgICAgdmFyIHUgPSBzLCBoID0gMDtcbiAgICAgICAgcmV0dXJuICh1ICYgODE5MSkgPT09IDAgJiYgKGggKz0gMTMsIHUgPj4+PSAxMyksICh1ICYgMTI3KSA9PT0gMCAmJiAoaCArPSA3LCB1ID4+Pj0gNyksICh1ICYgMTUpID09PSAwICYmIChoICs9IDQsIHUgPj4+PSA0KSwgKHUgJiAzKSA9PT0gMCAmJiAoaCArPSAyLCB1ID4+Pj0gMiksICh1ICYgMSkgPT09IDAgJiYgaCsrLCBoO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdLCB1ID0gdGhpcy5fY291bnRCaXRzKHMpO1xuICAgICAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIHU7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gUihkKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSBuZXcgQXJyYXkoZC5iaXRMZW5ndGgoKSksIHUgPSAwOyB1IDwgcy5sZW5ndGg7IHUrKykge1xuICAgICAgICAgIHZhciBoID0gdSAvIDI2IHwgMCwgZyA9IHUgJSAyNjtcbiAgICAgICAgICBzW3VdID0gZC53b3Jkc1toXSA+Pj4gZyAmIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCB1ID0gMDsgdSA8IHRoaXMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbdV0pO1xuICAgICAgICAgIGlmIChzICs9IGgsIGggIT09IDI2KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gdGhpcy5hYnMoKS5pbm90bihzKS5pYWRkbigxKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0bihzIC0gMSkgPyB0aGlzLm5vdG4ocykuaWFkZG4oMSkuaW5lZygpIDogdGhpcy5jbG9uZSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzWmVybygpIHx8ICh0aGlzLm5lZ2F0aXZlIF49IDEpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgZm9yICg7IHRoaXMubGVuZ3RoIDwgcy5sZW5ndGg7IClcbiAgICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBzLmxlbmd0aDsgdSsrKVxuICAgICAgICAgIHRoaXMud29yZHNbdV0gPSB0aGlzLndvcmRzW3VdIHwgcy53b3Jkc1t1XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKCh0aGlzLm5lZ2F0aXZlIHwgcy5uZWdhdGl2ZSkgPT09IDApLCB0aGlzLml1b3Iocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaW9yKHMpIDogcy5jbG9uZSgpLmlvcih0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXVvcihzKSA6IHMuY2xvbmUoKS5pdW9yKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICB0aGlzLmxlbmd0aCA+IHMubGVuZ3RoID8gdSA9IHMgOiB1ID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCB1Lmxlbmd0aDsgaCsrKVxuICAgICAgICAgIHRoaXMud29yZHNbaF0gPSB0aGlzLndvcmRzW2hdICYgcy53b3Jkc1toXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID0gdS5sZW5ndGgsIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbigodGhpcy5uZWdhdGl2ZSB8IHMubmVnYXRpdmUpID09PSAwKSwgdGhpcy5pdWFuZChzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaWFuZChzKSA6IHMuY2xvbmUoKS5pYW5kKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXVhbmQocykgOiBzLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUsIGg7XG4gICAgICAgIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyAodSA9IHRoaXMsIGggPSBzKSA6ICh1ID0gcywgaCA9IHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGgubGVuZ3RoOyBnKyspXG4gICAgICAgICAgdGhpcy53b3Jkc1tnXSA9IHUud29yZHNbZ10gXiBoLndvcmRzW2ddO1xuICAgICAgICBpZiAodGhpcyAhPT0gdSlcbiAgICAgICAgICBmb3IgKDsgZyA8IHUubGVuZ3RoOyBnKyspXG4gICAgICAgICAgICB0aGlzLndvcmRzW2ddID0gdS53b3Jkc1tnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID0gdS5sZW5ndGgsIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbigodGhpcy5uZWdhdGl2ZSB8IHMubmVnYXRpdmUpID09PSAwKSwgdGhpcy5pdXhvcihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXhvcihzKSA6IHMuY2xvbmUoKS5peG9yKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXV4b3IocykgOiBzLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbih0eXBlb2YgcyA9PSBcIm51bWJlclwiICYmIHMgPj0gMCk7XG4gICAgICAgIHZhciB1ID0gTWF0aC5jZWlsKHMgLyAyNikgfCAwLCBoID0gcyAlIDI2O1xuICAgICAgICB0aGlzLl9leHBhbmQodSksIGggPiAwICYmIHUtLTtcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCB1OyBnKyspXG4gICAgICAgICAgdGhpcy53b3Jkc1tnXSA9IH50aGlzLndvcmRzW2ddICYgNjcxMDg4NjM7XG4gICAgICAgIHJldHVybiBoID4gMCAmJiAodGhpcy53b3Jkc1tnXSA9IH50aGlzLndvcmRzW2ddICYgNjcxMDg4NjMgPj4gMjYgLSBoKSwgdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBuKHR5cGVvZiBzID09IFwibnVtYmVyXCIgJiYgcyA+PSAwKTtcbiAgICAgICAgdmFyIGggPSBzIC8gMjYgfCAwLCBnID0gcyAlIDI2O1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5kKGggKyAxKSwgdSA/IHRoaXMud29yZHNbaF0gPSB0aGlzLndvcmRzW2hdIHwgMSA8PCBnIDogdGhpcy53b3Jkc1toXSA9IHRoaXMud29yZHNbaF0gJiB+KDEgPDwgZyksIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgcy5uZWdhdGl2ZSA9PT0gMClcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIHUgPSB0aGlzLmlzdWIocyksIHRoaXMubmVnYXRpdmUgXj0gMSwgdGhpcy5fbm9ybVNpZ24oKTtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgcy5uZWdhdGl2ZSAhPT0gMClcbiAgICAgICAgICByZXR1cm4gcy5uZWdhdGl2ZSA9IDAsIHUgPSB0aGlzLmlzdWIocyksIHMubmVnYXRpdmUgPSAxLCB1Ll9ub3JtU2lnbigpO1xuICAgICAgICB2YXIgaCwgZztcbiAgICAgICAgdGhpcy5sZW5ndGggPiBzLmxlbmd0aCA/IChoID0gdGhpcywgZyA9IHMpIDogKGggPSBzLCBnID0gdGhpcyk7XG4gICAgICAgIGZvciAodmFyIHcgPSAwLCBfID0gMDsgXyA8IGcubGVuZ3RoOyBfKyspXG4gICAgICAgICAgdSA9IChoLndvcmRzW19dIHwgMCkgKyAoZy53b3Jkc1tfXSB8IDApICsgdywgdGhpcy53b3Jkc1tfXSA9IHUgJiA2NzEwODg2MywgdyA9IHUgPj4+IDI2O1xuICAgICAgICBmb3IgKDsgdyAhPT0gMCAmJiBfIDwgaC5sZW5ndGg7IF8rKylcbiAgICAgICAgICB1ID0gKGgud29yZHNbX10gfCAwKSArIHcsIHRoaXMud29yZHNbX10gPSB1ICYgNjcxMDg4NjMsIHcgPSB1ID4+PiAyNjtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID0gaC5sZW5ndGgsIHcgIT09IDApXG4gICAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSB3LCB0aGlzLmxlbmd0aCsrO1xuICAgICAgICBlbHNlIGlmIChoICE9PSB0aGlzKVxuICAgICAgICAgIGZvciAoOyBfIDwgaC5sZW5ndGg7IF8rKylcbiAgICAgICAgICAgIHRoaXMud29yZHNbX10gPSBoLndvcmRzW19dO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHU7XG4gICAgICAgIHJldHVybiBzLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDAgPyAocy5uZWdhdGl2ZSA9IDAsIHUgPSB0aGlzLnN1YihzKSwgcy5uZWdhdGl2ZSBePSAxLCB1KSA6IHMubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCA/ICh0aGlzLm5lZ2F0aXZlID0gMCwgdSA9IHMuc3ViKHRoaXMpLCB0aGlzLm5lZ2F0aXZlID0gMSwgdSkgOiB0aGlzLmxlbmd0aCA+IHMubGVuZ3RoID8gdGhpcy5jbG9uZSgpLmlhZGQocykgOiBzLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgICAgdmFyIHUgPSB0aGlzLmlhZGQocyk7XG4gICAgICAgICAgcmV0dXJuIHMubmVnYXRpdmUgPSAxLCB1Ll9ub3JtU2lnbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzLmlhZGQocyksIHRoaXMubmVnYXRpdmUgPSAxLCB0aGlzLl9ub3JtU2lnbigpO1xuICAgICAgICB2YXIgaCA9IHRoaXMuY21wKHMpO1xuICAgICAgICBpZiAoaCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMubGVuZ3RoID0gMSwgdGhpcy53b3Jkc1swXSA9IDAsIHRoaXM7XG4gICAgICAgIHZhciBnLCB3O1xuICAgICAgICBoID4gMCA/IChnID0gdGhpcywgdyA9IHMpIDogKGcgPSBzLCB3ID0gdGhpcyk7XG4gICAgICAgIGZvciAodmFyIF8gPSAwLCBBID0gMDsgQSA8IHcubGVuZ3RoOyBBKyspXG4gICAgICAgICAgdSA9IChnLndvcmRzW0FdIHwgMCkgLSAody53b3Jkc1tBXSB8IDApICsgXywgXyA9IHUgPj4gMjYsIHRoaXMud29yZHNbQV0gPSB1ICYgNjcxMDg4NjM7XG4gICAgICAgIGZvciAoOyBfICE9PSAwICYmIEEgPCBnLmxlbmd0aDsgQSsrKVxuICAgICAgICAgIHUgPSAoZy53b3Jkc1tBXSB8IDApICsgXywgXyA9IHUgPj4gMjYsIHRoaXMud29yZHNbQV0gPSB1ICYgNjcxMDg4NjM7XG4gICAgICAgIGlmIChfID09PSAwICYmIEEgPCBnLmxlbmd0aCAmJiBnICE9PSB0aGlzKVxuICAgICAgICAgIGZvciAoOyBBIDwgZy5sZW5ndGg7IEErKylcbiAgICAgICAgICAgIHRoaXMud29yZHNbQV0gPSBnLndvcmRzW0FdO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgQSksIGcgIT09IHRoaXMgJiYgKHRoaXMubmVnYXRpdmUgPSAxKSwgdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKHMpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHooZCwgcywgdSkge1xuICAgICAgICB1Lm5lZ2F0aXZlID0gcy5uZWdhdGl2ZSBeIGQubmVnYXRpdmU7XG4gICAgICAgIHZhciBoID0gZC5sZW5ndGggKyBzLmxlbmd0aCB8IDA7XG4gICAgICAgIHUubGVuZ3RoID0gaCwgaCA9IGggLSAxIHwgMDtcbiAgICAgICAgdmFyIGcgPSBkLndvcmRzWzBdIHwgMCwgdyA9IHMud29yZHNbMF0gfCAwLCBfID0gZyAqIHcsIEEgPSBfICYgNjcxMDg4NjMsIHAgPSBfIC8gNjcxMDg4NjQgfCAwO1xuICAgICAgICB1LndvcmRzWzBdID0gQTtcbiAgICAgICAgZm9yICh2YXIgYSA9IDE7IGEgPCBoOyBhKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBsID0gcCA+Pj4gMjYsIE0gPSBwICYgNjcxMDg4NjMsIGsgPSBNYXRoLm1pbihhLCBzLmxlbmd0aCAtIDEpLCAkID0gTWF0aC5tYXgoMCwgYSAtIGQubGVuZ3RoICsgMSk7ICQgPD0gazsgJCsrKSB7XG4gICAgICAgICAgICB2YXIgWCA9IGEgLSAkIHwgMDtcbiAgICAgICAgICAgIGcgPSBkLndvcmRzW1hdIHwgMCwgdyA9IHMud29yZHNbJF0gfCAwLCBfID0gZyAqIHcgKyBNLCBsICs9IF8gLyA2NzEwODg2NCB8IDAsIE0gPSBfICYgNjcxMDg4NjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHUud29yZHNbYV0gPSBNIHwgMCwgcCA9IGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwICE9PSAwID8gdS53b3Jkc1thXSA9IHAgfCAwIDogdS5sZW5ndGgtLSwgdS5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICAgIHZhciBLID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICB2YXIgZyA9IHMud29yZHMsIHcgPSB1LndvcmRzLCBfID0gaC53b3JkcywgQSA9IDAsIHAsIGEsIGwsIE0gPSBnWzBdIHwgMCwgayA9IE0gJiA4MTkxLCAkID0gTSA+Pj4gMTMsIFggPSBnWzFdIHwgMCwgcmUgPSBYICYgODE5MSwgc2UgPSBYID4+PiAxMywgdXQgPSBnWzJdIHwgMCwgeGUgPSB1dCAmIDgxOTEsIEllID0gdXQgPj4+IDEzLCBYZSA9IGdbM10gfCAwLCBhZSA9IFhlICYgODE5MSwgZ2UgPSBYZSA+Pj4gMTMsIGl0ID0gZ1s0XSB8IDAsIHdlID0gaXQgJiA4MTkxLCBNZSA9IGl0ID4+PiAxMywgZnQgPSBnWzVdIHwgMCwgeWUgPSBmdCAmIDgxOTEsIGJlID0gZnQgPj4+IDEzLCB4dCA9IGdbNl0gfCAwLCBTZSA9IHh0ICYgODE5MSwga2UgPSB4dCA+Pj4gMTMsIGN0ID0gZ1s3XSB8IDAsIF9lID0gY3QgJiA4MTkxLCBFID0gY3QgPj4+IDEzLCBtID0gZ1s4XSB8IDAsIHkgPSBtICYgODE5MSwgSSA9IG0gPj4+IDEzLCBxID0gZ1s5XSB8IDAsIEggPSBxICYgODE5MSwgVyA9IHEgPj4+IDEzLCBCZSA9IHdbMF0gfCAwLCBtZSA9IEJlICYgODE5MSwgZGUgPSBCZSA+Pj4gMTMsIG90ID0gd1sxXSB8IDAsIGNlID0gb3QgJiA4MTkxLCBMZSA9IG90ID4+PiAxMywgVm4gPSB3WzJdIHwgMCwgT2UgPSBWbiAmIDgxOTEsIE5lID0gVm4gPj4+IDEzLCBIbiA9IHdbM10gfCAwLCBqZSA9IEhuICYgODE5MSwgVWUgPSBIbiA+Pj4gMTMsIEtuID0gd1s0XSB8IDAsIEZlID0gS24gJiA4MTkxLCBQZSA9IEtuID4+PiAxMywgV24gPSB3WzVdIHwgMCwgRGUgPSBXbiAmIDgxOTEsICRlID0gV24gPj4+IDEzLCBHbiA9IHdbNl0gfCAwLCB6ZSA9IEduICYgODE5MSwgcWUgPSBHbiA+Pj4gMTMsIFluID0gd1s3XSB8IDAsIFplID0gWW4gJiA4MTkxLCBWZSA9IFluID4+PiAxMywgSm4gPSB3WzhdIHwgMCwgSGUgPSBKbiAmIDgxOTEsIEtlID0gSm4gPj4+IDEzLCBYbiA9IHdbOV0gfCAwLCBXZSA9IFhuICYgODE5MSwgR2UgPSBYbiA+Pj4gMTM7XG4gICAgICAgIGgubmVnYXRpdmUgPSBzLm5lZ2F0aXZlIF4gdS5uZWdhdGl2ZSwgaC5sZW5ndGggPSAxOSwgcCA9IE1hdGguaW11bChrLCBtZSksIGEgPSBNYXRoLmltdWwoaywgZGUpLCBhID0gYSArIE1hdGguaW11bCgkLCBtZSkgfCAwLCBsID0gTWF0aC5pbXVsKCQsIGRlKTtcbiAgICAgICAgdmFyIEZyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoRnIgPj4+IDI2KSB8IDAsIEZyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKHJlLCBtZSksIGEgPSBNYXRoLmltdWwocmUsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoc2UsIG1lKSB8IDAsIGwgPSBNYXRoLmltdWwoc2UsIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwoaywgY2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgTGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgY2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgTGUpIHwgMDtcbiAgICAgICAgdmFyIFByID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoUHIgPj4+IDI2KSB8IDAsIFByICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKHhlLCBtZSksIGEgPSBNYXRoLmltdWwoeGUsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIG1lKSB8IDAsIGwgPSBNYXRoLmltdWwoSWUsIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwocmUsIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHJlLCBMZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChzZSwgY2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoc2UsIExlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGssIE9lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGssIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKCQsIE9lKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKCQsIE5lKSB8IDA7XG4gICAgICAgIHZhciBEciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKERyID4+PiAyNikgfCAwLCBEciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChhZSwgbWUpLCBhID0gTWF0aC5pbXVsKGFlLCBkZSksIGEgPSBhICsgTWF0aC5pbXVsKGdlLCBtZSkgfCAwLCBsID0gTWF0aC5pbXVsKGdlLCBkZSksIHAgPSBwICsgTWF0aC5pbXVsKHhlLCBjZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh4ZSwgTGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIGNlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEllLCBMZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChyZSwgT2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwocmUsIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHNlLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChzZSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoaywgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgVWUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgVWUpIHwgMDtcbiAgICAgICAgdmFyICRyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoJHIgPj4+IDI2KSB8IDAsICRyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKHdlLCBtZSksIGEgPSBNYXRoLmltdWwod2UsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoTWUsIG1lKSB8IDAsIGwgPSBNYXRoLmltdWwoTWUsIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwoYWUsIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGFlLCBMZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChnZSwgY2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoZ2UsIExlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHhlLCBPZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh4ZSwgTmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIE9lKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEllLCBOZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChyZSwgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwocmUsIFVlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHNlLCBqZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChzZSwgVWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoaywgRmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgRmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgUGUpIHwgMDtcbiAgICAgICAgdmFyIHpyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoenIgPj4+IDI2KSB8IDAsIHpyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKHllLCBtZSksIGEgPSBNYXRoLmltdWwoeWUsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoYmUsIG1lKSB8IDAsIGwgPSBNYXRoLmltdWwoYmUsIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwod2UsIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHdlLCBMZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChNZSwgY2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoTWUsIExlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGFlLCBPZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChhZSwgTmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoZ2UsIE9lKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGdlLCBOZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh4ZSwgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeGUsIFVlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEllLCBqZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJZSwgVWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwocmUsIEZlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHJlLCBQZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChzZSwgRmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoc2UsIFBlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGssIERlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGssICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKCQsIERlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKCQsICRlKSB8IDA7XG4gICAgICAgIHZhciBxciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKHFyID4+PiAyNikgfCAwLCBxciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChTZSwgbWUpLCBhID0gTWF0aC5pbXVsKFNlLCBkZSksIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBtZSkgfCAwLCBsID0gTWF0aC5pbXVsKGtlLCBkZSksIHAgPSBwICsgTWF0aC5pbXVsKHllLCBjZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5ZSwgTGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYmUsIGNlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGJlLCBMZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh3ZSwgT2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwod2UsIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKE1lLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChNZSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoYWUsIGplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGFlLCBVZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChnZSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoZ2UsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHhlLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh4ZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEllLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChyZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwocmUsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHNlLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChzZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoaywgemUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgcWUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgcWUpIHwgMDtcbiAgICAgICAgdmFyIFpyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoWnIgPj4+IDI2KSB8IDAsIFpyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKF9lLCBtZSksIGEgPSBNYXRoLmltdWwoX2UsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoRSwgbWUpIHwgMCwgbCA9IE1hdGguaW11bChFLCBkZSksIHAgPSBwICsgTWF0aC5pbXVsKFNlLCBjZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChTZSwgTGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoa2UsIGNlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGtlLCBMZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh5ZSwgT2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeWUsIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGJlLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChiZSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwod2UsIGplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHdlLCBVZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChNZSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoTWUsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGFlLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChhZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoZ2UsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGdlLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh4ZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeGUsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEllLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwocmUsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHJlLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChzZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoc2UsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGssIFplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGssIFZlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKCQsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKCQsIFZlKSB8IDA7XG4gICAgICAgIHZhciBWciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKFZyID4+PiAyNikgfCAwLCBWciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bCh5LCBtZSksIGEgPSBNYXRoLmltdWwoeSwgZGUpLCBhID0gYSArIE1hdGguaW11bChJLCBtZSkgfCAwLCBsID0gTWF0aC5pbXVsKEksIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCBMZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBjZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCBMZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgT2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeWUsIGplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHllLCBVZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChiZSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoYmUsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHdlLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh3ZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoTWUsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKE1lLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChhZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYWUsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGdlLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChnZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeGUsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHhlLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSWUsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHJlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChyZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoc2UsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKHNlLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChrLCBIZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChrLCBLZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCgkLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bCgkLCBLZSkgfCAwO1xuICAgICAgICB2YXIgSHIgPSAoQSArIHAgfCAwKSArICgoYSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIEEgPSAobCArIChhID4+PiAxMykgfCAwKSArIChIciA+Pj4gMjYpIHwgMCwgSHIgJj0gNjcxMDg4NjMsIHAgPSBNYXRoLmltdWwoSCwgbWUpLCBhID0gTWF0aC5pbXVsKEgsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoVywgbWUpIHwgMCwgbCA9IE1hdGguaW11bChXLCBkZSksIHAgPSBwICsgTWF0aC5pbXVsKHksIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHksIExlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEksIGNlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEksIExlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKF9lLCBPZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChfZSwgTmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoRSwgT2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoRSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoU2UsIGplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKFNlLCBVZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChrZSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoa2UsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHllLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5ZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYmUsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGJlLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh3ZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwod2UsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKE1lLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChNZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoYWUsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGFlLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChnZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoZ2UsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHhlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh4ZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEllLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChyZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwocmUsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHNlLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChzZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoaywgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgR2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgR2UpIHwgMDtcbiAgICAgICAgdmFyIEtyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoS3IgPj4+IDI2KSB8IDAsIEtyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKEgsIGNlKSwgYSA9IE1hdGguaW11bChILCBMZSksIGEgPSBhICsgTWF0aC5pbXVsKFcsIGNlKSB8IDAsIGwgPSBNYXRoLmltdWwoVywgTGUpLCBwID0gcCArIE1hdGguaW11bCh5LCBPZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5LCBOZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJLCBOZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChfZSwgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoX2UsIFVlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEUsIGplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEUsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKFNlLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChTZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoa2UsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGtlLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh5ZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeWUsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGJlLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChiZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwod2UsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHdlLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChNZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoTWUsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGFlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChhZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoZ2UsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGdlLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh4ZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeGUsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEllLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwocmUsIFdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHJlLCBHZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChzZSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoc2UsIEdlKSB8IDA7XG4gICAgICAgIHZhciBXciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKFdyID4+PiAyNikgfCAwLCBXciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCBPZSksIGEgPSBNYXRoLmltdWwoSCwgTmUpLCBhID0gYSArIE1hdGguaW11bChXLCBPZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsIE5lKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgVWUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgVWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIEZlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCBQZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBGZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeWUsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHllLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChiZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoYmUsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHdlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh3ZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoTWUsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKE1lLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChhZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYWUsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGdlLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChnZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeGUsIFdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHhlLCBHZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJZSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSWUsIEdlKSB8IDA7XG4gICAgICAgIHZhciBHciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKEdyID4+PiAyNikgfCAwLCBHciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCBqZSksIGEgPSBNYXRoLmltdWwoSCwgVWUpLCBhID0gYSArIE1hdGguaW11bChXLCBqZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsIFVlKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgRmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgRmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgUGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIERlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCAkZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCAkZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgemUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsIHFlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCB6ZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgcWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeWUsIFplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHllLCBWZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChiZSwgWmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoYmUsIFZlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHdlLCBIZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh3ZSwgS2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoTWUsIEhlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKE1lLCBLZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChhZSwgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYWUsIEdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGdlLCBXZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChnZSwgR2UpIHwgMDtcbiAgICAgICAgdmFyIFlyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoWXIgPj4+IDI2KSB8IDAsIFlyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKEgsIEZlKSwgYSA9IE1hdGguaW11bChILCBQZSksIGEgPSBhICsgTWF0aC5pbXVsKFcsIEZlKSB8IDAsIGwgPSBNYXRoLmltdWwoVywgUGUpLCBwID0gcCArIE1hdGguaW11bCh5LCBEZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5LCAkZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJLCAkZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChfZSwgemUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoX2UsIHFlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEUsIHplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEUsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKFNlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChTZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoa2UsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGtlLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh5ZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeWUsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGJlLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChiZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwod2UsIFdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHdlLCBHZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChNZSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoTWUsIEdlKSB8IDA7XG4gICAgICAgIHZhciBKciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKEpyID4+PiAyNikgfCAwLCBKciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCBEZSksIGEgPSBNYXRoLmltdWwoSCwgJGUpLCBhID0gYSArIE1hdGguaW11bChXLCBEZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsICRlKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgemUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgcWUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgcWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIFplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCBWZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBaZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeWUsIFdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHllLCBHZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChiZSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoYmUsIEdlKSB8IDA7XG4gICAgICAgIHZhciBYciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKFhyID4+PiAyNikgfCAwLCBYciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCB6ZSksIGEgPSBNYXRoLmltdWwoSCwgcWUpLCBhID0gYSArIE1hdGguaW11bChXLCB6ZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsIHFlKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgWmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgWmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgVmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIEhlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCBLZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCBLZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsIEdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBXZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgR2UpIHwgMDtcbiAgICAgICAgdmFyIFFyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoUXIgPj4+IDI2KSB8IDAsIFFyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKEgsIFplKSwgYSA9IE1hdGguaW11bChILCBWZSksIGEgPSBhICsgTWF0aC5pbXVsKFcsIFplKSB8IDAsIGwgPSBNYXRoLmltdWwoVywgVmUpLCBwID0gcCArIE1hdGguaW11bCh5LCBIZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5LCBLZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJLCBLZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChfZSwgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoX2UsIEdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEUsIFdlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEUsIEdlKSB8IDA7XG4gICAgICAgIHZhciBlbiA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKGVuID4+PiAyNikgfCAwLCBlbiAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCBIZSksIGEgPSBNYXRoLmltdWwoSCwgS2UpLCBhID0gYSArIE1hdGguaW11bChXLCBIZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsIEtlKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgR2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgR2UpIHwgMDtcbiAgICAgICAgdmFyIHRuID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAodG4gPj4+IDI2KSB8IDAsIHRuICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKEgsIFdlKSwgYSA9IE1hdGguaW11bChILCBHZSksIGEgPSBhICsgTWF0aC5pbXVsKFcsIFdlKSB8IDAsIGwgPSBNYXRoLmltdWwoVywgR2UpO1xuICAgICAgICB2YXIgcm4gPSAoQSArIHAgfCAwKSArICgoYSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIHJldHVybiBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAocm4gPj4+IDI2KSB8IDAsIHJuICY9IDY3MTA4ODYzLCBfWzBdID0gRnIsIF9bMV0gPSBQciwgX1syXSA9IERyLCBfWzNdID0gJHIsIF9bNF0gPSB6ciwgX1s1XSA9IHFyLCBfWzZdID0gWnIsIF9bN10gPSBWciwgX1s4XSA9IEhyLCBfWzldID0gS3IsIF9bMTBdID0gV3IsIF9bMTFdID0gR3IsIF9bMTJdID0gWXIsIF9bMTNdID0gSnIsIF9bMTRdID0gWHIsIF9bMTVdID0gUXIsIF9bMTZdID0gZW4sIF9bMTddID0gdG4sIF9bMThdID0gcm4sIEEgIT09IDAgJiYgKF9bMTldID0gQSwgaC5sZW5ndGgrKyksIGg7XG4gICAgICB9O1xuICAgICAgTWF0aC5pbXVsIHx8IChLID0geik7XG4gICAgICBmdW5jdGlvbiBaKGQsIHMsIHUpIHtcbiAgICAgICAgdS5uZWdhdGl2ZSA9IHMubmVnYXRpdmUgXiBkLm5lZ2F0aXZlLCB1Lmxlbmd0aCA9IGQubGVuZ3RoICsgcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGggPSAwLCBnID0gMCwgdyA9IDA7IHcgPCB1Lmxlbmd0aCAtIDE7IHcrKykge1xuICAgICAgICAgIHZhciBfID0gZztcbiAgICAgICAgICBnID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBBID0gaCAmIDY3MTA4ODYzLCBwID0gTWF0aC5taW4odywgcy5sZW5ndGggLSAxKSwgYSA9IE1hdGgubWF4KDAsIHcgLSBkLmxlbmd0aCArIDEpOyBhIDw9IHA7IGErKykge1xuICAgICAgICAgICAgdmFyIGwgPSB3IC0gYSwgTSA9IGQud29yZHNbbF0gfCAwLCBrID0gcy53b3Jkc1thXSB8IDAsICQgPSBNICogaywgWCA9ICQgJiA2NzEwODg2MztcbiAgICAgICAgICAgIF8gPSBfICsgKCQgLyA2NzEwODg2NCB8IDApIHwgMCwgWCA9IFggKyBBIHwgMCwgQSA9IFggJiA2NzEwODg2MywgXyA9IF8gKyAoWCA+Pj4gMjYpIHwgMCwgZyArPSBfID4+PiAyNiwgXyAmPSA2NzEwODg2MztcbiAgICAgICAgICB9XG4gICAgICAgICAgdS53b3Jkc1t3XSA9IEEsIGggPSBfLCBfID0gZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaCAhPT0gMCA/IHUud29yZHNbd10gPSBoIDogdS5sZW5ndGgtLSwgdS5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFEoZCwgcywgdSkge1xuICAgICAgICByZXR1cm4gWihkLCBzLCB1KTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICB2YXIgaCwgZyA9IHRoaXMubGVuZ3RoICsgcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMTAgJiYgcy5sZW5ndGggPT09IDEwID8gaCA9IEsodGhpcywgcywgdSkgOiBnIDwgNjMgPyBoID0geih0aGlzLCBzLCB1KSA6IGcgPCAxMDI0ID8gaCA9IFoodGhpcywgcywgdSkgOiBoID0gUSh0aGlzLCBzLCB1KSwgaDtcbiAgICAgIH0sIGkucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBuZXcgaShudWxsKTtcbiAgICAgICAgcmV0dXJuIHUud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBzLmxlbmd0aCksIHRoaXMubXVsVG8ocywgdSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IG5ldyBpKG51bGwpO1xuICAgICAgICByZXR1cm4gdS53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIHMubGVuZ3RoKSwgUSh0aGlzLCBzLCB1KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8ocywgdGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBzIDwgMDtcbiAgICAgICAgdSAmJiAocyA9IC1zKSwgbih0eXBlb2YgcyA9PSBcIm51bWJlclwiKSwgbihzIDwgNjcxMDg4NjQpO1xuICAgICAgICBmb3IgKHZhciBoID0gMCwgZyA9IDA7IGcgPCB0aGlzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tnXSB8IDApICogcywgXyA9ICh3ICYgNjcxMDg4NjMpICsgKGggJiA2NzEwODg2Myk7XG4gICAgICAgICAgaCA+Pj0gMjYsIGggKz0gdyAvIDY3MTA4ODY0IHwgMCwgaCArPSBfID4+PiAyNiwgdGhpcy53b3Jkc1tnXSA9IF8gJiA2NzEwODg2MztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaCAhPT0gMCAmJiAodGhpcy53b3Jkc1tnXSA9IGgsIHRoaXMubGVuZ3RoKyspLCB1ID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBSKHMpO1xuICAgICAgICBpZiAodS5sZW5ndGggPT09IDApIHJldHVybiBuZXcgaSgxKTtcbiAgICAgICAgZm9yICh2YXIgaCA9IHRoaXMsIGcgPSAwOyBnIDwgdS5sZW5ndGggJiYgdVtnXSA9PT0gMDsgZysrLCBoID0gaC5zcXIoKSlcbiAgICAgICAgICA7XG4gICAgICAgIGlmICgrK2cgPCB1Lmxlbmd0aClcbiAgICAgICAgICBmb3IgKHZhciB3ID0gaC5zcXIoKTsgZyA8IHUubGVuZ3RoOyBnKyssIHcgPSB3LnNxcigpKVxuICAgICAgICAgICAgdVtnXSAhPT0gMCAmJiAoaCA9IGgubXVsKHcpKTtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIG4odHlwZW9mIHMgPT0gXCJudW1iZXJcIiAmJiBzID49IDApO1xuICAgICAgICB2YXIgdSA9IHMgJSAyNiwgaCA9IChzIC0gdSkgLyAyNiwgZyA9IDY3MTA4ODYzID4+PiAyNiAtIHUgPDwgMjYgLSB1LCB3O1xuICAgICAgICBpZiAodSAhPT0gMCkge1xuICAgICAgICAgIHZhciBfID0gMDtcbiAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgICAgdmFyIEEgPSB0aGlzLndvcmRzW3ddICYgZywgcCA9ICh0aGlzLndvcmRzW3ddIHwgMCkgLSBBIDw8IHU7XG4gICAgICAgICAgICB0aGlzLndvcmRzW3ddID0gcCB8IF8sIF8gPSBBID4+PiAyNiAtIHU7XG4gICAgICAgICAgfVxuICAgICAgICAgIF8gJiYgKHRoaXMud29yZHNbd10gPSBfLCB0aGlzLmxlbmd0aCsrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCAhPT0gMCkge1xuICAgICAgICAgIGZvciAodyA9IHRoaXMubGVuZ3RoIC0gMTsgdyA+PSAwOyB3LS0pXG4gICAgICAgICAgICB0aGlzLndvcmRzW3cgKyBoXSA9IHRoaXMud29yZHNbd107XG4gICAgICAgICAgZm9yICh3ID0gMDsgdyA8IGg7IHcrKylcbiAgICAgICAgICAgIHRoaXMud29yZHNbd10gPSAwO1xuICAgICAgICAgIHRoaXMubGVuZ3RoICs9IGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5uZWdhdGl2ZSA9PT0gMCksIHRoaXMuaXVzaGxuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICBuKHR5cGVvZiBzID09IFwibnVtYmVyXCIgJiYgcyA+PSAwKTtcbiAgICAgICAgdmFyIGc7XG4gICAgICAgIHUgPyBnID0gKHUgLSB1ICUgMjYpIC8gMjYgOiBnID0gMDtcbiAgICAgICAgdmFyIHcgPSBzICUgMjYsIF8gPSBNYXRoLm1pbigocyAtIHcpIC8gMjYsIHRoaXMubGVuZ3RoKSwgQSA9IDY3MTA4ODYzIF4gNjcxMDg4NjMgPj4+IHcgPDwgdywgcCA9IGg7XG4gICAgICAgIGlmIChnIC09IF8sIGcgPSBNYXRoLm1heCgwLCBnKSwgcCkge1xuICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgXzsgYSsrKVxuICAgICAgICAgICAgcC53b3Jkc1thXSA9IHRoaXMud29yZHNbYV07XG4gICAgICAgICAgcC5sZW5ndGggPSBfO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfICE9PSAwKSBpZiAodGhpcy5sZW5ndGggPiBfKVxuICAgICAgICAgIGZvciAodGhpcy5sZW5ndGggLT0gXywgYSA9IDA7IGEgPCB0aGlzLmxlbmd0aDsgYSsrKVxuICAgICAgICAgICAgdGhpcy53b3Jkc1thXSA9IHRoaXMud29yZHNbYSArIF9dO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy53b3Jkc1swXSA9IDAsIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICBmb3IgKGEgPSB0aGlzLmxlbmd0aCAtIDE7IGEgPj0gMCAmJiAobCAhPT0gMCB8fCBhID49IGcpOyBhLS0pIHtcbiAgICAgICAgICB2YXIgTSA9IHRoaXMud29yZHNbYV0gfCAwO1xuICAgICAgICAgIHRoaXMud29yZHNbYV0gPSBsIDw8IDI2IC0gdyB8IE0gPj4+IHcsIGwgPSBNICYgQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcCAmJiBsICE9PSAwICYmIChwLndvcmRzW3AubGVuZ3RoKytdID0gbCksIHRoaXMubGVuZ3RoID09PSAwICYmICh0aGlzLndvcmRzWzBdID0gMCwgdGhpcy5sZW5ndGggPSAxKSwgdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICByZXR1cm4gbih0aGlzLm5lZ2F0aXZlID09PSAwKSwgdGhpcy5pdXNocm4ocywgdSwgaCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24ocykge1xuICAgICAgICBuKHR5cGVvZiBzID09IFwibnVtYmVyXCIgJiYgcyA+PSAwKTtcbiAgICAgICAgdmFyIHUgPSBzICUgMjYsIGggPSAocyAtIHUpIC8gMjYsIGcgPSAxIDw8IHU7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8PSBoKSByZXR1cm4gITE7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1toXTtcbiAgICAgICAgcmV0dXJuICEhKHcgJiBnKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbih0eXBlb2YgcyA9PSBcIm51bWJlclwiICYmIHMgPj0gMCk7XG4gICAgICAgIHZhciB1ID0gcyAlIDI2LCBoID0gKHMgLSB1KSAvIDI2O1xuICAgICAgICBpZiAobih0aGlzLm5lZ2F0aXZlID09PSAwLCBcImltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVyc1wiKSwgdGhpcy5sZW5ndGggPD0gaClcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHUgIT09IDAgJiYgaCsrLCB0aGlzLmxlbmd0aCA9IE1hdGgubWluKGgsIHRoaXMubGVuZ3RoKSwgdSAhPT0gMCkge1xuICAgICAgICAgIHZhciBnID0gNjcxMDg4NjMgXiA2NzEwODg2MyA+Pj4gdSA8PCB1O1xuICAgICAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKHR5cGVvZiBzID09IFwibnVtYmVyXCIpLCBuKHMgPCA2NzEwODg2NCksIHMgPCAwID8gdGhpcy5pc3VibigtcykgOiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gdGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8PSBzID8gKHRoaXMud29yZHNbMF0gPSBzIC0gKHRoaXMud29yZHNbMF0gfCAwKSwgdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMpIDogKHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzLmlzdWJuKHMpLCB0aGlzLm5lZ2F0aXZlID0gMSwgdGhpcykgOiB0aGlzLl9pYWRkbihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSBzO1xuICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbdV0gPj0gNjcxMDg4NjQ7IHUrKylcbiAgICAgICAgICB0aGlzLndvcmRzW3VdIC09IDY3MTA4ODY0LCB1ID09PSB0aGlzLmxlbmd0aCAtIDEgPyB0aGlzLndvcmRzW3UgKyAxXSA9IDEgOiB0aGlzLndvcmRzW3UgKyAxXSsrO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgdSArIDEpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChuKHR5cGVvZiBzID09IFwibnVtYmVyXCIpLCBuKHMgPCA2NzEwODg2NCksIHMgPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtcyk7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKVxuICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy5pYWRkbihzKSwgdGhpcy5uZWdhdGl2ZSA9IDEsIHRoaXM7XG4gICAgICAgIGlmICh0aGlzLndvcmRzWzBdIC09IHMsIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKVxuICAgICAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXSwgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbdV0gPCAwOyB1KyspXG4gICAgICAgICAgICB0aGlzLndvcmRzW3VdICs9IDY3MTA4ODY0LCB0aGlzLndvcmRzW3UgKyAxXSAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIHZhciBnID0gcy5sZW5ndGggKyBoLCB3O1xuICAgICAgICB0aGlzLl9leHBhbmQoZyk7XG4gICAgICAgIHZhciBfLCBBID0gMDtcbiAgICAgICAgZm9yICh3ID0gMDsgdyA8IHMubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICBfID0gKHRoaXMud29yZHNbdyArIGhdIHwgMCkgKyBBO1xuICAgICAgICAgIHZhciBwID0gKHMud29yZHNbd10gfCAwKSAqIHU7XG4gICAgICAgICAgXyAtPSBwICYgNjcxMDg4NjMsIEEgPSAoXyA+PiAyNikgLSAocCAvIDY3MTA4ODY0IHwgMCksIHRoaXMud29yZHNbdyArIGhdID0gXyAmIDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyB3IDwgdGhpcy5sZW5ndGggLSBoOyB3KyspXG4gICAgICAgICAgXyA9ICh0aGlzLndvcmRzW3cgKyBoXSB8IDApICsgQSwgQSA9IF8gPj4gMjYsIHRoaXMud29yZHNbdyArIGhdID0gXyAmIDY3MTA4ODYzO1xuICAgICAgICBpZiAoQSA9PT0gMCkgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICAgIGZvciAobihBID09PSAtMSksIEEgPSAwLCB3ID0gMDsgdyA8IHRoaXMubGVuZ3RoOyB3KyspXG4gICAgICAgICAgXyA9IC0odGhpcy53b3Jkc1t3XSB8IDApICsgQSwgQSA9IF8gPj4gMjYsIHRoaXMud29yZHNbd10gPSBfICYgNjcxMDg4NjM7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMSwgdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICB2YXIgaCA9IHRoaXMubGVuZ3RoIC0gcy5sZW5ndGgsIGcgPSB0aGlzLmNsb25lKCksIHcgPSBzLCBfID0gdy53b3Jkc1t3Lmxlbmd0aCAtIDFdIHwgMCwgQSA9IHRoaXMuX2NvdW50Qml0cyhfKTtcbiAgICAgICAgaCA9IDI2IC0gQSwgaCAhPT0gMCAmJiAodyA9IHcudXNobG4oaCksIGcuaXVzaGxuKGgpLCBfID0gdy53b3Jkc1t3Lmxlbmd0aCAtIDFdIHwgMCk7XG4gICAgICAgIHZhciBwID0gZy5sZW5ndGggLSB3Lmxlbmd0aCwgYTtcbiAgICAgICAgaWYgKHUgIT09IFwibW9kXCIpIHtcbiAgICAgICAgICBhID0gbmV3IGkobnVsbCksIGEubGVuZ3RoID0gcCArIDEsIGEud29yZHMgPSBuZXcgQXJyYXkoYS5sZW5ndGgpO1xuICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgYS5sZW5ndGg7IGwrKylcbiAgICAgICAgICAgIGEud29yZHNbbF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNID0gZy5jbG9uZSgpLl9pc2hsbnN1Ym11bCh3LCAxLCBwKTtcbiAgICAgICAgTS5uZWdhdGl2ZSA9PT0gMCAmJiAoZyA9IE0sIGEgJiYgKGEud29yZHNbcF0gPSAxKSk7XG4gICAgICAgIGZvciAodmFyIGsgPSBwIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICB2YXIgJCA9IChnLndvcmRzW3cubGVuZ3RoICsga10gfCAwKSAqIDY3MTA4ODY0ICsgKGcud29yZHNbdy5sZW5ndGggKyBrIC0gMV0gfCAwKTtcbiAgICAgICAgICBmb3IgKCQgPSBNYXRoLm1pbigkIC8gXyB8IDAsIDY3MTA4ODYzKSwgZy5faXNobG5zdWJtdWwodywgJCwgayk7IGcubmVnYXRpdmUgIT09IDA7IClcbiAgICAgICAgICAgICQtLSwgZy5uZWdhdGl2ZSA9IDAsIGcuX2lzaGxuc3VibXVsKHcsIDEsIGspLCBnLmlzWmVybygpIHx8IChnLm5lZ2F0aXZlIF49IDEpO1xuICAgICAgICAgIGEgJiYgKGEud29yZHNba10gPSAkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSAmJiBhLl9zdHJpcCgpLCBnLl9zdHJpcCgpLCB1ICE9PSBcImRpdlwiICYmIGggIT09IDAgJiYgZy5pdXNocm4oaCksIHtcbiAgICAgICAgICBkaXY6IGEgfHwgbnVsbCxcbiAgICAgICAgICBtb2Q6IGdcbiAgICAgICAgfTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uKHMsIHUsIGgpIHtcbiAgICAgICAgaWYgKG4oIXMuaXNaZXJvKCkpLCB0aGlzLmlzWmVybygpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXY6IG5ldyBpKDApLFxuICAgICAgICAgICAgbW9kOiBuZXcgaSgwKVxuICAgICAgICAgIH07XG4gICAgICAgIHZhciBnLCB3LCBfO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBzLm5lZ2F0aXZlID09PSAwID8gKF8gPSB0aGlzLm5lZygpLmRpdm1vZChzLCB1KSwgdSAhPT0gXCJtb2RcIiAmJiAoZyA9IF8uZGl2Lm5lZygpKSwgdSAhPT0gXCJkaXZcIiAmJiAodyA9IF8ubW9kLm5lZygpLCBoICYmIHcubmVnYXRpdmUgIT09IDAgJiYgdy5pYWRkKHMpKSwge1xuICAgICAgICAgIGRpdjogZyxcbiAgICAgICAgICBtb2Q6IHdcbiAgICAgICAgfSkgOiB0aGlzLm5lZ2F0aXZlID09PSAwICYmIHMubmVnYXRpdmUgIT09IDAgPyAoXyA9IHRoaXMuZGl2bW9kKHMubmVnKCksIHUpLCB1ICE9PSBcIm1vZFwiICYmIChnID0gXy5kaXYubmVnKCkpLCB7XG4gICAgICAgICAgZGl2OiBnLFxuICAgICAgICAgIG1vZDogXy5tb2RcbiAgICAgICAgfSkgOiAodGhpcy5uZWdhdGl2ZSAmIHMubmVnYXRpdmUpICE9PSAwID8gKF8gPSB0aGlzLm5lZygpLmRpdm1vZChzLm5lZygpLCB1KSwgdSAhPT0gXCJkaXZcIiAmJiAodyA9IF8ubW9kLm5lZygpLCBoICYmIHcubmVnYXRpdmUgIT09IDAgJiYgdy5pc3ViKHMpKSwge1xuICAgICAgICAgIGRpdjogXy5kaXYsXG4gICAgICAgICAgbW9kOiB3XG4gICAgICAgIH0pIDogcy5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChzKSA8IDAgPyB7XG4gICAgICAgICAgZGl2OiBuZXcgaSgwKSxcbiAgICAgICAgICBtb2Q6IHRoaXNcbiAgICAgICAgfSA6IHMubGVuZ3RoID09PSAxID8gdSA9PT0gXCJkaXZcIiA/IHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihzLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfSA6IHUgPT09IFwibW9kXCIgPyB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IGkodGhpcy5tb2RybihzLndvcmRzWzBdKSlcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihzLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG5ldyBpKHRoaXMubW9kcm4ocy53b3Jkc1swXSkpXG4gICAgICAgIH0gOiB0aGlzLl93b3JkRGl2KHMsIHUpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZtb2QocywgXCJkaXZcIiwgITEpLmRpdjtcbiAgICAgIH0sIGkucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2bW9kKHMsIFwibW9kXCIsICExKS5tb2Q7XG4gICAgICB9LCBpLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZtb2QocywgXCJtb2RcIiwgITApLm1vZDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IHRoaXMuZGl2bW9kKHMpO1xuICAgICAgICBpZiAodS5tb2QuaXNaZXJvKCkpIHJldHVybiB1LmRpdjtcbiAgICAgICAgdmFyIGggPSB1LmRpdi5uZWdhdGl2ZSAhPT0gMCA/IHUubW9kLmlzdWIocykgOiB1Lm1vZCwgZyA9IHMudXNocm4oMSksIHcgPSBzLmFuZGxuKDEpLCBfID0gaC5jbXAoZyk7XG4gICAgICAgIHJldHVybiBfIDwgMCB8fCB3ID09PSAxICYmIF8gPT09IDAgPyB1LmRpdiA6IHUuZGl2Lm5lZ2F0aXZlICE9PSAwID8gdS5kaXYuaXN1Ym4oMSkgOiB1LmRpdi5pYWRkbigxKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm1vZHJuID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IHMgPCAwO1xuICAgICAgICB1ICYmIChzID0gLXMpLCBuKHMgPD0gNjcxMDg4NjMpO1xuICAgICAgICBmb3IgKHZhciBoID0gKDEgPDwgMjYpICUgcywgZyA9IDAsIHcgPSB0aGlzLmxlbmd0aCAtIDE7IHcgPj0gMDsgdy0tKVxuICAgICAgICAgIGcgPSAoaCAqIGcgKyAodGhpcy53b3Jkc1t3XSB8IDApKSAlIHM7XG4gICAgICAgIHJldHVybiB1ID8gLWcgOiBnO1xuICAgICAgfSwgaS5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kcm4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBzIDwgMDtcbiAgICAgICAgdSAmJiAocyA9IC1zKSwgbihzIDw9IDY3MTA4ODYzKTtcbiAgICAgICAgZm9yICh2YXIgaCA9IDAsIGcgPSB0aGlzLmxlbmd0aCAtIDE7IGcgPj0gMDsgZy0tKSB7XG4gICAgICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tnXSB8IDApICsgaCAqIDY3MTA4ODY0O1xuICAgICAgICAgIHRoaXMud29yZHNbZ10gPSB3IC8gcyB8IDAsIGggPSB3ICUgcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKSwgdSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24ocykge1xuICAgICAgICBuKHMubmVnYXRpdmUgPT09IDApLCBuKCFzLmlzWmVybygpKTtcbiAgICAgICAgdmFyIHUgPSB0aGlzLCBoID0gcy5jbG9uZSgpO1xuICAgICAgICB1Lm5lZ2F0aXZlICE9PSAwID8gdSA9IHUudW1vZChzKSA6IHUgPSB1LmNsb25lKCk7XG4gICAgICAgIGZvciAodmFyIGcgPSBuZXcgaSgxKSwgdyA9IG5ldyBpKDApLCBfID0gbmV3IGkoMCksIEEgPSBuZXcgaSgxKSwgcCA9IDA7IHUuaXNFdmVuKCkgJiYgaC5pc0V2ZW4oKTsgKVxuICAgICAgICAgIHUuaXVzaHJuKDEpLCBoLml1c2hybigxKSwgKytwO1xuICAgICAgICBmb3IgKHZhciBhID0gaC5jbG9uZSgpLCBsID0gdS5jbG9uZSgpOyAhdS5pc1plcm8oKTsgKSB7XG4gICAgICAgICAgZm9yICh2YXIgTSA9IDAsIGsgPSAxOyAodS53b3Jkc1swXSAmIGspID09PSAwICYmIE0gPCAyNjsgKytNLCBrIDw8PSAxKSA7XG4gICAgICAgICAgaWYgKE0gPiAwKVxuICAgICAgICAgICAgZm9yICh1Lml1c2hybihNKTsgTS0tID4gMDsgKVxuICAgICAgICAgICAgICAoZy5pc09kZCgpIHx8IHcuaXNPZGQoKSkgJiYgKGcuaWFkZChhKSwgdy5pc3ViKGwpKSwgZy5pdXNocm4oMSksIHcuaXVzaHJuKDEpO1xuICAgICAgICAgIGZvciAodmFyICQgPSAwLCBYID0gMTsgKGgud29yZHNbMF0gJiBYKSA9PT0gMCAmJiAkIDwgMjY7ICsrJCwgWCA8PD0gMSkgO1xuICAgICAgICAgIGlmICgkID4gMClcbiAgICAgICAgICAgIGZvciAoaC5pdXNocm4oJCk7ICQtLSA+IDA7IClcbiAgICAgICAgICAgICAgKF8uaXNPZGQoKSB8fCBBLmlzT2RkKCkpICYmIChfLmlhZGQoYSksIEEuaXN1YihsKSksIF8uaXVzaHJuKDEpLCBBLml1c2hybigxKTtcbiAgICAgICAgICB1LmNtcChoKSA+PSAwID8gKHUuaXN1YihoKSwgZy5pc3ViKF8pLCB3LmlzdWIoQSkpIDogKGguaXN1Yih1KSwgXy5pc3ViKGcpLCBBLmlzdWIodykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYTogXyxcbiAgICAgICAgICBiOiBBLFxuICAgICAgICAgIGdjZDogaC5pdXNobG4ocClcbiAgICAgICAgfTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbihzLm5lZ2F0aXZlID09PSAwKSwgbighcy5pc1plcm8oKSk7XG4gICAgICAgIHZhciB1ID0gdGhpcywgaCA9IHMuY2xvbmUoKTtcbiAgICAgICAgdS5uZWdhdGl2ZSAhPT0gMCA/IHUgPSB1LnVtb2QocykgOiB1ID0gdS5jbG9uZSgpO1xuICAgICAgICBmb3IgKHZhciBnID0gbmV3IGkoMSksIHcgPSBuZXcgaSgwKSwgXyA9IGguY2xvbmUoKTsgdS5jbXBuKDEpID4gMCAmJiBoLmNtcG4oMSkgPiAwOyApIHtcbiAgICAgICAgICBmb3IgKHZhciBBID0gMCwgcCA9IDE7ICh1LndvcmRzWzBdICYgcCkgPT09IDAgJiYgQSA8IDI2OyArK0EsIHAgPDw9IDEpIDtcbiAgICAgICAgICBpZiAoQSA+IDApXG4gICAgICAgICAgICBmb3IgKHUuaXVzaHJuKEEpOyBBLS0gPiAwOyApXG4gICAgICAgICAgICAgIGcuaXNPZGQoKSAmJiBnLmlhZGQoXyksIGcuaXVzaHJuKDEpO1xuICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBsID0gMTsgKGgud29yZHNbMF0gJiBsKSA9PT0gMCAmJiBhIDwgMjY7ICsrYSwgbCA8PD0gMSkgO1xuICAgICAgICAgIGlmIChhID4gMClcbiAgICAgICAgICAgIGZvciAoaC5pdXNocm4oYSk7IGEtLSA+IDA7IClcbiAgICAgICAgICAgICAgdy5pc09kZCgpICYmIHcuaWFkZChfKSwgdy5pdXNocm4oMSk7XG4gICAgICAgICAgdS5jbXAoaCkgPj0gMCA/ICh1LmlzdWIoaCksIGcuaXN1Yih3KSkgOiAoaC5pc3ViKHUpLCB3LmlzdWIoZykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNO1xuICAgICAgICByZXR1cm4gdS5jbXBuKDEpID09PSAwID8gTSA9IGcgOiBNID0gdywgTS5jbXBuKDApIDwgMCAmJiBNLmlhZGQocyksIE07XG4gICAgICB9LCBpLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gcy5hYnMoKTtcbiAgICAgICAgaWYgKHMuaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuICAgICAgICB2YXIgdSA9IHRoaXMuY2xvbmUoKSwgaCA9IHMuY2xvbmUoKTtcbiAgICAgICAgdS5uZWdhdGl2ZSA9IDAsIGgubmVnYXRpdmUgPSAwO1xuICAgICAgICBmb3IgKHZhciBnID0gMDsgdS5pc0V2ZW4oKSAmJiBoLmlzRXZlbigpOyBnKyspXG4gICAgICAgICAgdS5pdXNocm4oMSksIGguaXVzaHJuKDEpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgZm9yICg7IHUuaXNFdmVuKCk7IClcbiAgICAgICAgICAgIHUuaXVzaHJuKDEpO1xuICAgICAgICAgIGZvciAoOyBoLmlzRXZlbigpOyApXG4gICAgICAgICAgICBoLml1c2hybigxKTtcbiAgICAgICAgICB2YXIgdyA9IHUuY21wKGgpO1xuICAgICAgICAgIGlmICh3IDwgMCkge1xuICAgICAgICAgICAgdmFyIF8gPSB1O1xuICAgICAgICAgICAgdSA9IGgsIGggPSBfO1xuICAgICAgICAgIH0gZWxzZSBpZiAodyA9PT0gMCB8fCBoLmNtcG4oMSkgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB1LmlzdWIoaCk7XG4gICAgICAgIH0gd2hpbGUgKCEwKTtcbiAgICAgICAgcmV0dXJuIGguaXVzaGxuKGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWdjZChzKS5hLnVtb2Qocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIHM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbih0eXBlb2YgcyA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgdmFyIHUgPSBzICUgMjYsIGggPSAocyAtIHUpIC8gMjYsIGcgPSAxIDw8IHU7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8PSBoKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9leHBhbmQoaCArIDEpLCB0aGlzLndvcmRzW2hdIHw9IGcsIHRoaXM7XG4gICAgICAgIGZvciAodmFyIHcgPSBnLCBfID0gaDsgdyAhPT0gMCAmJiBfIDwgdGhpcy5sZW5ndGg7IF8rKykge1xuICAgICAgICAgIHZhciBBID0gdGhpcy53b3Jkc1tfXSB8IDA7XG4gICAgICAgICAgQSArPSB3LCB3ID0gQSA+Pj4gMjYsIEEgJj0gNjcxMDg4NjMsIHRoaXMud29yZHNbX10gPSBBO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ICE9PSAwICYmICh0aGlzLndvcmRzW19dID0gdywgdGhpcy5sZW5ndGgrKyksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IHMgPCAwO1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhdSkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiB1KSByZXR1cm4gMTtcbiAgICAgICAgdGhpcy5fc3RyaXAoKTtcbiAgICAgICAgdmFyIGg7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgaCA9IDE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHUgJiYgKHMgPSAtcyksIG4ocyA8PSA2NzEwODg2MywgXCJOdW1iZXIgaXMgdG9vIGJpZ1wiKTtcbiAgICAgICAgICB2YXIgZyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgICAgIGggPSBnID09PSBzID8gMCA6IGcgPCBzID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gLWggfCAwIDogaDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgcy5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcbiAgICAgICAgdmFyIHUgPSB0aGlzLnVjbXAocyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gLXUgfCAwIDogdTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IHMubGVuZ3RoKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgcy5sZW5ndGgpIHJldHVybiAtMTtcbiAgICAgICAgZm9yICh2YXIgdSA9IDAsIGggPSB0aGlzLmxlbmd0aCAtIDE7IGggPj0gMDsgaC0tKSB7XG4gICAgICAgICAgdmFyIGcgPSB0aGlzLndvcmRzW2hdIHwgMCwgdyA9IHMud29yZHNbaF0gfCAwO1xuICAgICAgICAgIGlmIChnICE9PSB3KSB7XG4gICAgICAgICAgICBnIDwgdyA/IHUgPSAtMSA6IGcgPiB3ICYmICh1ID0gMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHU7XG4gICAgICB9LCBpLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcG4ocykgPT09IDE7XG4gICAgICB9LCBpLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKHMpID09PSAxO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wbihzKSA+PSAwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXAocykgPj0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wbihzKSA9PT0gLTE7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKHMpID09PSAtMTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcG4ocykgPD0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKHMpIDw9IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcG4ocykgPT09IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKHMpID09PSAwO1xuICAgICAgfSwgaS5yZWQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTChzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbighdGhpcy5yZWQsIFwiQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dFwiKSwgbih0aGlzLm5lZ2F0aXZlID09PSAwLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLCBzLmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcImZyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHRcIiksIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWQgPSBzLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKCF0aGlzLnJlZCwgXCJBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpLCB0aGlzLl9mb3JjZVJlZChzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwicmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuYWRkKHRoaXMsIHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwicmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLmlhZGQodGhpcywgcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLnN1Yih0aGlzLCBzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5pc3ViKHRoaXMsIHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbih0aGlzLnJlZCwgXCJyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5zaGwodGhpcywgcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIHMpLCB0aGlzLnJlZC5tdWwodGhpcywgcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbih0aGlzLnJlZCwgXCJyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBzKSwgdGhpcy5yZWQuaW11bCh0aGlzLCBzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbih0aGlzLnJlZCwgXCJyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQuc3FyKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbih0aGlzLnJlZCwgXCJyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwicmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5uZWcodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkICYmICFzLnJlZCwgXCJyZWRQb3cobm9ybWFsTnVtKVwiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLnBvdyh0aGlzLCBzKTtcbiAgICAgIH07XG4gICAgICB2YXIgaiA9IHtcbiAgICAgICAgazI1NjogbnVsbCxcbiAgICAgICAgcDIyNDogbnVsbCxcbiAgICAgICAgcDE5MjogbnVsbCxcbiAgICAgICAgcDI1NTE5OiBudWxsXG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gVihkLCBzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IGQsIHRoaXMucCA9IG5ldyBpKHMsIDE2KSwgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpLCB0aGlzLmsgPSBuZXcgaSgxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCksIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gICAgICB9XG4gICAgICBWLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gbmV3IGkobnVsbCk7XG4gICAgICAgIHJldHVybiBzLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpLCBzO1xuICAgICAgfSwgVi5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBzLCBoO1xuICAgICAgICBkb1xuICAgICAgICAgIHRoaXMuc3BsaXQodSwgdGhpcy50bXApLCB1ID0gdGhpcy5pbXVsSyh1KSwgdSA9IHUuaWFkZCh0aGlzLnRtcCksIGggPSB1LmJpdExlbmd0aCgpO1xuICAgICAgICB3aGlsZSAoaCA+IHRoaXMubik7XG4gICAgICAgIHZhciBnID0gaCA8IHRoaXMubiA/IC0xIDogdS51Y21wKHRoaXMucCk7XG4gICAgICAgIHJldHVybiBnID09PSAwID8gKHUud29yZHNbMF0gPSAwLCB1Lmxlbmd0aCA9IDEpIDogZyA+IDAgPyB1LmlzdWIodGhpcy5wKSA6IHUuc3RyaXAgIT09IHZvaWQgMCA/IHUuc3RyaXAoKSA6IHUuX3N0cmlwKCksIHU7XG4gICAgICB9LCBWLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgcy5pdXNocm4odGhpcy5uLCAwLCB1KTtcbiAgICAgIH0sIFYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5pbXVsKHRoaXMuayk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gZWUoKSB7XG4gICAgICAgIFYuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIFwiazI1NlwiLFxuICAgICAgICAgIFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmZcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbyhlZSwgViksIGVlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgZm9yICh2YXIgaCA9IDQxOTQzMDMsIGcgPSBNYXRoLm1pbihzLmxlbmd0aCwgOSksIHcgPSAwOyB3IDwgZzsgdysrKVxuICAgICAgICAgIHUud29yZHNbd10gPSBzLndvcmRzW3ddO1xuICAgICAgICBpZiAodS5sZW5ndGggPSBnLCBzLmxlbmd0aCA8PSA5KSB7XG4gICAgICAgICAgcy53b3Jkc1swXSA9IDAsIHMubGVuZ3RoID0gMTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF8gPSBzLndvcmRzWzldO1xuICAgICAgICBmb3IgKHUud29yZHNbdS5sZW5ndGgrK10gPSBfICYgaCwgdyA9IDEwOyB3IDwgcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciBBID0gcy53b3Jkc1t3XSB8IDA7XG4gICAgICAgICAgcy53b3Jkc1t3IC0gMTBdID0gKEEgJiBoKSA8PCA0IHwgXyA+Pj4gMjIsIF8gPSBBO1xuICAgICAgICB9XG4gICAgICAgIF8gPj4+PSAyMiwgcy53b3Jkc1t3IC0gMTBdID0gXywgXyA9PT0gMCAmJiBzLmxlbmd0aCA+IDEwID8gcy5sZW5ndGggLT0gMTAgOiBzLmxlbmd0aCAtPSA5O1xuICAgICAgfSwgZWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24ocykge1xuICAgICAgICBzLndvcmRzW3MubGVuZ3RoXSA9IDAsIHMud29yZHNbcy5sZW5ndGggKyAxXSA9IDAsIHMubGVuZ3RoICs9IDI7XG4gICAgICAgIGZvciAodmFyIHUgPSAwLCBoID0gMDsgaCA8IHMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICB2YXIgZyA9IHMud29yZHNbaF0gfCAwO1xuICAgICAgICAgIHUgKz0gZyAqIDk3Nywgcy53b3Jkc1toXSA9IHUgJiA2NzEwODg2MywgdSA9IGcgKiA2NCArICh1IC8gNjcxMDg4NjQgfCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcy53b3Jkc1tzLmxlbmd0aCAtIDFdID09PSAwICYmIChzLmxlbmd0aC0tLCBzLndvcmRzW3MubGVuZ3RoIC0gMV0gPT09IDAgJiYgcy5sZW5ndGgtLSksIHM7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gRygpIHtcbiAgICAgICAgVi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCJwMjI0XCIsXG4gICAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvKEcsIFYpO1xuICAgICAgZnVuY3Rpb24gTigpIHtcbiAgICAgICAgVi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCJwMTkyXCIsXG4gICAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvKE4sIFYpO1xuICAgICAgZnVuY3Rpb24gTygpIHtcbiAgICAgICAgVi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCIyNTUxOVwiLFxuICAgICAgICAgIFwiN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvKE8sIFYpLCBPLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IDAsIGggPSAwOyBoIDwgcy5sZW5ndGg7IGgrKykge1xuICAgICAgICAgIHZhciBnID0gKHMud29yZHNbaF0gfCAwKSAqIDE5ICsgdSwgdyA9IGcgJiA2NzEwODg2MztcbiAgICAgICAgICBnID4+Pj0gMjYsIHMud29yZHNbaF0gPSB3LCB1ID0gZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdSAhPT0gMCAmJiAocy53b3Jkc1tzLmxlbmd0aCsrXSA9IHUpLCBzO1xuICAgICAgfSwgaS5fcHJpbWUgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChqW3NdKSByZXR1cm4galtzXTtcbiAgICAgICAgdmFyIHU7XG4gICAgICAgIGlmIChzID09PSBcImsyNTZcIilcbiAgICAgICAgICB1ID0gbmV3IGVlKCk7XG4gICAgICAgIGVsc2UgaWYgKHMgPT09IFwicDIyNFwiKVxuICAgICAgICAgIHUgPSBuZXcgRygpO1xuICAgICAgICBlbHNlIGlmIChzID09PSBcInAxOTJcIilcbiAgICAgICAgICB1ID0gbmV3IE4oKTtcbiAgICAgICAgZWxzZSBpZiAocyA9PT0gXCJwMjU1MTlcIilcbiAgICAgICAgICB1ID0gbmV3IE8oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcHJpbWUgXCIgKyBzKTtcbiAgICAgICAgcmV0dXJuIGpbc10gPSB1LCB1O1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIEwoZCkge1xuICAgICAgICBpZiAodHlwZW9mIGQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhciBzID0gaS5fcHJpbWUoZCk7XG4gICAgICAgICAgdGhpcy5tID0gcy5wLCB0aGlzLnByaW1lID0gcztcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbihkLmd0bigxKSwgXCJtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksIHRoaXMubSA9IGQsIHRoaXMucHJpbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgTC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIG4ocy5uZWdhdGl2ZSA9PT0gMCwgXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKSwgbihzLnJlZCwgXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO1xuICAgICAgfSwgTC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIG4oKHMubmVnYXRpdmUgfCB1Lm5lZ2F0aXZlKSA9PT0gMCwgXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKSwgbihcbiAgICAgICAgICBzLnJlZCAmJiBzLnJlZCA9PT0gdS5yZWQsXG4gICAgICAgICAgXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCJcbiAgICAgICAgKTtcbiAgICAgIH0sIEwucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaW1lID8gdGhpcy5wcmltZS5pcmVkdWNlKHMpLl9mb3JjZVJlZCh0aGlzKSA6IChiKHMsIHMudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKSksIHMpO1xuICAgICAgfSwgTC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5pc1plcm8oKSA/IHMuY2xvbmUoKSA6IHRoaXMubS5zdWIocykuX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgfSwgTC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICB0aGlzLl92ZXJpZnkyKHMsIHUpO1xuICAgICAgICB2YXIgaCA9IHMuYWRkKHUpO1xuICAgICAgICByZXR1cm4gaC5jbXAodGhpcy5tKSA+PSAwICYmIGguaXN1Yih0aGlzLm0pLCBoLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH0sIEwucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeTIocywgdSk7XG4gICAgICAgIHZhciBoID0gcy5pYWRkKHUpO1xuICAgICAgICByZXR1cm4gaC5jbXAodGhpcy5tKSA+PSAwICYmIGguaXN1Yih0aGlzLm0pLCBoO1xuICAgICAgfSwgTC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICB0aGlzLl92ZXJpZnkyKHMsIHUpO1xuICAgICAgICB2YXIgaCA9IHMuc3ViKHUpO1xuICAgICAgICByZXR1cm4gaC5jbXBuKDApIDwgMCAmJiBoLmlhZGQodGhpcy5tKSwgaC5fZm9yY2VSZWQodGhpcyk7XG4gICAgICB9LCBMLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICB0aGlzLl92ZXJpZnkyKHMsIHUpO1xuICAgICAgICB2YXIgaCA9IHMuaXN1Yih1KTtcbiAgICAgICAgcmV0dXJuIGguY21wbigwKSA8IDAgJiYgaC5pYWRkKHRoaXMubSksIGg7XG4gICAgICB9LCBMLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkxKHMpLCB0aGlzLmltb2Qocy51c2hsbih1KSk7XG4gICAgICB9LCBMLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyaWZ5MihzLCB1KSwgdGhpcy5pbW9kKHMuaW11bCh1KSk7XG4gICAgICB9LCBMLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkyKHMsIHUpLCB0aGlzLmltb2Qocy5tdWwodSkpO1xuICAgICAgfSwgTC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW11bChzLCBzLmNsb25lKCkpO1xuICAgICAgfSwgTC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwocywgcyk7XG4gICAgICB9LCBMLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAocy5pc1plcm8oKSkgcmV0dXJuIHMuY2xvbmUoKTtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgICAgIGlmIChuKHUgJSAyID09PSAxKSwgdSA9PT0gMykge1xuICAgICAgICAgIHZhciBoID0gdGhpcy5tLmFkZChuZXcgaSgxKSkuaXVzaHJuKDIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBvdyhzLCBoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBnID0gdGhpcy5tLnN1Ym4oMSksIHcgPSAwOyAhZy5pc1plcm8oKSAmJiBnLmFuZGxuKDEpID09PSAwOyApXG4gICAgICAgICAgdysrLCBnLml1c2hybigxKTtcbiAgICAgICAgbighZy5pc1plcm8oKSk7XG4gICAgICAgIHZhciBfID0gbmV3IGkoMSkudG9SZWQodGhpcyksIEEgPSBfLnJlZE5lZygpLCBwID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpLCBhID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgICAgICBmb3IgKGEgPSBuZXcgaSgyICogYSAqIGEpLnRvUmVkKHRoaXMpOyB0aGlzLnBvdyhhLCBwKS5jbXAoQSkgIT09IDA7IClcbiAgICAgICAgICBhLnJlZElBZGQoQSk7XG4gICAgICAgIGZvciAodmFyIGwgPSB0aGlzLnBvdyhhLCBnKSwgTSA9IHRoaXMucG93KHMsIGcuYWRkbigxKS5pdXNocm4oMSkpLCBrID0gdGhpcy5wb3cocywgZyksICQgPSB3OyBrLmNtcChfKSAhPT0gMDsgKSB7XG4gICAgICAgICAgZm9yICh2YXIgWCA9IGssIHJlID0gMDsgWC5jbXAoXykgIT09IDA7IHJlKyspXG4gICAgICAgICAgICBYID0gWC5yZWRTcXIoKTtcbiAgICAgICAgICBuKHJlIDwgJCk7XG4gICAgICAgICAgdmFyIHNlID0gdGhpcy5wb3cobCwgbmV3IGkoMSkuaXVzaGxuKCQgLSByZSAtIDEpKTtcbiAgICAgICAgICBNID0gTS5yZWRNdWwoc2UpLCBsID0gc2UucmVkU3FyKCksIGsgPSBrLnJlZE11bChsKSwgJCA9IHJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNO1xuICAgICAgfSwgTC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBzLl9pbnZtcCh0aGlzLm0pO1xuICAgICAgICByZXR1cm4gdS5uZWdhdGl2ZSAhPT0gMCA/ICh1Lm5lZ2F0aXZlID0gMCwgdGhpcy5pbW9kKHUpLnJlZE5lZygpKSA6IHRoaXMuaW1vZCh1KTtcbiAgICAgIH0sIEwucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgaWYgKHUuaXNaZXJvKCkpIHJldHVybiBuZXcgaSgxKS50b1JlZCh0aGlzKTtcbiAgICAgICAgaWYgKHUuY21wbigxKSA9PT0gMCkgcmV0dXJuIHMuY2xvbmUoKTtcbiAgICAgICAgdmFyIGggPSA0LCBnID0gbmV3IEFycmF5KDEgPDwgaCk7XG4gICAgICAgIGdbMF0gPSBuZXcgaSgxKS50b1JlZCh0aGlzKSwgZ1sxXSA9IHM7XG4gICAgICAgIGZvciAodmFyIHcgPSAyOyB3IDwgZy5sZW5ndGg7IHcrKylcbiAgICAgICAgICBnW3ddID0gdGhpcy5tdWwoZ1t3IC0gMV0sIHMpO1xuICAgICAgICB2YXIgXyA9IGdbMF0sIEEgPSAwLCBwID0gMCwgYSA9IHUuYml0TGVuZ3RoKCkgJSAyNjtcbiAgICAgICAgZm9yIChhID09PSAwICYmIChhID0gMjYpLCB3ID0gdS5sZW5ndGggLSAxOyB3ID49IDA7IHctLSkge1xuICAgICAgICAgIGZvciAodmFyIGwgPSB1LndvcmRzW3ddLCBNID0gYSAtIDE7IE0gPj0gMDsgTS0tKSB7XG4gICAgICAgICAgICB2YXIgayA9IGwgPj4gTSAmIDE7XG4gICAgICAgICAgICBpZiAoXyAhPT0gZ1swXSAmJiAoXyA9IHRoaXMuc3FyKF8pKSwgayA9PT0gMCAmJiBBID09PSAwKSB7XG4gICAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEEgPDw9IDEsIEEgfD0gaywgcCsrLCAhKHAgIT09IGggJiYgKHcgIT09IDAgfHwgTSAhPT0gMCkpICYmIChfID0gdGhpcy5tdWwoXywgZ1tBXSksIHAgPSAwLCBBID0gMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGEgPSAyNjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXztcbiAgICAgIH0sIEwucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBzLnVtb2QodGhpcy5tKTtcbiAgICAgICAgcmV0dXJuIHUgPT09IHMgPyB1LmNsb25lKCkgOiB1O1xuICAgICAgfSwgTC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1ID0gcy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gdS5yZWQgPSBudWxsLCB1O1xuICAgICAgfSwgaS5tb250ID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbmV3IEYocyk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gRihkKSB7XG4gICAgICAgIEwuY2FsbCh0aGlzLCBkKSwgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKSwgdGhpcy5zaGlmdCAlIDI2ICE9PSAwICYmICh0aGlzLnNoaWZ0ICs9IDI2IC0gdGhpcy5zaGlmdCAlIDI2KSwgdGhpcy5yID0gbmV3IGkoMSkuaXVzaGxuKHRoaXMuc2hpZnQpLCB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSksIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKSwgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pLCB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpLCB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gICAgICB9XG4gICAgICBvKEYsIEwpLCBGLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltb2Qocy51c2hsbih0aGlzLnNoaWZ0KSk7XG4gICAgICB9LCBGLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLmltb2Qocy5tdWwodGhpcy5yaW52KSk7XG4gICAgICAgIHJldHVybiB1LnJlZCA9IG51bGwsIHU7XG4gICAgICB9LCBGLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBpZiAocy5pc1plcm8oKSB8fCB1LmlzWmVybygpKVxuICAgICAgICAgIHJldHVybiBzLndvcmRzWzBdID0gMCwgcy5sZW5ndGggPSAxLCBzO1xuICAgICAgICB2YXIgaCA9IHMuaW11bCh1KSwgZyA9IGgubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pLCB3ID0gaC5pc3ViKGcpLml1c2hybih0aGlzLnNoaWZ0KSwgXyA9IHc7XG4gICAgICAgIHJldHVybiB3LmNtcCh0aGlzLm0pID49IDAgPyBfID0gdy5pc3ViKHRoaXMubSkgOiB3LmNtcG4oMCkgPCAwICYmIChfID0gdy5pYWRkKHRoaXMubSkpLCBfLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH0sIEYucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgaWYgKHMuaXNaZXJvKCkgfHwgdS5pc1plcm8oKSkgcmV0dXJuIG5ldyBpKDApLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgICAgdmFyIGggPSBzLm11bCh1KSwgZyA9IGgubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pLCB3ID0gaC5pc3ViKGcpLml1c2hybih0aGlzLnNoaWZ0KSwgXyA9IHc7XG4gICAgICAgIHJldHVybiB3LmNtcCh0aGlzLm0pID49IDAgPyBfID0gdy5pc3ViKHRoaXMubSkgOiB3LmNtcG4oMCkgPCAwICYmIChfID0gdy5pYWRkKHRoaXMubSkpLCBfLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH0sIEYucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5pbW9kKHMuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICAgICAgcmV0dXJuIHUuX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgfTtcbiAgICB9KSh0LCBOaCk7XG4gIH0ocnMpKSwgcnMuZXhwb3J0cztcbn1cbnZhciBVaCA9IGpoKCk7XG5jb25zdCBLYSA9IC8qIEBfX1BVUkVfXyAqLyBRbyhVaCk7XG52YXIgV2kgPSB7IGV4cG9ydHM6IHt9IH07XG4vKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbnZhciBXYTtcbmZ1bmN0aW9uIGtjKCkge1xuICByZXR1cm4gV2EgfHwgKFdhID0gMSwgZnVuY3Rpb24odCwgZSkge1xuICAgIHZhciByID0gbmEoKSwgbiA9IHIuQnVmZmVyO1xuICAgIGZ1bmN0aW9uIG8oYywgZikge1xuICAgICAgZm9yICh2YXIgdiBpbiBjKVxuICAgICAgICBmW3ZdID0gY1t2XTtcbiAgICB9XG4gICAgbi5mcm9tICYmIG4uYWxsb2MgJiYgbi5hbGxvY1Vuc2FmZSAmJiBuLmFsbG9jVW5zYWZlU2xvdyA/IHQuZXhwb3J0cyA9IHIgOiAobyhyLCBlKSwgZS5CdWZmZXIgPSBpKTtcbiAgICBmdW5jdGlvbiBpKGMsIGYsIHYpIHtcbiAgICAgIHJldHVybiBuKGMsIGYsIHYpO1xuICAgIH1cbiAgICBpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobi5wcm90b3R5cGUpLCBvKG4sIGkpLCBpLmZyb20gPSBmdW5jdGlvbihjLCBmLCB2KSB7XG4gICAgICBpZiAodHlwZW9mIGMgPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgcmV0dXJuIG4oYywgZiwgdik7XG4gICAgfSwgaS5hbGxvYyA9IGZ1bmN0aW9uKGMsIGYsIHYpIHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgIHZhciB4ID0gbihjKTtcbiAgICAgIHJldHVybiBmICE9PSB2b2lkIDAgPyB0eXBlb2YgdiA9PSBcInN0cmluZ1wiID8geC5maWxsKGYsIHYpIDogeC5maWxsKGYpIDogeC5maWxsKDApLCB4O1xuICAgIH0sIGkuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAodHlwZW9mIGMgIT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICByZXR1cm4gbihjKTtcbiAgICB9LCBpLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgIHJldHVybiByLlNsb3dCdWZmZXIoYyk7XG4gICAgfTtcbiAgfShXaSwgV2kuZXhwb3J0cykpLCBXaS5leHBvcnRzO1xufVxudmFyIGVvLCBHYTtcbmZ1bmN0aW9uIEZoKCkge1xuICBpZiAoR2EpIHJldHVybiBlbztcbiAgR2EgPSAxO1xuICB2YXIgdCA9IGtjKCkuQnVmZmVyO1xuICBmdW5jdGlvbiBlKHIpIHtcbiAgICBpZiAoci5sZW5ndGggPj0gMjU1KVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFscGhhYmV0IHRvbyBsb25nXCIpO1xuICAgIGZvciAodmFyIG4gPSBuZXcgVWludDhBcnJheSgyNTYpLCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICBuW29dID0gMjU1O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByLmNoYXJBdChpKSwgZiA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChuW2ZdICE9PSAyNTUpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYyArIFwiIGlzIGFtYmlndW91c1wiKTtcbiAgICAgIG5bZl0gPSBpO1xuICAgIH1cbiAgICB2YXIgdiA9IHIubGVuZ3RoLCB4ID0gci5jaGFyQXQoMCksIGIgPSBNYXRoLmxvZyh2KSAvIE1hdGgubG9nKDI1NiksIFMgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2codik7XG4gICAgZnVuY3Rpb24gVChCKSB7XG4gICAgICBpZiAoKEFycmF5LmlzQXJyYXkoQikgfHwgQiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmIChCID0gdC5mcm9tKEIpKSwgIXQuaXNCdWZmZXIoQikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBCdWZmZXJcIik7XG4gICAgICBpZiAoQi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgZm9yICh2YXIgUiA9IDAsIHogPSAwLCBLID0gMCwgWiA9IEIubGVuZ3RoOyBLICE9PSBaICYmIEJbS10gPT09IDA7IClcbiAgICAgICAgSysrLCBSKys7XG4gICAgICBmb3IgKHZhciBRID0gKFogLSBLKSAqIFMgKyAxID4+PiAwLCBqID0gbmV3IFVpbnQ4QXJyYXkoUSk7IEsgIT09IFo7ICkge1xuICAgICAgICBmb3IgKHZhciBWID0gQltLXSwgZWUgPSAwLCBHID0gUSAtIDE7IChWICE9PSAwIHx8IGVlIDwgeikgJiYgRyAhPT0gLTE7IEctLSwgZWUrKylcbiAgICAgICAgICBWICs9IDI1NiAqIGpbR10gPj4+IDAsIGpbR10gPSBWICUgdiA+Pj4gMCwgViA9IFYgLyB2ID4+PiAwO1xuICAgICAgICBpZiAoViAhPT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24temVybyBjYXJyeVwiKTtcbiAgICAgICAgeiA9IGVlLCBLKys7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBOID0gUSAtIHo7IE4gIT09IFEgJiYgaltOXSA9PT0gMDsgKVxuICAgICAgICBOKys7XG4gICAgICBmb3IgKHZhciBPID0geC5yZXBlYXQoUik7IE4gPCBROyArK04pXG4gICAgICAgIE8gKz0gci5jaGFyQXQoaltOXSk7XG4gICAgICByZXR1cm4gTztcbiAgICB9XG4gICAgZnVuY3Rpb24gQyhCKSB7XG4gICAgICBpZiAodHlwZW9mIEIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcbiAgICAgIGlmIChCLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHQuYWxsb2MoMCk7XG4gICAgICBmb3IgKHZhciBSID0gMCwgeiA9IDAsIEsgPSAwOyBCW1JdID09PSB4OyApXG4gICAgICAgIHorKywgUisrO1xuICAgICAgZm9yICh2YXIgWiA9IChCLmxlbmd0aCAtIFIpICogYiArIDEgPj4+IDAsIFEgPSBuZXcgVWludDhBcnJheShaKTsgUiA8IEIubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGogPSBCLmNoYXJDb2RlQXQoUik7XG4gICAgICAgIGlmIChqID4gMjU1KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIFYgPSBuW2pdO1xuICAgICAgICBpZiAoViA9PT0gMjU1KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgZWUgPSAwLCBHID0gWiAtIDE7IChWICE9PSAwIHx8IGVlIDwgSykgJiYgRyAhPT0gLTE7IEctLSwgZWUrKylcbiAgICAgICAgICBWICs9IHYgKiBRW0ddID4+PiAwLCBRW0ddID0gViAlIDI1NiA+Pj4gMCwgViA9IFYgLyAyNTYgPj4+IDA7XG4gICAgICAgIGlmIChWICE9PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgICBLID0gZWUsIFIrKztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIE4gPSBaIC0gSzsgTiAhPT0gWiAmJiBRW05dID09PSAwOyApXG4gICAgICAgIE4rKztcbiAgICAgIHZhciBPID0gdC5hbGxvY1Vuc2FmZSh6ICsgKFogLSBOKSk7XG4gICAgICBPLmZpbGwoMCwgMCwgeik7XG4gICAgICBmb3IgKHZhciBMID0gejsgTiAhPT0gWjsgKVxuICAgICAgICBPW0wrK10gPSBRW04rK107XG4gICAgICByZXR1cm4gTztcbiAgICB9XG4gICAgZnVuY3Rpb24gUChCKSB7XG4gICAgICB2YXIgUiA9IEMoQik7XG4gICAgICBpZiAoUilcbiAgICAgICAgcmV0dXJuIFI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24tYmFzZVwiICsgdiArIFwiIGNoYXJhY3RlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZTogVCxcbiAgICAgIGRlY29kZVVuc2FmZTogQyxcbiAgICAgIGRlY29kZTogUFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGVvID0gZSwgZW87XG59XG52YXIgdG8sIFlhO1xuZnVuY3Rpb24gUGgoKSB7XG4gIGlmIChZYSkgcmV0dXJuIHRvO1xuICBZYSA9IDE7XG4gIHZhciB0ID0gRmgoKSwgZSA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xuICByZXR1cm4gdG8gPSB0KGUpLCB0bztcbn1cbnZhciBEaCA9IFBoKCk7XG5jb25zdCBOdCA9IC8qIEBfX1BVUkVfXyAqLyBRbyhEaCk7XG5mdW5jdGlvbiAkaCh0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodCkgJiYgdC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlVpbnQ4QXJyYXlcIjtcbn1cbmZ1bmN0aW9uIEljKHQsIC4uLmUpIHtcbiAgaWYgKCEkaCh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICBpZiAoZS5sZW5ndGggPiAwICYmICFlLmluY2x1ZGVzKHQubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCBcIiArIGUgKyBcIiwgZ290IGxlbmd0aD1cIiArIHQubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIEphKHQsIGUgPSAhMCkge1xuICBpZiAodC5kZXN0cm95ZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWRcIik7XG4gIGlmIChlICYmIHQuZmluaXNoZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcbn1cbmZ1bmN0aW9uIHpoKHQsIGUpIHtcbiAgSWModCk7XG4gIGNvbnN0IHIgPSBlLm91dHB1dExlbjtcbiAgaWYgKHQubGVuZ3RoIDwgcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCBcIiArIHIpO1xufVxuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZnVuY3Rpb24gcm8odCkge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KHQuYnVmZmVyLCB0LmJ5dGVPZmZzZXQsIHQuYnl0ZUxlbmd0aCk7XG59XG5mdW5jdGlvbiBlcih0LCBlKSB7XG4gIHJldHVybiB0IDw8IDMyIC0gZSB8IHQgPj4+IGU7XG59XG5mdW5jdGlvbiBxaCh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcInV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290IFwiICsgdHlwZW9mIHQpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpKTtcbn1cbmZ1bmN0aW9uIEJjKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBxaCh0KSksIEljKHQpLCB0O1xufVxuY2xhc3MgWmgge1xuICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICB9XG59XG5mdW5jdGlvbiBWaCh0KSB7XG4gIGNvbnN0IGUgPSAobikgPT4gdCgpLnVwZGF0ZShCYyhuKSkuZGlnZXN0KCksIHIgPSB0KCk7XG4gIHJldHVybiBlLm91dHB1dExlbiA9IHIub3V0cHV0TGVuLCBlLmJsb2NrTGVuID0gci5ibG9ja0xlbiwgZS5jcmVhdGUgPSAoKSA9PiB0KCksIGU7XG59XG5mdW5jdGlvbiBIaCh0LCBlLCByLCBuKSB7XG4gIGlmICh0eXBlb2YgdC5zZXRCaWdVaW50NjQgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiB0LnNldEJpZ1VpbnQ2NChlLCByLCBuKTtcbiAgY29uc3QgbyA9IEJpZ0ludCgzMiksIGkgPSBCaWdJbnQoNDI5NDk2NzI5NSksIGMgPSBOdW1iZXIociA+PiBvICYgaSksIGYgPSBOdW1iZXIociAmIGkpLCB2ID0gbiA/IDQgOiAwLCB4ID0gbiA/IDAgOiA0O1xuICB0LnNldFVpbnQzMihlICsgdiwgYywgbiksIHQuc2V0VWludDMyKGUgKyB4LCBmLCBuKTtcbn1cbmZ1bmN0aW9uIEtoKHQsIGUsIHIpIHtcbiAgcmV0dXJuIHQgJiBlIF4gfnQgJiByO1xufVxuZnVuY3Rpb24gV2godCwgZSwgcikge1xuICByZXR1cm4gdCAmIGUgXiB0ICYgciBeIGUgJiByO1xufVxuY2xhc3MgR2ggZXh0ZW5kcyBaaCB7XG4gIGNvbnN0cnVjdG9yKGUsIHIsIG4sIG8pIHtcbiAgICBzdXBlcigpLCB0aGlzLmJsb2NrTGVuID0gZSwgdGhpcy5vdXRwdXRMZW4gPSByLCB0aGlzLnBhZE9mZnNldCA9IG4sIHRoaXMuaXNMRSA9IG8sIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5sZW5ndGggPSAwLCB0aGlzLnBvcyA9IDAsIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZSksIHRoaXMudmlldyA9IHJvKHRoaXMuYnVmZmVyKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIEphKHRoaXMpO1xuICAgIGNvbnN0IHsgdmlldzogciwgYnVmZmVyOiBuLCBibG9ja0xlbjogbyB9ID0gdGhpcztcbiAgICBlID0gQmMoZSk7XG4gICAgY29uc3QgaSA9IGUubGVuZ3RoO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgaTsgKSB7XG4gICAgICBjb25zdCBmID0gTWF0aC5taW4obyAtIHRoaXMucG9zLCBpIC0gYyk7XG4gICAgICBpZiAoZiA9PT0gbykge1xuICAgICAgICBjb25zdCB2ID0gcm8oZSk7XG4gICAgICAgIGZvciAoOyBvIDw9IGkgLSBjOyBjICs9IG8pXG4gICAgICAgICAgdGhpcy5wcm9jZXNzKHYsIGMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG4uc2V0KGUuc3ViYXJyYXkoYywgYyArIGYpLCB0aGlzLnBvcyksIHRoaXMucG9zICs9IGYsIGMgKz0gZiwgdGhpcy5wb3MgPT09IG8gJiYgKHRoaXMucHJvY2VzcyhyLCAwKSwgdGhpcy5wb3MgPSAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoICs9IGUubGVuZ3RoLCB0aGlzLnJvdW5kQ2xlYW4oKSwgdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKGUpIHtcbiAgICBKYSh0aGlzKSwgemgoZSwgdGhpcyksIHRoaXMuZmluaXNoZWQgPSAhMDtcbiAgICBjb25zdCB7IGJ1ZmZlcjogciwgdmlldzogbiwgYmxvY2tMZW46IG8sIGlzTEU6IGkgfSA9IHRoaXM7XG4gICAgbGV0IHsgcG9zOiBjIH0gPSB0aGlzO1xuICAgIHJbYysrXSA9IDEyOCwgdGhpcy5idWZmZXIuc3ViYXJyYXkoYykuZmlsbCgwKSwgdGhpcy5wYWRPZmZzZXQgPiBvIC0gYyAmJiAodGhpcy5wcm9jZXNzKG4sIDApLCBjID0gMCk7XG4gICAgZm9yIChsZXQgUyA9IGM7IFMgPCBvOyBTKyspXG4gICAgICByW1NdID0gMDtcbiAgICBIaChuLCBvIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGkpLCB0aGlzLnByb2Nlc3MobiwgMCk7XG4gICAgY29uc3QgZiA9IHJvKGUpLCB2ID0gdGhpcy5vdXRwdXRMZW47XG4gICAgaWYgKHYgJSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdFwiKTtcbiAgICBjb25zdCB4ID0gdiAvIDQsIGIgPSB0aGlzLmdldCgpO1xuICAgIGlmICh4ID4gYi5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlXCIpO1xuICAgIGZvciAobGV0IFMgPSAwOyBTIDwgeDsgUysrKVxuICAgICAgZi5zZXRVaW50MzIoNCAqIFMsIGJbU10sIGkpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogZSwgb3V0cHV0TGVuOiByIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhlKTtcbiAgICBjb25zdCBuID0gZS5zbGljZSgwLCByKTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCksIG47XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpLCBlLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuOiByLCBidWZmZXI6IG4sIGxlbmd0aDogbywgZmluaXNoZWQ6IGksIGRlc3Ryb3llZDogYywgcG9zOiBmIH0gPSB0aGlzO1xuICAgIHJldHVybiBlLmxlbmd0aCA9IG8sIGUucG9zID0gZiwgZS5maW5pc2hlZCA9IGksIGUuZGVzdHJveWVkID0gYywgbyAlIHIgJiYgZS5idWZmZXIuc2V0KG4pLCBlO1xuICB9XG59XG5jb25zdCBZaCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAxMTE2MzUyNDA4LFxuICAxODk5NDQ3NDQxLFxuICAzMDQ5MzIzNDcxLFxuICAzOTIxMDA5NTczLFxuICA5NjE5ODcxNjMsXG4gIDE1MDg5NzA5OTMsXG4gIDI0NTM2MzU3NDgsXG4gIDI4NzA3NjMyMjEsXG4gIDM2MjQzODEwODAsXG4gIDMxMDU5ODQwMSxcbiAgNjA3MjI1Mjc4LFxuICAxNDI2ODgxOTg3LFxuICAxOTI1MDc4Mzg4LFxuICAyMTYyMDc4MjA2LFxuICAyNjE0ODg4MTAzLFxuICAzMjQ4MjIyNTgwLFxuICAzODM1MzkwNDAxLFxuICA0MDIyMjI0Nzc0LFxuICAyNjQzNDcwNzgsXG4gIDYwNDgwNzYyOCxcbiAgNzcwMjU1OTgzLFxuICAxMjQ5MTUwMTIyLFxuICAxNTU1MDgxNjkyLFxuICAxOTk2MDY0OTg2LFxuICAyNTU0MjIwODgyLFxuICAyODIxODM0MzQ5LFxuICAyOTUyOTk2ODA4LFxuICAzMjEwMzEzNjcxLFxuICAzMzM2NTcxODkxLFxuICAzNTg0NTI4NzExLFxuICAxMTM5MjY5OTMsXG4gIDMzODI0MTg5NSxcbiAgNjY2MzA3MjA1LFxuICA3NzM1Mjk5MTIsXG4gIDEyOTQ3NTczNzIsXG4gIDEzOTYxODIyOTEsXG4gIDE2OTUxODM3MDAsXG4gIDE5ODY2NjEwNTEsXG4gIDIxNzcwMjYzNTAsXG4gIDI0NTY5NTYwMzcsXG4gIDI3MzA0ODU5MjEsXG4gIDI4MjAzMDI0MTEsXG4gIDMyNTk3MzA4MDAsXG4gIDMzNDU3NjQ3NzEsXG4gIDM1MTYwNjU4MTcsXG4gIDM2MDAzNTI4MDQsXG4gIDQwOTQ1NzE5MDksXG4gIDI3NTQyMzM0NCxcbiAgNDMwMjI3NzM0LFxuICA1MDY5NDg2MTYsXG4gIDY1OTA2MDU1NixcbiAgODgzOTk3ODc3LFxuICA5NTgxMzk1NzEsXG4gIDEzMjI4MjIyMTgsXG4gIDE1MzcwMDIwNjMsXG4gIDE3NDc4NzM3NzksXG4gIDE5NTU1NjIyMjIsXG4gIDIwMjQxMDQ4MTUsXG4gIDIyMjc3MzA0NTIsXG4gIDIzNjE4NTI0MjQsXG4gIDI0Mjg0MzY0NzQsXG4gIDI3NTY3MzQxODcsXG4gIDMyMDQwMzE0NzksXG4gIDMzMjkzMjUyOThcbl0pLCBTciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAxNzc5MDMzNzAzLFxuICAzMTQ0MTM0Mjc3LFxuICAxMDEzOTA0MjQyLFxuICAyNzczNDgwNzYyLFxuICAxMzU5ODkzMTE5LFxuICAyNjAwODIyOTI0LFxuICA1Mjg3MzQ2MzUsXG4gIDE1NDE0NTkyMjVcbl0pLCBBciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgSmggZXh0ZW5kcyBHaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAzMiwgOCwgITEpLCB0aGlzLkEgPSBTclswXSB8IDAsIHRoaXMuQiA9IFNyWzFdIHwgMCwgdGhpcy5DID0gU3JbMl0gfCAwLCB0aGlzLkQgPSBTclszXSB8IDAsIHRoaXMuRSA9IFNyWzRdIHwgMCwgdGhpcy5GID0gU3JbNV0gfCAwLCB0aGlzLkcgPSBTcls2XSB8IDAsIHRoaXMuSCA9IFNyWzddIHwgMDtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBOiBlLCBCOiByLCBDOiBuLCBEOiBvLCBFOiBpLCBGOiBjLCBHOiBmLCBIOiB2IH0gPSB0aGlzO1xuICAgIHJldHVybiBbZSwgciwgbiwgbywgaSwgYywgZiwgdl07XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHNldChlLCByLCBuLCBvLCBpLCBjLCBmLCB2KSB7XG4gICAgdGhpcy5BID0gZSB8IDAsIHRoaXMuQiA9IHIgfCAwLCB0aGlzLkMgPSBuIHwgMCwgdGhpcy5EID0gbyB8IDAsIHRoaXMuRSA9IGkgfCAwLCB0aGlzLkYgPSBjIHwgMCwgdGhpcy5HID0gZiB8IDAsIHRoaXMuSCA9IHYgfCAwO1xuICB9XG4gIHByb2Nlc3MoZSwgcikge1xuICAgIGZvciAobGV0IFMgPSAwOyBTIDwgMTY7IFMrKywgciArPSA0KVxuICAgICAgQXJbU10gPSBlLmdldFVpbnQzMihyLCAhMSk7XG4gICAgZm9yIChsZXQgUyA9IDE2OyBTIDwgNjQ7IFMrKykge1xuICAgICAgY29uc3QgVCA9IEFyW1MgLSAxNV0sIEMgPSBBcltTIC0gMl0sIFAgPSBlcihULCA3KSBeIGVyKFQsIDE4KSBeIFQgPj4+IDMsIEIgPSBlcihDLCAxNykgXiBlcihDLCAxOSkgXiBDID4+PiAxMDtcbiAgICAgIEFyW1NdID0gQiArIEFyW1MgLSA3XSArIFAgKyBBcltTIC0gMTZdIHwgMDtcbiAgICB9XG4gICAgbGV0IHsgQTogbiwgQjogbywgQzogaSwgRDogYywgRTogZiwgRjogdiwgRzogeCwgSDogYiB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBTID0gMDsgUyA8IDY0OyBTKyspIHtcbiAgICAgIGNvbnN0IFQgPSBlcihmLCA2KSBeIGVyKGYsIDExKSBeIGVyKGYsIDI1KSwgQyA9IGIgKyBUICsgS2goZiwgdiwgeCkgKyBZaFtTXSArIEFyW1NdIHwgMCwgQiA9IChlcihuLCAyKSBeIGVyKG4sIDEzKSBeIGVyKG4sIDIyKSkgKyBXaChuLCBvLCBpKSB8IDA7XG4gICAgICBiID0geCwgeCA9IHYsIHYgPSBmLCBmID0gYyArIEMgfCAwLCBjID0gaSwgaSA9IG8sIG8gPSBuLCBuID0gQyArIEIgfCAwO1xuICAgIH1cbiAgICBuID0gbiArIHRoaXMuQSB8IDAsIG8gPSBvICsgdGhpcy5CIHwgMCwgaSA9IGkgKyB0aGlzLkMgfCAwLCBjID0gYyArIHRoaXMuRCB8IDAsIGYgPSBmICsgdGhpcy5FIHwgMCwgdiA9IHYgKyB0aGlzLkYgfCAwLCB4ID0geCArIHRoaXMuRyB8IDAsIGIgPSBiICsgdGhpcy5IIHwgMCwgdGhpcy5zZXQobiwgbywgaSwgYywgZiwgdiwgeCwgYik7XG4gIH1cbiAgcm91bmRDbGVhbigpIHtcbiAgICBBci5maWxsKDApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCksIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gIH1cbn1cbmNvbnN0IFhhID0gLyogQF9fUFVSRV9fICovIFZoKCgpID0+IG5ldyBKaCgpKTtcbnZhciBzdCA9IHt9LCBucyA9IHsgZXhwb3J0czoge30gfSwgWGggPSBucy5leHBvcnRzLCBRYTtcbmZ1bmN0aW9uIFFoKCkge1xuICByZXR1cm4gUWEgfHwgKFFhID0gMSwgZnVuY3Rpb24odCkge1xuICAgIChmdW5jdGlvbihlLCByKSB7XG4gICAgICBmdW5jdGlvbiBuKGQsIHMpIHtcbiAgICAgICAgaWYgKCFkKSB0aHJvdyBuZXcgRXJyb3IocyB8fCBcIkFzc2VydGlvbiBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvKGQsIHMpIHtcbiAgICAgICAgZC5zdXBlcl8gPSBzO1xuICAgICAgICB2YXIgdSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB9O1xuICAgICAgICB1LnByb3RvdHlwZSA9IHMucHJvdG90eXBlLCBkLnByb3RvdHlwZSA9IG5ldyB1KCksIGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGkoZCwgcywgdSkge1xuICAgICAgICBpZiAoaS5pc0JOKGQpKVxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy53b3JkcyA9IG51bGwsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5yZWQgPSBudWxsLCBkICE9PSBudWxsICYmICgocyA9PT0gXCJsZVwiIHx8IHMgPT09IFwiYmVcIikgJiYgKHUgPSBzLCBzID0gMTApLCB0aGlzLl9pbml0KGQgfHwgMCwgcyB8fCAxMCwgdSB8fCBcImJlXCIpKTtcbiAgICAgIH1cbiAgICAgIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlLmV4cG9ydHMgPSBpIDogci5CTiA9IGksIGkuQk4gPSBpLCBpLndvcmRTaXplID0gMjY7XG4gICAgICB2YXIgYztcbiAgICAgIHRyeSB7XG4gICAgICAgIHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2Ygd2luZG93LkJ1ZmZlciA8IFwidVwiID8gYyA9IHdpbmRvdy5CdWZmZXIgOiBjID0gQWMuQnVmZmVyO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBpLmlzQk4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzIGluc3RhbmNlb2YgaSA/ICEwIDogcyAhPT0gbnVsbCAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmIHMuY29uc3RydWN0b3Iud29yZFNpemUgPT09IGkud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShzLndvcmRzKTtcbiAgICAgIH0sIGkubWF4ID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICByZXR1cm4gcy5jbXAodSkgPiAwID8gcyA6IHU7XG4gICAgICB9LCBpLm1pbiA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgcmV0dXJuIHMuY21wKHUpIDwgMCA/IHMgOiB1O1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcyA9PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKHMsIHUsIGgpO1xuICAgICAgICBpZiAodHlwZW9mIHMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KHMsIHUsIGgpO1xuICAgICAgICB1ID09PSBcImhleFwiICYmICh1ID0gMTYpLCBuKHUgPT09ICh1IHwgMCkgJiYgdSA+PSAyICYmIHUgPD0gMzYpLCBzID0gcy50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgXCJcIik7XG4gICAgICAgIHZhciBnID0gMDtcbiAgICAgICAgc1swXSA9PT0gXCItXCIgJiYgKGcrKywgdGhpcy5uZWdhdGl2ZSA9IDEpLCBnIDwgcy5sZW5ndGggJiYgKHUgPT09IDE2ID8gdGhpcy5fcGFyc2VIZXgocywgZywgaCkgOiAodGhpcy5fcGFyc2VCYXNlKHMsIHUsIGcpLCBoID09PSBcImxlXCIgJiYgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCB1LCBoKSkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIHMgPCAwICYmICh0aGlzLm5lZ2F0aXZlID0gMSwgcyA9IC1zKSwgcyA8IDY3MTA4ODY0ID8gKHRoaXMud29yZHMgPSBbcyAmIDY3MTA4ODYzXSwgdGhpcy5sZW5ndGggPSAxKSA6IHMgPCA0NTAzNTk5NjI3MzcwNDk2ID8gKHRoaXMud29yZHMgPSBbXG4gICAgICAgICAgcyAmIDY3MTA4ODYzLFxuICAgICAgICAgIHMgLyA2NzEwODg2NCAmIDY3MTA4ODYzXG4gICAgICAgIF0sIHRoaXMubGVuZ3RoID0gMikgOiAobihzIDwgOTAwNzE5OTI1NDc0MDk5MiksIHRoaXMud29yZHMgPSBbXG4gICAgICAgICAgcyAmIDY3MTA4ODYzLFxuICAgICAgICAgIHMgLyA2NzEwODg2NCAmIDY3MTA4ODYzLFxuICAgICAgICAgIDFcbiAgICAgICAgXSwgdGhpcy5sZW5ndGggPSAzKSwgaCA9PT0gXCJsZVwiICYmIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgdSwgaCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICBpZiAobih0eXBlb2Ygcy5sZW5ndGggPT0gXCJudW1iZXJcIiksIHMubGVuZ3RoIDw9IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMud29yZHMgPSBbMF0sIHRoaXMubGVuZ3RoID0gMSwgdGhpcztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwocy5sZW5ndGggLyAzKSwgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgdGhpcy5sZW5ndGg7IGcrKylcbiAgICAgICAgICB0aGlzLndvcmRzW2ddID0gMDtcbiAgICAgICAgdmFyIHcsIF8sIEEgPSAwO1xuICAgICAgICBpZiAoaCA9PT0gXCJiZVwiKVxuICAgICAgICAgIGZvciAoZyA9IHMubGVuZ3RoIC0gMSwgdyA9IDA7IGcgPj0gMDsgZyAtPSAzKVxuICAgICAgICAgICAgXyA9IHNbZ10gfCBzW2cgLSAxXSA8PCA4IHwgc1tnIC0gMl0gPDwgMTYsIHRoaXMud29yZHNbd10gfD0gXyA8PCBBICYgNjcxMDg4NjMsIHRoaXMud29yZHNbdyArIDFdID0gXyA+Pj4gMjYgLSBBICYgNjcxMDg4NjMsIEEgKz0gMjQsIEEgPj0gMjYgJiYgKEEgLT0gMjYsIHcrKyk7XG4gICAgICAgIGVsc2UgaWYgKGggPT09IFwibGVcIilcbiAgICAgICAgICBmb3IgKGcgPSAwLCB3ID0gMDsgZyA8IHMubGVuZ3RoOyBnICs9IDMpXG4gICAgICAgICAgICBfID0gc1tnXSB8IHNbZyArIDFdIDw8IDggfCBzW2cgKyAyXSA8PCAxNiwgdGhpcy53b3Jkc1t3XSB8PSBfIDw8IEEgJiA2NzEwODg2MywgdGhpcy53b3Jkc1t3ICsgMV0gPSBfID4+PiAyNiAtIEEgJiA2NzEwODg2MywgQSArPSAyNCwgQSA+PSAyNiAmJiAoQSAtPSAyNiwgdysrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gZihkLCBzKSB7XG4gICAgICAgIHZhciB1ID0gZC5jaGFyQ29kZUF0KHMpO1xuICAgICAgICBpZiAodSA+PSA0OCAmJiB1IDw9IDU3KVxuICAgICAgICAgIHJldHVybiB1IC0gNDg7XG4gICAgICAgIGlmICh1ID49IDY1ICYmIHUgPD0gNzApXG4gICAgICAgICAgcmV0dXJuIHUgLSA1NTtcbiAgICAgICAgaWYgKHUgPj0gOTcgJiYgdSA8PSAxMDIpXG4gICAgICAgICAgcmV0dXJuIHUgLSA4NztcbiAgICAgICAgbighMSwgXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBcIiArIGQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdihkLCBzLCB1KSB7XG4gICAgICAgIHZhciBoID0gZihkLCB1KTtcbiAgICAgICAgcmV0dXJuIHUgLSAxID49IHMgJiYgKGggfD0gZihkLCB1IC0gMSkgPDwgNCksIGg7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChzLmxlbmd0aCAtIHUpIC8gNiksIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IHRoaXMubGVuZ3RoOyBnKyspXG4gICAgICAgICAgdGhpcy53b3Jkc1tnXSA9IDA7XG4gICAgICAgIHZhciB3ID0gMCwgXyA9IDAsIEE7XG4gICAgICAgIGlmIChoID09PSBcImJlXCIpXG4gICAgICAgICAgZm9yIChnID0gcy5sZW5ndGggLSAxOyBnID49IHU7IGcgLT0gMilcbiAgICAgICAgICAgIEEgPSB2KHMsIHUsIGcpIDw8IHcsIHRoaXMud29yZHNbX10gfD0gQSAmIDY3MTA4ODYzLCB3ID49IDE4ID8gKHcgLT0gMTgsIF8gKz0gMSwgdGhpcy53b3Jkc1tfXSB8PSBBID4+PiAyNikgOiB3ICs9IDg7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwID0gcy5sZW5ndGggLSB1O1xuICAgICAgICAgIGZvciAoZyA9IHAgJSAyID09PSAwID8gdSArIDEgOiB1OyBnIDwgcy5sZW5ndGg7IGcgKz0gMilcbiAgICAgICAgICAgIEEgPSB2KHMsIHUsIGcpIDw8IHcsIHRoaXMud29yZHNbX10gfD0gQSAmIDY3MTA4ODYzLCB3ID49IDE4ID8gKHcgLT0gMTgsIF8gKz0gMSwgdGhpcy53b3Jkc1tfXSB8PSBBID4+PiAyNikgOiB3ICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RyaXAoKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiB4KGQsIHMsIHUsIGgpIHtcbiAgICAgICAgZm9yICh2YXIgZyA9IDAsIHcgPSAwLCBfID0gTWF0aC5taW4oZC5sZW5ndGgsIHUpLCBBID0gczsgQSA8IF87IEErKykge1xuICAgICAgICAgIHZhciBwID0gZC5jaGFyQ29kZUF0KEEpIC0gNDg7XG4gICAgICAgICAgZyAqPSBoLCBwID49IDQ5ID8gdyA9IHAgLSA0OSArIDEwIDogcCA+PSAxNyA/IHcgPSBwIC0gMTcgKyAxMCA6IHcgPSBwLCBuKHAgPj0gMCAmJiB3IDwgaCwgXCJJbnZhbGlkIGNoYXJhY3RlclwiKSwgZyArPSB3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uKHMsIHUsIGgpIHtcbiAgICAgICAgdGhpcy53b3JkcyA9IFswXSwgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICBmb3IgKHZhciBnID0gMCwgdyA9IDE7IHcgPD0gNjcxMDg4NjM7IHcgKj0gdSlcbiAgICAgICAgICBnKys7XG4gICAgICAgIGctLSwgdyA9IHcgLyB1IHwgMDtcbiAgICAgICAgZm9yICh2YXIgXyA9IHMubGVuZ3RoIC0gaCwgQSA9IF8gJSBnLCBwID0gTWF0aC5taW4oXywgXyAtIEEpICsgaCwgYSA9IDAsIGwgPSBoOyBsIDwgcDsgbCArPSBnKVxuICAgICAgICAgIGEgPSB4KHMsIGwsIGwgKyBnLCB1KSwgdGhpcy5pbXVsbih3KSwgdGhpcy53b3Jkc1swXSArIGEgPCA2NzEwODg2NCA/IHRoaXMud29yZHNbMF0gKz0gYSA6IHRoaXMuX2lhZGRuKGEpO1xuICAgICAgICBpZiAoQSAhPT0gMCkge1xuICAgICAgICAgIHZhciBNID0gMTtcbiAgICAgICAgICBmb3IgKGEgPSB4KHMsIGwsIHMubGVuZ3RoLCB1KSwgbCA9IDA7IGwgPCBBOyBsKyspXG4gICAgICAgICAgICBNICo9IHU7XG4gICAgICAgICAgdGhpcy5pbXVsbihNKSwgdGhpcy53b3Jkc1swXSArIGEgPCA2NzEwODg2NCA/IHRoaXMud29yZHNbMF0gKz0gYSA6IHRoaXMuX2lhZGRuKGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICBzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCB0aGlzLmxlbmd0aDsgdSsrKVxuICAgICAgICAgIHMud29yZHNbdV0gPSB0aGlzLndvcmRzW3VdO1xuICAgICAgICBzLmxlbmd0aCA9IHRoaXMubGVuZ3RoLCBzLm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZSwgcy5yZWQgPSB0aGlzLnJlZDtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBiKGQsIHMpIHtcbiAgICAgICAgZC53b3JkcyA9IHMud29yZHMsIGQubGVuZ3RoID0gcy5sZW5ndGgsIGQubmVnYXRpdmUgPSBzLm5lZ2F0aXZlLCBkLnJlZCA9IHMucmVkO1xuICAgICAgfVxuICAgICAgaWYgKGkucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24ocykge1xuICAgICAgICBiKHMsIHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgaShudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShzKSwgcztcbiAgICAgIH0sIGkucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGZvciAoOyB0aGlzLmxlbmd0aCA8IHM7IClcbiAgICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICg7IHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDA7IClcbiAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCAmJiAodGhpcy5uZWdhdGl2ZSA9IDApLCB0aGlzO1xuICAgICAgfSwgdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIHR5cGVvZiBTeW1ib2wuZm9yID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpLnByb3RvdHlwZVtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildID0gUztcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgaS5wcm90b3R5cGUuaW5zcGVjdCA9IFM7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgaS5wcm90b3R5cGUuaW5zcGVjdCA9IFM7XG4gICAgICBmdW5jdGlvbiBTKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucmVkID8gXCI8Qk4tUjogXCIgOiBcIjxCTjogXCIpICsgdGhpcy50b1N0cmluZygxNikgKyBcIj5cIjtcbiAgICAgIH1cbiAgICAgIHZhciBUID0gW1xuICAgICAgICBcIlwiLFxuICAgICAgICBcIjBcIixcbiAgICAgICAgXCIwMFwiLFxuICAgICAgICBcIjAwMFwiLFxuICAgICAgICBcIjAwMDBcIixcbiAgICAgICAgXCIwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgXSwgQyA9IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMjUsXG4gICAgICAgIDE2LFxuICAgICAgICAxMixcbiAgICAgICAgMTEsXG4gICAgICAgIDEwLFxuICAgICAgICA5LFxuICAgICAgICA4LFxuICAgICAgICA4LFxuICAgICAgICA3LFxuICAgICAgICA3LFxuICAgICAgICA3LFxuICAgICAgICA3LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA2LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1LFxuICAgICAgICA1XG4gICAgICBdLCBQID0gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAzMzU1NDQzMixcbiAgICAgICAgNDMwNDY3MjEsXG4gICAgICAgIDE2Nzc3MjE2LFxuICAgICAgICA0ODgyODEyNSxcbiAgICAgICAgNjA0NjYxNzYsXG4gICAgICAgIDQwMzUzNjA3LFxuICAgICAgICAxNjc3NzIxNixcbiAgICAgICAgNDMwNDY3MjEsXG4gICAgICAgIDFlNyxcbiAgICAgICAgMTk0ODcxNzEsXG4gICAgICAgIDM1ODMxODA4LFxuICAgICAgICA2Mjc0ODUxNyxcbiAgICAgICAgNzUyOTUzNixcbiAgICAgICAgMTEzOTA2MjUsXG4gICAgICAgIDE2Nzc3MjE2LFxuICAgICAgICAyNDEzNzU2OSxcbiAgICAgICAgMzQwMTIyMjQsXG4gICAgICAgIDQ3MDQ1ODgxLFxuICAgICAgICA2NGU2LFxuICAgICAgICA0MDg0MTAxLFxuICAgICAgICA1MTUzNjMyLFxuICAgICAgICA2NDM2MzQzLFxuICAgICAgICA3OTYyNjI0LFxuICAgICAgICA5NzY1NjI1LFxuICAgICAgICAxMTg4MTM3NixcbiAgICAgICAgMTQzNDg5MDcsXG4gICAgICAgIDE3MjEwMzY4LFxuICAgICAgICAyMDUxMTE0OSxcbiAgICAgICAgMjQzZTUsXG4gICAgICAgIDI4NjI5MTUxLFxuICAgICAgICAzMzU1NDQzMixcbiAgICAgICAgMzkxMzUzOTMsXG4gICAgICAgIDQ1NDM1NDI0LFxuICAgICAgICA1MjUyMTg3NSxcbiAgICAgICAgNjA0NjYxNzZcbiAgICAgIF07XG4gICAgICBpLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgcyA9IHMgfHwgMTAsIHUgPSB1IHwgMCB8fCAxO1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgaWYgKHMgPT09IDE2IHx8IHMgPT09IFwiaGV4XCIpIHtcbiAgICAgICAgICBoID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHZhciBnID0gMCwgdyA9IDAsIF8gPSAwOyBfIDwgdGhpcy5sZW5ndGg7IF8rKykge1xuICAgICAgICAgICAgdmFyIEEgPSB0aGlzLndvcmRzW19dLCBwID0gKChBIDw8IGcgfCB3KSAmIDE2Nzc3MjE1KS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB3ID0gQSA+Pj4gMjQgLSBnICYgMTY3NzcyMTUsIGcgKz0gMiwgZyA+PSAyNiAmJiAoZyAtPSAyNiwgXy0tKSwgdyAhPT0gMCB8fCBfICE9PSB0aGlzLmxlbmd0aCAtIDEgPyBoID0gVFs2IC0gcC5sZW5ndGhdICsgcCArIGggOiBoID0gcCArIGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodyAhPT0gMCAmJiAoaCA9IHcudG9TdHJpbmcoMTYpICsgaCk7IGgubGVuZ3RoICUgdSAhPT0gMDsgKVxuICAgICAgICAgICAgaCA9IFwiMFwiICsgaDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAoaCA9IFwiLVwiICsgaCksIGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMgPT09IChzIHwgMCkgJiYgcyA+PSAyICYmIHMgPD0gMzYpIHtcbiAgICAgICAgICB2YXIgYSA9IENbc10sIGwgPSBQW3NdO1xuICAgICAgICAgIGggPSBcIlwiO1xuICAgICAgICAgIHZhciBNID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgIGZvciAoTS5uZWdhdGl2ZSA9IDA7ICFNLmlzWmVybygpOyApIHtcbiAgICAgICAgICAgIHZhciBrID0gTS5tb2RybihsKS50b1N0cmluZyhzKTtcbiAgICAgICAgICAgIE0gPSBNLmlkaXZuKGwpLCBNLmlzWmVybygpID8gaCA9IGsgKyBoIDogaCA9IFRbYSAtIGsubGVuZ3RoXSArIGsgKyBoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHRoaXMuaXNaZXJvKCkgJiYgKGggPSBcIjBcIiArIGgpOyBoLmxlbmd0aCAlIHUgIT09IDA7IClcbiAgICAgICAgICAgIGggPSBcIjBcIiArIGg7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgJiYgKGggPSBcIi1cIiArIGgpLCBoO1xuICAgICAgICB9XG4gICAgICAgIG4oITEsIFwiQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNlwiKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy53b3Jkc1swXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAyID8gcyArPSB0aGlzLndvcmRzWzFdICogNjcxMDg4NjQgOiB0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAxID8gcyArPSA0NTAzNTk5NjI3MzcwNDk2ICsgdGhpcy53b3Jkc1sxXSAqIDY3MTA4ODY0IDogdGhpcy5sZW5ndGggPiAyICYmIG4oITEsIFwiTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzXCIpLCB0aGlzLm5lZ2F0aXZlICE9PSAwID8gLXMgOiBzO1xuICAgICAgfSwgaS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2LCAyKTtcbiAgICAgIH0sIGMgJiYgKGkucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShjLCBzLCB1KTtcbiAgICAgIH0pLCBpLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgcywgdSk7XG4gICAgICB9O1xuICAgICAgdmFyIEIgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHJldHVybiBzLmFsbG9jVW5zYWZlID8gcy5hbGxvY1Vuc2FmZSh1KSA6IG5ldyBzKHUpO1xuICAgICAgfTtcbiAgICAgIGkucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICB0aGlzLl9zdHJpcCgpO1xuICAgICAgICB2YXIgZyA9IHRoaXMuYnl0ZUxlbmd0aCgpLCB3ID0gaCB8fCBNYXRoLm1heCgxLCBnKTtcbiAgICAgICAgbihnIDw9IHcsIFwiYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aFwiKSwgbih3ID4gMCwgXCJSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDBcIik7XG4gICAgICAgIHZhciBfID0gQihzLCB3KSwgQSA9IHUgPT09IFwibGVcIiA/IFwiTEVcIiA6IFwiQkVcIjtcbiAgICAgICAgcmV0dXJuIHRoaXNbXCJfdG9BcnJheUxpa2VcIiArIEFdKF8sIGcpLCBfO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3RvQXJyYXlMaWtlTEUgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIGZvciAodmFyIGggPSAwLCBnID0gMCwgdyA9IDAsIF8gPSAwOyB3IDwgdGhpcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciBBID0gdGhpcy53b3Jkc1t3XSA8PCBfIHwgZztcbiAgICAgICAgICBzW2grK10gPSBBICYgMjU1LCBoIDwgcy5sZW5ndGggJiYgKHNbaCsrXSA9IEEgPj4gOCAmIDI1NSksIGggPCBzLmxlbmd0aCAmJiAoc1toKytdID0gQSA+PiAxNiAmIDI1NSksIF8gPT09IDYgPyAoaCA8IHMubGVuZ3RoICYmIChzW2grK10gPSBBID4+IDI0ICYgMjU1KSwgZyA9IDAsIF8gPSAwKSA6IChnID0gQSA+Pj4gMjQsIF8gKz0gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggPCBzLmxlbmd0aClcbiAgICAgICAgICBmb3IgKHNbaCsrXSA9IGc7IGggPCBzLmxlbmd0aDsgKVxuICAgICAgICAgICAgc1toKytdID0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLl90b0FycmF5TGlrZUJFID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBmb3IgKHZhciBoID0gcy5sZW5ndGggLSAxLCBnID0gMCwgdyA9IDAsIF8gPSAwOyB3IDwgdGhpcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciBBID0gdGhpcy53b3Jkc1t3XSA8PCBfIHwgZztcbiAgICAgICAgICBzW2gtLV0gPSBBICYgMjU1LCBoID49IDAgJiYgKHNbaC0tXSA9IEEgPj4gOCAmIDI1NSksIGggPj0gMCAmJiAoc1toLS1dID0gQSA+PiAxNiAmIDI1NSksIF8gPT09IDYgPyAoaCA+PSAwICYmIChzW2gtLV0gPSBBID4+IDI0ICYgMjU1KSwgZyA9IDAsIF8gPSAwKSA6IChnID0gQSA+Pj4gMjQsIF8gKz0gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggPj0gMClcbiAgICAgICAgICBmb3IgKHNbaC0tXSA9IGc7IGggPj0gMDsgKVxuICAgICAgICAgICAgc1toLS1dID0gMDtcbiAgICAgIH0sIE1hdGguY2x6MzIgPyBpLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHMpO1xuICAgICAgfSA6IGkucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1ID0gcywgaCA9IDA7XG4gICAgICAgIHJldHVybiB1ID49IDQwOTYgJiYgKGggKz0gMTMsIHUgPj4+PSAxMyksIHUgPj0gNjQgJiYgKGggKz0gNywgdSA+Pj49IDcpLCB1ID49IDggJiYgKGggKz0gNCwgdSA+Pj49IDQpLCB1ID49IDIgJiYgKGggKz0gMiwgdSA+Pj49IDIpLCBoICsgdTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMgPT09IDApIHJldHVybiAyNjtcbiAgICAgICAgdmFyIHUgPSBzLCBoID0gMDtcbiAgICAgICAgcmV0dXJuICh1ICYgODE5MSkgPT09IDAgJiYgKGggKz0gMTMsIHUgPj4+PSAxMyksICh1ICYgMTI3KSA9PT0gMCAmJiAoaCArPSA3LCB1ID4+Pj0gNyksICh1ICYgMTUpID09PSAwICYmIChoICs9IDQsIHUgPj4+PSA0KSwgKHUgJiAzKSA9PT0gMCAmJiAoaCArPSAyLCB1ID4+Pj0gMiksICh1ICYgMSkgPT09IDAgJiYgaCsrLCBoO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdLCB1ID0gdGhpcy5fY291bnRCaXRzKHMpO1xuICAgICAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIHU7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gUihkKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSBuZXcgQXJyYXkoZC5iaXRMZW5ndGgoKSksIHUgPSAwOyB1IDwgcy5sZW5ndGg7IHUrKykge1xuICAgICAgICAgIHZhciBoID0gdSAvIDI2IHwgMCwgZyA9IHUgJSAyNjtcbiAgICAgICAgICBzW3VdID0gZC53b3Jkc1toXSA+Pj4gZyAmIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCB1ID0gMDsgdSA8IHRoaXMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbdV0pO1xuICAgICAgICAgIGlmIChzICs9IGgsIGggIT09IDI2KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gdGhpcy5hYnMoKS5pbm90bihzKS5pYWRkbigxKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0bihzIC0gMSkgPyB0aGlzLm5vdG4ocykuaWFkZG4oMSkuaW5lZygpIDogdGhpcy5jbG9uZSgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzWmVybygpIHx8ICh0aGlzLm5lZ2F0aXZlIF49IDEpLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgZm9yICg7IHRoaXMubGVuZ3RoIDwgcy5sZW5ndGg7IClcbiAgICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBzLmxlbmd0aDsgdSsrKVxuICAgICAgICAgIHRoaXMud29yZHNbdV0gPSB0aGlzLndvcmRzW3VdIHwgcy53b3Jkc1t1XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKCh0aGlzLm5lZ2F0aXZlIHwgcy5uZWdhdGl2ZSkgPT09IDApLCB0aGlzLml1b3Iocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaW9yKHMpIDogcy5jbG9uZSgpLmlvcih0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXVvcihzKSA6IHMuY2xvbmUoKS5pdW9yKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICB0aGlzLmxlbmd0aCA+IHMubGVuZ3RoID8gdSA9IHMgOiB1ID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCB1Lmxlbmd0aDsgaCsrKVxuICAgICAgICAgIHRoaXMud29yZHNbaF0gPSB0aGlzLndvcmRzW2hdICYgcy53b3Jkc1toXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID0gdS5sZW5ndGgsIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbigodGhpcy5uZWdhdGl2ZSB8IHMubmVnYXRpdmUpID09PSAwKSwgdGhpcy5pdWFuZChzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaWFuZChzKSA6IHMuY2xvbmUoKS5pYW5kKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXVhbmQocykgOiBzLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUsIGg7XG4gICAgICAgIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyAodSA9IHRoaXMsIGggPSBzKSA6ICh1ID0gcywgaCA9IHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGgubGVuZ3RoOyBnKyspXG4gICAgICAgICAgdGhpcy53b3Jkc1tnXSA9IHUud29yZHNbZ10gXiBoLndvcmRzW2ddO1xuICAgICAgICBpZiAodGhpcyAhPT0gdSlcbiAgICAgICAgICBmb3IgKDsgZyA8IHUubGVuZ3RoOyBnKyspXG4gICAgICAgICAgICB0aGlzLndvcmRzW2ddID0gdS53b3Jkc1tnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID0gdS5sZW5ndGgsIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbigodGhpcy5uZWdhdGl2ZSB8IHMubmVnYXRpdmUpID09PSAwKSwgdGhpcy5pdXhvcihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXhvcihzKSA6IHMuY2xvbmUoKS5peG9yKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcy5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXV4b3IocykgOiBzLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbih0eXBlb2YgcyA9PSBcIm51bWJlclwiICYmIHMgPj0gMCk7XG4gICAgICAgIHZhciB1ID0gTWF0aC5jZWlsKHMgLyAyNikgfCAwLCBoID0gcyAlIDI2O1xuICAgICAgICB0aGlzLl9leHBhbmQodSksIGggPiAwICYmIHUtLTtcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCB1OyBnKyspXG4gICAgICAgICAgdGhpcy53b3Jkc1tnXSA9IH50aGlzLndvcmRzW2ddICYgNjcxMDg4NjM7XG4gICAgICAgIHJldHVybiBoID4gMCAmJiAodGhpcy53b3Jkc1tnXSA9IH50aGlzLndvcmRzW2ddICYgNjcxMDg4NjMgPj4gMjYgLSBoKSwgdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBuKHR5cGVvZiBzID09IFwibnVtYmVyXCIgJiYgcyA+PSAwKTtcbiAgICAgICAgdmFyIGggPSBzIC8gMjYgfCAwLCBnID0gcyAlIDI2O1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5kKGggKyAxKSwgdSA/IHRoaXMud29yZHNbaF0gPSB0aGlzLndvcmRzW2hdIHwgMSA8PCBnIDogdGhpcy53b3Jkc1toXSA9IHRoaXMud29yZHNbaF0gJiB+KDEgPDwgZyksIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgcy5uZWdhdGl2ZSA9PT0gMClcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIHUgPSB0aGlzLmlzdWIocyksIHRoaXMubmVnYXRpdmUgXj0gMSwgdGhpcy5fbm9ybVNpZ24oKTtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgcy5uZWdhdGl2ZSAhPT0gMClcbiAgICAgICAgICByZXR1cm4gcy5uZWdhdGl2ZSA9IDAsIHUgPSB0aGlzLmlzdWIocyksIHMubmVnYXRpdmUgPSAxLCB1Ll9ub3JtU2lnbigpO1xuICAgICAgICB2YXIgaCwgZztcbiAgICAgICAgdGhpcy5sZW5ndGggPiBzLmxlbmd0aCA/IChoID0gdGhpcywgZyA9IHMpIDogKGggPSBzLCBnID0gdGhpcyk7XG4gICAgICAgIGZvciAodmFyIHcgPSAwLCBfID0gMDsgXyA8IGcubGVuZ3RoOyBfKyspXG4gICAgICAgICAgdSA9IChoLndvcmRzW19dIHwgMCkgKyAoZy53b3Jkc1tfXSB8IDApICsgdywgdGhpcy53b3Jkc1tfXSA9IHUgJiA2NzEwODg2MywgdyA9IHUgPj4+IDI2O1xuICAgICAgICBmb3IgKDsgdyAhPT0gMCAmJiBfIDwgaC5sZW5ndGg7IF8rKylcbiAgICAgICAgICB1ID0gKGgud29yZHNbX10gfCAwKSArIHcsIHRoaXMud29yZHNbX10gPSB1ICYgNjcxMDg4NjMsIHcgPSB1ID4+PiAyNjtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID0gaC5sZW5ndGgsIHcgIT09IDApXG4gICAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSB3LCB0aGlzLmxlbmd0aCsrO1xuICAgICAgICBlbHNlIGlmIChoICE9PSB0aGlzKVxuICAgICAgICAgIGZvciAoOyBfIDwgaC5sZW5ndGg7IF8rKylcbiAgICAgICAgICAgIHRoaXMud29yZHNbX10gPSBoLndvcmRzW19dO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHU7XG4gICAgICAgIHJldHVybiBzLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDAgPyAocy5uZWdhdGl2ZSA9IDAsIHUgPSB0aGlzLnN1YihzKSwgcy5uZWdhdGl2ZSBePSAxLCB1KSA6IHMubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCA/ICh0aGlzLm5lZ2F0aXZlID0gMCwgdSA9IHMuc3ViKHRoaXMpLCB0aGlzLm5lZ2F0aXZlID0gMSwgdSkgOiB0aGlzLmxlbmd0aCA+IHMubGVuZ3RoID8gdGhpcy5jbG9uZSgpLmlhZGQocykgOiBzLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgICAgdmFyIHUgPSB0aGlzLmlhZGQocyk7XG4gICAgICAgICAgcmV0dXJuIHMubmVnYXRpdmUgPSAxLCB1Ll9ub3JtU2lnbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzLmlhZGQocyksIHRoaXMubmVnYXRpdmUgPSAxLCB0aGlzLl9ub3JtU2lnbigpO1xuICAgICAgICB2YXIgaCA9IHRoaXMuY21wKHMpO1xuICAgICAgICBpZiAoaCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMubGVuZ3RoID0gMSwgdGhpcy53b3Jkc1swXSA9IDAsIHRoaXM7XG4gICAgICAgIHZhciBnLCB3O1xuICAgICAgICBoID4gMCA/IChnID0gdGhpcywgdyA9IHMpIDogKGcgPSBzLCB3ID0gdGhpcyk7XG4gICAgICAgIGZvciAodmFyIF8gPSAwLCBBID0gMDsgQSA8IHcubGVuZ3RoOyBBKyspXG4gICAgICAgICAgdSA9IChnLndvcmRzW0FdIHwgMCkgLSAody53b3Jkc1tBXSB8IDApICsgXywgXyA9IHUgPj4gMjYsIHRoaXMud29yZHNbQV0gPSB1ICYgNjcxMDg4NjM7XG4gICAgICAgIGZvciAoOyBfICE9PSAwICYmIEEgPCBnLmxlbmd0aDsgQSsrKVxuICAgICAgICAgIHUgPSAoZy53b3Jkc1tBXSB8IDApICsgXywgXyA9IHUgPj4gMjYsIHRoaXMud29yZHNbQV0gPSB1ICYgNjcxMDg4NjM7XG4gICAgICAgIGlmIChfID09PSAwICYmIEEgPCBnLmxlbmd0aCAmJiBnICE9PSB0aGlzKVxuICAgICAgICAgIGZvciAoOyBBIDwgZy5sZW5ndGg7IEErKylcbiAgICAgICAgICAgIHRoaXMud29yZHNbQV0gPSBnLndvcmRzW0FdO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgQSksIGcgIT09IHRoaXMgJiYgKHRoaXMubmVnYXRpdmUgPSAxKSwgdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKHMpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHooZCwgcywgdSkge1xuICAgICAgICB1Lm5lZ2F0aXZlID0gcy5uZWdhdGl2ZSBeIGQubmVnYXRpdmU7XG4gICAgICAgIHZhciBoID0gZC5sZW5ndGggKyBzLmxlbmd0aCB8IDA7XG4gICAgICAgIHUubGVuZ3RoID0gaCwgaCA9IGggLSAxIHwgMDtcbiAgICAgICAgdmFyIGcgPSBkLndvcmRzWzBdIHwgMCwgdyA9IHMud29yZHNbMF0gfCAwLCBfID0gZyAqIHcsIEEgPSBfICYgNjcxMDg4NjMsIHAgPSBfIC8gNjcxMDg4NjQgfCAwO1xuICAgICAgICB1LndvcmRzWzBdID0gQTtcbiAgICAgICAgZm9yICh2YXIgYSA9IDE7IGEgPCBoOyBhKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBsID0gcCA+Pj4gMjYsIE0gPSBwICYgNjcxMDg4NjMsIGsgPSBNYXRoLm1pbihhLCBzLmxlbmd0aCAtIDEpLCAkID0gTWF0aC5tYXgoMCwgYSAtIGQubGVuZ3RoICsgMSk7ICQgPD0gazsgJCsrKSB7XG4gICAgICAgICAgICB2YXIgWCA9IGEgLSAkIHwgMDtcbiAgICAgICAgICAgIGcgPSBkLndvcmRzW1hdIHwgMCwgdyA9IHMud29yZHNbJF0gfCAwLCBfID0gZyAqIHcgKyBNLCBsICs9IF8gLyA2NzEwODg2NCB8IDAsIE0gPSBfICYgNjcxMDg4NjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHUud29yZHNbYV0gPSBNIHwgMCwgcCA9IGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwICE9PSAwID8gdS53b3Jkc1thXSA9IHAgfCAwIDogdS5sZW5ndGgtLSwgdS5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICAgIHZhciBLID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICB2YXIgZyA9IHMud29yZHMsIHcgPSB1LndvcmRzLCBfID0gaC53b3JkcywgQSA9IDAsIHAsIGEsIGwsIE0gPSBnWzBdIHwgMCwgayA9IE0gJiA4MTkxLCAkID0gTSA+Pj4gMTMsIFggPSBnWzFdIHwgMCwgcmUgPSBYICYgODE5MSwgc2UgPSBYID4+PiAxMywgdXQgPSBnWzJdIHwgMCwgeGUgPSB1dCAmIDgxOTEsIEllID0gdXQgPj4+IDEzLCBYZSA9IGdbM10gfCAwLCBhZSA9IFhlICYgODE5MSwgZ2UgPSBYZSA+Pj4gMTMsIGl0ID0gZ1s0XSB8IDAsIHdlID0gaXQgJiA4MTkxLCBNZSA9IGl0ID4+PiAxMywgZnQgPSBnWzVdIHwgMCwgeWUgPSBmdCAmIDgxOTEsIGJlID0gZnQgPj4+IDEzLCB4dCA9IGdbNl0gfCAwLCBTZSA9IHh0ICYgODE5MSwga2UgPSB4dCA+Pj4gMTMsIGN0ID0gZ1s3XSB8IDAsIF9lID0gY3QgJiA4MTkxLCBFID0gY3QgPj4+IDEzLCBtID0gZ1s4XSB8IDAsIHkgPSBtICYgODE5MSwgSSA9IG0gPj4+IDEzLCBxID0gZ1s5XSB8IDAsIEggPSBxICYgODE5MSwgVyA9IHEgPj4+IDEzLCBCZSA9IHdbMF0gfCAwLCBtZSA9IEJlICYgODE5MSwgZGUgPSBCZSA+Pj4gMTMsIG90ID0gd1sxXSB8IDAsIGNlID0gb3QgJiA4MTkxLCBMZSA9IG90ID4+PiAxMywgVm4gPSB3WzJdIHwgMCwgT2UgPSBWbiAmIDgxOTEsIE5lID0gVm4gPj4+IDEzLCBIbiA9IHdbM10gfCAwLCBqZSA9IEhuICYgODE5MSwgVWUgPSBIbiA+Pj4gMTMsIEtuID0gd1s0XSB8IDAsIEZlID0gS24gJiA4MTkxLCBQZSA9IEtuID4+PiAxMywgV24gPSB3WzVdIHwgMCwgRGUgPSBXbiAmIDgxOTEsICRlID0gV24gPj4+IDEzLCBHbiA9IHdbNl0gfCAwLCB6ZSA9IEduICYgODE5MSwgcWUgPSBHbiA+Pj4gMTMsIFluID0gd1s3XSB8IDAsIFplID0gWW4gJiA4MTkxLCBWZSA9IFluID4+PiAxMywgSm4gPSB3WzhdIHwgMCwgSGUgPSBKbiAmIDgxOTEsIEtlID0gSm4gPj4+IDEzLCBYbiA9IHdbOV0gfCAwLCBXZSA9IFhuICYgODE5MSwgR2UgPSBYbiA+Pj4gMTM7XG4gICAgICAgIGgubmVnYXRpdmUgPSBzLm5lZ2F0aXZlIF4gdS5uZWdhdGl2ZSwgaC5sZW5ndGggPSAxOSwgcCA9IE1hdGguaW11bChrLCBtZSksIGEgPSBNYXRoLmltdWwoaywgZGUpLCBhID0gYSArIE1hdGguaW11bCgkLCBtZSkgfCAwLCBsID0gTWF0aC5pbXVsKCQsIGRlKTtcbiAgICAgICAgdmFyIEZyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoRnIgPj4+IDI2KSB8IDAsIEZyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKHJlLCBtZSksIGEgPSBNYXRoLmltdWwocmUsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoc2UsIG1lKSB8IDAsIGwgPSBNYXRoLmltdWwoc2UsIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwoaywgY2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgTGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgY2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgTGUpIHwgMDtcbiAgICAgICAgdmFyIFByID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoUHIgPj4+IDI2KSB8IDAsIFByICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKHhlLCBtZSksIGEgPSBNYXRoLmltdWwoeGUsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIG1lKSB8IDAsIGwgPSBNYXRoLmltdWwoSWUsIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwocmUsIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHJlLCBMZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChzZSwgY2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoc2UsIExlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGssIE9lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGssIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKCQsIE9lKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKCQsIE5lKSB8IDA7XG4gICAgICAgIHZhciBEciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKERyID4+PiAyNikgfCAwLCBEciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChhZSwgbWUpLCBhID0gTWF0aC5pbXVsKGFlLCBkZSksIGEgPSBhICsgTWF0aC5pbXVsKGdlLCBtZSkgfCAwLCBsID0gTWF0aC5pbXVsKGdlLCBkZSksIHAgPSBwICsgTWF0aC5pbXVsKHhlLCBjZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh4ZSwgTGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIGNlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEllLCBMZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChyZSwgT2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwocmUsIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHNlLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChzZSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoaywgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgVWUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgVWUpIHwgMDtcbiAgICAgICAgdmFyICRyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoJHIgPj4+IDI2KSB8IDAsICRyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKHdlLCBtZSksIGEgPSBNYXRoLmltdWwod2UsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoTWUsIG1lKSB8IDAsIGwgPSBNYXRoLmltdWwoTWUsIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwoYWUsIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGFlLCBMZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChnZSwgY2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoZ2UsIExlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHhlLCBPZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh4ZSwgTmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIE9lKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEllLCBOZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChyZSwgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwocmUsIFVlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHNlLCBqZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChzZSwgVWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoaywgRmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgRmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgUGUpIHwgMDtcbiAgICAgICAgdmFyIHpyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoenIgPj4+IDI2KSB8IDAsIHpyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKHllLCBtZSksIGEgPSBNYXRoLmltdWwoeWUsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoYmUsIG1lKSB8IDAsIGwgPSBNYXRoLmltdWwoYmUsIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwod2UsIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHdlLCBMZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChNZSwgY2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoTWUsIExlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGFlLCBPZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChhZSwgTmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoZ2UsIE9lKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGdlLCBOZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh4ZSwgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeGUsIFVlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEllLCBqZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJZSwgVWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwocmUsIEZlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHJlLCBQZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChzZSwgRmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoc2UsIFBlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGssIERlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGssICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKCQsIERlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKCQsICRlKSB8IDA7XG4gICAgICAgIHZhciBxciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKHFyID4+PiAyNikgfCAwLCBxciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChTZSwgbWUpLCBhID0gTWF0aC5pbXVsKFNlLCBkZSksIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBtZSkgfCAwLCBsID0gTWF0aC5pbXVsKGtlLCBkZSksIHAgPSBwICsgTWF0aC5pbXVsKHllLCBjZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5ZSwgTGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYmUsIGNlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGJlLCBMZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh3ZSwgT2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwod2UsIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKE1lLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChNZSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoYWUsIGplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGFlLCBVZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChnZSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoZ2UsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHhlLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh4ZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEllLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChyZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwocmUsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHNlLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChzZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoaywgemUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgcWUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgcWUpIHwgMDtcbiAgICAgICAgdmFyIFpyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoWnIgPj4+IDI2KSB8IDAsIFpyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKF9lLCBtZSksIGEgPSBNYXRoLmltdWwoX2UsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoRSwgbWUpIHwgMCwgbCA9IE1hdGguaW11bChFLCBkZSksIHAgPSBwICsgTWF0aC5pbXVsKFNlLCBjZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChTZSwgTGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoa2UsIGNlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGtlLCBMZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh5ZSwgT2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeWUsIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGJlLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChiZSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwod2UsIGplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHdlLCBVZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChNZSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoTWUsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGFlLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChhZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoZ2UsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGdlLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh4ZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeGUsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEllLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwocmUsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHJlLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChzZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoc2UsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGssIFplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGssIFZlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKCQsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKCQsIFZlKSB8IDA7XG4gICAgICAgIHZhciBWciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKFZyID4+PiAyNikgfCAwLCBWciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bCh5LCBtZSksIGEgPSBNYXRoLmltdWwoeSwgZGUpLCBhID0gYSArIE1hdGguaW11bChJLCBtZSkgfCAwLCBsID0gTWF0aC5pbXVsKEksIGRlKSwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCBMZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBjZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCBMZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgT2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsIE5lKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeWUsIGplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHllLCBVZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChiZSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoYmUsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHdlLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh3ZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoTWUsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKE1lLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChhZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYWUsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGdlLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChnZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeGUsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHhlLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSWUsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHJlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChyZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoc2UsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKHNlLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChrLCBIZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChrLCBLZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCgkLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bCgkLCBLZSkgfCAwO1xuICAgICAgICB2YXIgSHIgPSAoQSArIHAgfCAwKSArICgoYSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIEEgPSAobCArIChhID4+PiAxMykgfCAwKSArIChIciA+Pj4gMjYpIHwgMCwgSHIgJj0gNjcxMDg4NjMsIHAgPSBNYXRoLmltdWwoSCwgbWUpLCBhID0gTWF0aC5pbXVsKEgsIGRlKSwgYSA9IGEgKyBNYXRoLmltdWwoVywgbWUpIHwgMCwgbCA9IE1hdGguaW11bChXLCBkZSksIHAgPSBwICsgTWF0aC5pbXVsKHksIGNlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHksIExlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEksIGNlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEksIExlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKF9lLCBPZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChfZSwgTmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoRSwgT2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoRSwgTmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoU2UsIGplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKFNlLCBVZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChrZSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoa2UsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHllLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5ZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYmUsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGJlLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh3ZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwod2UsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKE1lLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChNZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoYWUsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGFlLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChnZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoZ2UsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHhlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh4ZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSWUsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEllLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChyZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwocmUsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHNlLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChzZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoaywgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoaywgR2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoJCwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoJCwgR2UpIHwgMDtcbiAgICAgICAgdmFyIEtyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoS3IgPj4+IDI2KSB8IDAsIEtyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKEgsIGNlKSwgYSA9IE1hdGguaW11bChILCBMZSksIGEgPSBhICsgTWF0aC5pbXVsKFcsIGNlKSB8IDAsIGwgPSBNYXRoLmltdWwoVywgTGUpLCBwID0gcCArIE1hdGguaW11bCh5LCBPZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5LCBOZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJLCBPZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJLCBOZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChfZSwgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoX2UsIFVlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEUsIGplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEUsIFVlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKFNlLCBGZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChTZSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoa2UsIEZlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGtlLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh5ZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeWUsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGJlLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChiZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwod2UsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHdlLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChNZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoTWUsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKGFlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChhZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoZ2UsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGdlLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh4ZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeGUsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEllLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwocmUsIFdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHJlLCBHZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChzZSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoc2UsIEdlKSB8IDA7XG4gICAgICAgIHZhciBXciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKFdyID4+PiAyNikgfCAwLCBXciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCBPZSksIGEgPSBNYXRoLmltdWwoSCwgTmUpLCBhID0gYSArIE1hdGguaW11bChXLCBPZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsIE5lKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgamUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgVWUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgamUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgVWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIEZlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCBQZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBGZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCBQZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgRGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsICRlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgJGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeWUsIHplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHllLCBxZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChiZSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoYmUsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHdlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh3ZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoTWUsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKE1lLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChhZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYWUsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGdlLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChnZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeGUsIFdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHhlLCBHZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJZSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSWUsIEdlKSB8IDA7XG4gICAgICAgIHZhciBHciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKEdyID4+PiAyNikgfCAwLCBHciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCBqZSksIGEgPSBNYXRoLmltdWwoSCwgVWUpLCBhID0gYSArIE1hdGguaW11bChXLCBqZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsIFVlKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgRmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgUGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgRmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgUGUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIERlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCAkZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCAkZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgemUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsIHFlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCB6ZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgcWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeWUsIFplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHllLCBWZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChiZSwgWmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoYmUsIFZlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKHdlLCBIZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh3ZSwgS2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoTWUsIEhlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKE1lLCBLZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChhZSwgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoYWUsIEdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGdlLCBXZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChnZSwgR2UpIHwgMDtcbiAgICAgICAgdmFyIFlyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoWXIgPj4+IDI2KSB8IDAsIFlyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKEgsIEZlKSwgYSA9IE1hdGguaW11bChILCBQZSksIGEgPSBhICsgTWF0aC5pbXVsKFcsIEZlKSB8IDAsIGwgPSBNYXRoLmltdWwoVywgUGUpLCBwID0gcCArIE1hdGguaW11bCh5LCBEZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5LCAkZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJLCBEZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJLCAkZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChfZSwgemUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoX2UsIHFlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEUsIHplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEUsIHFlKSB8IDAsIHAgPSBwICsgTWF0aC5pbXVsKFNlLCBaZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChTZSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoa2UsIFplKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKGtlLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bCh5ZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeWUsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGJlLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChiZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwod2UsIFdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHdlLCBHZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChNZSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoTWUsIEdlKSB8IDA7XG4gICAgICAgIHZhciBKciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKEpyID4+PiAyNikgfCAwLCBKciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCBEZSksIGEgPSBNYXRoLmltdWwoSCwgJGUpLCBhID0gYSArIE1hdGguaW11bChXLCBEZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsICRlKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgemUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgcWUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgemUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgcWUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIFplKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCBWZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBaZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCBWZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgSGUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsIEtlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgS2UpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoeWUsIFdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKHllLCBHZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChiZSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoYmUsIEdlKSB8IDA7XG4gICAgICAgIHZhciBYciA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKFhyID4+PiAyNikgfCAwLCBYciAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCB6ZSksIGEgPSBNYXRoLmltdWwoSCwgcWUpLCBhID0gYSArIE1hdGguaW11bChXLCB6ZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsIHFlKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgWmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgVmUpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgWmUpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgVmUpIHwgMCwgcCA9IHAgKyBNYXRoLmltdWwoX2UsIEhlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKF9lLCBLZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChFLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChFLCBLZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChTZSwgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoU2UsIEdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKGtlLCBXZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChrZSwgR2UpIHwgMDtcbiAgICAgICAgdmFyIFFyID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAoUXIgPj4+IDI2KSB8IDAsIFFyICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKEgsIFplKSwgYSA9IE1hdGguaW11bChILCBWZSksIGEgPSBhICsgTWF0aC5pbXVsKFcsIFplKSB8IDAsIGwgPSBNYXRoLmltdWwoVywgVmUpLCBwID0gcCArIE1hdGguaW11bCh5LCBIZSkgfCAwLCBhID0gYSArIE1hdGguaW11bCh5LCBLZSkgfCAwLCBhID0gYSArIE1hdGguaW11bChJLCBIZSkgfCAwLCBsID0gbCArIE1hdGguaW11bChJLCBLZSkgfCAwLCBwID0gcCArIE1hdGguaW11bChfZSwgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoX2UsIEdlKSB8IDAsIGEgPSBhICsgTWF0aC5pbXVsKEUsIFdlKSB8IDAsIGwgPSBsICsgTWF0aC5pbXVsKEUsIEdlKSB8IDA7XG4gICAgICAgIHZhciBlbiA9IChBICsgcCB8IDApICsgKChhICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgQSA9IChsICsgKGEgPj4+IDEzKSB8IDApICsgKGVuID4+PiAyNikgfCAwLCBlbiAmPSA2NzEwODg2MywgcCA9IE1hdGguaW11bChILCBIZSksIGEgPSBNYXRoLmltdWwoSCwgS2UpLCBhID0gYSArIE1hdGguaW11bChXLCBIZSkgfCAwLCBsID0gTWF0aC5pbXVsKFcsIEtlKSwgcCA9IHAgKyBNYXRoLmltdWwoeSwgV2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoeSwgR2UpIHwgMCwgYSA9IGEgKyBNYXRoLmltdWwoSSwgV2UpIHwgMCwgbCA9IGwgKyBNYXRoLmltdWwoSSwgR2UpIHwgMDtcbiAgICAgICAgdmFyIHRuID0gKEEgKyBwIHwgMCkgKyAoKGEgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAodG4gPj4+IDI2KSB8IDAsIHRuICY9IDY3MTA4ODYzLCBwID0gTWF0aC5pbXVsKEgsIFdlKSwgYSA9IE1hdGguaW11bChILCBHZSksIGEgPSBhICsgTWF0aC5pbXVsKFcsIFdlKSB8IDAsIGwgPSBNYXRoLmltdWwoVywgR2UpO1xuICAgICAgICB2YXIgcm4gPSAoQSArIHAgfCAwKSArICgoYSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIHJldHVybiBBID0gKGwgKyAoYSA+Pj4gMTMpIHwgMCkgKyAocm4gPj4+IDI2KSB8IDAsIHJuICY9IDY3MTA4ODYzLCBfWzBdID0gRnIsIF9bMV0gPSBQciwgX1syXSA9IERyLCBfWzNdID0gJHIsIF9bNF0gPSB6ciwgX1s1XSA9IHFyLCBfWzZdID0gWnIsIF9bN10gPSBWciwgX1s4XSA9IEhyLCBfWzldID0gS3IsIF9bMTBdID0gV3IsIF9bMTFdID0gR3IsIF9bMTJdID0gWXIsIF9bMTNdID0gSnIsIF9bMTRdID0gWHIsIF9bMTVdID0gUXIsIF9bMTZdID0gZW4sIF9bMTddID0gdG4sIF9bMThdID0gcm4sIEEgIT09IDAgJiYgKF9bMTldID0gQSwgaC5sZW5ndGgrKyksIGg7XG4gICAgICB9O1xuICAgICAgTWF0aC5pbXVsIHx8IChLID0geik7XG4gICAgICBmdW5jdGlvbiBaKGQsIHMsIHUpIHtcbiAgICAgICAgdS5uZWdhdGl2ZSA9IHMubmVnYXRpdmUgXiBkLm5lZ2F0aXZlLCB1Lmxlbmd0aCA9IGQubGVuZ3RoICsgcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGggPSAwLCBnID0gMCwgdyA9IDA7IHcgPCB1Lmxlbmd0aCAtIDE7IHcrKykge1xuICAgICAgICAgIHZhciBfID0gZztcbiAgICAgICAgICBnID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBBID0gaCAmIDY3MTA4ODYzLCBwID0gTWF0aC5taW4odywgcy5sZW5ndGggLSAxKSwgYSA9IE1hdGgubWF4KDAsIHcgLSBkLmxlbmd0aCArIDEpOyBhIDw9IHA7IGErKykge1xuICAgICAgICAgICAgdmFyIGwgPSB3IC0gYSwgTSA9IGQud29yZHNbbF0gfCAwLCBrID0gcy53b3Jkc1thXSB8IDAsICQgPSBNICogaywgWCA9ICQgJiA2NzEwODg2MztcbiAgICAgICAgICAgIF8gPSBfICsgKCQgLyA2NzEwODg2NCB8IDApIHwgMCwgWCA9IFggKyBBIHwgMCwgQSA9IFggJiA2NzEwODg2MywgXyA9IF8gKyAoWCA+Pj4gMjYpIHwgMCwgZyArPSBfID4+PiAyNiwgXyAmPSA2NzEwODg2MztcbiAgICAgICAgICB9XG4gICAgICAgICAgdS53b3Jkc1t3XSA9IEEsIGggPSBfLCBfID0gZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaCAhPT0gMCA/IHUud29yZHNbd10gPSBoIDogdS5sZW5ndGgtLSwgdS5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFEoZCwgcywgdSkge1xuICAgICAgICByZXR1cm4gWihkLCBzLCB1KTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICB2YXIgaCwgZyA9IHRoaXMubGVuZ3RoICsgcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMTAgJiYgcy5sZW5ndGggPT09IDEwID8gaCA9IEsodGhpcywgcywgdSkgOiBnIDwgNjMgPyBoID0geih0aGlzLCBzLCB1KSA6IGcgPCAxMDI0ID8gaCA9IFoodGhpcywgcywgdSkgOiBoID0gUSh0aGlzLCBzLCB1KSwgaDtcbiAgICAgIH0sIGkucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBuZXcgaShudWxsKTtcbiAgICAgICAgcmV0dXJuIHUud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBzLmxlbmd0aCksIHRoaXMubXVsVG8ocywgdSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IG5ldyBpKG51bGwpO1xuICAgICAgICByZXR1cm4gdS53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIHMubGVuZ3RoKSwgUSh0aGlzLCBzLCB1KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8ocywgdGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBzIDwgMDtcbiAgICAgICAgdSAmJiAocyA9IC1zKSwgbih0eXBlb2YgcyA9PSBcIm51bWJlclwiKSwgbihzIDwgNjcxMDg4NjQpO1xuICAgICAgICBmb3IgKHZhciBoID0gMCwgZyA9IDA7IGcgPCB0aGlzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tnXSB8IDApICogcywgXyA9ICh3ICYgNjcxMDg4NjMpICsgKGggJiA2NzEwODg2Myk7XG4gICAgICAgICAgaCA+Pj0gMjYsIGggKz0gdyAvIDY3MTA4ODY0IHwgMCwgaCArPSBfID4+PiAyNiwgdGhpcy53b3Jkc1tnXSA9IF8gJiA2NzEwODg2MztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaCAhPT0gMCAmJiAodGhpcy53b3Jkc1tnXSA9IGgsIHRoaXMubGVuZ3RoKyspLCB0aGlzLmxlbmd0aCA9IHMgPT09IDAgPyAxIDogdGhpcy5sZW5ndGgsIHUgPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IFIocyk7XG4gICAgICAgIGlmICh1Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBpKDEpO1xuICAgICAgICBmb3IgKHZhciBoID0gdGhpcywgZyA9IDA7IGcgPCB1Lmxlbmd0aCAmJiB1W2ddID09PSAwOyBnKyssIGggPSBoLnNxcigpKVxuICAgICAgICAgIDtcbiAgICAgICAgaWYgKCsrZyA8IHUubGVuZ3RoKVxuICAgICAgICAgIGZvciAodmFyIHcgPSBoLnNxcigpOyBnIDwgdS5sZW5ndGg7IGcrKywgdyA9IHcuc3FyKCkpXG4gICAgICAgICAgICB1W2ddICE9PSAwICYmIChoID0gaC5tdWwodykpO1xuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH0sIGkucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbih0eXBlb2YgcyA9PSBcIm51bWJlclwiICYmIHMgPj0gMCk7XG4gICAgICAgIHZhciB1ID0gcyAlIDI2LCBoID0gKHMgLSB1KSAvIDI2LCBnID0gNjcxMDg4NjMgPj4+IDI2IC0gdSA8PCAyNiAtIHUsIHc7XG4gICAgICAgIGlmICh1ICE9PSAwKSB7XG4gICAgICAgICAgdmFyIF8gPSAwO1xuICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICB2YXIgQSA9IHRoaXMud29yZHNbd10gJiBnLCBwID0gKHRoaXMud29yZHNbd10gfCAwKSAtIEEgPDwgdTtcbiAgICAgICAgICAgIHRoaXMud29yZHNbd10gPSBwIHwgXywgXyA9IEEgPj4+IDI2IC0gdTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXyAmJiAodGhpcy53b3Jkc1t3XSA9IF8sIHRoaXMubGVuZ3RoKyspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICE9PSAwKSB7XG4gICAgICAgICAgZm9yICh3ID0gdGhpcy5sZW5ndGggLSAxOyB3ID49IDA7IHctLSlcbiAgICAgICAgICAgIHRoaXMud29yZHNbdyArIGhdID0gdGhpcy53b3Jkc1t3XTtcbiAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgaDsgdysrKVxuICAgICAgICAgICAgdGhpcy53b3Jkc1t3XSA9IDA7XG4gICAgICAgICAgdGhpcy5sZW5ndGggKz0gaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbih0aGlzLm5lZ2F0aXZlID09PSAwKSwgdGhpcy5pdXNobG4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIG4odHlwZW9mIHMgPT0gXCJudW1iZXJcIiAmJiBzID49IDApO1xuICAgICAgICB2YXIgZztcbiAgICAgICAgdSA/IGcgPSAodSAtIHUgJSAyNikgLyAyNiA6IGcgPSAwO1xuICAgICAgICB2YXIgdyA9IHMgJSAyNiwgXyA9IE1hdGgubWluKChzIC0gdykgLyAyNiwgdGhpcy5sZW5ndGgpLCBBID0gNjcxMDg4NjMgXiA2NzEwODg2MyA+Pj4gdyA8PCB3LCBwID0gaDtcbiAgICAgICAgaWYgKGcgLT0gXywgZyA9IE1hdGgubWF4KDAsIGcpLCBwKSB7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBfOyBhKyspXG4gICAgICAgICAgICBwLndvcmRzW2FdID0gdGhpcy53b3Jkc1thXTtcbiAgICAgICAgICBwLmxlbmd0aCA9IF87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8gIT09IDApIGlmICh0aGlzLmxlbmd0aCA+IF8pXG4gICAgICAgICAgZm9yICh0aGlzLmxlbmd0aCAtPSBfLCBhID0gMDsgYSA8IHRoaXMubGVuZ3RoOyBhKyspXG4gICAgICAgICAgICB0aGlzLndvcmRzW2FdID0gdGhpcy53b3Jkc1thICsgX107XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLndvcmRzWzBdID0gMCwgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICB2YXIgbCA9IDA7XG4gICAgICAgIGZvciAoYSA9IHRoaXMubGVuZ3RoIC0gMTsgYSA+PSAwICYmIChsICE9PSAwIHx8IGEgPj0gZyk7IGEtLSkge1xuICAgICAgICAgIHZhciBNID0gdGhpcy53b3Jkc1thXSB8IDA7XG4gICAgICAgICAgdGhpcy53b3Jkc1thXSA9IGwgPDwgMjYgLSB3IHwgTSA+Pj4gdywgbCA9IE0gJiBBO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwICYmIGwgIT09IDAgJiYgKHAud29yZHNbcC5sZW5ndGgrK10gPSBsKSwgdGhpcy5sZW5ndGggPT09IDAgJiYgKHRoaXMud29yZHNbMF0gPSAwLCB0aGlzLmxlbmd0aCA9IDEpLCB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbihzLCB1LCBoKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMubmVnYXRpdmUgPT09IDApLCB0aGlzLml1c2hybihzLCB1LCBoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIG4odHlwZW9mIHMgPT0gXCJudW1iZXJcIiAmJiBzID49IDApO1xuICAgICAgICB2YXIgdSA9IHMgJSAyNiwgaCA9IChzIC0gdSkgLyAyNiwgZyA9IDEgPDwgdTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDw9IGgpIHJldHVybiAhMTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2hdO1xuICAgICAgICByZXR1cm4gISEodyAmIGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24ocykge1xuICAgICAgICBuKHR5cGVvZiBzID09IFwibnVtYmVyXCIgJiYgcyA+PSAwKTtcbiAgICAgICAgdmFyIHUgPSBzICUgMjYsIGggPSAocyAtIHUpIC8gMjY7XG4gICAgICAgIGlmIChuKHRoaXMubmVnYXRpdmUgPT09IDAsIFwiaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzXCIpLCB0aGlzLmxlbmd0aCA8PSBoKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodSAhPT0gMCAmJiBoKyssIHRoaXMubGVuZ3RoID0gTWF0aC5taW4oaCwgdGhpcy5sZW5ndGgpLCB1ICE9PSAwKSB7XG4gICAgICAgICAgdmFyIGcgPSA2NzEwODg2MyBeIDY3MTA4ODYzID4+PiB1IDw8IHU7XG4gICAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IGc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4odHlwZW9mIHMgPT0gXCJudW1iZXJcIiksIG4ocyA8IDY3MTA4ODY0KSwgcyA8IDAgPyB0aGlzLmlzdWJuKC1zKSA6IHRoaXMubmVnYXRpdmUgIT09IDAgPyB0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDw9IHMgPyAodGhpcy53b3Jkc1swXSA9IHMgLSAodGhpcy53b3Jkc1swXSB8IDApLCB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcykgOiAodGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMuaXN1Ym4ocyksIHRoaXMubmVnYXRpdmUgPSAxLCB0aGlzKSA6IHRoaXMuX2lhZGRuKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24ocykge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHM7XG4gICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1t1XSA+PSA2NzEwODg2NDsgdSsrKVxuICAgICAgICAgIHRoaXMud29yZHNbdV0gLT0gNjcxMDg4NjQsIHUgPT09IHRoaXMubGVuZ3RoIC0gMSA/IHRoaXMud29yZHNbdSArIDFdID0gMSA6IHRoaXMud29yZHNbdSArIDFdKys7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCB1ICsgMSksIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKG4odHlwZW9mIHMgPT0gXCJudW1iZXJcIiksIG4ocyA8IDY3MTA4ODY0KSwgcyA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1zKTtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzLmlhZGRuKHMpLCB0aGlzLm5lZ2F0aXZlID0gMSwgdGhpcztcbiAgICAgICAgaWYgKHRoaXMud29yZHNbMF0gLT0gcywgdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApXG4gICAgICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdLCB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1t1XSA8IDA7IHUrKylcbiAgICAgICAgICAgIHRoaXMud29yZHNbdV0gKz0gNjcxMDg4NjQsIHRoaXMud29yZHNbdSArIDFdIC09IDE7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4ocyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uKHMsIHUsIGgpIHtcbiAgICAgICAgdmFyIGcgPSBzLmxlbmd0aCArIGgsIHc7XG4gICAgICAgIHRoaXMuX2V4cGFuZChnKTtcbiAgICAgICAgdmFyIF8sIEEgPSAwO1xuICAgICAgICBmb3IgKHcgPSAwOyB3IDwgcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIF8gPSAodGhpcy53b3Jkc1t3ICsgaF0gfCAwKSArIEE7XG4gICAgICAgICAgdmFyIHAgPSAocy53b3Jkc1t3XSB8IDApICogdTtcbiAgICAgICAgICBfIC09IHAgJiA2NzEwODg2MywgQSA9IChfID4+IDI2KSAtIChwIC8gNjcxMDg4NjQgfCAwKSwgdGhpcy53b3Jkc1t3ICsgaF0gPSBfICYgNjcxMDg4NjM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHcgPCB0aGlzLmxlbmd0aCAtIGg7IHcrKylcbiAgICAgICAgICBfID0gKHRoaXMud29yZHNbdyArIGhdIHwgMCkgKyBBLCBBID0gXyA+PiAyNiwgdGhpcy53b3Jkc1t3ICsgaF0gPSBfICYgNjcxMDg4NjM7XG4gICAgICAgIGlmIChBID09PSAwKSByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICAgICAgZm9yIChuKEEgPT09IC0xKSwgQSA9IDAsIHcgPSAwOyB3IDwgdGhpcy5sZW5ndGg7IHcrKylcbiAgICAgICAgICBfID0gLSh0aGlzLndvcmRzW3ddIHwgMCkgKyBBLCBBID0gXyA+PiAyNiwgdGhpcy53b3Jkc1t3XSA9IF8gJiA2NzEwODg2MztcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAxLCB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5sZW5ndGggLSBzLmxlbmd0aCwgZyA9IHRoaXMuY2xvbmUoKSwgdyA9IHMsIF8gPSB3LndvcmRzW3cubGVuZ3RoIC0gMV0gfCAwLCBBID0gdGhpcy5fY291bnRCaXRzKF8pO1xuICAgICAgICBoID0gMjYgLSBBLCBoICE9PSAwICYmICh3ID0gdy51c2hsbihoKSwgZy5pdXNobG4oaCksIF8gPSB3LndvcmRzW3cubGVuZ3RoIC0gMV0gfCAwKTtcbiAgICAgICAgdmFyIHAgPSBnLmxlbmd0aCAtIHcubGVuZ3RoLCBhO1xuICAgICAgICBpZiAodSAhPT0gXCJtb2RcIikge1xuICAgICAgICAgIGEgPSBuZXcgaShudWxsKSwgYS5sZW5ndGggPSBwICsgMSwgYS53b3JkcyA9IG5ldyBBcnJheShhLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBhLmxlbmd0aDsgbCsrKVxuICAgICAgICAgICAgYS53b3Jkc1tsXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE0gPSBnLmNsb25lKCkuX2lzaGxuc3VibXVsKHcsIDEsIHApO1xuICAgICAgICBNLm5lZ2F0aXZlID09PSAwICYmIChnID0gTSwgYSAmJiAoYS53b3Jkc1twXSA9IDEpKTtcbiAgICAgICAgZm9yICh2YXIgayA9IHAgLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICAgIHZhciAkID0gKGcud29yZHNbdy5sZW5ndGggKyBrXSB8IDApICogNjcxMDg4NjQgKyAoZy53b3Jkc1t3Lmxlbmd0aCArIGsgLSAxXSB8IDApO1xuICAgICAgICAgIGZvciAoJCA9IE1hdGgubWluKCQgLyBfIHwgMCwgNjcxMDg4NjMpLCBnLl9pc2hsbnN1Ym11bCh3LCAkLCBrKTsgZy5uZWdhdGl2ZSAhPT0gMDsgKVxuICAgICAgICAgICAgJC0tLCBnLm5lZ2F0aXZlID0gMCwgZy5faXNobG5zdWJtdWwodywgMSwgayksIGcuaXNaZXJvKCkgfHwgKGcubmVnYXRpdmUgXj0gMSk7XG4gICAgICAgICAgYSAmJiAoYS53b3Jkc1trXSA9ICQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhICYmIGEuX3N0cmlwKCksIGcuX3N0cmlwKCksIHUgIT09IFwiZGl2XCIgJiYgaCAhPT0gMCAmJiBnLml1c2hybihoKSwge1xuICAgICAgICAgIGRpdjogYSB8fCBudWxsLFxuICAgICAgICAgIG1vZDogZ1xuICAgICAgICB9O1xuICAgICAgfSwgaS5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24ocywgdSwgaCkge1xuICAgICAgICBpZiAobighcy5pc1plcm8oKSksIHRoaXMuaXNaZXJvKCkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpdjogbmV3IGkoMCksXG4gICAgICAgICAgICBtb2Q6IG5ldyBpKDApXG4gICAgICAgICAgfTtcbiAgICAgICAgdmFyIGcsIHcsIF87XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwICYmIHMubmVnYXRpdmUgPT09IDAgPyAoXyA9IHRoaXMubmVnKCkuZGl2bW9kKHMsIHUpLCB1ICE9PSBcIm1vZFwiICYmIChnID0gXy5kaXYubmVnKCkpLCB1ICE9PSBcImRpdlwiICYmICh3ID0gXy5tb2QubmVnKCksIGggJiYgdy5uZWdhdGl2ZSAhPT0gMCAmJiB3LmlhZGQocykpLCB7XG4gICAgICAgICAgZGl2OiBnLFxuICAgICAgICAgIG1vZDogd1xuICAgICAgICB9KSA6IHRoaXMubmVnYXRpdmUgPT09IDAgJiYgcy5uZWdhdGl2ZSAhPT0gMCA/IChfID0gdGhpcy5kaXZtb2Qocy5uZWcoKSwgdSksIHUgIT09IFwibW9kXCIgJiYgKGcgPSBfLmRpdi5uZWcoKSksIHtcbiAgICAgICAgICBkaXY6IGcsXG4gICAgICAgICAgbW9kOiBfLm1vZFxuICAgICAgICB9KSA6ICh0aGlzLm5lZ2F0aXZlICYgcy5uZWdhdGl2ZSkgIT09IDAgPyAoXyA9IHRoaXMubmVnKCkuZGl2bW9kKHMubmVnKCksIHUpLCB1ICE9PSBcImRpdlwiICYmICh3ID0gXy5tb2QubmVnKCksIGggJiYgdy5uZWdhdGl2ZSAhPT0gMCAmJiB3LmlzdWIocykpLCB7XG4gICAgICAgICAgZGl2OiBfLmRpdixcbiAgICAgICAgICBtb2Q6IHdcbiAgICAgICAgfSkgOiBzLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKHMpIDwgMCA/IHtcbiAgICAgICAgICBkaXY6IG5ldyBpKDApLFxuICAgICAgICAgIG1vZDogdGhpc1xuICAgICAgICB9IDogcy5sZW5ndGggPT09IDEgPyB1ID09PSBcImRpdlwiID8ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKHMud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9IDogdSA9PT0gXCJtb2RcIiA/IHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgaSh0aGlzLm1vZHJuKHMud29yZHNbMF0pKVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKHMud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbmV3IGkodGhpcy5tb2RybihzLndvcmRzWzBdKSlcbiAgICAgICAgfSA6IHRoaXMuX3dvcmREaXYocywgdSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdm1vZChzLCBcImRpdlwiLCAhMSkuZGl2O1xuICAgICAgfSwgaS5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZtb2QocywgXCJtb2RcIiwgITEpLm1vZDtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdm1vZChzLCBcIm1vZFwiLCAhMCkubW9kO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5kaXZtb2Qocyk7XG4gICAgICAgIGlmICh1Lm1vZC5pc1plcm8oKSkgcmV0dXJuIHUuZGl2O1xuICAgICAgICB2YXIgaCA9IHUuZGl2Lm5lZ2F0aXZlICE9PSAwID8gdS5tb2QuaXN1YihzKSA6IHUubW9kLCBnID0gcy51c2hybigxKSwgdyA9IHMuYW5kbG4oMSksIF8gPSBoLmNtcChnKTtcbiAgICAgICAgcmV0dXJuIF8gPCAwIHx8IHcgPT09IDEgJiYgXyA9PT0gMCA/IHUuZGl2IDogdS5kaXYubmVnYXRpdmUgIT09IDAgPyB1LmRpdi5pc3VibigxKSA6IHUuZGl2LmlhZGRuKDEpO1xuICAgICAgfSwgaS5wcm90b3R5cGUubW9kcm4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1ID0gcyA8IDA7XG4gICAgICAgIHUgJiYgKHMgPSAtcyksIG4ocyA8PSA2NzEwODg2Myk7XG4gICAgICAgIGZvciAodmFyIGggPSAoMSA8PCAyNikgJSBzLCBnID0gMCwgdyA9IHRoaXMubGVuZ3RoIC0gMTsgdyA+PSAwOyB3LS0pXG4gICAgICAgICAgZyA9IChoICogZyArICh0aGlzLndvcmRzW3ddIHwgMCkpICUgcztcbiAgICAgICAgcmV0dXJuIHUgPyAtZyA6IGc7XG4gICAgICB9LCBpLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RybihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IHMgPCAwO1xuICAgICAgICB1ICYmIChzID0gLXMpLCBuKHMgPD0gNjcxMDg4NjMpO1xuICAgICAgICBmb3IgKHZhciBoID0gMCwgZyA9IHRoaXMubGVuZ3RoIC0gMTsgZyA+PSAwOyBnLS0pIHtcbiAgICAgICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ddIHwgMCkgKyBoICogNjcxMDg4NjQ7XG4gICAgICAgICAgdGhpcy53b3Jkc1tnXSA9IHcgLyBzIHwgMCwgaCA9IHcgJSBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpLCB1ID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIG4ocy5uZWdhdGl2ZSA9PT0gMCksIG4oIXMuaXNaZXJvKCkpO1xuICAgICAgICB2YXIgdSA9IHRoaXMsIGggPSBzLmNsb25lKCk7XG4gICAgICAgIHUubmVnYXRpdmUgIT09IDAgPyB1ID0gdS51bW9kKHMpIDogdSA9IHUuY2xvbmUoKTtcbiAgICAgICAgZm9yICh2YXIgZyA9IG5ldyBpKDEpLCB3ID0gbmV3IGkoMCksIF8gPSBuZXcgaSgwKSwgQSA9IG5ldyBpKDEpLCBwID0gMDsgdS5pc0V2ZW4oKSAmJiBoLmlzRXZlbigpOyApXG4gICAgICAgICAgdS5pdXNocm4oMSksIGguaXVzaHJuKDEpLCArK3A7XG4gICAgICAgIGZvciAodmFyIGEgPSBoLmNsb25lKCksIGwgPSB1LmNsb25lKCk7ICF1LmlzWmVybygpOyApIHtcbiAgICAgICAgICBmb3IgKHZhciBNID0gMCwgayA9IDE7ICh1LndvcmRzWzBdICYgaykgPT09IDAgJiYgTSA8IDI2OyArK00sIGsgPDw9IDEpIDtcbiAgICAgICAgICBpZiAoTSA+IDApXG4gICAgICAgICAgICBmb3IgKHUuaXVzaHJuKE0pOyBNLS0gPiAwOyApXG4gICAgICAgICAgICAgIChnLmlzT2RkKCkgfHwgdy5pc09kZCgpKSAmJiAoZy5pYWRkKGEpLCB3LmlzdWIobCkpLCBnLml1c2hybigxKSwgdy5pdXNocm4oMSk7XG4gICAgICAgICAgZm9yICh2YXIgJCA9IDAsIFggPSAxOyAoaC53b3Jkc1swXSAmIFgpID09PSAwICYmICQgPCAyNjsgKyskLCBYIDw8PSAxKSA7XG4gICAgICAgICAgaWYgKCQgPiAwKVxuICAgICAgICAgICAgZm9yIChoLml1c2hybigkKTsgJC0tID4gMDsgKVxuICAgICAgICAgICAgICAoXy5pc09kZCgpIHx8IEEuaXNPZGQoKSkgJiYgKF8uaWFkZChhKSwgQS5pc3ViKGwpKSwgXy5pdXNocm4oMSksIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIHUuY21wKGgpID49IDAgPyAodS5pc3ViKGgpLCBnLmlzdWIoXyksIHcuaXN1YihBKSkgOiAoaC5pc3ViKHUpLCBfLmlzdWIoZyksIEEuaXN1Yih3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhOiBfLFxuICAgICAgICAgIGI6IEEsXG4gICAgICAgICAgZ2NkOiBoLml1c2hsbihwKVxuICAgICAgICB9O1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24ocykge1xuICAgICAgICBuKHMubmVnYXRpdmUgPT09IDApLCBuKCFzLmlzWmVybygpKTtcbiAgICAgICAgdmFyIHUgPSB0aGlzLCBoID0gcy5jbG9uZSgpO1xuICAgICAgICB1Lm5lZ2F0aXZlICE9PSAwID8gdSA9IHUudW1vZChzKSA6IHUgPSB1LmNsb25lKCk7XG4gICAgICAgIGZvciAodmFyIGcgPSBuZXcgaSgxKSwgdyA9IG5ldyBpKDApLCBfID0gaC5jbG9uZSgpOyB1LmNtcG4oMSkgPiAwICYmIGguY21wbigxKSA+IDA7ICkge1xuICAgICAgICAgIGZvciAodmFyIEEgPSAwLCBwID0gMTsgKHUud29yZHNbMF0gJiBwKSA9PT0gMCAmJiBBIDwgMjY7ICsrQSwgcCA8PD0gMSkgO1xuICAgICAgICAgIGlmIChBID4gMClcbiAgICAgICAgICAgIGZvciAodS5pdXNocm4oQSk7IEEtLSA+IDA7IClcbiAgICAgICAgICAgICAgZy5pc09kZCgpICYmIGcuaWFkZChfKSwgZy5pdXNocm4oMSk7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IDAsIGwgPSAxOyAoaC53b3Jkc1swXSAmIGwpID09PSAwICYmIGEgPCAyNjsgKythLCBsIDw8PSAxKSA7XG4gICAgICAgICAgaWYgKGEgPiAwKVxuICAgICAgICAgICAgZm9yIChoLml1c2hybihhKTsgYS0tID4gMDsgKVxuICAgICAgICAgICAgICB3LmlzT2RkKCkgJiYgdy5pYWRkKF8pLCB3Lml1c2hybigxKTtcbiAgICAgICAgICB1LmNtcChoKSA+PSAwID8gKHUuaXN1YihoKSwgZy5pc3ViKHcpKSA6IChoLmlzdWIodSksIHcuaXN1YihnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE07XG4gICAgICAgIHJldHVybiB1LmNtcG4oMSkgPT09IDAgPyBNID0gZyA6IE0gPSB3LCBNLmNtcG4oMCkgPCAwICYmIE0uaWFkZChzKSwgTTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBzLmFicygpO1xuICAgICAgICBpZiAocy5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG4gICAgICAgIHZhciB1ID0gdGhpcy5jbG9uZSgpLCBoID0gcy5jbG9uZSgpO1xuICAgICAgICB1Lm5lZ2F0aXZlID0gMCwgaC5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGcgPSAwOyB1LmlzRXZlbigpICYmIGguaXNFdmVuKCk7IGcrKylcbiAgICAgICAgICB1Lml1c2hybigxKSwgaC5pdXNocm4oMSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBmb3IgKDsgdS5pc0V2ZW4oKTsgKVxuICAgICAgICAgICAgdS5pdXNocm4oMSk7XG4gICAgICAgICAgZm9yICg7IGguaXNFdmVuKCk7IClcbiAgICAgICAgICAgIGguaXVzaHJuKDEpO1xuICAgICAgICAgIHZhciB3ID0gdS5jbXAoaCk7XG4gICAgICAgICAgaWYgKHcgPCAwKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHU7XG4gICAgICAgICAgICB1ID0gaCwgaCA9IF87XG4gICAgICAgICAgfSBlbHNlIGlmICh3ID09PSAwIHx8IGguY21wbigxKSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHUuaXN1YihoKTtcbiAgICAgICAgfSB3aGlsZSAoITApO1xuICAgICAgICByZXR1cm4gaC5pdXNobG4oZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5lZ2NkKHMpLmEudW1vZChzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24ocykge1xuICAgICAgICBuKHR5cGVvZiBzID09IFwibnVtYmVyXCIpO1xuICAgICAgICB2YXIgdSA9IHMgJSAyNiwgaCA9IChzIC0gdSkgLyAyNiwgZyA9IDEgPDwgdTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDw9IGgpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZChoICsgMSksIHRoaXMud29yZHNbaF0gfD0gZywgdGhpcztcbiAgICAgICAgZm9yICh2YXIgdyA9IGcsIF8gPSBoOyB3ICE9PSAwICYmIF8gPCB0aGlzLmxlbmd0aDsgXysrKSB7XG4gICAgICAgICAgdmFyIEEgPSB0aGlzLndvcmRzW19dIHwgMDtcbiAgICAgICAgICBBICs9IHcsIHcgPSBBID4+PiAyNiwgQSAmPSA2NzEwODg2MywgdGhpcy53b3Jkc1tfXSA9IEE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHcgIT09IDAgJiYgKHRoaXMud29yZHNbX10gPSB3LCB0aGlzLmxlbmd0aCsrKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciB1ID0gcyA8IDA7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICF1KSByZXR1cm4gLTE7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIHUpIHJldHVybiAxO1xuICAgICAgICB0aGlzLl9zdHJpcCgpO1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSlcbiAgICAgICAgICBoID0gMTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdSAmJiAocyA9IC1zKSwgbihzIDw9IDY3MTA4ODYzLCBcIk51bWJlciBpcyB0b28gYmlnXCIpO1xuICAgICAgICAgIHZhciBnID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICAgICAgaCA9IGcgPT09IHMgPyAwIDogZyA8IHMgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgPyAtaCB8IDAgOiBoO1xuICAgICAgfSwgaS5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBzLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIHMubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuICAgICAgICB2YXIgdSA9IHRoaXMudWNtcChzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgPyAtdSB8IDAgOiB1O1xuICAgICAgfSwgaS5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gcy5sZW5ndGgpIHJldHVybiAxO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPCBzLmxlbmd0aCkgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKHZhciB1ID0gMCwgaCA9IHRoaXMubGVuZ3RoIC0gMTsgaCA+PSAwOyBoLS0pIHtcbiAgICAgICAgICB2YXIgZyA9IHRoaXMud29yZHNbaF0gfCAwLCB3ID0gcy53b3Jkc1toXSB8IDA7XG4gICAgICAgICAgaWYgKGcgIT09IHcpIHtcbiAgICAgICAgICAgIGcgPCB3ID8gdSA9IC0xIDogZyA+IHcgJiYgKHUgPSAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wbihzKSA9PT0gMTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXAocykgPT09IDE7XG4gICAgICB9LCBpLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXBuKHMpID49IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcChzKSA+PSAwO1xuICAgICAgfSwgaS5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXBuKHMpID09PSAtMTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXAocykgPT09IC0xO1xuICAgICAgfSwgaS5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wbihzKSA8PSAwO1xuICAgICAgfSwgaS5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXAocykgPD0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wbihzKSA9PT0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmVxID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXAocykgPT09IDA7XG4gICAgICB9LCBpLnJlZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKCF0aGlzLnJlZCwgXCJBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpLCBuKHRoaXMubmVnYXRpdmUgPT09IDAsIFwicmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXNcIiksIHMuY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwiZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dFwiKSwgdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZCA9IHMsIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4oIXRoaXMucmVkLCBcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIiksIHRoaXMuX2ZvcmNlUmVkKHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbih0aGlzLnJlZCwgXCJyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5hZGQodGhpcywgcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbih0aGlzLnJlZCwgXCJyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuaWFkZCh0aGlzLCBzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwicmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuc3ViKHRoaXMsIHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwicmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLmlzdWIodGhpcywgcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLnNobCh0aGlzLCBzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwicmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgcyksIHRoaXMucmVkLm11bCh0aGlzLCBzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIHMpLCB0aGlzLnJlZC5pbXVsKHRoaXMsIHMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5zcXIodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuKHRoaXMucmVkLCBcInJlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwicmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbih0aGlzLnJlZCwgXCJyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLmludm0odGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQsIFwicmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIG4odGhpcy5yZWQgJiYgIXMucmVkLCBcInJlZFBvdyhub3JtYWxOdW0pXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQucG93KHRoaXMsIHMpO1xuICAgICAgfTtcbiAgICAgIHZhciBqID0ge1xuICAgICAgICBrMjU2OiBudWxsLFxuICAgICAgICBwMjI0OiBudWxsLFxuICAgICAgICBwMTkyOiBudWxsLFxuICAgICAgICBwMjU1MTk6IG51bGxcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBWKGQsIHMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gZCwgdGhpcy5wID0gbmV3IGkocywgMTYpLCB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCksIHRoaXMuayA9IG5ldyBpKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKSwgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgICAgIH1cbiAgICAgIFYucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgaShudWxsKTtcbiAgICAgICAgcmV0dXJuIHMud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSksIHM7XG4gICAgICB9LCBWLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IHMsIGg7XG4gICAgICAgIGRvXG4gICAgICAgICAgdGhpcy5zcGxpdCh1LCB0aGlzLnRtcCksIHUgPSB0aGlzLmltdWxLKHUpLCB1ID0gdS5pYWRkKHRoaXMudG1wKSwgaCA9IHUuYml0TGVuZ3RoKCk7XG4gICAgICAgIHdoaWxlIChoID4gdGhpcy5uKTtcbiAgICAgICAgdmFyIGcgPSBoIDwgdGhpcy5uID8gLTEgOiB1LnVjbXAodGhpcy5wKTtcbiAgICAgICAgcmV0dXJuIGcgPT09IDAgPyAodS53b3Jkc1swXSA9IDAsIHUubGVuZ3RoID0gMSkgOiBnID4gMCA/IHUuaXN1Yih0aGlzLnApIDogdS5zdHJpcCAhPT0gdm9pZCAwID8gdS5zdHJpcCgpIDogdS5fc3RyaXAoKSwgdTtcbiAgICAgIH0sIFYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBzLml1c2hybih0aGlzLm4sIDAsIHUpO1xuICAgICAgfSwgVi5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzLmltdWwodGhpcy5rKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBlZSgpIHtcbiAgICAgICAgVi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCJrMjU2XCIsXG4gICAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvKGVlLCBWKSwgZWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBmb3IgKHZhciBoID0gNDE5NDMwMywgZyA9IE1hdGgubWluKHMubGVuZ3RoLCA5KSwgdyA9IDA7IHcgPCBnOyB3KyspXG4gICAgICAgICAgdS53b3Jkc1t3XSA9IHMud29yZHNbd107XG4gICAgICAgIGlmICh1Lmxlbmd0aCA9IGcsIHMubGVuZ3RoIDw9IDkpIHtcbiAgICAgICAgICBzLndvcmRzWzBdID0gMCwgcy5sZW5ndGggPSAxO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgXyA9IHMud29yZHNbOV07XG4gICAgICAgIGZvciAodS53b3Jkc1t1Lmxlbmd0aCsrXSA9IF8gJiBoLCB3ID0gMTA7IHcgPCBzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgdmFyIEEgPSBzLndvcmRzW3ddIHwgMDtcbiAgICAgICAgICBzLndvcmRzW3cgLSAxMF0gPSAoQSAmIGgpIDw8IDQgfCBfID4+PiAyMiwgXyA9IEE7XG4gICAgICAgIH1cbiAgICAgICAgXyA+Pj49IDIyLCBzLndvcmRzW3cgLSAxMF0gPSBfLCBfID09PSAwICYmIHMubGVuZ3RoID4gMTAgPyBzLmxlbmd0aCAtPSAxMCA6IHMubGVuZ3RoIC09IDk7XG4gICAgICB9LCBlZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMud29yZHNbcy5sZW5ndGhdID0gMCwgcy53b3Jkc1tzLmxlbmd0aCArIDFdID0gMCwgcy5sZW5ndGggKz0gMjtcbiAgICAgICAgZm9yICh2YXIgdSA9IDAsIGggPSAwOyBoIDwgcy5sZW5ndGg7IGgrKykge1xuICAgICAgICAgIHZhciBnID0gcy53b3Jkc1toXSB8IDA7XG4gICAgICAgICAgdSArPSBnICogOTc3LCBzLndvcmRzW2hdID0gdSAmIDY3MTA4ODYzLCB1ID0gZyAqIDY0ICsgKHUgLyA2NzEwODg2NCB8IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzLndvcmRzW3MubGVuZ3RoIC0gMV0gPT09IDAgJiYgKHMubGVuZ3RoLS0sIHMud29yZHNbcy5sZW5ndGggLSAxXSA9PT0gMCAmJiBzLmxlbmd0aC0tKSwgcztcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBHKCkge1xuICAgICAgICBWLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBcInAyMjRcIixcbiAgICAgICAgICBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG8oRywgVik7XG4gICAgICBmdW5jdGlvbiBOKCkge1xuICAgICAgICBWLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBcInAxOTJcIixcbiAgICAgICAgICBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG8oTiwgVik7XG4gICAgICBmdW5jdGlvbiBPKCkge1xuICAgICAgICBWLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBcIjI1NTE5XCIsXG4gICAgICAgICAgXCI3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG8oTywgViksIE8ucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24ocykge1xuICAgICAgICBmb3IgKHZhciB1ID0gMCwgaCA9IDA7IGggPCBzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgdmFyIGcgPSAocy53b3Jkc1toXSB8IDApICogMTkgKyB1LCB3ID0gZyAmIDY3MTA4ODYzO1xuICAgICAgICAgIGcgPj4+PSAyNiwgcy53b3Jkc1toXSA9IHcsIHUgPSBnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1ICE9PSAwICYmIChzLndvcmRzW3MubGVuZ3RoKytdID0gdSksIHM7XG4gICAgICB9LCBpLl9wcmltZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKGpbc10pIHJldHVybiBqW3NdO1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgaWYgKHMgPT09IFwiazI1NlwiKVxuICAgICAgICAgIHUgPSBuZXcgZWUoKTtcbiAgICAgICAgZWxzZSBpZiAocyA9PT0gXCJwMjI0XCIpXG4gICAgICAgICAgdSA9IG5ldyBHKCk7XG4gICAgICAgIGVsc2UgaWYgKHMgPT09IFwicDE5MlwiKVxuICAgICAgICAgIHUgPSBuZXcgTigpO1xuICAgICAgICBlbHNlIGlmIChzID09PSBcInAyNTUxOVwiKVxuICAgICAgICAgIHUgPSBuZXcgTygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwcmltZSBcIiArIHMpO1xuICAgICAgICByZXR1cm4galtzXSA9IHUsIHU7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gTChkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFyIHMgPSBpLl9wcmltZShkKTtcbiAgICAgICAgICB0aGlzLm0gPSBzLnAsIHRoaXMucHJpbWUgPSBzO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBuKGQuZ3RuKDEpLCBcIm1vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKSwgdGhpcy5tID0gZCwgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBMLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbihzLm5lZ2F0aXZlID09PSAwLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLCBuKHMucmVkLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7XG4gICAgICB9LCBMLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgbigocy5uZWdhdGl2ZSB8IHUubmVnYXRpdmUpID09PSAwLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLCBuKFxuICAgICAgICAgIHMucmVkICYmIHMucmVkID09PSB1LnJlZCxcbiAgICAgICAgICBcInJlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIlxuICAgICAgICApO1xuICAgICAgfSwgTC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbWUgPyB0aGlzLnByaW1lLmlyZWR1Y2UocykuX2ZvcmNlUmVkKHRoaXMpIDogKGIocywgcy51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpKSwgcyk7XG4gICAgICB9LCBMLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzLmlzWmVybygpID8gcy5jbG9uZSgpIDogdGhpcy5tLnN1YihzKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgICB9LCBMLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeTIocywgdSk7XG4gICAgICAgIHZhciBoID0gcy5hZGQodSk7XG4gICAgICAgIHJldHVybiBoLmNtcCh0aGlzLm0pID49IDAgJiYgaC5pc3ViKHRoaXMubSksIGguX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgfSwgTC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5MihzLCB1KTtcbiAgICAgICAgdmFyIGggPSBzLmlhZGQodSk7XG4gICAgICAgIHJldHVybiBoLmNtcCh0aGlzLm0pID49IDAgJiYgaC5pc3ViKHRoaXMubSksIGg7XG4gICAgICB9LCBMLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeTIocywgdSk7XG4gICAgICAgIHZhciBoID0gcy5zdWIodSk7XG4gICAgICAgIHJldHVybiBoLmNtcG4oMCkgPCAwICYmIGguaWFkZCh0aGlzLm0pLCBoLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH0sIEwucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeTIocywgdSk7XG4gICAgICAgIHZhciBoID0gcy5pc3ViKHUpO1xuICAgICAgICByZXR1cm4gaC5jbXBuKDApIDwgMCAmJiBoLmlhZGQodGhpcy5tKSwgaDtcbiAgICAgIH0sIEwucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeTEocyksIHRoaXMuaW1vZChzLnVzaGxuKHUpKTtcbiAgICAgIH0sIEwucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkyKHMsIHUpLCB0aGlzLmltb2Qocy5pbXVsKHUpKTtcbiAgICAgIH0sIEwucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeTIocywgdSksIHRoaXMuaW1vZChzLm11bCh1KSk7XG4gICAgICB9LCBMLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbXVsKHMsIHMuY2xvbmUoKSk7XG4gICAgICB9LCBMLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bChzLCBzKTtcbiAgICAgIH0sIEwucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLmlzWmVybygpKSByZXR1cm4gcy5jbG9uZSgpO1xuICAgICAgICB2YXIgdSA9IHRoaXMubS5hbmRsbigzKTtcbiAgICAgICAgaWYgKG4odSAlIDIgPT09IDEpLCB1ID09PSAzKSB7XG4gICAgICAgICAgdmFyIGggPSB0aGlzLm0uYWRkKG5ldyBpKDEpKS5pdXNocm4oMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG93KHMsIGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGcgPSB0aGlzLm0uc3VibigxKSwgdyA9IDA7ICFnLmlzWmVybygpICYmIGcuYW5kbG4oMSkgPT09IDA7IClcbiAgICAgICAgICB3KyssIGcuaXVzaHJuKDEpO1xuICAgICAgICBuKCFnLmlzWmVybygpKTtcbiAgICAgICAgdmFyIF8gPSBuZXcgaSgxKS50b1JlZCh0aGlzKSwgQSA9IF8ucmVkTmVnKCksIHAgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSksIGEgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgICAgIGZvciAoYSA9IG5ldyBpKDIgKiBhICogYSkudG9SZWQodGhpcyk7IHRoaXMucG93KGEsIHApLmNtcChBKSAhPT0gMDsgKVxuICAgICAgICAgIGEucmVkSUFkZChBKTtcbiAgICAgICAgZm9yICh2YXIgbCA9IHRoaXMucG93KGEsIGcpLCBNID0gdGhpcy5wb3cocywgZy5hZGRuKDEpLml1c2hybigxKSksIGsgPSB0aGlzLnBvdyhzLCBnKSwgJCA9IHc7IGsuY21wKF8pICE9PSAwOyApIHtcbiAgICAgICAgICBmb3IgKHZhciBYID0gaywgcmUgPSAwOyBYLmNtcChfKSAhPT0gMDsgcmUrKylcbiAgICAgICAgICAgIFggPSBYLnJlZFNxcigpO1xuICAgICAgICAgIG4ocmUgPCAkKTtcbiAgICAgICAgICB2YXIgc2UgPSB0aGlzLnBvdyhsLCBuZXcgaSgxKS5pdXNobG4oJCAtIHJlIC0gMSkpO1xuICAgICAgICAgIE0gPSBNLnJlZE11bChzZSksIGwgPSBzZS5yZWRTcXIoKSwgayA9IGsucmVkTXVsKGwpLCAkID0gcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE07XG4gICAgICB9LCBMLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IHMuX2ludm1wKHRoaXMubSk7XG4gICAgICAgIHJldHVybiB1Lm5lZ2F0aXZlICE9PSAwID8gKHUubmVnYXRpdmUgPSAwLCB0aGlzLmltb2QodSkucmVkTmVnKCkpIDogdGhpcy5pbW9kKHUpO1xuICAgICAgfSwgTC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBpZiAodS5pc1plcm8oKSkgcmV0dXJuIG5ldyBpKDEpLnRvUmVkKHRoaXMpO1xuICAgICAgICBpZiAodS5jbXBuKDEpID09PSAwKSByZXR1cm4gcy5jbG9uZSgpO1xuICAgICAgICB2YXIgaCA9IDQsIGcgPSBuZXcgQXJyYXkoMSA8PCBoKTtcbiAgICAgICAgZ1swXSA9IG5ldyBpKDEpLnRvUmVkKHRoaXMpLCBnWzFdID0gcztcbiAgICAgICAgZm9yICh2YXIgdyA9IDI7IHcgPCBnLmxlbmd0aDsgdysrKVxuICAgICAgICAgIGdbd10gPSB0aGlzLm11bChnW3cgLSAxXSwgcyk7XG4gICAgICAgIHZhciBfID0gZ1swXSwgQSA9IDAsIHAgPSAwLCBhID0gdS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgICAgICBmb3IgKGEgPT09IDAgJiYgKGEgPSAyNiksIHcgPSB1Lmxlbmd0aCAtIDE7IHcgPj0gMDsgdy0tKSB7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IHUud29yZHNbd10sIE0gPSBhIC0gMTsgTSA+PSAwOyBNLS0pIHtcbiAgICAgICAgICAgIHZhciBrID0gbCA+PiBNICYgMTtcbiAgICAgICAgICAgIGlmIChfICE9PSBnWzBdICYmIChfID0gdGhpcy5zcXIoXykpLCBrID09PSAwICYmIEEgPT09IDApIHtcbiAgICAgICAgICAgICAgcCA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQSA8PD0gMSwgQSB8PSBrLCBwKyssICEocCAhPT0gaCAmJiAodyAhPT0gMCB8fCBNICE9PSAwKSkgJiYgKF8gPSB0aGlzLm11bChfLCBnW0FdKSwgcCA9IDAsIEEgPSAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYSA9IDI2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfSwgTC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IHMudW1vZCh0aGlzLm0pO1xuICAgICAgICByZXR1cm4gdSA9PT0gcyA/IHUuY2xvbmUoKSA6IHU7XG4gICAgICB9LCBMLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSBzLmNsb25lKCk7XG4gICAgICAgIHJldHVybiB1LnJlZCA9IG51bGwsIHU7XG4gICAgICB9LCBpLm1vbnQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRihzKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBGKGQpIHtcbiAgICAgICAgTC5jYWxsKHRoaXMsIGQpLCB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpLCB0aGlzLnNoaWZ0ICUgMjYgIT09IDAgJiYgKHRoaXMuc2hpZnQgKz0gMjYgLSB0aGlzLnNoaWZ0ICUgMjYpLCB0aGlzLnIgPSBuZXcgaSgxKS5pdXNobG4odGhpcy5zaGlmdCksIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKSwgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pLCB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSksIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMuciksIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgICAgIH1cbiAgICAgIG8oRiwgTCksIEYucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1vZChzLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgICAgIH0sIEYucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgdSA9IHRoaXMuaW1vZChzLm11bCh0aGlzLnJpbnYpKTtcbiAgICAgICAgcmV0dXJuIHUucmVkID0gbnVsbCwgdTtcbiAgICAgIH0sIEYucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbihzLCB1KSB7XG4gICAgICAgIGlmIChzLmlzWmVybygpIHx8IHUuaXNaZXJvKCkpXG4gICAgICAgICAgcmV0dXJuIHMud29yZHNbMF0gPSAwLCBzLmxlbmd0aCA9IDEsIHM7XG4gICAgICAgIHZhciBoID0gcy5pbXVsKHUpLCBnID0gaC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSksIHcgPSBoLmlzdWIoZykuaXVzaHJuKHRoaXMuc2hpZnQpLCBfID0gdztcbiAgICAgICAgcmV0dXJuIHcuY21wKHRoaXMubSkgPj0gMCA/IF8gPSB3LmlzdWIodGhpcy5tKSA6IHcuY21wbigwKSA8IDAgJiYgKF8gPSB3LmlhZGQodGhpcy5tKSksIF8uX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgfSwgRi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24ocywgdSkge1xuICAgICAgICBpZiAocy5pc1plcm8oKSB8fCB1LmlzWmVybygpKSByZXR1cm4gbmV3IGkoMCkuX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgICB2YXIgaCA9IHMubXVsKHUpLCBnID0gaC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSksIHcgPSBoLmlzdWIoZykuaXVzaHJuKHRoaXMuc2hpZnQpLCBfID0gdztcbiAgICAgICAgcmV0dXJuIHcuY21wKHRoaXMubSkgPj0gMCA/IF8gPSB3LmlzdWIodGhpcy5tKSA6IHcuY21wbigwKSA8IDAgJiYgKF8gPSB3LmlhZGQodGhpcy5tKSksIF8uX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgfSwgRi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLmltb2Qocy5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgICAgICByZXR1cm4gdS5fZm9yY2VSZWQodGhpcyk7XG4gICAgICB9O1xuICAgIH0pKHQsIFhoKTtcbiAgfShucykpLCBucy5leHBvcnRzO1xufVxudmFyIG5vLCBldTtcbmZ1bmN0aW9uIGVkKCkge1xuICBpZiAoZXUpIHJldHVybiBubztcbiAgZXUgPSAxO1xuICB2YXIgdCA9IGtjKCkuQnVmZmVyO1xuICBmdW5jdGlvbiBlKHIpIHtcbiAgICBpZiAoci5sZW5ndGggPj0gMjU1KVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFscGhhYmV0IHRvbyBsb25nXCIpO1xuICAgIGZvciAodmFyIG4gPSBuZXcgVWludDhBcnJheSgyNTYpLCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICBuW29dID0gMjU1O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByLmNoYXJBdChpKSwgZiA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChuW2ZdICE9PSAyNTUpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYyArIFwiIGlzIGFtYmlndW91c1wiKTtcbiAgICAgIG5bZl0gPSBpO1xuICAgIH1cbiAgICB2YXIgdiA9IHIubGVuZ3RoLCB4ID0gci5jaGFyQXQoMCksIGIgPSBNYXRoLmxvZyh2KSAvIE1hdGgubG9nKDI1NiksIFMgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2codik7XG4gICAgZnVuY3Rpb24gVChCKSB7XG4gICAgICBpZiAoKEFycmF5LmlzQXJyYXkoQikgfHwgQiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmIChCID0gdC5mcm9tKEIpKSwgIXQuaXNCdWZmZXIoQikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBCdWZmZXJcIik7XG4gICAgICBpZiAoQi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgZm9yICh2YXIgUiA9IDAsIHogPSAwLCBLID0gMCwgWiA9IEIubGVuZ3RoOyBLICE9PSBaICYmIEJbS10gPT09IDA7IClcbiAgICAgICAgSysrLCBSKys7XG4gICAgICBmb3IgKHZhciBRID0gKFogLSBLKSAqIFMgKyAxID4+PiAwLCBqID0gbmV3IFVpbnQ4QXJyYXkoUSk7IEsgIT09IFo7ICkge1xuICAgICAgICBmb3IgKHZhciBWID0gQltLXSwgZWUgPSAwLCBHID0gUSAtIDE7IChWICE9PSAwIHx8IGVlIDwgeikgJiYgRyAhPT0gLTE7IEctLSwgZWUrKylcbiAgICAgICAgICBWICs9IDI1NiAqIGpbR10gPj4+IDAsIGpbR10gPSBWICUgdiA+Pj4gMCwgViA9IFYgLyB2ID4+PiAwO1xuICAgICAgICBpZiAoViAhPT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24temVybyBjYXJyeVwiKTtcbiAgICAgICAgeiA9IGVlLCBLKys7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBOID0gUSAtIHo7IE4gIT09IFEgJiYgaltOXSA9PT0gMDsgKVxuICAgICAgICBOKys7XG4gICAgICBmb3IgKHZhciBPID0geC5yZXBlYXQoUik7IE4gPCBROyArK04pXG4gICAgICAgIE8gKz0gci5jaGFyQXQoaltOXSk7XG4gICAgICByZXR1cm4gTztcbiAgICB9XG4gICAgZnVuY3Rpb24gQyhCKSB7XG4gICAgICBpZiAodHlwZW9mIEIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcbiAgICAgIGlmIChCLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHQuYWxsb2MoMCk7XG4gICAgICBmb3IgKHZhciBSID0gMCwgeiA9IDAsIEsgPSAwOyBCW1JdID09PSB4OyApXG4gICAgICAgIHorKywgUisrO1xuICAgICAgZm9yICh2YXIgWiA9IChCLmxlbmd0aCAtIFIpICogYiArIDEgPj4+IDAsIFEgPSBuZXcgVWludDhBcnJheShaKTsgUiA8IEIubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGogPSBCLmNoYXJDb2RlQXQoUik7XG4gICAgICAgIGlmIChqID4gMjU1KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIFYgPSBuW2pdO1xuICAgICAgICBpZiAoViA9PT0gMjU1KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgZWUgPSAwLCBHID0gWiAtIDE7IChWICE9PSAwIHx8IGVlIDwgSykgJiYgRyAhPT0gLTE7IEctLSwgZWUrKylcbiAgICAgICAgICBWICs9IHYgKiBRW0ddID4+PiAwLCBRW0ddID0gViAlIDI1NiA+Pj4gMCwgViA9IFYgLyAyNTYgPj4+IDA7XG4gICAgICAgIGlmIChWICE9PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgICBLID0gZWUsIFIrKztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIE4gPSBaIC0gSzsgTiAhPT0gWiAmJiBRW05dID09PSAwOyApXG4gICAgICAgIE4rKztcbiAgICAgIHZhciBPID0gdC5hbGxvY1Vuc2FmZSh6ICsgKFogLSBOKSk7XG4gICAgICBPLmZpbGwoMCwgMCwgeik7XG4gICAgICBmb3IgKHZhciBMID0gejsgTiAhPT0gWjsgKVxuICAgICAgICBPW0wrK10gPSBRW04rK107XG4gICAgICByZXR1cm4gTztcbiAgICB9XG4gICAgZnVuY3Rpb24gUChCKSB7XG4gICAgICB2YXIgUiA9IEMoQik7XG4gICAgICBpZiAoUilcbiAgICAgICAgcmV0dXJuIFI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24tYmFzZVwiICsgdiArIFwiIGNoYXJhY3RlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZTogVCxcbiAgICAgIGRlY29kZVVuc2FmZTogQyxcbiAgICAgIGRlY29kZTogUFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5vID0gZSwgbm87XG59XG52YXIgaW8sIHR1O1xuZnVuY3Rpb24gdGQoKSB7XG4gIGlmICh0dSkgcmV0dXJuIGlvO1xuICB0dSA9IDE7XG4gIHZhciB0ID0gZWQoKSwgZSA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xuICByZXR1cm4gaW8gPSB0KGUpLCBpbztcbn1cbmZ1bmN0aW9uIGdyKHQsIGUsIHIpIHtcbiAgcmV0dXJuIGUgPD0gdCAmJiB0IDw9IHI7XG59XG5mdW5jdGlvbiBVcyh0KSB7XG4gIGlmICh0ID09PSB2b2lkIDApIHJldHVybiB7fTtcbiAgaWYgKHQgPT09IE9iamVjdCh0KSkgcmV0dXJuIHQ7XG4gIHRocm93IFR5cGVFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IGFyZ3VtZW50IHRvIGRpY3Rpb25hcnlcIik7XG59XG5mdW5jdGlvbiByZCh0KSB7XG4gIGZvciAodmFyIGUgPSBTdHJpbmcodCksIHIgPSBlLmxlbmd0aCwgbiA9IDAsIG8gPSBbXTsgbiA8IHI7ICkge1xuICAgIHZhciBpID0gZS5jaGFyQ29kZUF0KG4pO1xuICAgIGlmIChpIDwgNTUyOTYgfHwgaSA+IDU3MzQzKVxuICAgICAgby5wdXNoKGkpO1xuICAgIGVsc2UgaWYgKDU2MzIwIDw9IGkgJiYgaSA8PSA1NzM0MylcbiAgICAgIG8ucHVzaCg2NTUzMyk7XG4gICAgZWxzZSBpZiAoNTUyOTYgPD0gaSAmJiBpIDw9IDU2MzE5KVxuICAgICAgaWYgKG4gPT09IHIgLSAxKVxuICAgICAgICBvLnB1c2goNjU1MzMpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBjID0gdC5jaGFyQ29kZUF0KG4gKyAxKTtcbiAgICAgICAgaWYgKDU2MzIwIDw9IGMgJiYgYyA8PSA1NzM0Mykge1xuICAgICAgICAgIHZhciBmID0gaSAmIDEwMjMsIHYgPSBjICYgMTAyMztcbiAgICAgICAgICBvLnB1c2goNjU1MzYgKyAoZiA8PCAxMCkgKyB2KSwgbiArPSAxO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBvLnB1c2goNjU1MzMpO1xuICAgICAgfVxuICAgIG4gKz0gMTtcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIG5kKHQpIHtcbiAgZm9yICh2YXIgZSA9IFwiXCIsIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikge1xuICAgIHZhciBuID0gdFtyXTtcbiAgICBuIDw9IDY1NTM1ID8gZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pIDogKG4gLT0gNjU1MzYsIGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgIChuID4+IDEwKSArIDU1Mjk2LFxuICAgICAgKG4gJiAxMDIzKSArIDU2MzIwXG4gICAgKSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG52YXIgZ3MgPSAtMTtcbmZ1bmN0aW9uIGNhKHQpIHtcbiAgdGhpcy50b2tlbnMgPSBbXS5zbGljZS5jYWxsKHQpO1xufVxuY2EucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBlbmQtb2Ytc3RyZWFtIGhhcyBiZWVuIGhpdC5cbiAgICovXG4gIGVuZE9mU3RyZWFtOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMudG9rZW5zLmxlbmd0aDtcbiAgfSxcbiAgLyoqXG4gICAqIFdoZW4gYSB0b2tlbiBpcyByZWFkIGZyb20gYSBzdHJlYW0sIHRoZSBmaXJzdCB0b2tlbiBpbiB0aGVcbiAgICogc3RyZWFtIG11c3QgYmUgcmV0dXJuZWQgYW5kIHN1YnNlcXVlbnRseSByZW1vdmVkLCBhbmRcbiAgICogZW5kLW9mLXN0cmVhbSBtdXN0IGJlIHJldHVybmVkIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBHZXQgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgc3RyZWFtLCBvclxuICAgKiBlbmRfb2Zfc3RyZWFtLlxuICAgKi9cbiAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zLmxlbmd0aCA/IHRoaXMudG9rZW5zLnNoaWZ0KCkgOiBncztcbiAgfSxcbiAgLyoqXG4gICAqIFdoZW4gb25lIG9yIG1vcmUgdG9rZW5zIGFyZSBwcmVwZW5kZWQgdG8gYSBzdHJlYW0sIHRob3NlIHRva2Vuc1xuICAgKiBtdXN0IGJlIGluc2VydGVkLCBpbiBnaXZlbiBvcmRlciwgYmVmb3JlIHRoZSBmaXJzdCB0b2tlbiBpbiB0aGVcbiAgICogc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gdG9rZW4gVGhlIHRva2VuKHMpIHRvIHByZXBlbmQgdG8gdGhlIHN0cmVhbS5cbiAgICovXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSlcbiAgICAgIGZvciAodmFyIGUgPSAoXG4gICAgICAgIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki9cbiAgICAgICAgdFxuICAgICAgKTsgZS5sZW5ndGg7IClcbiAgICAgICAgdGhpcy50b2tlbnMudW5zaGlmdChlLnBvcCgpKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnRva2Vucy51bnNoaWZ0KHQpO1xuICB9LFxuICAvKipcbiAgICogV2hlbiBvbmUgb3IgbW9yZSB0b2tlbnMgYXJlIHB1c2hlZCB0byBhIHN0cmVhbSwgdGhvc2UgdG9rZW5zXG4gICAqIG11c3QgYmUgaW5zZXJ0ZWQsIGluIGdpdmVuIG9yZGVyLCBhZnRlciB0aGUgbGFzdCB0b2tlbiBpbiB0aGVcbiAgICogc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gdG9rZW4gVGhlIHRva2VucyhzKSB0byBwcmVwZW5kIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICBwdXNoOiBmdW5jdGlvbih0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodCkpXG4gICAgICBmb3IgKHZhciBlID0gKFxuICAgICAgICAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovXG4gICAgICAgIHRcbiAgICAgICk7IGUubGVuZ3RoOyApXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goZS5zaGlmdCgpKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHQpO1xuICB9XG59O1xudmFyIFVuID0gLTE7XG5mdW5jdGlvbiBzbyh0LCBlKSB7XG4gIGlmICh0KVxuICAgIHRocm93IFR5cGVFcnJvcihcIkRlY29kZXIgZXJyb3JcIik7XG4gIHJldHVybiBlIHx8IDY1NTMzO1xufVxudmFyIHlzID0gXCJ1dGYtOFwiO1xuZnVuY3Rpb24gdnModCwgZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgdnMpKVxuICAgIHJldHVybiBuZXcgdnModCwgZSk7XG4gIGlmICh0ID0gdCAhPT0gdm9pZCAwID8gU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCkgOiB5cywgdCAhPT0geXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jb2Rpbmcgbm90IHN1cHBvcnRlZC4gT25seSB1dGYtOCBpcyBzdXBwb3J0ZWRcIik7XG4gIGUgPSBVcyhlKSwgdGhpcy5fc3RyZWFtaW5nID0gITEsIHRoaXMuX0JPTXNlZW4gPSAhMSwgdGhpcy5fZGVjb2RlciA9IG51bGwsIHRoaXMuX2ZhdGFsID0gISFlLmZhdGFsLCB0aGlzLl9pZ25vcmVCT00gPSAhIWUuaWdub3JlQk9NLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmNvZGluZ1wiLCB7IHZhbHVlOiBcInV0Zi04XCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZhdGFsXCIsIHsgdmFsdWU6IHRoaXMuX2ZhdGFsIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVCT01cIiwgeyB2YWx1ZTogdGhpcy5faWdub3JlQk9NIH0pO1xufVxudnMucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXc9fSBpbnB1dCBUaGUgYnVmZmVyIG9mIGJ5dGVzIHRvIGRlY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICAgKi9cbiAgZGVjb2RlOiBmdW5jdGlvbihlLCByKSB7XG4gICAgdmFyIG47XG4gICAgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuID0gbmV3IFVpbnQ4QXJyYXkoZSkgOiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIFwiYnVmZmVyXCIgaW4gZSAmJiBlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbiA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgZS5idWZmZXIsXG4gICAgICBlLmJ5dGVPZmZzZXQsXG4gICAgICBlLmJ5dGVMZW5ndGhcbiAgICApIDogbiA9IG5ldyBVaW50OEFycmF5KDApLCByID0gVXMociksIHRoaXMuX3N0cmVhbWluZyB8fCAodGhpcy5fZGVjb2RlciA9IG5ldyBpZCh7IGZhdGFsOiB0aGlzLl9mYXRhbCB9KSwgdGhpcy5fQk9Nc2VlbiA9ICExKSwgdGhpcy5fc3RyZWFtaW5nID0gISFyLnN0cmVhbTtcbiAgICBmb3IgKHZhciBvID0gbmV3IGNhKG4pLCBpID0gW10sIGM7ICFvLmVuZE9mU3RyZWFtKCkgJiYgKGMgPSB0aGlzLl9kZWNvZGVyLmhhbmRsZXIobywgby5yZWFkKCkpLCBjICE9PSBVbik7IClcbiAgICAgIGMgIT09IG51bGwgJiYgKEFycmF5LmlzQXJyYXkoYykgPyBpLnB1c2guYXBwbHkoXG4gICAgICAgIGksXG4gICAgICAgIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki9cbiAgICAgICAgY1xuICAgICAgKSA6IGkucHVzaChjKSk7XG4gICAgaWYgKCF0aGlzLl9zdHJlYW1pbmcpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGMgPSB0aGlzLl9kZWNvZGVyLmhhbmRsZXIobywgby5yZWFkKCkpLCBjID09PSBVbilcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgYyAhPT0gbnVsbCAmJiAoQXJyYXkuaXNBcnJheShjKSA/IGkucHVzaC5hcHBseShcbiAgICAgICAgICBpLFxuICAgICAgICAgIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki9cbiAgICAgICAgICBjXG4gICAgICAgICkgOiBpLnB1c2goYykpO1xuICAgICAgfSB3aGlsZSAoIW8uZW5kT2ZTdHJlYW0oKSk7XG4gICAgICB0aGlzLl9kZWNvZGVyID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGkubGVuZ3RoICYmIFtcInV0Zi04XCJdLmluZGV4T2YodGhpcy5lbmNvZGluZykgIT09IC0xICYmICF0aGlzLl9pZ25vcmVCT00gJiYgIXRoaXMuX0JPTXNlZW4gJiYgKGlbMF0gPT09IDY1Mjc5ID8gKHRoaXMuX0JPTXNlZW4gPSAhMCwgaS5zaGlmdCgpKSA6IHRoaXMuX0JPTXNlZW4gPSAhMCksIG5kKGkpO1xuICB9XG59O1xuZnVuY3Rpb24gd3ModCwgZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2Ygd3MpKVxuICAgIHJldHVybiBuZXcgd3ModCwgZSk7XG4gIGlmICh0ID0gdCAhPT0gdm9pZCAwID8gU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCkgOiB5cywgdCAhPT0geXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jb2Rpbmcgbm90IHN1cHBvcnRlZC4gT25seSB1dGYtOCBpcyBzdXBwb3J0ZWRcIik7XG4gIGUgPSBVcyhlKSwgdGhpcy5fc3RyZWFtaW5nID0gITEsIHRoaXMuX2VuY29kZXIgPSBudWxsLCB0aGlzLl9vcHRpb25zID0geyBmYXRhbDogISFlLmZhdGFsIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kaW5nXCIsIHsgdmFsdWU6IFwidXRmLThcIiB9KTtcbn1cbndzLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3N0cmluZyBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IEVuY29kZWQgYnl0ZXMsIGFzIGEgVWludDhBcnJheS5cbiAgICovXG4gIGVuY29kZTogZnVuY3Rpb24oZSwgcikge1xuICAgIGUgPSBlID8gU3RyaW5nKGUpIDogXCJcIiwgciA9IFVzKHIpLCB0aGlzLl9zdHJlYW1pbmcgfHwgKHRoaXMuX2VuY29kZXIgPSBuZXcgc2QodGhpcy5fb3B0aW9ucykpLCB0aGlzLl9zdHJlYW1pbmcgPSAhIXIuc3RyZWFtO1xuICAgIGZvciAodmFyIG4gPSBbXSwgbyA9IG5ldyBjYShyZChlKSksIGk7ICFvLmVuZE9mU3RyZWFtKCkgJiYgKGkgPSB0aGlzLl9lbmNvZGVyLmhhbmRsZXIobywgby5yZWFkKCkpLCBpICE9PSBVbik7IClcbiAgICAgIEFycmF5LmlzQXJyYXkoaSkgPyBuLnB1c2guYXBwbHkoXG4gICAgICAgIG4sXG4gICAgICAgIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki9cbiAgICAgICAgaVxuICAgICAgKSA6IG4ucHVzaChpKTtcbiAgICBpZiAoIXRoaXMuX3N0cmVhbWluZykge1xuICAgICAgZm9yICg7IGkgPSB0aGlzLl9lbmNvZGVyLmhhbmRsZXIobywgby5yZWFkKCkpLCBpICE9PSBVbjsgKVxuICAgICAgICBBcnJheS5pc0FycmF5KGkpID8gbi5wdXNoLmFwcGx5KFxuICAgICAgICAgIG4sXG4gICAgICAgICAgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qL1xuICAgICAgICAgIGlcbiAgICAgICAgKSA6IG4ucHVzaChpKTtcbiAgICAgIHRoaXMuX2VuY29kZXIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobik7XG4gIH1cbn07XG5mdW5jdGlvbiBpZCh0KSB7XG4gIHZhciBlID0gdC5mYXRhbCwgciA9IDAsIG4gPSAwLCBvID0gMCwgaSA9IDEyOCwgYyA9IDE5MTtcbiAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oZiwgdikge1xuICAgIGlmICh2ID09PSBncyAmJiBvICE9PSAwKVxuICAgICAgcmV0dXJuIG8gPSAwLCBzbyhlKTtcbiAgICBpZiAodiA9PT0gZ3MpXG4gICAgICByZXR1cm4gVW47XG4gICAgaWYgKG8gPT09IDApIHtcbiAgICAgIGlmIChncih2LCAwLCAxMjcpKVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIGlmIChncih2LCAxOTQsIDIyMykpXG4gICAgICAgIG8gPSAxLCByID0gdiAtIDE5MjtcbiAgICAgIGVsc2UgaWYgKGdyKHYsIDIyNCwgMjM5KSlcbiAgICAgICAgdiA9PT0gMjI0ICYmIChpID0gMTYwKSwgdiA9PT0gMjM3ICYmIChjID0gMTU5KSwgbyA9IDIsIHIgPSB2IC0gMjI0O1xuICAgICAgZWxzZSBpZiAoZ3IodiwgMjQwLCAyNDQpKVxuICAgICAgICB2ID09PSAyNDAgJiYgKGkgPSAxNDQpLCB2ID09PSAyNDQgJiYgKGMgPSAxNDMpLCBvID0gMywgciA9IHYgLSAyNDA7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBzbyhlKTtcbiAgICAgIHJldHVybiByID0gciA8PCA2ICogbywgbnVsbDtcbiAgICB9XG4gICAgaWYgKCFncih2LCBpLCBjKSlcbiAgICAgIHJldHVybiByID0gbyA9IG4gPSAwLCBpID0gMTI4LCBjID0gMTkxLCBmLnByZXBlbmQodiksIHNvKGUpO1xuICAgIGlmIChpID0gMTI4LCBjID0gMTkxLCBuICs9IDEsIHIgKz0gdiAtIDEyOCA8PCA2ICogKG8gLSBuKSwgbiAhPT0gbylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciB4ID0gcjtcbiAgICByZXR1cm4gciA9IG8gPSBuID0gMCwgeDtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNkKHQpIHtcbiAgdC5mYXRhbCwgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oZSwgcikge1xuICAgIGlmIChyID09PSBncylcbiAgICAgIHJldHVybiBVbjtcbiAgICBpZiAoZ3IociwgMCwgMTI3KSlcbiAgICAgIHJldHVybiByO1xuICAgIHZhciBuLCBvO1xuICAgIGdyKHIsIDEyOCwgMjA0NykgPyAobiA9IDEsIG8gPSAxOTIpIDogZ3IociwgMjA0OCwgNjU1MzUpID8gKG4gPSAyLCBvID0gMjI0KSA6IGdyKHIsIDY1NTM2LCAxMTE0MTExKSAmJiAobiA9IDMsIG8gPSAyNDApO1xuICAgIGZvciAodmFyIGkgPSBbKHIgPj4gNiAqIG4pICsgb107IG4gPiAwOyApIHtcbiAgICAgIHZhciBjID0gciA+PiA2ICogKG4gLSAxKTtcbiAgICAgIGkucHVzaCgxMjggfCBjICYgNjMpLCBuIC09IDE7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xufVxuY29uc3Qgb2QgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBUZXh0RGVjb2RlcjogdnMsXG4gIFRleHRFbmNvZGVyOiB3c1xufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgYWQgPSAvKiBAX19QVVJFX18gKi8gZWEob2QpO1xudmFyIHJ1O1xuZnVuY3Rpb24gdWQoKSB7XG4gIGlmIChydSkgcmV0dXJuIHN0O1xuICBydSA9IDE7XG4gIHZhciB0ID0gc3QgJiYgc3QuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24oTiwgTywgTCwgRikge1xuICAgIEYgPT09IHZvaWQgMCAmJiAoRiA9IEwpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTiwgRiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBPW0xdO1xuICAgIH0gfSk7XG4gIH0gOiBmdW5jdGlvbihOLCBPLCBMLCBGKSB7XG4gICAgRiA9PT0gdm9pZCAwICYmIChGID0gTCksIE5bRl0gPSBPW0xdO1xuICB9KSwgZSA9IHN0ICYmIHN0Ll9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uKE4sIE8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTiwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBPIH0pO1xuICB9IDogZnVuY3Rpb24oTiwgTykge1xuICAgIE4uZGVmYXVsdCA9IE87XG4gIH0pLCByID0gc3QgJiYgc3QuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihOLCBPLCBMLCBGKSB7XG4gICAgdmFyIGQgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gZCA8IDMgPyBPIDogRiA9PT0gbnVsbCA/IEYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEwpIDogRiwgdTtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PSBcImZ1bmN0aW9uXCIpIHMgPSBSZWZsZWN0LmRlY29yYXRlKE4sIE8sIEwsIEYpO1xuICAgIGVsc2UgZm9yICh2YXIgaCA9IE4ubGVuZ3RoIC0gMTsgaCA+PSAwOyBoLS0pICh1ID0gTltoXSkgJiYgKHMgPSAoZCA8IDMgPyB1KHMpIDogZCA+IDMgPyB1KE8sIEwsIHMpIDogdShPLCBMKSkgfHwgcyk7XG4gICAgcmV0dXJuIGQgPiAzICYmIHMgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIEwsIHMpLCBzO1xuICB9LCBuID0gc3QgJiYgc3QuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uKE4pIHtcbiAgICBpZiAoTiAmJiBOLl9fZXNNb2R1bGUpIHJldHVybiBOO1xuICAgIHZhciBPID0ge307XG4gICAgaWYgKE4gIT0gbnVsbCkgZm9yICh2YXIgTCBpbiBOKSBMICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChOLCBMKSAmJiB0KE8sIE4sIEwpO1xuICAgIHJldHVybiBlKE8sIE4pLCBPO1xuICB9LCBvID0gc3QgJiYgc3QuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKE4pIHtcbiAgICByZXR1cm4gTiAmJiBOLl9fZXNNb2R1bGUgPyBOIDogeyBkZWZhdWx0OiBOIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBzdC5kZXNlcmlhbGl6ZVVuY2hlY2tlZCA9IHN0LmRlc2VyaWFsaXplID0gc3Quc2VyaWFsaXplID0gc3QuQmluYXJ5UmVhZGVyID0gc3QuQmluYXJ5V3JpdGVyID0gc3QuQm9yc2hFcnJvciA9IHN0LmJhc2VEZWNvZGUgPSBzdC5iYXNlRW5jb2RlID0gdm9pZCAwO1xuICBjb25zdCBpID0gbyhRaCgpKSwgYyA9IG8odGQoKSksIGYgPSBuKGFkKSwgdiA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSBcImZ1bmN0aW9uXCIgPyBmLlRleHREZWNvZGVyIDogVGV4dERlY29kZXIsIHggPSBuZXcgdihcInV0Zi04XCIsIHsgZmF0YWw6ICEwIH0pO1xuICBmdW5jdGlvbiBiKE4pIHtcbiAgICByZXR1cm4gdHlwZW9mIE4gPT0gXCJzdHJpbmdcIiAmJiAoTiA9IEJ1ZmZlci5mcm9tKE4sIFwidXRmOFwiKSksIGMuZGVmYXVsdC5lbmNvZGUoQnVmZmVyLmZyb20oTikpO1xuICB9XG4gIHN0LmJhc2VFbmNvZGUgPSBiO1xuICBmdW5jdGlvbiBTKE4pIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYy5kZWZhdWx0LmRlY29kZShOKSk7XG4gIH1cbiAgc3QuYmFzZURlY29kZSA9IFM7XG4gIGNvbnN0IFQgPSAxMDI0O1xuICBjbGFzcyBDIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKE8pIHtcbiAgICAgIHN1cGVyKE8pLCB0aGlzLmZpZWxkUGF0aCA9IFtdLCB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IE87XG4gICAgfVxuICAgIGFkZFRvRmllbGRQYXRoKE8pIHtcbiAgICAgIHRoaXMuZmllbGRQYXRoLnNwbGljZSgwLCAwLCBPKSwgdGhpcy5tZXNzYWdlID0gdGhpcy5vcmlnaW5hbE1lc3NhZ2UgKyBcIjogXCIgKyB0aGlzLmZpZWxkUGF0aC5qb2luKFwiLlwiKTtcbiAgICB9XG4gIH1cbiAgc3QuQm9yc2hFcnJvciA9IEM7XG4gIGNsYXNzIFAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2MoVCksIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgbWF5YmVSZXNpemUoKSB7XG4gICAgICB0aGlzLmJ1Zi5sZW5ndGggPCAxNiArIHRoaXMubGVuZ3RoICYmICh0aGlzLmJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmLCBCdWZmZXIuYWxsb2MoVCldKSk7XG4gICAgfVxuICAgIHdyaXRlVTgoTykge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpLCB0aGlzLmJ1Zi53cml0ZVVJbnQ4KE8sIHRoaXMubGVuZ3RoKSwgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9XG4gICAgd3JpdGVVMTYoTykge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpLCB0aGlzLmJ1Zi53cml0ZVVJbnQxNkxFKE8sIHRoaXMubGVuZ3RoKSwgdGhpcy5sZW5ndGggKz0gMjtcbiAgICB9XG4gICAgd3JpdGVVMzIoTykge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpLCB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKE8sIHRoaXMubGVuZ3RoKSwgdGhpcy5sZW5ndGggKz0gNDtcbiAgICB9XG4gICAgd3JpdGVVNjQoTykge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpLCB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBpLmRlZmF1bHQoTykudG9BcnJheShcImxlXCIsIDgpKSk7XG4gICAgfVxuICAgIHdyaXRlVTEyOChPKSB7XG4gICAgICB0aGlzLm1heWJlUmVzaXplKCksIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGkuZGVmYXVsdChPKS50b0FycmF5KFwibGVcIiwgMTYpKSk7XG4gICAgfVxuICAgIHdyaXRlVTI1NihPKSB7XG4gICAgICB0aGlzLm1heWJlUmVzaXplKCksIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGkuZGVmYXVsdChPKS50b0FycmF5KFwibGVcIiwgMzIpKSk7XG4gICAgfVxuICAgIHdyaXRlVTUxMihPKSB7XG4gICAgICB0aGlzLm1heWJlUmVzaXplKCksIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGkuZGVmYXVsdChPKS50b0FycmF5KFwibGVcIiwgNjQpKSk7XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyKE8pIHtcbiAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIEJ1ZmZlci5mcm9tKHRoaXMuYnVmLnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKSksXG4gICAgICAgIE8sXG4gICAgICAgIEJ1ZmZlci5hbGxvYyhUKVxuICAgICAgXSksIHRoaXMubGVuZ3RoICs9IE8ubGVuZ3RoO1xuICAgIH1cbiAgICB3cml0ZVN0cmluZyhPKSB7XG4gICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICBjb25zdCBMID0gQnVmZmVyLmZyb20oTywgXCJ1dGY4XCIpO1xuICAgICAgdGhpcy53cml0ZVUzMihMLmxlbmd0aCksIHRoaXMud3JpdGVCdWZmZXIoTCk7XG4gICAgfVxuICAgIHdyaXRlRml4ZWRBcnJheShPKSB7XG4gICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKE8pKTtcbiAgICB9XG4gICAgd3JpdGVBcnJheShPLCBMKSB7XG4gICAgICB0aGlzLm1heWJlUmVzaXplKCksIHRoaXMud3JpdGVVMzIoTy5sZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBGIG9mIE8pXG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKSwgTChGKTtcbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHN0LkJpbmFyeVdyaXRlciA9IFA7XG4gIGZ1bmN0aW9uIEIoTiwgTywgTCkge1xuICAgIGNvbnN0IEYgPSBMLnZhbHVlO1xuICAgIEwudmFsdWUgPSBmdW5jdGlvbiguLi5kKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gRi5hcHBseSh0aGlzLCBkKTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgY29uc3QgdSA9IHMuY29kZTtcbiAgICAgICAgICBpZiAoW1wiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTXCIsIFwiRVJSX09VVF9PRl9SQU5HRVwiXS5pbmRleE9mKHUpID49IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgQyhcIlJlYWNoZWQgdGhlIGVuZCBvZiBidWZmZXIgd2hlbiBkZXNlcmlhbGl6aW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjbGFzcyBSIHtcbiAgICBjb25zdHJ1Y3RvcihPKSB7XG4gICAgICB0aGlzLmJ1ZiA9IE8sIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmVhZFU4KCkge1xuICAgICAgY29uc3QgTyA9IHRoaXMuYnVmLnJlYWRVSW50OCh0aGlzLm9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgKz0gMSwgTztcbiAgICB9XG4gICAgcmVhZFUxNigpIHtcbiAgICAgIGNvbnN0IE8gPSB0aGlzLmJ1Zi5yZWFkVUludDE2TEUodGhpcy5vZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICs9IDIsIE87XG4gICAgfVxuICAgIHJlYWRVMzIoKSB7XG4gICAgICBjb25zdCBPID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMub2Zmc2V0KTtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldCArPSA0LCBPO1xuICAgIH1cbiAgICByZWFkVTY0KCkge1xuICAgICAgY29uc3QgTyA9IHRoaXMucmVhZEJ1ZmZlcig4KTtcbiAgICAgIHJldHVybiBuZXcgaS5kZWZhdWx0KE8sIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRVMTI4KCkge1xuICAgICAgY29uc3QgTyA9IHRoaXMucmVhZEJ1ZmZlcigxNik7XG4gICAgICByZXR1cm4gbmV3IGkuZGVmYXVsdChPLCBcImxlXCIpO1xuICAgIH1cbiAgICByZWFkVTI1NigpIHtcbiAgICAgIGNvbnN0IE8gPSB0aGlzLnJlYWRCdWZmZXIoMzIpO1xuICAgICAgcmV0dXJuIG5ldyBpLmRlZmF1bHQoTywgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFU1MTIoKSB7XG4gICAgICBjb25zdCBPID0gdGhpcy5yZWFkQnVmZmVyKDY0KTtcbiAgICAgIHJldHVybiBuZXcgaS5kZWZhdWx0KE8sIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRCdWZmZXIoTykge1xuICAgICAgaWYgKHRoaXMub2Zmc2V0ICsgTyA+IHRoaXMuYnVmLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEMoYEV4cGVjdGVkIGJ1ZmZlciBsZW5ndGggJHtPfSBpc24ndCB3aXRoaW4gYm91bmRzYCk7XG4gICAgICBjb25zdCBMID0gdGhpcy5idWYuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgTyk7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgKz0gTywgTDtcbiAgICB9XG4gICAgcmVhZFN0cmluZygpIHtcbiAgICAgIGNvbnN0IE8gPSB0aGlzLnJlYWRVMzIoKSwgTCA9IHRoaXMucmVhZEJ1ZmZlcihPKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB4LmRlY29kZShMKTtcbiAgICAgIH0gY2F0Y2ggKEYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEMoYEVycm9yIGRlY29kaW5nIFVURi04IHN0cmluZzogJHtGfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZWFkRml4ZWRBcnJheShPKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5yZWFkQnVmZmVyKE8pKTtcbiAgICB9XG4gICAgcmVhZEFycmF5KE8pIHtcbiAgICAgIGNvbnN0IEwgPSB0aGlzLnJlYWRVMzIoKSwgRiA9IEFycmF5KCk7XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IEw7ICsrZClcbiAgICAgICAgRi5wdXNoKE8oKSk7XG4gICAgICByZXR1cm4gRjtcbiAgICB9XG4gIH1cbiAgcihbXG4gICAgQlxuICBdLCBSLnByb3RvdHlwZSwgXCJyZWFkVThcIiwgbnVsbCksIHIoW1xuICAgIEJcbiAgXSwgUi5wcm90b3R5cGUsIFwicmVhZFUxNlwiLCBudWxsKSwgcihbXG4gICAgQlxuICBdLCBSLnByb3RvdHlwZSwgXCJyZWFkVTMyXCIsIG51bGwpLCByKFtcbiAgICBCXG4gIF0sIFIucHJvdG90eXBlLCBcInJlYWRVNjRcIiwgbnVsbCksIHIoW1xuICAgIEJcbiAgXSwgUi5wcm90b3R5cGUsIFwicmVhZFUxMjhcIiwgbnVsbCksIHIoW1xuICAgIEJcbiAgXSwgUi5wcm90b3R5cGUsIFwicmVhZFUyNTZcIiwgbnVsbCksIHIoW1xuICAgIEJcbiAgXSwgUi5wcm90b3R5cGUsIFwicmVhZFU1MTJcIiwgbnVsbCksIHIoW1xuICAgIEJcbiAgXSwgUi5wcm90b3R5cGUsIFwicmVhZFN0cmluZ1wiLCBudWxsKSwgcihbXG4gICAgQlxuICBdLCBSLnByb3RvdHlwZSwgXCJyZWFkRml4ZWRBcnJheVwiLCBudWxsKSwgcihbXG4gICAgQlxuICBdLCBSLnByb3RvdHlwZSwgXCJyZWFkQXJyYXlcIiwgbnVsbCksIHN0LkJpbmFyeVJlYWRlciA9IFI7XG4gIGZ1bmN0aW9uIHooTikge1xuICAgIHJldHVybiBOLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgTi5zbGljZSgxKTtcbiAgfVxuICBmdW5jdGlvbiBLKE4sIE8sIEwsIEYsIGQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBGID09IFwic3RyaW5nXCIpXG4gICAgICAgIGRbYHdyaXRlJHt6KEYpfWBdKEwpO1xuICAgICAgZWxzZSBpZiAoRiBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICBpZiAodHlwZW9mIEZbMF0gPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGlmIChMLmxlbmd0aCAhPT0gRlswXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBDKGBFeHBlY3RpbmcgYnl0ZSBhcnJheSBvZiBsZW5ndGggJHtGWzBdfSwgYnV0IGdvdCAke0wubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgIGQud3JpdGVGaXhlZEFycmF5KEwpO1xuICAgICAgICB9IGVsc2UgaWYgKEYubGVuZ3RoID09PSAyICYmIHR5cGVvZiBGWzFdID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAoTC5sZW5ndGggIT09IEZbMV0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgQyhgRXhwZWN0aW5nIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoICR7RlsxXX0sIGJ1dCBnb3QgJHtMLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IEZbMV07IHMrKylcbiAgICAgICAgICAgIEsoTiwgbnVsbCwgTFtzXSwgRlswXSwgZCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGQud3JpdGVBcnJheShMLCAocykgPT4ge1xuICAgICAgICAgICAgSyhOLCBPLCBzLCBGWzBdLCBkKTtcbiAgICAgICAgICB9KTtcbiAgICAgIGVsc2UgaWYgKEYua2luZCAhPT0gdm9pZCAwKVxuICAgICAgICBzd2l0Y2ggKEYua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjoge1xuICAgICAgICAgICAgTCA9PSBudWxsID8gZC53cml0ZVU4KDApIDogKGQud3JpdGVVOCgxKSwgSyhOLCBPLCBMLCBGLnR5cGUsIGQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibWFwXCI6IHtcbiAgICAgICAgICAgIGQud3JpdGVVMzIoTC5zaXplKSwgTC5mb3JFYWNoKChzLCB1KSA9PiB7XG4gICAgICAgICAgICAgIEsoTiwgTywgdSwgRi5rZXksIGQpLCBLKE4sIE8sIHMsIEYudmFsdWUsIGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBDKGBGaWVsZFR5cGUgJHtGfSB1bnJlY29nbml6ZWRgKTtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBaKE4sIEwsIGQpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIHRocm93IHMgaW5zdGFuY2VvZiBDICYmIHMuYWRkVG9GaWVsZFBhdGgoTyksIHM7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFooTiwgTywgTCkge1xuICAgIGlmICh0eXBlb2YgTy5ib3JzaFNlcmlhbGl6ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIE8uYm9yc2hTZXJpYWxpemUoTCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IEYgPSBOLmdldChPLmNvbnN0cnVjdG9yKTtcbiAgICBpZiAoIUYpXG4gICAgICB0aHJvdyBuZXcgQyhgQ2xhc3MgJHtPLmNvbnN0cnVjdG9yLm5hbWV9IGlzIG1pc3NpbmcgaW4gc2NoZW1hYCk7XG4gICAgaWYgKEYua2luZCA9PT0gXCJzdHJ1Y3RcIilcbiAgICAgIEYuZmllbGRzLm1hcCgoW2QsIHNdKSA9PiB7XG4gICAgICAgIEsoTiwgZCwgT1tkXSwgcywgTCk7XG4gICAgICB9KTtcbiAgICBlbHNlIGlmIChGLmtpbmQgPT09IFwiZW51bVwiKSB7XG4gICAgICBjb25zdCBkID0gT1tGLmZpZWxkXTtcbiAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgRi52YWx1ZXMubGVuZ3RoOyArK3MpIHtcbiAgICAgICAgY29uc3QgW3UsIGhdID0gRi52YWx1ZXNbc107XG4gICAgICAgIGlmICh1ID09PSBkKSB7XG4gICAgICAgICAgTC53cml0ZVU4KHMpLCBLKE4sIHUsIE9bdV0sIGgsIEwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBuZXcgQyhgVW5leHBlY3RlZCBzY2hlbWEga2luZDogJHtGLmtpbmR9IGZvciAke08uY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuICBmdW5jdGlvbiBRKE4sIE8sIEwgPSBQKSB7XG4gICAgY29uc3QgRiA9IG5ldyBMKCk7XG4gICAgcmV0dXJuIFooTiwgTywgRiksIEYudG9BcnJheSgpO1xuICB9XG4gIHN0LnNlcmlhbGl6ZSA9IFE7XG4gIGZ1bmN0aW9uIGooTiwgTywgTCwgRikge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIEwgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIEZbYHJlYWQke3ooTCl9YF0oKTtcbiAgICAgIGlmIChMIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBMWzBdID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuIEYucmVhZEZpeGVkQXJyYXkoTFswXSk7XG4gICAgICAgIGlmICh0eXBlb2YgTFsxXSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc3QgZCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgTFsxXTsgcysrKVxuICAgICAgICAgICAgZC5wdXNoKGooTiwgbnVsbCwgTFswXSwgRikpO1xuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByZXR1cm4gRi5yZWFkQXJyYXkoKCkgPT4gaihOLCBPLCBMWzBdLCBGKSk7XG4gICAgICB9XG4gICAgICBpZiAoTC5raW5kID09PSBcIm9wdGlvblwiKVxuICAgICAgICByZXR1cm4gRi5yZWFkVTgoKSA/IGooTiwgTywgTC50eXBlLCBGKSA6IHZvaWQgMDtcbiAgICAgIGlmIChMLmtpbmQgPT09IFwibWFwXCIpIHtcbiAgICAgICAgbGV0IGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBzID0gRi5yZWFkVTMyKCk7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgczsgdSsrKSB7XG4gICAgICAgICAgY29uc3QgaCA9IGooTiwgTywgTC5rZXksIEYpLCBnID0gaihOLCBPLCBMLnZhbHVlLCBGKTtcbiAgICAgICAgICBkLnNldChoLCBnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBWKE4sIEwsIEYpO1xuICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgIHRocm93IGQgaW5zdGFuY2VvZiBDICYmIGQuYWRkVG9GaWVsZFBhdGgoTyksIGQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFYoTiwgTywgTCkge1xuICAgIGlmICh0eXBlb2YgTy5ib3JzaERlc2VyaWFsaXplID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiBPLmJvcnNoRGVzZXJpYWxpemUoTCk7XG4gICAgY29uc3QgRiA9IE4uZ2V0KE8pO1xuICAgIGlmICghRilcbiAgICAgIHRocm93IG5ldyBDKGBDbGFzcyAke08ubmFtZX0gaXMgbWlzc2luZyBpbiBzY2hlbWFgKTtcbiAgICBpZiAoRi5raW5kID09PSBcInN0cnVjdFwiKSB7XG4gICAgICBjb25zdCBkID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtzLCB1XSBvZiBOLmdldChPKS5maWVsZHMpXG4gICAgICAgIGRbc10gPSBqKE4sIHMsIHUsIEwpO1xuICAgICAgcmV0dXJuIG5ldyBPKGQpO1xuICAgIH1cbiAgICBpZiAoRi5raW5kID09PSBcImVudW1cIikge1xuICAgICAgY29uc3QgZCA9IEwucmVhZFU4KCk7XG4gICAgICBpZiAoZCA+PSBGLnZhbHVlcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBDKGBFbnVtIGluZGV4OiAke2R9IGlzIG91dCBvZiByYW5nZWApO1xuICAgICAgY29uc3QgW3MsIHVdID0gRi52YWx1ZXNbZF0sIGggPSBqKE4sIHMsIHUsIEwpO1xuICAgICAgcmV0dXJuIG5ldyBPKHsgW3NdOiBoIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQyhgVW5leHBlY3RlZCBzY2hlbWEga2luZDogJHtGLmtpbmR9IGZvciAke08uY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuICBmdW5jdGlvbiBlZShOLCBPLCBMLCBGID0gUikge1xuICAgIGNvbnN0IGQgPSBuZXcgRihMKSwgcyA9IFYoTiwgTywgZCk7XG4gICAgaWYgKGQub2Zmc2V0IDwgTC5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgQyhgVW5leHBlY3RlZCAke0wubGVuZ3RoIC0gZC5vZmZzZXR9IGJ5dGVzIGFmdGVyIGRlc2VyaWFsaXplZCBkYXRhYCk7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgc3QuZGVzZXJpYWxpemUgPSBlZTtcbiAgZnVuY3Rpb24gRyhOLCBPLCBMLCBGID0gUikge1xuICAgIGNvbnN0IGQgPSBuZXcgRihMKTtcbiAgICByZXR1cm4gVihOLCBPLCBkKTtcbiAgfVxuICByZXR1cm4gc3QuZGVzZXJpYWxpemVVbmNoZWNrZWQgPSBHLCBzdDtcbn1cbnZhciBvbyA9IHVkKCksIFkgPSB7fSwgbnU7XG5mdW5jdGlvbiBjZCgpIHtcbiAgaWYgKG51KSByZXR1cm4gWTtcbiAgbnUgPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoWSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBZLnMxNiA9IFkuczggPSBZLm51NjRiZSA9IFkudTQ4YmUgPSBZLnU0MGJlID0gWS51MzJiZSA9IFkudTI0YmUgPSBZLnUxNmJlID0gWS5udTY0ID0gWS51NDggPSBZLnU0MCA9IFkudTMyID0gWS51MjQgPSBZLnUxNiA9IFkudTggPSBZLm9mZnNldCA9IFkuZ3JlZWR5ID0gWS5Db25zdGFudCA9IFkuVVRGOCA9IFkuQ1N0cmluZyA9IFkuQmxvYiA9IFkuQm9vbGVhbiA9IFkuQml0RmllbGQgPSBZLkJpdFN0cnVjdHVyZSA9IFkuVmFyaWFudExheW91dCA9IFkuVW5pb24gPSBZLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IFkuVW5pb25EaXNjcmltaW5hdG9yID0gWS5TdHJ1Y3R1cmUgPSBZLlNlcXVlbmNlID0gWS5Eb3VibGVCRSA9IFkuRG91YmxlID0gWS5GbG9hdEJFID0gWS5GbG9hdCA9IFkuTmVhckludDY0QkUgPSBZLk5lYXJJbnQ2NCA9IFkuTmVhclVJbnQ2NEJFID0gWS5OZWFyVUludDY0ID0gWS5JbnRCRSA9IFkuSW50ID0gWS5VSW50QkUgPSBZLlVJbnQgPSBZLk9mZnNldExheW91dCA9IFkuR3JlZWR5Q291bnQgPSBZLkV4dGVybmFsTGF5b3V0ID0gWS5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSBZLm5hbWVXaXRoUHJvcGVydHkgPSBZLkxheW91dCA9IFkudWludDhBcnJheVRvQnVmZmVyID0gWS5jaGVja1VpbnQ4QXJyYXkgPSB2b2lkIDAsIFkuY29uc3RhbnQgPSBZLnV0ZjggPSBZLmNzdHIgPSBZLmJsb2IgPSBZLnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IFkudW5pb24gPSBZLnNlcSA9IFkuYml0cyA9IFkuc3RydWN0ID0gWS5mNjRiZSA9IFkuZjY0ID0gWS5mMzJiZSA9IFkuZjMyID0gWS5uczY0YmUgPSBZLnM0OGJlID0gWS5zNDBiZSA9IFkuczMyYmUgPSBZLnMyNGJlID0gWS5zMTZiZSA9IFkubnM2NCA9IFkuczQ4ID0gWS5zNDAgPSBZLnMzMiA9IFkuczI0ID0gdm9pZCAwO1xuICBjb25zdCB0ID0gbmEoKTtcbiAgZnVuY3Rpb24gZShhKSB7XG4gICAgaWYgKCEoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImIgbXVzdCBiZSBhIFVpbnQ4QXJyYXlcIik7XG4gIH1cbiAgWS5jaGVja1VpbnQ4QXJyYXkgPSBlO1xuICBmdW5jdGlvbiByKGEpIHtcbiAgICByZXR1cm4gZShhKSwgdC5CdWZmZXIuZnJvbShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmxlbmd0aCk7XG4gIH1cbiAgWS51aW50OEFycmF5VG9CdWZmZXIgPSByO1xuICBsZXQgbiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzcGFuIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgIHRoaXMuc3BhbiA9IGwsIHRoaXMucHJvcGVydHkgPSBNO1xuICAgIH1cbiAgICAvKiogRnVuY3Rpb24gdG8gY3JlYXRlIGFuIE9iamVjdCBpbnRvIHdoaWNoIGRlY29kZWQgcHJvcGVydGllcyB3aWxsXG4gICAgICogYmUgd3JpdHRlbi5cbiAgICAgKlxuICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICogaW5zdGFuY2VzLCB3aGljaCBtZWFuczpcbiAgICAgKiAqIHtAbGluayBTdHJ1Y3R1cmV9XG4gICAgICogKiB7QGxpbmsgVW5pb259XG4gICAgICogKiB7QGxpbmsgVmFyaWFudExheW91dH1cbiAgICAgKiAqIHtAbGluayBCaXRTdHJ1Y3R1cmV9XG4gICAgICpcbiAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGVzZSBsYXlvdXRzXG4gICAgICogd2lsbCBiZSBPYmplY3QgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBiaW5kQ29uc3RydWN0b3JMYXlvdXR9LlxuICAgICAqL1xuICAgIG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzcGFuIG9mIGEgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGIgLSB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMgYW4gZW5jb2RlZCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVuY29kZWQgaW5zdGFuY2VcbiAgICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvdmVyZWQgYnkgdGhlIGxheW91dFxuICAgICAqIGluc3RhbmNlLiAgSWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0aGVcbiAgICAgKiBkZWZpbml0aW9uLXRpbWUgY29uc3RhbnQge0BsaW5rIExheW91dCNzcGFufHNwYW59IHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IC0gaWYgdGhlIGxlbmd0aCBvZiB0aGUgdmFsdWUgY2Fubm90IGJlXG4gICAgICogZGV0ZXJtaW5lZC5cbiAgICAgKi9cbiAgICBnZXRTcGFuKGwsIE0pIHtcbiAgICAgIGlmICgwID4gdGhpcy5zcGFuKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluZGV0ZXJtaW5hdGUgc3BhblwiKTtcbiAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxpY2F0ZSB0aGUgbGF5b3V0IHVzaW5nIGEgbmV3IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gZ2V0IGEgc3RydWN0dXJhbGx5LWVxdWl2YWxlbnQgbGF5b3V0XG4gICAgICogd2l0aCBhIGRpZmZlcmVudCBuYW1lIHNpbmNlIGFsbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZXMgYXJlXG4gICAgICogaW1tdXRhYmxlLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gIEFsbCBmaWVsZHMgZXhjZXB0IHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gYXJlIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBvcmlnaW4gbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHZhbHVlIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGluIHRoZSByZXBsaWNhLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0xheW91dH0gLSB0aGUgY29weSB3aXRoIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gICAgICogc2V0IHRvIGBwcm9wZXJ0eWAuXG4gICAgICovXG4gICAgcmVwbGljYXRlKGwpIHtcbiAgICAgIGNvbnN0IE0gPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE0sIHRoaXMpLCBNLnByb3BlcnR5ID0gbCwgTTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9iamVjdCBmcm9tIGxheW91dCBwcm9wZXJ0aWVzIGFuZCBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgaW52b2tlZCBvbiBhIGxheW91dFxuICAgICAqIHRoYXQgZG9lcyBub3QgcmV0dXJuIGl0cyB2YWx1ZSBhcyBhbiBPYmplY3QuICBPYmplY3RzIGFyZVxuICAgICAqIHJldHVybmVkIGZvciB0aGluZ3MgdGhhdCBhcmUgYSB7QGxpbmsgU3RydWN0dXJlfSwgd2hpY2ggaW5jbHVkZXNcbiAgICAgKiB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IGlmIHRoZXkgYXJlIHN0cnVjdHVyZXMsIGFuZFxuICAgICAqIGV4Y2x1ZGVzIHtAbGluayBVbmlvbn1zLiAgSWYgeW91IHdhbnQgdGhpcyBmZWF0dXJlIGZvciBhIHVuaW9uXG4gICAgICogeW91IG11c3QgdXNlIHtAbGluayBVbmlvbi5nZXRWYXJpYW50fGdldFZhcmlhbnR9IHRvIHNlbGVjdCB0aGVcbiAgICAgKiBkZXNpcmVkIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIGFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gICAgICogZGVmYXVsdCBvcmRlciBmb3IgcHJvcGVydGllcy4gIEFzIHdpdGgge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfVxuICAgICAqIGxheW91dCBlbGVtZW50cyB0aGF0IGhhdmUgbm8gcHJvcGVydHkgbmFtZSBhcmUgc2tpcHBlZCB3aGVuXG4gICAgICogaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IHZhbHVlcy4gIE9ubHkgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIGFzc2lnbmVkOyBhcmd1bWVudHMgYXJlIG5vdCBhc3NpZ25lZCB0byBwcm9wZXJ0aWVzIG9mIGNvbnRhaW5lZFxuICAgICAqIGxheW91dHMuICBBbnkgdW51c2VkIHZhbHVlcyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyhPYmplY3R8dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBmcm9tQXJyYXkobCkge1xuICAgIH1cbiAgfTtcbiAgWS5MYXlvdXQgPSBuO1xuICBmdW5jdGlvbiBvKGEsIGwpIHtcbiAgICByZXR1cm4gbC5wcm9wZXJ0eSA/IGEgKyBcIltcIiArIGwucHJvcGVydHkgKyBcIl1cIiA6IGE7XG4gIH1cbiAgWS5uYW1lV2l0aFByb3BlcnR5ID0gbztcbiAgZnVuY3Rpb24gaShhLCBsKSB7XG4gICAgaWYgKHR5cGVvZiBhICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBtdXN0IGJlIGNvbnN0cnVjdG9yXCIpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgXCJsYXlvdXRfXCIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xhc3MgaXMgYWxyZWFkeSBib3VuZCB0byBhIGxheW91dFwiKTtcbiAgICBpZiAoIShsICYmIGwgaW5zdGFuY2VvZiBuKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsYXlvdXQgbXVzdCBiZSBhIExheW91dFwiKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGwsIFwiYm91bmRDb25zdHJ1Y3Rvcl9cIikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsYXlvdXQgaXMgYWxyZWFkeSBib3VuZCB0byBhIGNvbnN0cnVjdG9yXCIpO1xuICAgIGEubGF5b3V0XyA9IGwsIGwuYm91bmRDb25zdHJ1Y3Rvcl8gPSBhLCBsLm1ha2VEZXN0aW5hdGlvbk9iamVjdCA9ICgpID0+IG5ldyBhKCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLnByb3RvdHlwZSwgXCJlbmNvZGVcIiwge1xuICAgICAgdmFsdWUoTSwgaykge1xuICAgICAgICByZXR1cm4gbC5lbmNvZGUodGhpcywgTSwgayk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImRlY29kZVwiLCB7XG4gICAgICB2YWx1ZShNLCBrKSB7XG4gICAgICAgIHJldHVybiBsLmRlY29kZShNLCBrKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogITBcbiAgICB9KTtcbiAgfVxuICBZLmJpbmRDb25zdHJ1Y3RvckxheW91dCA9IGk7XG4gIGNsYXNzIGMgZXh0ZW5kcyBuIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmZiB0aGUgZXh0ZXJuYWwgbGF5b3V0IGRlY29kZXMgdG8gYW4gdW5zaWduZWRcbiAgICAgKiBpbnRlZ2VyIGxheW91dC5cbiAgICAgKlxuICAgICAqIEluIHRoYXQgY2FzZSBpdCBjYW4gYmUgdXNlZCBhcyB0aGUgc291cmNlIG9mIHtAbGlua1xuICAgICAqIFNlcXVlbmNlI2NvdW50fFNlcXVlbmNlIGNvdW50c30sIHtAbGluayBCbG9iI2xlbmd0aHxCbG9iIGxlbmd0aHN9LFxuICAgICAqIG9yIGFzIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGV4dGVybmFsIHVuaW9uXG4gICAgICogZGlzY3JpbWluYXRvcnN9LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4dGVybmFsTGF5b3V0IGlzIGFic3RyYWN0XCIpO1xuICAgIH1cbiAgfVxuICBZLkV4dGVybmFsTGF5b3V0ID0gYztcbiAgY2xhc3MgZiBleHRlbmRzIGMge1xuICAgIGNvbnN0cnVjdG9yKGwgPSAxLCBNKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobCkgfHwgMCA+PSBsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZWxlbWVudFNwYW4gbXVzdCBiZSBhIChwb3NpdGl2ZSkgaW50ZWdlclwiKTtcbiAgICAgIHN1cGVyKC0xLCBNKSwgdGhpcy5lbGVtZW50U3BhbiA9IGw7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICBlKGwpO1xuICAgICAgY29uc3QgayA9IGwubGVuZ3RoIC0gTTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGsgLyB0aGlzLmVsZW1lbnRTcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgWS5HcmVlZHlDb3VudCA9IGY7XG4gIGNsYXNzIHYgZXh0ZW5kcyBjIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNID0gMCwgaykge1xuICAgICAgaWYgKCEobCBpbnN0YW5jZW9mIG4pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGF5b3V0IG11c3QgYmUgYSBMYXlvdXRcIik7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoTSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvZmZzZXQgbXVzdCBiZSBpbnRlZ2VyIG9yIHVuZGVmaW5lZFwiKTtcbiAgICAgIHN1cGVyKGwuc3BhbiwgayB8fCBsLnByb3BlcnR5KSwgdGhpcy5sYXlvdXQgPSBsLCB0aGlzLm9mZnNldCA9IE07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5b3V0IGluc3RhbmNlb2YgeCB8fCB0aGlzLmxheW91dCBpbnN0YW5jZW9mIGI7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUobCwgTSA9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUobCwgTSArIHRoaXMub2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShsLCBNLCBrICsgdGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgfVxuICBZLk9mZnNldExheW91dCA9IHY7XG4gIGNsYXNzIHggZXh0ZW5kcyBuIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNKSB7XG4gICAgICBpZiAoc3VwZXIobCwgTSksIDYgPCB0aGlzLnNwYW4pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlc1wiKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShsLCBNID0gMCkge1xuICAgICAgcmV0dXJuIHIobCkucmVhZFVJbnRMRShNLCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKGwsIE0sIGsgPSAwKSB7XG4gICAgICByZXR1cm4gcihNKS53cml0ZVVJbnRMRShsLCBrLCB0aGlzLnNwYW4pLCB0aGlzLnNwYW47XG4gICAgfVxuICB9XG4gIFkuVUludCA9IHg7XG4gIGNsYXNzIGIgZXh0ZW5kcyBuIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNKSB7XG4gICAgICBpZiAoc3VwZXIobCwgTSksIDYgPCB0aGlzLnNwYW4pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlc1wiKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShsLCBNID0gMCkge1xuICAgICAgcmV0dXJuIHIobCkucmVhZFVJbnRCRShNLCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKGwsIE0sIGsgPSAwKSB7XG4gICAgICByZXR1cm4gcihNKS53cml0ZVVJbnRCRShsLCBrLCB0aGlzLnNwYW4pLCB0aGlzLnNwYW47XG4gICAgfVxuICB9XG4gIFkuVUludEJFID0gYjtcbiAgY2xhc3MgUyBleHRlbmRzIG4ge1xuICAgIGNvbnN0cnVjdG9yKGwsIE0pIHtcbiAgICAgIGlmIChzdXBlcihsLCBNKSwgNiA8IHRoaXMuc3BhbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICByZXR1cm4gcihsKS5yZWFkSW50TEUoTSwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgcmV0dXJuIHIoTSkud3JpdGVJbnRMRShsLCBrLCB0aGlzLnNwYW4pLCB0aGlzLnNwYW47XG4gICAgfVxuICB9XG4gIFkuSW50ID0gUztcbiAgY2xhc3MgVCBleHRlbmRzIG4ge1xuICAgIGNvbnN0cnVjdG9yKGwsIE0pIHtcbiAgICAgIGlmIChzdXBlcihsLCBNKSwgNiA8IHRoaXMuc3BhbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICByZXR1cm4gcihsKS5yZWFkSW50QkUoTSwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgcmV0dXJuIHIoTSkud3JpdGVJbnRCRShsLCBrLCB0aGlzLnNwYW4pLCB0aGlzLnNwYW47XG4gICAgfVxuICB9XG4gIFkuSW50QkUgPSBUO1xuICBjb25zdCBDID0gTWF0aC5wb3coMiwgMzIpO1xuICBmdW5jdGlvbiBQKGEpIHtcbiAgICBjb25zdCBsID0gTWF0aC5mbG9vcihhIC8gQyksIE0gPSBhIC0gbCAqIEM7XG4gICAgcmV0dXJuIHsgaGkzMjogbCwgbG8zMjogTSB9O1xuICB9XG4gIGZ1bmN0aW9uIEIoYSwgbCkge1xuICAgIHJldHVybiBhICogQyArIGw7XG4gIH1cbiAgY2xhc3MgUiBleHRlbmRzIG4ge1xuICAgIGNvbnN0cnVjdG9yKGwpIHtcbiAgICAgIHN1cGVyKDgsIGwpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICBjb25zdCBrID0gcihsKSwgJCA9IGsucmVhZFVJbnQzMkxFKE0pLCBYID0gay5yZWFkVUludDMyTEUoTSArIDQpO1xuICAgICAgcmV0dXJuIEIoWCwgJCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUobCwgTSwgayA9IDApIHtcbiAgICAgIGNvbnN0ICQgPSBQKGwpLCBYID0gcihNKTtcbiAgICAgIHJldHVybiBYLndyaXRlVUludDMyTEUoJC5sbzMyLCBrKSwgWC53cml0ZVVJbnQzMkxFKCQuaGkzMiwgayArIDQpLCA4O1xuICAgIH1cbiAgfVxuICBZLk5lYXJVSW50NjQgPSBSO1xuICBjbGFzcyB6IGV4dGVuZHMgbiB7XG4gICAgY29uc3RydWN0b3IobCkge1xuICAgICAgc3VwZXIoOCwgbCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUobCwgTSA9IDApIHtcbiAgICAgIGNvbnN0IGsgPSByKGwpLCAkID0gay5yZWFkVUludDMyQkUoTSksIFggPSBrLnJlYWRVSW50MzJCRShNICsgNCk7XG4gICAgICByZXR1cm4gQigkLCBYKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgY29uc3QgJCA9IFAobCksIFggPSByKE0pO1xuICAgICAgcmV0dXJuIFgud3JpdGVVSW50MzJCRSgkLmhpMzIsIGspLCBYLndyaXRlVUludDMyQkUoJC5sbzMyLCBrICsgNCksIDg7XG4gICAgfVxuICB9XG4gIFkuTmVhclVJbnQ2NEJFID0gejtcbiAgY2xhc3MgSyBleHRlbmRzIG4ge1xuICAgIGNvbnN0cnVjdG9yKGwpIHtcbiAgICAgIHN1cGVyKDgsIGwpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICBjb25zdCBrID0gcihsKSwgJCA9IGsucmVhZFVJbnQzMkxFKE0pLCBYID0gay5yZWFkSW50MzJMRShNICsgNCk7XG4gICAgICByZXR1cm4gQihYLCAkKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgY29uc3QgJCA9IFAobCksIFggPSByKE0pO1xuICAgICAgcmV0dXJuIFgud3JpdGVVSW50MzJMRSgkLmxvMzIsIGspLCBYLndyaXRlSW50MzJMRSgkLmhpMzIsIGsgKyA0KSwgODtcbiAgICB9XG4gIH1cbiAgWS5OZWFySW50NjQgPSBLO1xuICBjbGFzcyBaIGV4dGVuZHMgbiB7XG4gICAgY29uc3RydWN0b3IobCkge1xuICAgICAgc3VwZXIoOCwgbCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUobCwgTSA9IDApIHtcbiAgICAgIGNvbnN0IGsgPSByKGwpLCAkID0gay5yZWFkSW50MzJCRShNKSwgWCA9IGsucmVhZFVJbnQzMkJFKE0gKyA0KTtcbiAgICAgIHJldHVybiBCKCQsIFgpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKGwsIE0sIGsgPSAwKSB7XG4gICAgICBjb25zdCAkID0gUChsKSwgWCA9IHIoTSk7XG4gICAgICByZXR1cm4gWC53cml0ZUludDMyQkUoJC5oaTMyLCBrKSwgWC53cml0ZVVJbnQzMkJFKCQubG8zMiwgayArIDQpLCA4O1xuICAgIH1cbiAgfVxuICBZLk5lYXJJbnQ2NEJFID0gWjtcbiAgY2xhc3MgUSBleHRlbmRzIG4ge1xuICAgIGNvbnN0cnVjdG9yKGwpIHtcbiAgICAgIHN1cGVyKDQsIGwpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICByZXR1cm4gcihsKS5yZWFkRmxvYXRMRShNKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgcmV0dXJuIHIoTSkud3JpdGVGbG9hdExFKGwsIGspLCA0O1xuICAgIH1cbiAgfVxuICBZLkZsb2F0ID0gUTtcbiAgY2xhc3MgaiBleHRlbmRzIG4ge1xuICAgIGNvbnN0cnVjdG9yKGwpIHtcbiAgICAgIHN1cGVyKDQsIGwpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICByZXR1cm4gcihsKS5yZWFkRmxvYXRCRShNKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgcmV0dXJuIHIoTSkud3JpdGVGbG9hdEJFKGwsIGspLCA0O1xuICAgIH1cbiAgfVxuICBZLkZsb2F0QkUgPSBqO1xuICBjbGFzcyBWIGV4dGVuZHMgbiB7XG4gICAgY29uc3RydWN0b3IobCkge1xuICAgICAgc3VwZXIoOCwgbCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUobCwgTSA9IDApIHtcbiAgICAgIHJldHVybiByKGwpLnJlYWREb3VibGVMRShNKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgcmV0dXJuIHIoTSkud3JpdGVEb3VibGVMRShsLCBrKSwgODtcbiAgICB9XG4gIH1cbiAgWS5Eb3VibGUgPSBWO1xuICBjbGFzcyBlZSBleHRlbmRzIG4ge1xuICAgIGNvbnN0cnVjdG9yKGwpIHtcbiAgICAgIHN1cGVyKDgsIGwpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICByZXR1cm4gcihsKS5yZWFkRG91YmxlQkUoTSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUobCwgTSwgayA9IDApIHtcbiAgICAgIHJldHVybiByKE0pLndyaXRlRG91YmxlQkUobCwgayksIDg7XG4gICAgfVxuICB9XG4gIFkuRG91YmxlQkUgPSBlZTtcbiAgY2xhc3MgRyBleHRlbmRzIG4ge1xuICAgIGNvbnN0cnVjdG9yKGwsIE0sIGspIHtcbiAgICAgIGlmICghKGwgaW5zdGFuY2VvZiBuKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVsZW1lbnRMYXlvdXQgbXVzdCBiZSBhIExheW91dFwiKTtcbiAgICAgIGlmICghKE0gaW5zdGFuY2VvZiBjICYmIE0uaXNDb3VudCgpIHx8IE51bWJlci5pc0ludGVnZXIoTSkgJiYgMCA8PSBNKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvdW50IG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXIgb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dFwiKTtcbiAgICAgIGxldCAkID0gLTE7XG4gICAgICAhKE0gaW5zdGFuY2VvZiBjKSAmJiAwIDwgbC5zcGFuICYmICgkID0gTSAqIGwuc3BhbiksIHN1cGVyKCQsIGspLCB0aGlzLmVsZW1lbnRMYXlvdXQgPSBsLCB0aGlzLmNvdW50ID0gTTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4obCwgTSA9IDApIHtcbiAgICAgIGlmICgwIDw9IHRoaXMuc3BhbilcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgIGxldCBrID0gMCwgJCA9IHRoaXMuY291bnQ7XG4gICAgICBpZiAoJCBpbnN0YW5jZW9mIGMgJiYgKCQgPSAkLmRlY29kZShsLCBNKSksIDAgPCB0aGlzLmVsZW1lbnRMYXlvdXQuc3BhbilcbiAgICAgICAgayA9ICQgKiB0aGlzLmVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgWCA9IDA7XG4gICAgICAgIGZvciAoOyBYIDwgJDsgKVxuICAgICAgICAgIGsgKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4obCwgTSArIGspLCArK1g7XG4gICAgICB9XG4gICAgICByZXR1cm4gaztcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShsLCBNID0gMCkge1xuICAgICAgY29uc3QgayA9IFtdO1xuICAgICAgbGV0ICQgPSAwLCBYID0gdGhpcy5jb3VudDtcbiAgICAgIGZvciAoWCBpbnN0YW5jZW9mIGMgJiYgKFggPSBYLmRlY29kZShsLCBNKSk7ICQgPCBYOyApXG4gICAgICAgIGsucHVzaCh0aGlzLmVsZW1lbnRMYXlvdXQuZGVjb2RlKGwsIE0pKSwgTSArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihsLCBNKSwgJCArPSAxO1xuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFNlcXVlbmNlfS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIGBzcmNgIGlzIHNob3J0ZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZW5cbiAgICAgKiB0aGUgdW51c2VkIHNwYWNlIGluIHRoZSBidWZmZXIgaXMgbGVmdCB1bmNoYW5nZWQuICBJZiBgc3JjYCBpc1xuICAgICAqIGxvbmdlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlIHVubmVlZGVkIGVsZW1lbnRzIGFyZVxuICAgICAqIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgY29uc3QgJCA9IHRoaXMuZWxlbWVudExheW91dCwgWCA9IGwucmVkdWNlKChyZSwgc2UpID0+IHJlICsgJC5lbmNvZGUoc2UsIE0sIGsgKyByZSksIDApO1xuICAgICAgcmV0dXJuIHRoaXMuY291bnQgaW5zdGFuY2VvZiBjICYmIHRoaXMuY291bnQuZW5jb2RlKGwubGVuZ3RoLCBNLCBrKSwgWDtcbiAgICB9XG4gIH1cbiAgWS5TZXF1ZW5jZSA9IEc7XG4gIGNsYXNzIE4gZXh0ZW5kcyBuIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNLCBrKSB7XG4gICAgICBpZiAoIShBcnJheS5pc0FycmF5KGwpICYmIGwucmVkdWNlKChYLCByZSkgPT4gWCAmJiByZSBpbnN0YW5jZW9mIG4sICEwKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmaWVsZHMgbXVzdCBiZSBhcnJheSBvZiBMYXlvdXQgaW5zdGFuY2VzXCIpO1xuICAgICAgdHlwZW9mIE0gPT0gXCJib29sZWFuXCIgJiYgayA9PT0gdm9pZCAwICYmIChrID0gTSwgTSA9IHZvaWQgMCk7XG4gICAgICBmb3IgKGNvbnN0IFggb2YgbClcbiAgICAgICAgaWYgKDAgPiBYLnNwYW4gJiYgWC5wcm9wZXJ0eSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpZWxkcyBjYW5ub3QgY29udGFpbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBsYXlvdXRcIik7XG4gICAgICBsZXQgJCA9IC0xO1xuICAgICAgdHJ5IHtcbiAgICAgICAgJCA9IGwucmVkdWNlKChYLCByZSkgPT4gWCArIHJlLmdldFNwYW4oKSwgMCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHN1cGVyKCQsIE0pLCB0aGlzLmZpZWxkcyA9IGwsIHRoaXMuZGVjb2RlUHJlZml4ZXMgPSAhIWs7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGwsIE0gPSAwKSB7XG4gICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pXG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICBsZXQgayA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBrID0gdGhpcy5maWVsZHMucmVkdWNlKCgkLCBYKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmUgPSBYLmdldFNwYW4obCwgTSk7XG4gICAgICAgICAgcmV0dXJuIE0gKz0gcmUsICQgKyByZTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmRldGVybWluYXRlIHNwYW5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaztcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShsLCBNID0gMCkge1xuICAgICAgZShsKTtcbiAgICAgIGNvbnN0IGsgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgZm9yIChjb25zdCAkIG9mIHRoaXMuZmllbGRzKVxuICAgICAgICBpZiAoJC5wcm9wZXJ0eSAhPT0gdm9pZCAwICYmIChrWyQucHJvcGVydHldID0gJC5kZWNvZGUobCwgTSkpLCBNICs9ICQuZ2V0U3BhbihsLCBNKSwgdGhpcy5kZWNvZGVQcmVmaXhlcyAmJiBsLmxlbmd0aCA9PT0gTSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIHJldHVybiBrO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTdHJ1Y3R1cmV9LlxuICAgICAqXG4gICAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGlzXG4gICAgICogbGVmdCB1bm1vZGlmaWVkLiAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgY29uc3QgJCA9IGs7XG4gICAgICBsZXQgWCA9IDAsIHJlID0gMDtcbiAgICAgIGZvciAoY29uc3Qgc2Ugb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgbGV0IHV0ID0gc2Uuc3BhbjtcbiAgICAgICAgaWYgKHJlID0gMCA8IHV0ID8gdXQgOiAwLCBzZS5wcm9wZXJ0eSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3QgeGUgPSBsW3NlLnByb3BlcnR5XTtcbiAgICAgICAgICB4ZSAhPT0gdm9pZCAwICYmIChyZSA9IHNlLmVuY29kZSh4ZSwgTSwgayksIDAgPiB1dCAmJiAodXQgPSBzZS5nZXRTcGFuKE0sIGspKSk7XG4gICAgICAgIH1cbiAgICAgICAgWCA9IGssIGsgKz0gdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gWCArIHJlIC0gJDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGZyb21BcnJheShsKSB7XG4gICAgICBjb25zdCBNID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgIGZvciAoY29uc3QgayBvZiB0aGlzLmZpZWxkcylcbiAgICAgICAgay5wcm9wZXJ0eSAhPT0gdm9pZCAwICYmIDAgPCBsLmxlbmd0aCAmJiAoTVtrLnByb3BlcnR5XSA9IGwuc2hpZnQoKSk7XG4gICAgICByZXR1cm4gTTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY2VzcyB0byB0aGUgbGF5b3V0IG9mIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgc3RydWN0dXJlIG1lbWJlciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0xheW91dH0gLSB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBgcHJvcGVydHlgLCBvclxuICAgICAqIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzdWNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGxheW91dEZvcihsKSB7XG4gICAgICBpZiAodHlwZW9mIGwgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3BlcnR5IG11c3QgYmUgc3RyaW5nXCIpO1xuICAgICAgZm9yIChjb25zdCBNIG9mIHRoaXMuZmllbGRzKVxuICAgICAgICBpZiAoTS5wcm9wZXJ0eSA9PT0gbClcbiAgICAgICAgICByZXR1cm4gTTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvZmZzZXQgb2YgYSBzdHJ1Y3R1cmUgbWVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG9mZnNldCBpbiBieXRlcyB0byB0aGUgc3RhcnQgb2YgYHByb3BlcnR5YFxuICAgICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLCBvciB1bmRlZmluZWQgaWYgYHByb3BlcnR5YCBpcyBub3QgYSBmaWVsZFxuICAgICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLiAgSWYgdGhlIHByb3BlcnR5IGlzIGEgbWVtYmVyIGJ1dCBmb2xsb3dzIGFcbiAgICAgKiB2YXJpYWJsZS1sZW5ndGggc3RydWN0dXJlIG1lbWJlciBhIG5lZ2F0aXZlIG51bWJlciB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgb2Zmc2V0T2YobCkge1xuICAgICAgaWYgKHR5cGVvZiBsICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICAgIGxldCBNID0gMDtcbiAgICAgIGZvciAoY29uc3QgayBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICBpZiAoay5wcm9wZXJ0eSA9PT0gbClcbiAgICAgICAgICByZXR1cm4gTTtcbiAgICAgICAgMCA+IGsuc3BhbiA/IE0gPSAtMSA6IDAgPD0gTSAmJiAoTSArPSBrLnNwYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBZLlN0cnVjdHVyZSA9IE47XG4gIGNsYXNzIE8ge1xuICAgIGNvbnN0cnVjdG9yKGwpIHtcbiAgICAgIHRoaXMucHJvcGVydHkgPSBsO1xuICAgIH1cbiAgICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBkZWNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCByZWZlcmVuY2UgdGhlIGJ1ZmZlciBpZlxuICAgICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gICAgZGVjb2RlKGwsIE0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdFwiKTtcbiAgICB9XG4gICAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZW5jb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3Qgc3RvcmUgdGhlIHZhbHVlIGlmXG4gICAgICogdmFyaWFudCBpbmZvcm1hdGlvbiBpcyBtYWludGFpbmVkIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gICAgZW5jb2RlKGwsIE0sIGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdFwiKTtcbiAgICB9XG4gIH1cbiAgWS5VbmlvbkRpc2NyaW1pbmF0b3IgPSBPO1xuICBjbGFzcyBMIGV4dGVuZHMgTyB7XG4gICAgY29uc3RydWN0b3IobCwgTSkge1xuICAgICAgaWYgKCEobCBpbnN0YW5jZW9mIGMgJiYgbC5pc0NvdW50KCkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGF5b3V0IG11c3QgYmUgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dFwiKTtcbiAgICAgIHN1cGVyKE0gfHwgbC5wcm9wZXJ0eSB8fCBcInZhcmlhbnRcIiksIHRoaXMubGF5b3V0ID0gbDtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIGRlY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gICAgZGVjb2RlKGwsIE0pIHtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUobCwgTSk7XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSBlbmNvZGluZyB0byB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGVuY29kZShsLCBNLCBrKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKGwsIE0sIGspO1xuICAgIH1cbiAgfVxuICBZLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IEw7XG4gIGNsYXNzIEYgZXh0ZW5kcyBuIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNLCBrKSB7XG4gICAgICBsZXQgJDtcbiAgICAgIGlmIChsIGluc3RhbmNlb2YgeCB8fCBsIGluc3RhbmNlb2YgYilcbiAgICAgICAgJCA9IG5ldyBMKG5ldyB2KGwpKTtcbiAgICAgIGVsc2UgaWYgKGwgaW5zdGFuY2VvZiBjICYmIGwuaXNDb3VudCgpKVxuICAgICAgICAkID0gbmV3IEwobCk7XG4gICAgICBlbHNlIGlmIChsIGluc3RhbmNlb2YgTylcbiAgICAgICAgJCA9IGw7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJkaXNjciBtdXN0IGJlIGEgVW5pb25EaXNjcmltaW5hdG9yIG9yIGFuIHVuc2lnbmVkIGludGVnZXIgbGF5b3V0XCIpO1xuICAgICAgaWYgKE0gPT09IHZvaWQgMCAmJiAoTSA9IG51bGwpLCAhKE0gPT09IG51bGwgfHwgTSBpbnN0YW5jZW9mIG4pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGVmYXVsdExheW91dCBtdXN0IGJlIG51bGwgb3IgYSBMYXlvdXRcIik7XG4gICAgICBpZiAoTSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoMCA+IE0uc3BhbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0TGF5b3V0IG11c3QgaGF2ZSBjb25zdGFudCBzcGFuXCIpO1xuICAgICAgICBNLnByb3BlcnR5ID09PSB2b2lkIDAgJiYgKE0gPSBNLnJlcGxpY2F0ZShcImNvbnRlbnRcIikpO1xuICAgICAgfVxuICAgICAgbGV0IFggPSAtMTtcbiAgICAgIE0gJiYgKFggPSBNLnNwYW4sIDAgPD0gWCAmJiAobCBpbnN0YW5jZW9mIHggfHwgbCBpbnN0YW5jZW9mIGIpICYmIChYICs9ICQubGF5b3V0LnNwYW4pKSwgc3VwZXIoWCwgayksIHRoaXMuZGlzY3JpbWluYXRvciA9ICQsIHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgPSBsIGluc3RhbmNlb2YgeCB8fCBsIGluc3RhbmNlb2YgYiwgdGhpcy5kZWZhdWx0TGF5b3V0ID0gTSwgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgICAgbGV0IHJlID0gdGhpcy5kZWZhdWx0R2V0U291cmNlVmFyaWFudC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5nZXRTb3VyY2VWYXJpYW50ID0gZnVuY3Rpb24oc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlKHNlKTtcbiAgICAgIH0sIHRoaXMuY29uZmlnR2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uKHNlKSB7XG4gICAgICAgIHJlID0gc2UuYmluZCh0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGwsIE0gPSAwKSB7XG4gICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pXG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICBjb25zdCBrID0gdGhpcy5nZXRWYXJpYW50KGwsIE0pO1xuICAgICAgaWYgKCFrKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHNwYW4gZm9yIHVucmVjb2duaXplZCB2YXJpYW50XCIpO1xuICAgICAgcmV0dXJuIGsuZ2V0U3BhbihsLCBNKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGluZmVyIGEgcmVnaXN0ZXJlZCBVbmlvbiB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBgc3JjYC5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCBzYXRpc2ZpZWQgcnVsZSBpbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIGRlZmluZXMgdGhlXG4gICAgICogcmV0dXJuIHZhbHVlOlxuICAgICAqICogSWYgYHNyY2AgaGFzIHByb3BlcnRpZXMgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IgYW5kXG4gICAgICogICB0aGUgZGVmYXVsdCBsYXlvdXQsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eSAodGhpcyBlbnN1cmVzIHRoZSBkZWZhdWx0XG4gICAgICogICBsYXlvdXQgd2lsbCBiZSB1c2VkKTtcbiAgICAgKiAqIElmIGBzcmNgIGhhcyBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yLCB0aGVcbiAgICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIGlkZW50aWZpZXMgYSByZWdpc3RlcmVkIHZhcmlhbnQsIGFuZFxuICAgICAqICAgZWl0aGVyIChhKSB0aGUgdmFyaWFudCBoYXMgbm8gbGF5b3V0LCBvciAoYikgYHNyY2AgaGFzIHRoZVxuICAgICAqICAgdmFyaWFudCdzIHByb3BlcnR5LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZVxuICAgICAqICAgc291cmNlIHNhdGlzZmllcyB0aGUgY29uc3RyYWludHMgb2YgdGhlIHZhcmlhbnQgaXQgaWRlbnRpZmllcyk7XG4gICAgICogKiBJZiBgc3JjYCBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uXG4gICAgICogICBkaXNjcmltaW5hdG9yLCBidXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgYSByZWdpc3RlcmVkXG4gICAgICogICB2YXJpYW50LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZSBzb3VyY2VcbiAgICAgKiAgIG1hdGNoZXMgYSB2YXJpYW50IHdpdGhvdXQgYW4gZXhwbGljaXQgY29uZmxpY3QpO1xuICAgICAqICogQW4gZXJyb3IgaXMgdGhyb3duIChiZWNhdXNlIHdlIGVpdGhlciBjYW4ndCBpZGVudGlmeSBhIHZhcmlhbnQsXG4gICAgICogICBvciB3ZSB3ZXJlIGV4cGxpY2l0bHkgdG9sZCB0aGUgdmFyaWFudCBidXQgY2FuJ3Qgc2F0aXNmeSBpdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYW4gb2JqZWN0IHByZXN1bWVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSBVbmlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IC0gYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gaWYgYHNyY2AgY2Fubm90IGJlIGFzc29jaWF0ZWQgd2l0aCBhIGRlZmF1bHQgb3JcbiAgICAgKiByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQobCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsLCB0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHkpKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRMYXlvdXQgJiYgdGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsLCB0aGlzLmRlZmF1bHRMYXlvdXQucHJvcGVydHkpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgTSA9IHRoaXMucmVnaXN0cnlbbFt0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHldXTtcbiAgICAgICAgaWYgKE0gJiYgKCFNLmxheW91dCB8fCBNLnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsLCBNLnByb3BlcnR5KSkpXG4gICAgICAgICAgcmV0dXJuIE07XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yIChjb25zdCBNIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgICBjb25zdCBrID0gdGhpcy5yZWdpc3RyeVtNXTtcbiAgICAgICAgICBpZiAoay5wcm9wZXJ0eSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobCwgay5wcm9wZXJ0eSkpXG4gICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGluZmVyIHNyYyB2YXJpYW50XCIpO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBpcyB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxyZWdpc3RlcmVkfSB0aGUgcmV0dXJuXG4gICAgICogdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB2YXJpYW50LCB3aXRoIG5vIGV4cGxpY2l0XG4gICAgICogZGlzY3JpbWluYXRvci4gIE90aGVyd2lzZSB0aGUge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdFxuICAgICAqIGxheW91dH0gaXMgdXNlZCB0byBkZWNvZGUgdGhlIGNvbnRlbnQuICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICBsZXQgaztcbiAgICAgIGNvbnN0ICQgPSB0aGlzLmRpc2NyaW1pbmF0b3IsIFggPSAkLmRlY29kZShsLCBNKSwgcmUgPSB0aGlzLnJlZ2lzdHJ5W1hdO1xuICAgICAgaWYgKHJlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2UgPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgIGxldCB1dCA9IDA7XG4gICAgICAgIHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgJiYgKHV0ID0gJC5sYXlvdXQuc3BhbiksIGsgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpLCBrWyQucHJvcGVydHldID0gWCwga1tzZS5wcm9wZXJ0eV0gPSBzZS5kZWNvZGUobCwgTSArIHV0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBrID0gcmUuZGVjb2RlKGwsIE0pO1xuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAgICAgKlxuICAgICAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGBzcmNgIG9iamVjdCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHVuaW9uJ3NcbiAgICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uICBUbyBlbmNvZGUgdmFyaWFudHNcbiAgICAgKiB1c2UgdGhlIGFwcHJvcHJpYXRlIHZhcmlhbnQtc3BlY2lmaWMge0BsaW5rIFZhcmlhbnRMYXlvdXQjZW5jb2RlfVxuICAgICAqIG1ldGhvZC4gKi9cbiAgICBlbmNvZGUobCwgTSwgayA9IDApIHtcbiAgICAgIGNvbnN0ICQgPSB0aGlzLmdldFNvdXJjZVZhcmlhbnQobCk7XG4gICAgICBpZiAoJCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IFggPSB0aGlzLmRpc2NyaW1pbmF0b3IsIHJlID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgICBsZXQgc2UgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvciAmJiAoc2UgPSBYLmxheW91dC5zcGFuKSwgWC5lbmNvZGUobFtYLnByb3BlcnR5XSwgTSwgayksIHNlICsgcmUuZW5jb2RlKGxbcmUucHJvcGVydHldLCBNLCBrICsgc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICQuZW5jb2RlKGwsIE0sIGspO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSBuZXcgdmFyaWFudCBzdHJ1Y3R1cmUgd2l0aGluIGEgdW5pb24uICBUaGUgbmV3bHlcbiAgICAgKiBjcmVhdGVkIHZhcmlhbnQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I3ZhcmlhbnR8dmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZhcmlhbnRMYXlvdXR9ICovXG4gICAgYWRkVmFyaWFudChsLCBNLCBrKSB7XG4gICAgICBjb25zdCAkID0gbmV3IGQodGhpcywgbCwgTSwgayk7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVtsXSA9ICQsICQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBhIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICAgKlxuICAgICAqIElmIGB2YmAgZG9lcyBub3QgcHJvZHVjZSBhIHJlZ2lzdGVyZWQgdmFyaWFudCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoTnVtYmVyfFVpbnQ4QXJyYXkpfSB2YiAtIGVpdGhlciB0aGUgdmFyaWFudCBudW1iZXIsIG9yIGFcbiAgICAgKiBidWZmZXIgZnJvbSB3aGljaCB0aGUgZGlzY3JpbWluYXRvciBpcyB0byBiZSByZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIG9mZnNldCBpbnRvIGB2YmAgZm9yIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiB1bmlvbi4gIFVzZWQgb25seSB3aGVuIGB2YmAgaXMgYW4gaW5zdGFuY2Ugb2Yge1VpbnQ4QXJyYXl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KHtWYXJpYW50TGF5b3V0fXx1bmRlZmluZWQpfVxuICAgICAqL1xuICAgIGdldFZhcmlhbnQobCwgTSA9IDApIHtcbiAgICAgIGxldCBrO1xuICAgICAgcmV0dXJuIGwgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gayA9IHRoaXMuZGlzY3JpbWluYXRvci5kZWNvZGUobCwgTSkgOiBrID0gbCwgdGhpcy5yZWdpc3RyeVtrXTtcbiAgICB9XG4gIH1cbiAgWS5VbmlvbiA9IEY7XG4gIGNsYXNzIGQgZXh0ZW5kcyBuIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNLCBrLCAkKSB7XG4gICAgICBpZiAoIShsIGluc3RhbmNlb2YgRikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bmlvbiBtdXN0IGJlIGEgVW5pb25cIik7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoTSkgfHwgMCA+IE0pXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YXJpYW50IG11c3QgYmUgYSAobm9uLW5lZ2F0aXZlKSBpbnRlZ2VyXCIpO1xuICAgICAgaWYgKHR5cGVvZiBrID09IFwic3RyaW5nXCIgJiYgJCA9PT0gdm9pZCAwICYmICgkID0gaywgayA9IG51bGwpLCBrKSB7XG4gICAgICAgIGlmICghKGsgaW5zdGFuY2VvZiBuKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGF5b3V0IG11c3QgYmUgYSBMYXlvdXRcIik7XG4gICAgICAgIGlmIChsLmRlZmF1bHRMYXlvdXQgIT09IG51bGwgJiYgMCA8PSBrLnNwYW4gJiYgay5zcGFuID4gbC5kZWZhdWx0TGF5b3V0LnNwYW4pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFyaWFudCBzcGFuIGV4Y2VlZHMgc3BhbiBvZiBjb250YWluaW5nIHVuaW9uXCIpO1xuICAgICAgICBpZiAodHlwZW9mICQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFyaWFudCBtdXN0IGhhdmUgYSBTdHJpbmcgcHJvcGVydHlcIik7XG4gICAgICB9XG4gICAgICBsZXQgWCA9IGwuc3BhbjtcbiAgICAgIDAgPiBsLnNwYW4gJiYgKFggPSBrID8gay5zcGFuIDogMCwgMCA8PSBYICYmIGwudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgJiYgKFggKz0gbC5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuKSksIHN1cGVyKFgsICQpLCB0aGlzLnVuaW9uID0gbCwgdGhpcy52YXJpYW50ID0gTSwgdGhpcy5sYXlvdXQgPSBrIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGwsIE0gPSAwKSB7XG4gICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pXG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICBsZXQgayA9IDA7XG4gICAgICB0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yICYmIChrID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuKTtcbiAgICAgIGxldCAkID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dCAmJiAoJCA9IHRoaXMubGF5b3V0LmdldFNwYW4obCwgTSArIGspKSwgayArICQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUobCwgTSA9IDApIHtcbiAgICAgIGNvbnN0IGsgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgaWYgKHRoaXMgIT09IHRoaXMudW5pb24uZ2V0VmFyaWFudChsLCBNKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFyaWFudCBtaXNtYXRjaFwiKTtcbiAgICAgIGxldCAkID0gMDtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yICYmICgkID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuKSwgdGhpcy5sYXlvdXQgPyBrW3RoaXMucHJvcGVydHldID0gdGhpcy5sYXlvdXQuZGVjb2RlKGwsIE0gKyAkKSA6IHRoaXMucHJvcGVydHkgPyBrW3RoaXMucHJvcGVydHldID0gITAgOiB0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yICYmIChrW3RoaXMudW5pb24uZGlzY3JpbWluYXRvci5wcm9wZXJ0eV0gPSB0aGlzLnZhcmlhbnQpLCBrO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKGwsIE0sIGsgPSAwKSB7XG4gICAgICBsZXQgJCA9IDA7XG4gICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvciAmJiAoJCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbiksIHRoaXMubGF5b3V0ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobCwgdGhpcy5wcm9wZXJ0eSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YXJpYW50IGxhY2tzIHByb3BlcnR5IFwiICsgdGhpcy5wcm9wZXJ0eSk7XG4gICAgICB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IuZW5jb2RlKHRoaXMudmFyaWFudCwgTSwgayk7XG4gICAgICBsZXQgWCA9ICQ7XG4gICAgICBpZiAodGhpcy5sYXlvdXQgJiYgKHRoaXMubGF5b3V0LmVuY29kZShsW3RoaXMucHJvcGVydHldLCBNLCBrICsgJCksIFggKz0gdGhpcy5sYXlvdXQuZ2V0U3BhbihNLCBrICsgJCksIDAgPD0gdGhpcy51bmlvbi5zcGFuICYmIFggPiB0aGlzLnVuaW9uLnNwYW4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmNvZGVkIHZhcmlhbnQgb3ZlcnJ1bnMgY29udGFpbmluZyB1bmlvblwiKTtcbiAgICAgIHJldHVybiBYO1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUge0BsaW5rIExheW91dCNmcm9tQXJyYXl8ZnJvbUFycmF5fSB0byB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGZyb21BcnJheShsKSB7XG4gICAgICBpZiAodGhpcy5sYXlvdXQpXG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5mcm9tQXJyYXkobCk7XG4gICAgfVxuICB9XG4gIFkuVmFyaWFudExheW91dCA9IGQ7XG4gIGZ1bmN0aW9uIHMoYSkge1xuICAgIHJldHVybiAwID4gYSAmJiAoYSArPSA0Mjk0OTY3Mjk2KSwgYTtcbiAgfVxuICBjbGFzcyB1IGV4dGVuZHMgbiB7XG4gICAgY29uc3RydWN0b3IobCwgTSwgaykge1xuICAgICAgaWYgKCEobCBpbnN0YW5jZW9mIHggfHwgbCBpbnN0YW5jZW9mIGIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwid29yZCBtdXN0IGJlIGEgVUludCBvciBVSW50QkUgbGF5b3V0XCIpO1xuICAgICAgaWYgKHR5cGVvZiBNID09IFwic3RyaW5nXCIgJiYgayA9PT0gdm9pZCAwICYmIChrID0gTSwgTSA9ICExKSwgNCA8IGwuc3BhbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ3b3JkIGNhbm5vdCBleGNlZWQgMzIgYml0c1wiKTtcbiAgICAgIHN1cGVyKGwuc3BhbiwgayksIHRoaXMud29yZCA9IGwsIHRoaXMubXNiID0gISFNLCB0aGlzLmZpZWxkcyA9IFtdO1xuICAgICAgbGV0ICQgPSAwO1xuICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUgPSBmdW5jdGlvbihYKSB7XG4gICAgICAgIHJldHVybiAkID0gcyhYKSwgdGhpcztcbiAgICAgIH0sIHRoaXMuX3BhY2tlZEdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkO1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShsLCBNID0gMCkge1xuICAgICAgY29uc3QgayA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCksICQgPSB0aGlzLndvcmQuZGVjb2RlKGwsIE0pO1xuICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUoJCk7XG4gICAgICBmb3IgKGNvbnN0IFggb2YgdGhpcy5maWVsZHMpXG4gICAgICAgIFgucHJvcGVydHkgIT09IHZvaWQgMCAmJiAoa1tYLnByb3BlcnR5XSA9IFguZGVjb2RlKGwpKTtcbiAgICAgIHJldHVybiBrO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICAgICAqXG4gICAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgcGFja2VkXG4gICAgICogdmFsdWUgaXMgbGVmdCB1bm1vZGlmaWVkLiAgVW51c2VkIGJpdHMgYXJlIGFsc28gbGVmdCB1bm1vZGlmaWVkLiAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgY29uc3QgJCA9IHRoaXMud29yZC5kZWNvZGUoTSwgayk7XG4gICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSgkKTtcbiAgICAgIGZvciAoY29uc3QgWCBvZiB0aGlzLmZpZWxkcylcbiAgICAgICAgaWYgKFgucHJvcGVydHkgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IHJlID0gbFtYLnByb3BlcnR5XTtcbiAgICAgICAgICByZSAhPT0gdm9pZCAwICYmIFguZW5jb2RlKHJlKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud29yZC5lbmNvZGUodGhpcy5fcGFja2VkR2V0VmFsdWUoKSwgTSwgayk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIG5ldyBiaXRmaWVsZCB3aXRoIGEgY29udGFpbmluZyBiaXQgc3RydWN0dXJlLiAgVGhlXG4gICAgICogcmVzdWx0aW5nIGJpdGZpZWxkIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0JpdEZpZWxkfSAqL1xuICAgIGFkZEZpZWxkKGwsIE0pIHtcbiAgICAgIGNvbnN0IGsgPSBuZXcgaCh0aGlzLCBsLCBNKTtcbiAgICAgIHJldHVybiB0aGlzLmZpZWxkcy5wdXNoKGspLCBrO1xuICAgIH1cbiAgICAvKiogQXMgd2l0aCB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBmb3Igc2luZ2xlLWJpdFxuICAgICAqIGZpZWxkcyB3aXRoIGBib29sZWFuYCB2YWx1ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gKi9cbiAgICAvLyBgQm9vbGVhbmAgY29uZmxpY3RzIHdpdGggdGhlIG5hdGl2ZSBwcmltaXRpdmUgdHlwZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgYWRkQm9vbGVhbihsKSB7XG4gICAgICBjb25zdCBNID0gbmV3IGcodGhpcywgbCk7XG4gICAgICByZXR1cm4gdGhpcy5maWVsZHMucHVzaChNKSwgTTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY2VzcyB0byB0aGUgYml0IGZpZWxkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIGJpdCBmaWVsZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0JpdEZpZWxkfSAtIHRoZSBmaWVsZCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmaWVsZEZvcihsKSB7XG4gICAgICBpZiAodHlwZW9mIGwgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3BlcnR5IG11c3QgYmUgc3RyaW5nXCIpO1xuICAgICAgZm9yIChjb25zdCBNIG9mIHRoaXMuZmllbGRzKVxuICAgICAgICBpZiAoTS5wcm9wZXJ0eSA9PT0gbClcbiAgICAgICAgICByZXR1cm4gTTtcbiAgICB9XG4gIH1cbiAgWS5CaXRTdHJ1Y3R1cmUgPSB1O1xuICBjbGFzcyBoIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNLCBrKSB7XG4gICAgICBpZiAoIShsIGluc3RhbmNlb2YgdSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjb250YWluZXIgbXVzdCBiZSBhIEJpdFN0cnVjdHVyZVwiKTtcbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihNKSB8fCAwID49IE0pXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJiaXRzIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgICAgIGNvbnN0ICQgPSA4ICogbC5zcGFuLCBYID0gbC5maWVsZHMucmVkdWNlKChyZSwgc2UpID0+IHJlICsgc2UuYml0cywgMCk7XG4gICAgICBpZiAoTSArIFggPiAkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiaXRzIHRvbyBsb25nIGZvciBzcGFuIHJlbWFpbmRlciAoXCIgKyAoJCAtIFgpICsgXCIgb2YgXCIgKyAkICsgXCIgcmVtYWluKVwiKTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gbCwgdGhpcy5iaXRzID0gTSwgdGhpcy52YWx1ZU1hc2sgPSAoMSA8PCBNKSAtIDEsIE0gPT09IDMyICYmICh0aGlzLnZhbHVlTWFzayA9IDQyOTQ5NjcyOTUpLCB0aGlzLnN0YXJ0ID0gWCwgdGhpcy5jb250YWluZXIubXNiICYmICh0aGlzLnN0YXJ0ID0gJCAtIFggLSBNKSwgdGhpcy53b3JkTWFzayA9IHModGhpcy52YWx1ZU1hc2sgPDwgdGhpcy5zdGFydCksIHRoaXMucHJvcGVydHkgPSBrO1xuICAgIH1cbiAgICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAgICogYml0IGZpZWxkLiAqL1xuICAgIGRlY29kZShsLCBNKSB7XG4gICAgICBjb25zdCBrID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gcyhrICYgdGhpcy53b3JkTWFzaykgPj4+IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiBiaXQgZmllbGQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGlzIG5vdCBhIHNwZWNpYWxpemF0aW9uIG9mIHtAbGlua1xuICAgICAqIExheW91dCNlbmNvZGV8TGF5b3V0LmVuY29kZX0gYW5kIHRoZXJlIGlzIG5vIHJldHVybiB2YWx1ZS4gKi9cbiAgICBlbmNvZGUobCkge1xuICAgICAgaWYgKHR5cGVvZiBsICE9IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc0ludGVnZXIobCkgfHwgbCAhPT0gcyhsICYgdGhpcy52YWx1ZU1hc2spKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG8oXCJCaXRGaWVsZC5lbmNvZGVcIiwgdGhpcykgKyBcIiB2YWx1ZSBtdXN0IGJlIGludGVnZXIgbm90IGV4Y2VlZGluZyBcIiArIHRoaXMudmFsdWVNYXNrKTtcbiAgICAgIGNvbnN0IE0gPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKSwgayA9IHMobCA8PCB0aGlzLnN0YXJ0KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLl9wYWNrZWRTZXRWYWx1ZShzKE0gJiB+dGhpcy53b3JkTWFzaykgfCBrKTtcbiAgICB9XG4gIH1cbiAgWS5CaXRGaWVsZCA9IGg7XG4gIGNsYXNzIGcgZXh0ZW5kcyBoIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNKSB7XG4gICAgICBzdXBlcihsLCAxLCBNKTtcbiAgICB9XG4gICAgLyoqIE92ZXJyaWRlIHtAbGluayBCaXRGaWVsZCNkZWNvZGV8ZGVjb2RlfSBmb3Ige0BsaW5rIEJvb2xlYW58Qm9vbGVhbn0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbiAgICBkZWNvZGUobCwgTSkge1xuICAgICAgcmV0dXJuICEhc3VwZXIuZGVjb2RlKGwsIE0pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKGwpIHtcbiAgICAgIHR5cGVvZiBsID09IFwiYm9vbGVhblwiICYmIChsID0gK2wpLCBzdXBlci5lbmNvZGUobCk7XG4gICAgfVxuICB9XG4gIFkuQm9vbGVhbiA9IGc7XG4gIGNsYXNzIHcgZXh0ZW5kcyBuIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNKSB7XG4gICAgICBpZiAoIShsIGluc3RhbmNlb2YgYyAmJiBsLmlzQ291bnQoKSB8fCBOdW1iZXIuaXNJbnRlZ2VyKGwpICYmIDAgPD0gbCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGggbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXRcIik7XG4gICAgICBsZXQgayA9IC0xO1xuICAgICAgbCBpbnN0YW5jZW9mIGMgfHwgKGsgPSBsKSwgc3VwZXIoaywgTSksIHRoaXMubGVuZ3RoID0gbDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4obCwgTSkge1xuICAgICAgbGV0IGsgPSB0aGlzLnNwYW47XG4gICAgICByZXR1cm4gMCA+IGsgJiYgKGsgPSB0aGlzLmxlbmd0aC5kZWNvZGUobCwgTSkpLCBrO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICBsZXQgayA9IHRoaXMuc3BhbjtcbiAgICAgIHJldHVybiAwID4gayAmJiAoayA9IHRoaXMubGVuZ3RoLmRlY29kZShsLCBNKSksIHIobCkuc2xpY2UoTSwgTSArIGspO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCbG9ifS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIHtAbGluayBMYXlvdXQjY291bnR8Y291bnR9IGlzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGVuIHRoZSBsZW5ndGggb2YgYHNyY2Agd2lsbCBiZSBlbmNvZGVkIGFzIHRoZVxuICAgICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gICAgZW5jb2RlKGwsIE0sIGspIHtcbiAgICAgIGxldCAkID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBjICYmICgkID0gbC5sZW5ndGgpLCAhKGwgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmICQgPT09IGwubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvKFwiQmxvYi5lbmNvZGVcIiwgdGhpcykgKyBcIiByZXF1aXJlcyAobGVuZ3RoIFwiICsgJCArIFwiKSBVaW50OEFycmF5IGFzIHNyY1wiKTtcbiAgICAgIGlmIChrICsgJCA+IE0ubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImVuY29kaW5nIG92ZXJydW5zIFVpbnQ4QXJyYXlcIik7XG4gICAgICBjb25zdCBYID0gcihsKTtcbiAgICAgIHJldHVybiByKE0pLndyaXRlKFgudG9TdHJpbmcoXCJoZXhcIiksIGssICQsIFwiaGV4XCIpLCB0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIGMgJiYgdGhpcy5sZW5ndGguZW5jb2RlKCQsIE0sIGspLCAkO1xuICAgIH1cbiAgfVxuICBZLkJsb2IgPSB3O1xuICBjbGFzcyBfIGV4dGVuZHMgbiB7XG4gICAgY29uc3RydWN0b3IobCkge1xuICAgICAgc3VwZXIoLTEsIGwpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihsLCBNID0gMCkge1xuICAgICAgZShsKTtcbiAgICAgIGxldCBrID0gTTtcbiAgICAgIGZvciAoOyBrIDwgbC5sZW5ndGggJiYgbFtrXSAhPT0gMDsgKVxuICAgICAgICBrICs9IDE7XG4gICAgICByZXR1cm4gMSArIGsgLSBNO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGwsIE0gPSAwKSB7XG4gICAgICBjb25zdCBrID0gdGhpcy5nZXRTcGFuKGwsIE0pO1xuICAgICAgcmV0dXJuIHIobCkuc2xpY2UoTSwgTSArIGsgLSAxKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKGwsIE0sIGsgPSAwKSB7XG4gICAgICB0eXBlb2YgbCAhPSBcInN0cmluZ1wiICYmIChsID0gU3RyaW5nKGwpKTtcbiAgICAgIGNvbnN0ICQgPSB0LkJ1ZmZlci5mcm9tKGwsIFwidXRmOFwiKSwgWCA9ICQubGVuZ3RoO1xuICAgICAgaWYgKGsgKyBYID4gTS5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyXCIpO1xuICAgICAgY29uc3QgcmUgPSByKE0pO1xuICAgICAgcmV0dXJuICQuY29weShyZSwgayksIHJlW2sgKyBYXSA9IDAsIFggKyAxO1xuICAgIH1cbiAgfVxuICBZLkNTdHJpbmcgPSBfO1xuICBjbGFzcyBBIGV4dGVuZHMgbiB7XG4gICAgY29uc3RydWN0b3IobCwgTSkge1xuICAgICAgaWYgKHR5cGVvZiBsID09IFwic3RyaW5nXCIgJiYgTSA9PT0gdm9pZCAwICYmIChNID0gbCwgbCA9IHZvaWQgMCksIGwgPT09IHZvaWQgMClcbiAgICAgICAgbCA9IC0xO1xuICAgICAgZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIobCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtYXhTcGFuIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgIHN1cGVyKC0xLCBNKSwgdGhpcy5tYXhTcGFuID0gbDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4obCwgTSA9IDApIHtcbiAgICAgIHJldHVybiBlKGwpLCBsLmxlbmd0aCAtIE07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUobCwgTSA9IDApIHtcbiAgICAgIGNvbnN0IGsgPSB0aGlzLmdldFNwYW4obCwgTSk7XG4gICAgICBpZiAoMCA8PSB0aGlzLm1heFNwYW4gJiYgdGhpcy5tYXhTcGFuIDwgaylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW5cIik7XG4gICAgICByZXR1cm4gcihsKS5zbGljZShNLCBNICsgaykudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShsLCBNLCBrID0gMCkge1xuICAgICAgdHlwZW9mIGwgIT0gXCJzdHJpbmdcIiAmJiAobCA9IFN0cmluZyhsKSk7XG4gICAgICBjb25zdCAkID0gdC5CdWZmZXIuZnJvbShsLCBcInV0ZjhcIiksIFggPSAkLmxlbmd0aDtcbiAgICAgIGlmICgwIDw9IHRoaXMubWF4U3BhbiAmJiB0aGlzLm1heFNwYW4gPCBYKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhblwiKTtcbiAgICAgIGlmIChrICsgWCA+IE0ubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImVuY29kaW5nIG92ZXJydW5zIEJ1ZmZlclwiKTtcbiAgICAgIHJldHVybiAkLmNvcHkocihNKSwgayksIFg7XG4gICAgfVxuICB9XG4gIFkuVVRGOCA9IEE7XG4gIGNsYXNzIHAgZXh0ZW5kcyBuIHtcbiAgICBjb25zdHJ1Y3RvcihsLCBNKSB7XG4gICAgICBzdXBlcigwLCBNKSwgdGhpcy52YWx1ZSA9IGw7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUobCwgTSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUobCwgTSwgaykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBZLkNvbnN0YW50ID0gcCwgWS5ncmVlZHkgPSAoYSwgbCkgPT4gbmV3IGYoYSwgbCksIFkub2Zmc2V0ID0gKGEsIGwsIE0pID0+IG5ldyB2KGEsIGwsIE0pLCBZLnU4ID0gKGEpID0+IG5ldyB4KDEsIGEpLCBZLnUxNiA9IChhKSA9PiBuZXcgeCgyLCBhKSwgWS51MjQgPSAoYSkgPT4gbmV3IHgoMywgYSksIFkudTMyID0gKGEpID0+IG5ldyB4KDQsIGEpLCBZLnU0MCA9IChhKSA9PiBuZXcgeCg1LCBhKSwgWS51NDggPSAoYSkgPT4gbmV3IHgoNiwgYSksIFkubnU2NCA9IChhKSA9PiBuZXcgUihhKSwgWS51MTZiZSA9IChhKSA9PiBuZXcgYigyLCBhKSwgWS51MjRiZSA9IChhKSA9PiBuZXcgYigzLCBhKSwgWS51MzJiZSA9IChhKSA9PiBuZXcgYig0LCBhKSwgWS51NDBiZSA9IChhKSA9PiBuZXcgYig1LCBhKSwgWS51NDhiZSA9IChhKSA9PiBuZXcgYig2LCBhKSwgWS5udTY0YmUgPSAoYSkgPT4gbmV3IHooYSksIFkuczggPSAoYSkgPT4gbmV3IFMoMSwgYSksIFkuczE2ID0gKGEpID0+IG5ldyBTKDIsIGEpLCBZLnMyNCA9IChhKSA9PiBuZXcgUygzLCBhKSwgWS5zMzIgPSAoYSkgPT4gbmV3IFMoNCwgYSksIFkuczQwID0gKGEpID0+IG5ldyBTKDUsIGEpLCBZLnM0OCA9IChhKSA9PiBuZXcgUyg2LCBhKSwgWS5uczY0ID0gKGEpID0+IG5ldyBLKGEpLCBZLnMxNmJlID0gKGEpID0+IG5ldyBUKDIsIGEpLCBZLnMyNGJlID0gKGEpID0+IG5ldyBUKDMsIGEpLCBZLnMzMmJlID0gKGEpID0+IG5ldyBUKDQsIGEpLCBZLnM0MGJlID0gKGEpID0+IG5ldyBUKDUsIGEpLCBZLnM0OGJlID0gKGEpID0+IG5ldyBUKDYsIGEpLCBZLm5zNjRiZSA9IChhKSA9PiBuZXcgWihhKSwgWS5mMzIgPSAoYSkgPT4gbmV3IFEoYSksIFkuZjMyYmUgPSAoYSkgPT4gbmV3IGooYSksIFkuZjY0ID0gKGEpID0+IG5ldyBWKGEpLCBZLmY2NGJlID0gKGEpID0+IG5ldyBlZShhKSwgWS5zdHJ1Y3QgPSAoYSwgbCwgTSkgPT4gbmV3IE4oYSwgbCwgTSksIFkuYml0cyA9IChhLCBsLCBNKSA9PiBuZXcgdShhLCBsLCBNKSwgWS5zZXEgPSAoYSwgbCwgTSkgPT4gbmV3IEcoYSwgbCwgTSksIFkudW5pb24gPSAoYSwgbCwgTSkgPT4gbmV3IEYoYSwgbCwgTSksIFkudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gKGEsIGwpID0+IG5ldyBMKGEsIGwpLCBZLmJsb2IgPSAoYSwgbCkgPT4gbmV3IHcoYSwgbCksIFkuY3N0ciA9IChhKSA9PiBuZXcgXyhhKSwgWS51dGY4ID0gKGEsIGwpID0+IG5ldyBBKGEsIGwpLCBZLmNvbnN0YW50ID0gKGEsIGwpID0+IG5ldyBwKGEsIGwpLCBZO1xufVxudmFyIEQgPSBjZCgpLCBsZCA9IDgwNzhlMywgZmQgPSA4MDc4MDAxLCBoZCA9IDgwNzgwMDQsIGRkID0gODA3ODAwNSwgcGQgPSA4MDc4MDA2LCBtZCA9IDgwNzgwMTE7XG5mdW5jdGlvbiBSYyh0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gXCIlNUJcIiArIHQubWFwKFJjKS5qb2luKFxuICAgIFwiJTJDJTIwXCJcbiAgICAvKiBcIiwgXCIgKi9cbiAgKSArIC8qIFwiXVwiICovXG4gIFwiJTVEXCIgOiB0eXBlb2YgdCA9PSBcImJpZ2ludFwiID8gYCR7dH1uYCA6IGVuY29kZVVSSUNvbXBvbmVudChcbiAgICBTdHJpbmcoXG4gICAgICB0ICE9IG51bGwgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpID09PSBudWxsID8gKFxuICAgICAgICAvLyBQbGFpbiBvYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIGRvbid0IGhhdmUgYSBgdG9TdHJpbmdgIG1ldGhvZC5cbiAgICAgICAgLy8gQ29udmVydCB0aGVtIGJlZm9yZSBzdHJpbmdpZnlpbmcgdGhlbS5cbiAgICAgICAgeyAuLi50IH1cbiAgICAgICkgOiB0XG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gZ2QoW3QsIGVdKSB7XG4gIHJldHVybiBgJHt0fT0ke1JjKGUpfWA7XG59XG5mdW5jdGlvbiB5ZCh0KSB7XG4gIGNvbnN0IGUgPSBPYmplY3QuZW50cmllcyh0KS5tYXAoZ2QpLmpvaW4oXCImXCIpO1xuICByZXR1cm4gYnRvYShlKTtcbn1cbmZ1bmN0aW9uIHZkKHQsIGUgPSB7fSkge1xuICB7XG4gICAgbGV0IHIgPSBgU29sYW5hIGVycm9yICMke3R9OyBEZWNvZGUgdGhpcyBlcnJvciBieSBydW5uaW5nIFxcYG5weCBAc29sYW5hL2Vycm9ycyBkZWNvZGUgLS0gJHt0fWA7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmxlbmd0aCAmJiAociArPSBgICcke3lkKGUpfSdgKSwgYCR7cn1cXGBgO1xuICB9XG59XG52YXIgSW4gPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoLi4uW2UsIHJdKSB7XG4gICAgbGV0IG4sIG87XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IHsgY2F1c2U6IGMsIC4uLmYgfSA9IHI7XG4gICAgICBjICYmIChvID0geyBjYXVzZTogYyB9KSwgT2JqZWN0LmtleXMoZikubGVuZ3RoID4gMCAmJiAobiA9IGYpO1xuICAgIH1cbiAgICBjb25zdCBpID0gdmQoZSwgbik7XG4gICAgc3VwZXIoaSwgbyk7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSByb290IGNhdXNlIG9mIHRoaXMge0BsaW5rIFNvbGFuYUVycm9yfSwgaWYgYW55LlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGEgdHJhbnNhY3Rpb24gZXJyb3IgbWlnaHQgaGF2ZSBhbiBpbnN0cnVjdGlvbiBlcnJvciBhcyBpdHMgcm9vdCBjYXVzZS4gSW4gdGhpc1xuICAgICAqIGNhc2UsIHlvdSB3aWxsIGJlIGFibGUgdG8gYWNjZXNzIHRoZSBpbnN0cnVjdGlvbiBlcnJvciBvbiB0aGUgdHJhbnNhY3Rpb24gZXJyb3IgYXMgYGNhdXNlYC5cbiAgICAgKi9cbiAgICBicih0aGlzLCBcImNhdXNlXCIsIHRoaXMuY2F1c2UpO1xuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIGNvbnRleHQgdGhhdCBjYW4gYXNzaXN0IGluIHVuZGVyc3RhbmRpbmcgb3IgcmVjb3ZlcmluZyBmcm9tIGEge0BsaW5rIFNvbGFuYUVycm9yfS5cbiAgICAgKi9cbiAgICBicih0aGlzLCBcImNvbnRleHRcIik7XG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgX19jb2RlOiBlLFxuICAgICAgLi4ublxuICAgIH0sIHRoaXMubmFtZSA9IFwiU29sYW5hRXJyb3JcIjtcbiAgfVxufTtcbmZ1bmN0aW9uIHdkKHQsIGUpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gZSA/IGUuZml4ZWRTaXplIDogZS5nZXRTaXplRnJvbVZhbHVlKHQpO1xufVxuZnVuY3Rpb24geGQodCkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4udCxcbiAgICBlbmNvZGU6IChlKSA9PiB7XG4gICAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkod2QoZSwgdCkpO1xuICAgICAgcmV0dXJuIHQud3JpdGUoZSwgciwgMCksIHI7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJkKHQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLnQsXG4gICAgZGVjb2RlOiAoZSwgciA9IDApID0+IHQucmVhZChlLCByKVswXVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9uKHQpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gdCAmJiB0eXBlb2YgdC5maXhlZFNpemUgPT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIF9kKHQsIGUpIHtcbiAgaWYgKF9uKHQpICE9PSBfbihlKSlcbiAgICB0aHJvdyBuZXcgSW4oaGQpO1xuICBpZiAoX24odCkgJiYgX24oZSkgJiYgdC5maXhlZFNpemUgIT09IGUuZml4ZWRTaXplKVxuICAgIHRocm93IG5ldyBJbihkZCwge1xuICAgICAgZGVjb2RlckZpeGVkU2l6ZTogZS5maXhlZFNpemUsXG4gICAgICBlbmNvZGVyRml4ZWRTaXplOiB0LmZpeGVkU2l6ZVxuICAgIH0pO1xuICBpZiAoIV9uKHQpICYmICFfbihlKSAmJiB0Lm1heFNpemUgIT09IGUubWF4U2l6ZSlcbiAgICB0aHJvdyBuZXcgSW4ocGQsIHtcbiAgICAgIGRlY29kZXJNYXhTaXplOiBlLm1heFNpemUsXG4gICAgICBlbmNvZGVyTWF4U2l6ZTogdC5tYXhTaXplXG4gICAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZSxcbiAgICAuLi50LFxuICAgIGRlY29kZTogZS5kZWNvZGUsXG4gICAgZW5jb2RlOiB0LmVuY29kZSxcbiAgICByZWFkOiBlLnJlYWQsXG4gICAgd3JpdGU6IHQud3JpdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIEVkKHQsIGUsIHIgPSAwKSB7XG4gIGlmIChlLmxlbmd0aCAtIHIgPD0gMClcbiAgICB0aHJvdyBuZXcgSW4obGQsIHtcbiAgICAgIGNvZGVjRGVzY3JpcHRpb246IHRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIE1kKHQsIGUsIHIsIG4gPSAwKSB7XG4gIGNvbnN0IG8gPSByLmxlbmd0aCAtIG47XG4gIGlmIChvIDwgZSlcbiAgICB0aHJvdyBuZXcgSW4oZmQsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoOiBvLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbjogdCxcbiAgICAgIGV4cGVjdGVkOiBlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBDZCh0LCBlLCByLCBuKSB7XG4gIGlmIChuIDwgZSB8fCBuID4gcilcbiAgICB0aHJvdyBuZXcgSW4obWQsIHtcbiAgICAgIGNvZGVjRGVzY3JpcHRpb246IHQsXG4gICAgICBtYXg6IHIsXG4gICAgICBtaW46IGUsXG4gICAgICB2YWx1ZTogblxuICAgIH0pO1xufVxuZnVuY3Rpb24gVGModCkge1xuICByZXR1cm4gKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZW5kaWFuKSAhPT0gMTtcbn1cbmZ1bmN0aW9uIFNkKHQpIHtcbiAgcmV0dXJuIHhkKHtcbiAgICBmaXhlZFNpemU6IHQuc2l6ZSxcbiAgICB3cml0ZShlLCByLCBuKSB7XG4gICAgICB0LnJhbmdlICYmIENkKHQubmFtZSwgdC5yYW5nZVswXSwgdC5yYW5nZVsxXSwgZSk7XG4gICAgICBjb25zdCBvID0gbmV3IEFycmF5QnVmZmVyKHQuc2l6ZSk7XG4gICAgICByZXR1cm4gdC5zZXQobmV3IERhdGFWaWV3KG8pLCBlLCBUYyh0LmNvbmZpZykpLCByLnNldChuZXcgVWludDhBcnJheShvKSwgbiksIG4gKyB0LnNpemU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEFkKHQpIHtcbiAgcmV0dXJuIGJkKHtcbiAgICBmaXhlZFNpemU6IHQuc2l6ZSxcbiAgICByZWFkKGUsIHIgPSAwKSB7XG4gICAgICBFZCh0Lm5hbWUsIGUsIHIpLCBNZCh0Lm5hbWUsIHQuc2l6ZSwgZSwgcik7XG4gICAgICBjb25zdCBuID0gbmV3IERhdGFWaWV3KGtkKGUsIHIsIHQuc2l6ZSkpO1xuICAgICAgcmV0dXJuIFt0LmdldChuLCBUYyh0LmNvbmZpZykpLCByICsgdC5zaXplXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24ga2QodCwgZSwgcikge1xuICBjb25zdCBuID0gdC5ieXRlT2Zmc2V0ICsgKGUgPz8gMCksIG8gPSByID8/IHQuYnl0ZUxlbmd0aDtcbiAgcmV0dXJuIHQuYnVmZmVyLnNsaWNlKG4sIG4gKyBvKTtcbn1cbnZhciBJZCA9ICh0ID0ge30pID0+IFNkKHtcbiAgY29uZmlnOiB0LFxuICBuYW1lOiBcInU2NFwiLFxuICByYW5nZTogWzBuLCBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIildLFxuICBzZXQ6IChlLCByLCBuKSA9PiBlLnNldEJpZ1VpbnQ2NCgwLCBCaWdJbnQociksIG4pLFxuICBzaXplOiA4XG59KSwgQmQgPSAodCA9IHt9KSA9PiBBZCh7XG4gIGNvbmZpZzogdCxcbiAgZ2V0OiAoZSwgcikgPT4gZS5nZXRCaWdVaW50NjQoMCwgciksXG4gIG5hbWU6IFwidTY0XCIsXG4gIHNpemU6IDhcbn0pLCBSZCA9ICh0ID0ge30pID0+IF9kKElkKHQpLCBCZCh0KSk7XG5jbGFzcyBUZCBleHRlbmRzIFR5cGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGUsIHIpIHtcbiAgICBsZXQgbjtcbiAgICBjb25zdCB7IG1lc3NhZ2U6IG8sIGV4cGxhbmF0aW9uOiBpLCAuLi5jIH0gPSBlLCB7IHBhdGg6IGYgfSA9IGUsIHYgPSBmLmxlbmd0aCA9PT0gMCA/IG8gOiBgQXQgcGF0aDogJHtmLmpvaW4oXCIuXCIpfSAtLSAke299YDtcbiAgICBzdXBlcihpID8/IHYpLCBpICE9IG51bGwgJiYgKHRoaXMuY2F1c2UgPSB2KSwgT2JqZWN0LmFzc2lnbih0aGlzLCBjKSwgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCB0aGlzLmZhaWx1cmVzID0gKCkgPT4gbiA/PyAobiA9IFtlLCAuLi5yKCldKTtcbiAgfVxufVxuZnVuY3Rpb24gTGQodCkge1xuICByZXR1cm4gUGkodCkgJiYgdHlwZW9mIHRbU3ltYm9sLml0ZXJhdG9yXSA9PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBQaSh0KSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHhzKHQpIHtcbiAgcmV0dXJuIFBpKHQpICYmICFBcnJheS5pc0FycmF5KHQpO1xufVxuZnVuY3Rpb24gSnQodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzeW1ib2xcIiA/IHQudG9TdHJpbmcoKSA6IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBKU09OLnN0cmluZ2lmeSh0KSA6IGAke3R9YDtcbn1cbmZ1bmN0aW9uIE9kKHQpIHtcbiAgY29uc3QgeyBkb25lOiBlLCB2YWx1ZTogciB9ID0gdC5uZXh0KCk7XG4gIHJldHVybiBlID8gdm9pZCAwIDogcjtcbn1cbmZ1bmN0aW9uIE5kKHQsIGUsIHIsIG4pIHtcbiAgaWYgKHQgPT09ICEwKVxuICAgIHJldHVybjtcbiAgdCA9PT0gITEgPyB0ID0ge30gOiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0geyBtZXNzYWdlOiB0IH0pO1xuICBjb25zdCB7IHBhdGg6IG8sIGJyYW5jaDogaSB9ID0gZSwgeyB0eXBlOiBjIH0gPSByLCB7IHJlZmluZW1lbnQ6IGYsIG1lc3NhZ2U6IHYgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7Y31cXGAke2YgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke2Z9XFxgYCA6IFwiXCJ9LCBidXQgcmVjZWl2ZWQ6IFxcYCR7SnQobil9XFxgYCB9ID0gdDtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogbixcbiAgICB0eXBlOiBjLFxuICAgIHJlZmluZW1lbnQ6IGYsXG4gICAga2V5OiBvW28ubGVuZ3RoIC0gMV0sXG4gICAgcGF0aDogbyxcbiAgICBicmFuY2g6IGksXG4gICAgLi4udCxcbiAgICBtZXNzYWdlOiB2XG4gIH07XG59XG5mdW5jdGlvbiogaXUodCwgZSwgciwgbikge1xuICBMZCh0KSB8fCAodCA9IFt0XSk7XG4gIGZvciAoY29uc3QgbyBvZiB0KSB7XG4gICAgY29uc3QgaSA9IE5kKG8sIGUsIHIsIG4pO1xuICAgIGkgJiYgKHlpZWxkIGkpO1xuICB9XG59XG5mdW5jdGlvbiogbGEodCwgZSwgciA9IHt9KSB7XG4gIGNvbnN0IHsgcGF0aDogbiA9IFtdLCBicmFuY2g6IG8gPSBbdF0sIGNvZXJjZTogaSA9ICExLCBtYXNrOiBjID0gITEgfSA9IHIsIGYgPSB7IHBhdGg6IG4sIGJyYW5jaDogbywgbWFzazogYyB9O1xuICBpICYmICh0ID0gZS5jb2VyY2VyKHQsIGYpKTtcbiAgbGV0IHYgPSBcInZhbGlkXCI7XG4gIGZvciAoY29uc3QgeCBvZiBlLnZhbGlkYXRvcih0LCBmKSlcbiAgICB4LmV4cGxhbmF0aW9uID0gci5tZXNzYWdlLCB2ID0gXCJub3RfdmFsaWRcIiwgeWllbGQgW3gsIHZvaWQgMF07XG4gIGZvciAobGV0IFt4LCBiLCBTXSBvZiBlLmVudHJpZXModCwgZikpIHtcbiAgICBjb25zdCBUID0gbGEoYiwgUywge1xuICAgICAgcGF0aDogeCA9PT0gdm9pZCAwID8gbiA6IFsuLi5uLCB4XSxcbiAgICAgIGJyYW5jaDogeCA9PT0gdm9pZCAwID8gbyA6IFsuLi5vLCBiXSxcbiAgICAgIGNvZXJjZTogaSxcbiAgICAgIG1hc2s6IGMsXG4gICAgICBtZXNzYWdlOiByLm1lc3NhZ2VcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IEMgb2YgVClcbiAgICAgIENbMF0gPyAodiA9IENbMF0ucmVmaW5lbWVudCAhPSBudWxsID8gXCJub3RfcmVmaW5lZFwiIDogXCJub3RfdmFsaWRcIiwgeWllbGQgW0NbMF0sIHZvaWQgMF0pIDogaSAmJiAoYiA9IENbMV0sIHggPT09IHZvaWQgMCA/IHQgPSBiIDogdCBpbnN0YW5jZW9mIE1hcCA/IHQuc2V0KHgsIGIpIDogdCBpbnN0YW5jZW9mIFNldCA/IHQuYWRkKGIpIDogUGkodCkgJiYgKGIgIT09IHZvaWQgMCB8fCB4IGluIHQpICYmICh0W3hdID0gYikpO1xuICB9XG4gIGlmICh2ICE9PSBcIm5vdF92YWxpZFwiKVxuICAgIGZvciAoY29uc3QgeCBvZiBlLnJlZmluZXIodCwgZikpXG4gICAgICB4LmV4cGxhbmF0aW9uID0gci5tZXNzYWdlLCB2ID0gXCJub3RfcmVmaW5lZFwiLCB5aWVsZCBbeCwgdm9pZCAwXTtcbiAgdiA9PT0gXCJ2YWxpZFwiICYmICh5aWVsZCBbdm9pZCAwLCB0XSk7XG59XG5sZXQgY3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBjb25zdCB7IHR5cGU6IHIsIHNjaGVtYTogbiwgdmFsaWRhdG9yOiBvLCByZWZpbmVyOiBpLCBjb2VyY2VyOiBjID0gKHYpID0+IHYsIGVudHJpZXM6IGYgPSBmdW5jdGlvbiogKCkge1xuICAgIH0gfSA9IGU7XG4gICAgdGhpcy50eXBlID0gciwgdGhpcy5zY2hlbWEgPSBuLCB0aGlzLmVudHJpZXMgPSBmLCB0aGlzLmNvZXJjZXIgPSBjLCBvID8gdGhpcy52YWxpZGF0b3IgPSAodiwgeCkgPT4ge1xuICAgICAgY29uc3QgYiA9IG8odiwgeCk7XG4gICAgICByZXR1cm4gaXUoYiwgeCwgdGhpcywgdik7XG4gICAgfSA6IHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW10sIGkgPyB0aGlzLnJlZmluZXIgPSAodiwgeCkgPT4ge1xuICAgICAgY29uc3QgYiA9IGkodiwgeCk7XG4gICAgICByZXR1cm4gaXUoYiwgeCwgdGhpcywgdik7XG4gICAgfSA6IHRoaXMucmVmaW5lciA9ICgpID0+IFtdO1xuICB9XG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICovXG4gIGFzc2VydChlLCByKSB7XG4gICAgcmV0dXJuIGpkKGUsIHRoaXMsIHIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyBjb2VyY2lvbiBsb2dpYywgdGhlbiB2YWxpZGF0ZSBpdC5cbiAgICovXG4gIGNyZWF0ZShlLCByKSB7XG4gICAgcmV0dXJuIHhpKGUsIHRoaXMsIHIpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbi5cbiAgICovXG4gIGlzKGUpIHtcbiAgICByZXR1cm4gTGMoZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1hc2sgYSB2YWx1ZSwgY29lcmNpbmcgYW5kIHZhbGlkYXRpbmcgaXQsIGJ1dCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mXG4gICAqIHByb3BlcnRpZXMgZGVmaW5lZCBieSB0aGUgc3RydWN0J3Mgc2NoZW1hLiBNYXNraW5nIGFwcGxpZXMgcmVjdXJzaXZlbHkgdG9cbiAgICogcHJvcHMgb2YgYG9iamVjdGAgc3RydWN0cyBvbmx5LlxuICAgKi9cbiAgbWFzayhlLCByKSB7XG4gICAgcmV0dXJuIFVkKGUsIHRoaXMsIHIpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgY29lcmNlYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgKiBjb250YWluIHRoZSBjb2VyY2VkIHJlc3VsdCB3aGVuIHN1Y2Nlc3NmdWwuIEFsc28sIGBtYXNrYCB3aWxsIHR1cm4gb25cbiAgICogbWFza2luZyBvZiB0aGUgdW5rbm93biBgb2JqZWN0YCBwcm9wcyByZWN1cnNpdmVseSBpZiBwYXNzZWQuXG4gICAqL1xuICB2YWxpZGF0ZShlLCByID0ge30pIHtcbiAgICByZXR1cm4gRGkoZSwgdGhpcywgcik7XG4gIH1cbn07XG5mdW5jdGlvbiBqZCh0LCBlLCByKSB7XG4gIGNvbnN0IG4gPSBEaSh0LCBlLCB7IG1lc3NhZ2U6IHIgfSk7XG4gIGlmIChuWzBdKVxuICAgIHRocm93IG5bMF07XG59XG5mdW5jdGlvbiB4aSh0LCBlLCByKSB7XG4gIGNvbnN0IG4gPSBEaSh0LCBlLCB7IGNvZXJjZTogITAsIG1lc3NhZ2U6IHIgfSk7XG4gIGlmIChuWzBdKVxuICAgIHRocm93IG5bMF07XG4gIHJldHVybiBuWzFdO1xufVxuZnVuY3Rpb24gVWQodCwgZSwgcikge1xuICBjb25zdCBuID0gRGkodCwgZSwgeyBjb2VyY2U6ICEwLCBtYXNrOiAhMCwgbWVzc2FnZTogciB9KTtcbiAgaWYgKG5bMF0pXG4gICAgdGhyb3cgblswXTtcbiAgcmV0dXJuIG5bMV07XG59XG5mdW5jdGlvbiBMYyh0LCBlKSB7XG4gIHJldHVybiAhRGkodCwgZSlbMF07XG59XG5mdW5jdGlvbiBEaSh0LCBlLCByID0ge30pIHtcbiAgY29uc3QgbiA9IGxhKHQsIGUsIHIpLCBvID0gT2Qobik7XG4gIHJldHVybiBvWzBdID8gW25ldyBUZChvWzBdLCBmdW5jdGlvbiogKCkge1xuICAgIGZvciAoY29uc3QgYyBvZiBuKVxuICAgICAgY1swXSAmJiAoeWllbGQgY1swXSk7XG4gIH0pLCB2b2lkIDBdIDogW3ZvaWQgMCwgb1sxXV07XG59XG5mdW5jdGlvbiBobih0LCBlKSB7XG4gIHJldHVybiBuZXcgY3IoeyB0eXBlOiB0LCBzY2hlbWE6IG51bGwsIHZhbGlkYXRvcjogZSB9KTtcbn1cbmZ1bmN0aW9uIEZkKCkge1xuICByZXR1cm4gaG4oXCJhbnlcIiwgKCkgPT4gITApO1xufVxuZnVuY3Rpb24gZmUodCkge1xuICByZXR1cm4gbmV3IGNyKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hOiB0LFxuICAgICplbnRyaWVzKGUpIHtcbiAgICAgIGlmICh0ICYmIEFycmF5LmlzQXJyYXkoZSkpXG4gICAgICAgIGZvciAoY29uc3QgW3IsIG5dIG9mIGUuZW50cmllcygpKVxuICAgICAgICAgIHlpZWxkIFtyLCBuLCB0XTtcbiAgICB9LFxuICAgIGNvZXJjZXIoZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgPyBlLnNsaWNlKCkgOiBlO1xuICAgIH0sXG4gICAgdmFsaWRhdG9yKGUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGUpIHx8IGBFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiAke0p0KGUpfWA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVyKCkge1xuICByZXR1cm4gaG4oXCJib29sZWFuXCIsICh0KSA9PiB0eXBlb2YgdCA9PSBcImJvb2xlYW5cIik7XG59XG5mdW5jdGlvbiBmYSh0KSB7XG4gIHJldHVybiBobihcImluc3RhbmNlXCIsIChlKSA9PiBlIGluc3RhbmNlb2YgdCB8fCBgRXhwZWN0ZWQgYSBcXGAke3QubmFtZX1cXGAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogJHtKdChlKX1gKTtcbn1cbmZ1bmN0aW9uIGR0KHQpIHtcbiAgY29uc3QgZSA9IEp0KHQpLCByID0gdHlwZW9mIHQ7XG4gIHJldHVybiBuZXcgY3Ioe1xuICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgIHNjaGVtYTogciA9PT0gXCJzdHJpbmdcIiB8fCByID09PSBcIm51bWJlclwiIHx8IHIgPT09IFwiYm9vbGVhblwiID8gdCA6IG51bGwsXG4gICAgdmFsaWRhdG9yKG4pIHtcbiAgICAgIHJldHVybiBuID09PSB0IHx8IGBFeHBlY3RlZCB0aGUgbGl0ZXJhbCBcXGAke2V9XFxgLCBidXQgcmVjZWl2ZWQ6ICR7SnQobil9YDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gUGQoKSB7XG4gIHJldHVybiBobihcIm5ldmVyXCIsICgpID0+ICExKTtcbn1cbmZ1bmN0aW9uIGhlKHQpIHtcbiAgcmV0dXJuIG5ldyBjcih7XG4gICAgLi4udCxcbiAgICB2YWxpZGF0b3I6IChlLCByKSA9PiBlID09PSBudWxsIHx8IHQudmFsaWRhdG9yKGUsIHIpLFxuICAgIHJlZmluZXI6IChlLCByKSA9PiBlID09PSBudWxsIHx8IHQucmVmaW5lcihlLCByKVxuICB9KTtcbn1cbmZ1bmN0aW9uIEooKSB7XG4gIHJldHVybiBobihcIm51bWJlclwiLCAodCkgPT4gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiAmJiAhaXNOYU4odCkgfHwgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7SnQodCl9YCk7XG59XG5mdW5jdGlvbiBFZSh0KSB7XG4gIHJldHVybiBuZXcgY3Ioe1xuICAgIC4uLnQsXG4gICAgdmFsaWRhdG9yOiAoZSwgcikgPT4gZSA9PT0gdm9pZCAwIHx8IHQudmFsaWRhdG9yKGUsIHIpLFxuICAgIHJlZmluZXI6IChlLCByKSA9PiBlID09PSB2b2lkIDAgfHwgdC5yZWZpbmVyKGUsIHIpXG4gIH0pO1xufVxuZnVuY3Rpb24gT2ModCwgZSkge1xuICByZXR1cm4gbmV3IGNyKHtcbiAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICAqZW50cmllcyhyKSB7XG4gICAgICBpZiAoUGkocikpXG4gICAgICAgIGZvciAoY29uc3QgbiBpbiByKSB7XG4gICAgICAgICAgY29uc3QgbyA9IHJbbl07XG4gICAgICAgICAgeWllbGQgW24sIG4sIHRdLCB5aWVsZCBbbiwgbywgZV07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRvcihyKSB7XG4gICAgICByZXR1cm4geHMocikgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke0p0KHIpfWA7XG4gICAgfSxcbiAgICBjb2VyY2VyKHIpIHtcbiAgICAgIHJldHVybiB4cyhyKSA/IHsgLi4uciB9IDogcjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaWUoKSB7XG4gIHJldHVybiBobihcInN0cmluZ1wiLCAodCkgPT4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiB8fCBgRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogJHtKdCh0KX1gKTtcbn1cbmZ1bmN0aW9uIGhhKHQpIHtcbiAgY29uc3QgZSA9IFBkKCk7XG4gIHJldHVybiBuZXcgY3Ioe1xuICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXMocikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocikpIHtcbiAgICAgICAgY29uc3QgbiA9IE1hdGgubWF4KHQubGVuZ3RoLCByLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbjsgbysrKVxuICAgICAgICAgIHlpZWxkIFtvLCByW29dLCB0W29dIHx8IGVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHIpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHIpIHx8IGBFeHBlY3RlZCBhbiBhcnJheSwgYnV0IHJlY2VpdmVkOiAke0p0KHIpfWA7XG4gICAgfSxcbiAgICBjb2VyY2VyKHIpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHIpID8gci5zbGljZSgpIDogcjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdGUodCkge1xuICBjb25zdCBlID0gT2JqZWN0LmtleXModCk7XG4gIHJldHVybiBuZXcgY3Ioe1xuICAgIHR5cGU6IFwidHlwZVwiLFxuICAgIHNjaGVtYTogdCxcbiAgICAqZW50cmllcyhyKSB7XG4gICAgICBpZiAoUGkocikpXG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBlKVxuICAgICAgICAgIHlpZWxkIFtuLCByW25dLCB0W25dXTtcbiAgICB9LFxuICAgIHZhbGlkYXRvcihyKSB7XG4gICAgICByZXR1cm4geHMocikgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke0p0KHIpfWA7XG4gICAgfSxcbiAgICBjb2VyY2VyKHIpIHtcbiAgICAgIHJldHVybiB4cyhyKSA/IHsgLi4uciB9IDogcjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gVXQodCkge1xuICBjb25zdCBlID0gdC5tYXAoKHIpID0+IHIudHlwZSkuam9pbihcIiB8IFwiKTtcbiAgcmV0dXJuIG5ldyBjcih7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICBjb2VyY2VyKHIsIG4pIHtcbiAgICAgIGZvciAoY29uc3QgbyBvZiB0KSB7XG4gICAgICAgIGNvbnN0IFtpLCBjXSA9IG8udmFsaWRhdGUociwge1xuICAgICAgICAgIGNvZXJjZTogITAsXG4gICAgICAgICAgbWFzazogbi5tYXNrXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHZhbGlkYXRvcihyLCBuKSB7XG4gICAgICBjb25zdCBvID0gW107XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgdCkge1xuICAgICAgICBjb25zdCBbLi4uY10gPSBsYShyLCBpLCBuKSwgW2ZdID0gYztcbiAgICAgICAgaWYgKGZbMF0pXG4gICAgICAgICAgZm9yIChjb25zdCBbdl0gb2YgYylcbiAgICAgICAgICAgIHYgJiYgby5wdXNoKHYpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtlfVxcYCwgYnV0IHJlY2VpdmVkOiAke0p0KHIpfWAsXG4gICAgICAgIC4uLm9cbiAgICAgIF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHpuKCkge1xuICByZXR1cm4gaG4oXCJ1bmtub3duXCIsICgpID0+ICEwKTtcbn1cbmZ1bmN0aW9uICRpKHQsIGUsIHIpIHtcbiAgcmV0dXJuIG5ldyBjcih7XG4gICAgLi4udCxcbiAgICBjb2VyY2VyOiAobiwgbykgPT4gTGMobiwgZSkgPyB0LmNvZXJjZXIocihuLCBvKSwgbykgOiB0LmNvZXJjZXIobiwgbylcbiAgfSk7XG59XG52YXIgR2ksIERkID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZnVuY3Rpb24gTmMoKSB7XG4gIGlmICghR2kgJiYgKEdpID0gdHlwZW9mIGNyeXB0byA8IFwidVwiICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvIDwgXCJ1XCIgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSBcImZ1bmN0aW9uXCIgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pLCAhR2kpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkXCIpO1xuICByZXR1cm4gR2koRGQpO1xufVxuY29uc3QgJGQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5mdW5jdGlvbiBGcyh0KSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICRkLnRlc3QodCk7XG59XG52YXIgTXQgPSBbXTtcbmZvciAodmFyIGFvID0gMDsgYW8gPCAyNTY7ICsrYW8pXG4gIE10LnB1c2goKGFvICsgMjU2KS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbmZ1bmN0aW9uIFBzKHQpIHtcbiAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDAsIHIgPSAoTXRbdFtlICsgMF1dICsgTXRbdFtlICsgMV1dICsgTXRbdFtlICsgMl1dICsgTXRbdFtlICsgM11dICsgXCItXCIgKyBNdFt0W2UgKyA0XV0gKyBNdFt0W2UgKyA1XV0gKyBcIi1cIiArIE10W3RbZSArIDZdXSArIE10W3RbZSArIDddXSArIFwiLVwiICsgTXRbdFtlICsgOF1dICsgTXRbdFtlICsgOV1dICsgXCItXCIgKyBNdFt0W2UgKyAxMF1dICsgTXRbdFtlICsgMTFdXSArIE10W3RbZSArIDEyXV0gKyBNdFt0W2UgKyAxM11dICsgTXRbdFtlICsgMTRdXSArIE10W3RbZSArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghRnMocikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkXCIpO1xuICByZXR1cm4gcjtcbn1cbnZhciBzdSwgdW8sIGNvID0gMCwgbG8gPSAwO1xuZnVuY3Rpb24gemQodCwgZSwgcikge1xuICB2YXIgbiA9IGUgJiYgciB8fCAwLCBvID0gZSB8fCBuZXcgQXJyYXkoMTYpO1xuICB0ID0gdCB8fCB7fTtcbiAgdmFyIGkgPSB0Lm5vZGUgfHwgc3UsIGMgPSB0LmNsb2Nrc2VxICE9PSB2b2lkIDAgPyB0LmNsb2Nrc2VxIDogdW87XG4gIGlmIChpID09IG51bGwgfHwgYyA9PSBudWxsKSB7XG4gICAgdmFyIGYgPSB0LnJhbmRvbSB8fCAodC5ybmcgfHwgTmMpKCk7XG4gICAgaSA9PSBudWxsICYmIChpID0gc3UgPSBbZlswXSB8IDEsIGZbMV0sIGZbMl0sIGZbM10sIGZbNF0sIGZbNV1dKSwgYyA9PSBudWxsICYmIChjID0gdW8gPSAoZls2XSA8PCA4IHwgZls3XSkgJiAxNjM4Myk7XG4gIH1cbiAgdmFyIHYgPSB0Lm1zZWNzICE9PSB2b2lkIDAgPyB0Lm1zZWNzIDogRGF0ZS5ub3coKSwgeCA9IHQubnNlY3MgIT09IHZvaWQgMCA/IHQubnNlY3MgOiBsbyArIDEsIGIgPSB2IC0gY28gKyAoeCAtIGxvKSAvIDFlNDtcbiAgaWYgKGIgPCAwICYmIHQuY2xvY2tzZXEgPT09IHZvaWQgMCAmJiAoYyA9IGMgKyAxICYgMTYzODMpLCAoYiA8IDAgfHwgdiA+IGNvKSAmJiB0Lm5zZWNzID09PSB2b2lkIDAgJiYgKHggPSAwKSwgeCA+PSAxZTQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIGNvID0gdiwgbG8gPSB4LCB1byA9IGMsIHYgKz0gMTIyMTkyOTI4ZTU7XG4gIHZhciBTID0gKCh2ICYgMjY4NDM1NDU1KSAqIDFlNCArIHgpICUgNDI5NDk2NzI5NjtcbiAgb1tuKytdID0gUyA+Pj4gMjQgJiAyNTUsIG9bbisrXSA9IFMgPj4+IDE2ICYgMjU1LCBvW24rK10gPSBTID4+PiA4ICYgMjU1LCBvW24rK10gPSBTICYgMjU1O1xuICB2YXIgVCA9IHYgLyA0Mjk0OTY3Mjk2ICogMWU0ICYgMjY4NDM1NDU1O1xuICBvW24rK10gPSBUID4+PiA4ICYgMjU1LCBvW24rK10gPSBUICYgMjU1LCBvW24rK10gPSBUID4+PiAyNCAmIDE1IHwgMTYsIG9bbisrXSA9IFQgPj4+IDE2ICYgMjU1LCBvW24rK10gPSBjID4+PiA4IHwgMTI4LCBvW24rK10gPSBjICYgMjU1O1xuICBmb3IgKHZhciBDID0gMDsgQyA8IDY7ICsrQylcbiAgICBvW24gKyBDXSA9IGlbQ107XG4gIHJldHVybiBlIHx8IFBzKG8pO1xufVxuZnVuY3Rpb24gamModCkge1xuICBpZiAoIUZzKHQpKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgVVVJRFwiKTtcbiAgdmFyIGUsIHIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHJldHVybiByWzBdID0gKGUgPSBwYXJzZUludCh0LnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNCwgclsxXSA9IGUgPj4+IDE2ICYgMjU1LCByWzJdID0gZSA+Pj4gOCAmIDI1NSwgclszXSA9IGUgJiAyNTUsIHJbNF0gPSAoZSA9IHBhcnNlSW50KHQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4LCByWzVdID0gZSAmIDI1NSwgcls2XSA9IChlID0gcGFyc2VJbnQodC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4LCByWzddID0gZSAmIDI1NSwgcls4XSA9IChlID0gcGFyc2VJbnQodC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4LCByWzldID0gZSAmIDI1NSwgclsxMF0gPSAoZSA9IHBhcnNlSW50KHQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDEwOTk1MTE2Mjc3NzYgJiAyNTUsIHJbMTFdID0gZSAvIDQyOTQ5NjcyOTYgJiAyNTUsIHJbMTJdID0gZSA+Pj4gMjQgJiAyNTUsIHJbMTNdID0gZSA+Pj4gMTYgJiAyNTUsIHJbMTRdID0gZSA+Pj4gOCAmIDI1NSwgclsxNV0gPSBlICYgMjU1LCByO1xufVxuZnVuY3Rpb24gcWQodCkge1xuICB0ID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHQpKTtcbiAgZm9yICh2YXIgZSA9IFtdLCByID0gMDsgciA8IHQubGVuZ3RoOyArK3IpXG4gICAgZS5wdXNoKHQuY2hhckNvZGVBdChyKSk7XG4gIHJldHVybiBlO1xufVxudmFyIFpkID0gXCI2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIiwgVmQgPSBcIjZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOFwiO1xuZnVuY3Rpb24gVWModCwgZSwgcikge1xuICBmdW5jdGlvbiBuKG8sIGksIGMsIGYpIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAobyA9IHFkKG8pKSwgdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiAoaSA9IGpjKGkpKSwgaS5sZW5ndGggIT09IDE2KVxuICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KVwiKTtcbiAgICB2YXIgdiA9IG5ldyBVaW50OEFycmF5KDE2ICsgby5sZW5ndGgpO1xuICAgIGlmICh2LnNldChpKSwgdi5zZXQobywgaS5sZW5ndGgpLCB2ID0gcih2KSwgdls2XSA9IHZbNl0gJiAxNSB8IGUsIHZbOF0gPSB2WzhdICYgNjMgfCAxMjgsIGMpIHtcbiAgICAgIGYgPSBmIHx8IDA7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDE2OyArK3gpXG4gICAgICAgIGNbZiArIHhdID0gdlt4XTtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICByZXR1cm4gUHModik7XG4gIH1cbiAgdHJ5IHtcbiAgICBuLm5hbWUgPSB0O1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gbi5ETlMgPSBaZCwgbi5VUkwgPSBWZCwgbjtcbn1cbmZ1bmN0aW9uIEhkKHQpIHtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgZSA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0KSk7XG4gICAgdCA9IG5ldyBVaW50OEFycmF5KGUubGVuZ3RoKTtcbiAgICBmb3IgKHZhciByID0gMDsgciA8IGUubGVuZ3RoOyArK3IpXG4gICAgICB0W3JdID0gZS5jaGFyQ29kZUF0KHIpO1xuICB9XG4gIHJldHVybiBLZChXZChHZCh0KSwgdC5sZW5ndGggKiA4KSk7XG59XG5mdW5jdGlvbiBLZCh0KSB7XG4gIGZvciAodmFyIGUgPSBbXSwgciA9IHQubGVuZ3RoICogMzIsIG4gPSBcIjAxMjM0NTY3ODlhYmNkZWZcIiwgbyA9IDA7IG8gPCByOyBvICs9IDgpIHtcbiAgICB2YXIgaSA9IHRbbyA+PiA1XSA+Pj4gbyAlIDMyICYgMjU1LCBjID0gcGFyc2VJbnQobi5jaGFyQXQoaSA+Pj4gNCAmIDE1KSArIG4uY2hhckF0KGkgJiAxNSksIDE2KTtcbiAgICBlLnB1c2goYyk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBGYyh0KSB7XG4gIHJldHVybiAodCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuZnVuY3Rpb24gV2QodCwgZSkge1xuICB0W2UgPj4gNV0gfD0gMTI4IDw8IGUgJSAzMiwgdFtGYyhlKSAtIDFdID0gZTtcbiAgZm9yICh2YXIgciA9IDE3MzI1ODQxOTMsIG4gPSAtMjcxNzMzODc5LCBvID0gLTE3MzI1ODQxOTQsIGkgPSAyNzE3MzM4NzgsIGMgPSAwOyBjIDwgdC5sZW5ndGg7IGMgKz0gMTYpIHtcbiAgICB2YXIgZiA9IHIsIHYgPSBuLCB4ID0gbywgYiA9IGk7XG4gICAgciA9IEF0KHIsIG4sIG8sIGksIHRbY10sIDcsIC02ODA4NzY5MzYpLCBpID0gQXQoaSwgciwgbiwgbywgdFtjICsgMV0sIDEyLCAtMzg5NTY0NTg2KSwgbyA9IEF0KG8sIGksIHIsIG4sIHRbYyArIDJdLCAxNywgNjA2MTA1ODE5KSwgbiA9IEF0KG4sIG8sIGksIHIsIHRbYyArIDNdLCAyMiwgLTEwNDQ1MjUzMzApLCByID0gQXQociwgbiwgbywgaSwgdFtjICsgNF0sIDcsIC0xNzY0MTg4OTcpLCBpID0gQXQoaSwgciwgbiwgbywgdFtjICsgNV0sIDEyLCAxMjAwMDgwNDI2KSwgbyA9IEF0KG8sIGksIHIsIG4sIHRbYyArIDZdLCAxNywgLTE0NzMyMzEzNDEpLCBuID0gQXQobiwgbywgaSwgciwgdFtjICsgN10sIDIyLCAtNDU3MDU5ODMpLCByID0gQXQociwgbiwgbywgaSwgdFtjICsgOF0sIDcsIDE3NzAwMzU0MTYpLCBpID0gQXQoaSwgciwgbiwgbywgdFtjICsgOV0sIDEyLCAtMTk1ODQxNDQxNyksIG8gPSBBdChvLCBpLCByLCBuLCB0W2MgKyAxMF0sIDE3LCAtNDIwNjMpLCBuID0gQXQobiwgbywgaSwgciwgdFtjICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpLCByID0gQXQociwgbiwgbywgaSwgdFtjICsgMTJdLCA3LCAxODA0NjAzNjgyKSwgaSA9IEF0KGksIHIsIG4sIG8sIHRbYyArIDEzXSwgMTIsIC00MDM0MTEwMSksIG8gPSBBdChvLCBpLCByLCBuLCB0W2MgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCksIG4gPSBBdChuLCBvLCBpLCByLCB0W2MgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KSwgciA9IGt0KHIsIG4sIG8sIGksIHRbYyArIDFdLCA1LCAtMTY1Nzk2NTEwKSwgaSA9IGt0KGksIHIsIG4sIG8sIHRbYyArIDZdLCA5LCAtMTA2OTUwMTYzMiksIG8gPSBrdChvLCBpLCByLCBuLCB0W2MgKyAxMV0sIDE0LCA2NDM3MTc3MTMpLCBuID0ga3QobiwgbywgaSwgciwgdFtjXSwgMjAsIC0zNzM4OTczMDIpLCByID0ga3QociwgbiwgbywgaSwgdFtjICsgNV0sIDUsIC03MDE1NTg2OTEpLCBpID0ga3QoaSwgciwgbiwgbywgdFtjICsgMTBdLCA5LCAzODAxNjA4MyksIG8gPSBrdChvLCBpLCByLCBuLCB0W2MgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KSwgbiA9IGt0KG4sIG8sIGksIHIsIHRbYyArIDRdLCAyMCwgLTQwNTUzNzg0OCksIHIgPSBrdChyLCBuLCBvLCBpLCB0W2MgKyA5XSwgNSwgNTY4NDQ2NDM4KSwgaSA9IGt0KGksIHIsIG4sIG8sIHRbYyArIDE0XSwgOSwgLTEwMTk4MDM2OTApLCBvID0ga3QobywgaSwgciwgbiwgdFtjICsgM10sIDE0LCAtMTg3MzYzOTYxKSwgbiA9IGt0KG4sIG8sIGksIHIsIHRbYyArIDhdLCAyMCwgMTE2MzUzMTUwMSksIHIgPSBrdChyLCBuLCBvLCBpLCB0W2MgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KSwgaSA9IGt0KGksIHIsIG4sIG8sIHRbYyArIDJdLCA5LCAtNTE0MDM3ODQpLCBvID0ga3QobywgaSwgciwgbiwgdFtjICsgN10sIDE0LCAxNzM1MzI4NDczKSwgbiA9IGt0KG4sIG8sIGksIHIsIHRbYyArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KSwgciA9IEl0KHIsIG4sIG8sIGksIHRbYyArIDVdLCA0LCAtMzc4NTU4KSwgaSA9IEl0KGksIHIsIG4sIG8sIHRbYyArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpLCBvID0gSXQobywgaSwgciwgbiwgdFtjICsgMTFdLCAxNiwgMTgzOTAzMDU2MiksIG4gPSBJdChuLCBvLCBpLCByLCB0W2MgKyAxNF0sIDIzLCAtMzUzMDk1NTYpLCByID0gSXQociwgbiwgbywgaSwgdFtjICsgMV0sIDQsIC0xNTMwOTkyMDYwKSwgaSA9IEl0KGksIHIsIG4sIG8sIHRbYyArIDRdLCAxMSwgMTI3Mjg5MzM1MyksIG8gPSBJdChvLCBpLCByLCBuLCB0W2MgKyA3XSwgMTYsIC0xNTU0OTc2MzIpLCBuID0gSXQobiwgbywgaSwgciwgdFtjICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApLCByID0gSXQociwgbiwgbywgaSwgdFtjICsgMTNdLCA0LCA2ODEyNzkxNzQpLCBpID0gSXQoaSwgciwgbiwgbywgdFtjXSwgMTEsIC0zNTg1MzcyMjIpLCBvID0gSXQobywgaSwgciwgbiwgdFtjICsgM10sIDE2LCAtNzIyNTIxOTc5KSwgbiA9IEl0KG4sIG8sIGksIHIsIHRbYyArIDZdLCAyMywgNzYwMjkxODkpLCByID0gSXQociwgbiwgbywgaSwgdFtjICsgOV0sIDQsIC02NDAzNjQ0ODcpLCBpID0gSXQoaSwgciwgbiwgbywgdFtjICsgMTJdLCAxMSwgLTQyMTgxNTgzNSksIG8gPSBJdChvLCBpLCByLCBuLCB0W2MgKyAxNV0sIDE2LCA1MzA3NDI1MjApLCBuID0gSXQobiwgbywgaSwgciwgdFtjICsgMl0sIDIzLCAtOTk1MzM4NjUxKSwgciA9IEJ0KHIsIG4sIG8sIGksIHRbY10sIDYsIC0xOTg2MzA4NDQpLCBpID0gQnQoaSwgciwgbiwgbywgdFtjICsgN10sIDEwLCAxMTI2ODkxNDE1KSwgbyA9IEJ0KG8sIGksIHIsIG4sIHRbYyArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KSwgbiA9IEJ0KG4sIG8sIGksIHIsIHRbYyArIDVdLCAyMSwgLTU3NDM0MDU1KSwgciA9IEJ0KHIsIG4sIG8sIGksIHRbYyArIDEyXSwgNiwgMTcwMDQ4NTU3MSksIGkgPSBCdChpLCByLCBuLCBvLCB0W2MgKyAzXSwgMTAsIC0xODk0OTg2NjA2KSwgbyA9IEJ0KG8sIGksIHIsIG4sIHRbYyArIDEwXSwgMTUsIC0xMDUxNTIzKSwgbiA9IEJ0KG4sIG8sIGksIHIsIHRbYyArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpLCByID0gQnQociwgbiwgbywgaSwgdFtjICsgOF0sIDYsIDE4NzMzMTMzNTkpLCBpID0gQnQoaSwgciwgbiwgbywgdFtjICsgMTVdLCAxMCwgLTMwNjExNzQ0KSwgbyA9IEJ0KG8sIGksIHIsIG4sIHRbYyArIDZdLCAxNSwgLTE1NjAxOTgzODApLCBuID0gQnQobiwgbywgaSwgciwgdFtjICsgMTNdLCAyMSwgMTMwOTE1MTY0OSksIHIgPSBCdChyLCBuLCBvLCBpLCB0W2MgKyA0XSwgNiwgLTE0NTUyMzA3MCksIGkgPSBCdChpLCByLCBuLCBvLCB0W2MgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSksIG8gPSBCdChvLCBpLCByLCBuLCB0W2MgKyAyXSwgMTUsIDcxODc4NzI1OSksIG4gPSBCdChuLCBvLCBpLCByLCB0W2MgKyA5XSwgMjEsIC0zNDM0ODU1NTEpLCByID0gSXIociwgZiksIG4gPSBJcihuLCB2KSwgbyA9IElyKG8sIHgpLCBpID0gSXIoaSwgYik7XG4gIH1cbiAgcmV0dXJuIFtyLCBuLCBvLCBpXTtcbn1cbmZ1bmN0aW9uIEdkKHQpIHtcbiAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgZm9yICh2YXIgZSA9IHQubGVuZ3RoICogOCwgciA9IG5ldyBVaW50MzJBcnJheShGYyhlKSksIG4gPSAwOyBuIDwgZTsgbiArPSA4KVxuICAgIHJbbiA+PiA1XSB8PSAodFtuIC8gOF0gJiAyNTUpIDw8IG4gJSAzMjtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBJcih0LCBlKSB7XG4gIHZhciByID0gKHQgJiA2NTUzNSkgKyAoZSAmIDY1NTM1KSwgbiA9ICh0ID4+IDE2KSArIChlID4+IDE2KSArIChyID4+IDE2KTtcbiAgcmV0dXJuIG4gPDwgMTYgfCByICYgNjU1MzU7XG59XG5mdW5jdGlvbiBZZCh0LCBlKSB7XG4gIHJldHVybiB0IDw8IGUgfCB0ID4+PiAzMiAtIGU7XG59XG5mdW5jdGlvbiBEcyh0LCBlLCByLCBuLCBvLCBpKSB7XG4gIHJldHVybiBJcihZZChJcihJcihlLCB0KSwgSXIobiwgaSkpLCBvKSwgcik7XG59XG5mdW5jdGlvbiBBdCh0LCBlLCByLCBuLCBvLCBpLCBjKSB7XG4gIHJldHVybiBEcyhlICYgciB8IH5lICYgbiwgdCwgZSwgbywgaSwgYyk7XG59XG5mdW5jdGlvbiBrdCh0LCBlLCByLCBuLCBvLCBpLCBjKSB7XG4gIHJldHVybiBEcyhlICYgbiB8IHIgJiB+biwgdCwgZSwgbywgaSwgYyk7XG59XG5mdW5jdGlvbiBJdCh0LCBlLCByLCBuLCBvLCBpLCBjKSB7XG4gIHJldHVybiBEcyhlIF4gciBeIG4sIHQsIGUsIG8sIGksIGMpO1xufVxuZnVuY3Rpb24gQnQodCwgZSwgciwgbiwgbywgaSwgYykge1xuICByZXR1cm4gRHMociBeIChlIHwgfm4pLCB0LCBlLCBvLCBpLCBjKTtcbn1cbnZhciBKZCA9IFVjKFwidjNcIiwgNDgsIEhkKTtcbmZ1bmN0aW9uIFhkKHQsIGUsIHIpIHtcbiAgdCA9IHQgfHwge307XG4gIHZhciBuID0gdC5yYW5kb20gfHwgKHQucm5nIHx8IE5jKSgpO1xuICBpZiAobls2XSA9IG5bNl0gJiAxNSB8IDY0LCBuWzhdID0gbls4XSAmIDYzIHwgMTI4LCBlKSB7XG4gICAgciA9IHIgfHwgMDtcbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IDE2OyArK28pXG4gICAgICBlW3IgKyBvXSA9IG5bb107XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgcmV0dXJuIFBzKG4pO1xufVxuZnVuY3Rpb24gUWQodCwgZSwgciwgbikge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZSAmIHIgXiB+ZSAmIG47XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGUgXiByIF4gbjtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZSAmIHIgXiBlICYgbiBeIHIgJiBuO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBlIF4gciBeIG47XG4gIH1cbn1cbmZ1bmN0aW9uIGZvKHQsIGUpIHtcbiAgcmV0dXJuIHQgPDwgZSB8IHQgPj4+IDMyIC0gZTtcbn1cbmZ1bmN0aW9uIGUxKHQpIHtcbiAgdmFyIGUgPSBbMTUxODUwMDI0OSwgMTg1OTc3NTM5MywgMjQwMDk1OTcwOCwgMzM5NTQ2OTc4Ml0sIHIgPSBbMTczMjU4NDE5MywgNDAyMzIzMzQxNywgMjU2MjM4MzEwMiwgMjcxNzMzODc4LCAzMjg1Mzc3NTIwXTtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgbiA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0KSk7XG4gICAgdCA9IFtdO1xuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgbi5sZW5ndGg7ICsrbylcbiAgICAgIHQucHVzaChuLmNoYXJDb2RlQXQobykpO1xuICB9IGVsc2UgQXJyYXkuaXNBcnJheSh0KSB8fCAodCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQpKTtcbiAgdC5wdXNoKDEyOCk7XG4gIGZvciAodmFyIGkgPSB0Lmxlbmd0aCAvIDQgKyAyLCBjID0gTWF0aC5jZWlsKGkgLyAxNiksIGYgPSBuZXcgQXJyYXkoYyksIHYgPSAwOyB2IDwgYzsgKyt2KSB7XG4gICAgZm9yICh2YXIgeCA9IG5ldyBVaW50MzJBcnJheSgxNiksIGIgPSAwOyBiIDwgMTY7ICsrYilcbiAgICAgIHhbYl0gPSB0W3YgKiA2NCArIGIgKiA0XSA8PCAyNCB8IHRbdiAqIDY0ICsgYiAqIDQgKyAxXSA8PCAxNiB8IHRbdiAqIDY0ICsgYiAqIDQgKyAyXSA8PCA4IHwgdFt2ICogNjQgKyBiICogNCArIDNdO1xuICAgIGZbdl0gPSB4O1xuICB9XG4gIGZbYyAtIDFdWzE0XSA9ICh0Lmxlbmd0aCAtIDEpICogOCAvIE1hdGgucG93KDIsIDMyKSwgZltjIC0gMV1bMTRdID0gTWF0aC5mbG9vcihmW2MgLSAxXVsxNF0pLCBmW2MgLSAxXVsxNV0gPSAodC5sZW5ndGggLSAxKSAqIDggJiA0Mjk0OTY3Mjk1O1xuICBmb3IgKHZhciBTID0gMDsgUyA8IGM7ICsrUykge1xuICAgIGZvciAodmFyIFQgPSBuZXcgVWludDMyQXJyYXkoODApLCBDID0gMDsgQyA8IDE2OyArK0MpXG4gICAgICBUW0NdID0gZltTXVtDXTtcbiAgICBmb3IgKHZhciBQID0gMTY7IFAgPCA4MDsgKytQKVxuICAgICAgVFtQXSA9IGZvKFRbUCAtIDNdIF4gVFtQIC0gOF0gXiBUW1AgLSAxNF0gXiBUW1AgLSAxNl0sIDEpO1xuICAgIGZvciAodmFyIEIgPSByWzBdLCBSID0gclsxXSwgeiA9IHJbMl0sIEsgPSByWzNdLCBaID0gcls0XSwgUSA9IDA7IFEgPCA4MDsgKytRKSB7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3IoUSAvIDIwKSwgViA9IGZvKEIsIDUpICsgUWQoaiwgUiwgeiwgSykgKyBaICsgZVtqXSArIFRbUV0gPj4+IDA7XG4gICAgICBaID0gSywgSyA9IHosIHogPSBmbyhSLCAzMCkgPj4+IDAsIFIgPSBCLCBCID0gVjtcbiAgICB9XG4gICAgclswXSA9IHJbMF0gKyBCID4+PiAwLCByWzFdID0gclsxXSArIFIgPj4+IDAsIHJbMl0gPSByWzJdICsgeiA+Pj4gMCwgclszXSA9IHJbM10gKyBLID4+PiAwLCByWzRdID0gcls0XSArIFogPj4+IDA7XG4gIH1cbiAgcmV0dXJuIFtyWzBdID4+IDI0ICYgMjU1LCByWzBdID4+IDE2ICYgMjU1LCByWzBdID4+IDggJiAyNTUsIHJbMF0gJiAyNTUsIHJbMV0gPj4gMjQgJiAyNTUsIHJbMV0gPj4gMTYgJiAyNTUsIHJbMV0gPj4gOCAmIDI1NSwgclsxXSAmIDI1NSwgclsyXSA+PiAyNCAmIDI1NSwgclsyXSA+PiAxNiAmIDI1NSwgclsyXSA+PiA4ICYgMjU1LCByWzJdICYgMjU1LCByWzNdID4+IDI0ICYgMjU1LCByWzNdID4+IDE2ICYgMjU1LCByWzNdID4+IDggJiAyNTUsIHJbM10gJiAyNTUsIHJbNF0gPj4gMjQgJiAyNTUsIHJbNF0gPj4gMTYgJiAyNTUsIHJbNF0gPj4gOCAmIDI1NSwgcls0XSAmIDI1NV07XG59XG52YXIgdDEgPSBVYyhcInY1XCIsIDgwLCBlMSk7XG5jb25zdCByMSA9IFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCI7XG5mdW5jdGlvbiBuMSh0KSB7XG4gIGlmICghRnModCkpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiSW52YWxpZCBVVUlEXCIpO1xuICByZXR1cm4gcGFyc2VJbnQodC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5jb25zdCBpMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIE5JTDogcjEsXG4gIHBhcnNlOiBqYyxcbiAgc3RyaW5naWZ5OiBQcyxcbiAgdjE6IHpkLFxuICB2MzogSmQsXG4gIHY0OiBYZCxcbiAgdjU6IHQxLFxuICB2YWxpZGF0ZTogRnMsXG4gIHZlcnNpb246IG4xXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBQYyA9IC8qIEBfX1BVUkVfXyAqLyBlYShpMSk7XG52YXIgaG8sIG91O1xuZnVuY3Rpb24gczEoKSB7XG4gIGlmIChvdSkgcmV0dXJuIGhvO1xuICBvdSA9IDE7XG4gIGNvbnN0IHQgPSBQYy52NDtcbiAgcmV0dXJuIGhvID0gZnVuY3Rpb24ociwgbiwgbywgaSkge1xuICAgIGlmICh0eXBlb2YgciAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihyICsgXCIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICBpID0gaSB8fCB7fTtcbiAgICBjb25zdCBjID0gdHlwZW9mIGkudmVyc2lvbiA9PSBcIm51bWJlclwiID8gaS52ZXJzaW9uIDogMjtcbiAgICBpZiAoYyAhPT0gMSAmJiBjICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjICsgXCIgbXVzdCBiZSAxIG9yIDJcIik7XG4gICAgY29uc3QgZiA9IHtcbiAgICAgIG1ldGhvZDogclxuICAgIH07XG4gICAgaWYgKGMgPT09IDIgJiYgKGYuanNvbnJwYyA9IFwiMi4wXCIpLCBuKSB7XG4gICAgICBpZiAodHlwZW9mIG4gIT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShuKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuICsgXCIgbXVzdCBiZSBhbiBvYmplY3QsIGFycmF5IG9yIG9taXR0ZWRcIik7XG4gICAgICBmLnBhcmFtcyA9IG47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbyA+IFwidVwiKSB7XG4gICAgICBjb25zdCB2ID0gdHlwZW9mIGkuZ2VuZXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGkuZ2VuZXJhdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0KCk7XG4gICAgICB9O1xuICAgICAgZi5pZCA9IHYoZiwgaSk7XG4gICAgfSBlbHNlIGMgPT09IDIgJiYgbyA9PT0gbnVsbCA/IGkubm90aWZpY2F0aW9uSWROdWxsICYmIChmLmlkID0gbnVsbCkgOiBmLmlkID0gbztcbiAgICByZXR1cm4gZjtcbiAgfSwgaG87XG59XG52YXIgcG8sIGF1O1xuZnVuY3Rpb24gbzEoKSB7XG4gIGlmIChhdSkgcmV0dXJuIHBvO1xuICBhdSA9IDE7XG4gIGNvbnN0IHQgPSBQYy52NCwgZSA9IHMxKCksIHIgPSBmdW5jdGlvbihuLCBvKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHIpKVxuICAgICAgcmV0dXJuIG5ldyByKG4sIG8pO1xuICAgIG8gfHwgKG8gPSB7fSksIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHJldml2ZXI6IHR5cGVvZiBvLnJldml2ZXIgPCBcInVcIiA/IG8ucmV2aXZlciA6IG51bGwsXG4gICAgICByZXBsYWNlcjogdHlwZW9mIG8ucmVwbGFjZXIgPCBcInVcIiA/IG8ucmVwbGFjZXIgOiBudWxsLFxuICAgICAgZ2VuZXJhdG9yOiB0eXBlb2Ygby5nZW5lcmF0b3IgPCBcInVcIiA/IG8uZ2VuZXJhdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0KCk7XG4gICAgICB9LFxuICAgICAgdmVyc2lvbjogdHlwZW9mIG8udmVyc2lvbiA8IFwidVwiID8gby52ZXJzaW9uIDogMixcbiAgICAgIG5vdGlmaWNhdGlvbklkTnVsbDogdHlwZW9mIG8ubm90aWZpY2F0aW9uSWROdWxsID09IFwiYm9vbGVhblwiID8gby5ub3RpZmljYXRpb25JZE51bGwgOiAhMVxuICAgIH0sIHRoaXMuY2FsbFNlcnZlciA9IG47XG4gIH07XG4gIHJldHVybiBwbyA9IHIsIHIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihuLCBvLCBpLCBjKSB7XG4gICAgY29uc3QgZiA9IHRoaXM7XG4gICAgbGV0IHYgPSBudWxsO1xuICAgIGNvbnN0IHggPSBBcnJheS5pc0FycmF5KG4pICYmIHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcnNpb24gPT09IDEgJiYgeClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJKU09OLVJQQyAxLjAgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaGluZ1wiKTtcbiAgICBpZiAoeCB8fCAheCAmJiBuICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgYyA9IG8sIHYgPSBuO1xuICAgIGVsc2Uge1xuICAgICAgdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiICYmIChjID0gaSwgaSA9IHZvaWQgMCk7XG4gICAgICBjb25zdCBUID0gdHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdiA9IGUobiwgbywgaSwge1xuICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy5vcHRpb25zLmdlbmVyYXRvcixcbiAgICAgICAgICB2ZXJzaW9uOiB0aGlzLm9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgICBub3RpZmljYXRpb25JZE51bGw6IHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChDKSB7XG4gICAgICAgIGlmIChUKVxuICAgICAgICAgIHJldHVybiBjKEMpO1xuICAgICAgICB0aHJvdyBDO1xuICAgICAgfVxuICAgICAgaWYgKCFUKVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgbGV0IFM7XG4gICAgdHJ5IHtcbiAgICAgIFMgPSBKU09OLnN0cmluZ2lmeSh2LCB0aGlzLm9wdGlvbnMucmVwbGFjZXIpO1xuICAgIH0gY2F0Y2ggKFQpIHtcbiAgICAgIHJldHVybiBjKFQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxsU2VydmVyKFMsIGZ1bmN0aW9uKFQsIEMpIHtcbiAgICAgIGYuX3BhcnNlUmVzcG9uc2UoVCwgQywgYyk7XG4gICAgfSksIHY7XG4gIH0sIHIucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24obiwgbywgaSkge1xuICAgIGlmIChuKSB7XG4gICAgICBpKG4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm4gaSgpO1xuICAgIGxldCBjO1xuICAgIHRyeSB7XG4gICAgICBjID0gSlNPTi5wYXJzZShvLCB0aGlzLm9wdGlvbnMucmV2aXZlcik7XG4gICAgfSBjYXRjaCAoZikge1xuICAgICAgcmV0dXJuIGkoZik7XG4gICAgfVxuICAgIGlmIChpLmxlbmd0aCA9PT0gMylcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICAgIGNvbnN0IGYgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB4LmVycm9yIDwgXCJ1XCI7XG4gICAgICAgIH0sIHYgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuICFmKHgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaShudWxsLCBjLmZpbHRlcihmKSwgYy5maWx0ZXIodikpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiBpKG51bGwsIGMuZXJyb3IsIGMucmVzdWx0KTtcbiAgICBpKG51bGwsIGMpO1xuICB9LCBwbztcbn1cbm8xKCk7XG52YXIgbW8gPSB7IGV4cG9ydHM6IHt9IH0sIHV1O1xuZnVuY3Rpb24gYTEoKSB7XG4gIHJldHVybiB1dSB8fCAodXUgPSAxLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCByID0gXCJ+XCI7XG4gICAgZnVuY3Rpb24gbigpIHtcbiAgICB9XG4gICAgT2JqZWN0LmNyZWF0ZSAmJiAobi5wcm90b3R5cGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgbmV3IG4oKS5fX3Byb3RvX18gfHwgKHIgPSAhMSkpO1xuICAgIGZ1bmN0aW9uIG8odiwgeCwgYikge1xuICAgICAgdGhpcy5mbiA9IHYsIHRoaXMuY29udGV4dCA9IHgsIHRoaXMub25jZSA9IGIgfHwgITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGkodiwgeCwgYiwgUywgVCkge1xuICAgICAgaWYgKHR5cGVvZiBiICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICB2YXIgQyA9IG5ldyBvKGIsIFMgfHwgdiwgVCksIFAgPSByID8gciArIHggOiB4O1xuICAgICAgcmV0dXJuIHYuX2V2ZW50c1tQXSA/IHYuX2V2ZW50c1tQXS5mbiA/IHYuX2V2ZW50c1tQXSA9IFt2Ll9ldmVudHNbUF0sIENdIDogdi5fZXZlbnRzW1BdLnB1c2goQykgOiAodi5fZXZlbnRzW1BdID0gQywgdi5fZXZlbnRzQ291bnQrKyksIHY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGModiwgeCkge1xuICAgICAgLS12Ll9ldmVudHNDb3VudCA9PT0gMCA/IHYuX2V2ZW50cyA9IG5ldyBuKCkgOiBkZWxldGUgdi5fZXZlbnRzW3hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IG4oKSwgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH1cbiAgICBmLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IFtdLCBiLCBTO1xuICAgICAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4geDtcbiAgICAgIGZvciAoUyBpbiBiID0gdGhpcy5fZXZlbnRzKVxuICAgICAgICBlLmNhbGwoYiwgUykgJiYgeC5wdXNoKHIgPyBTLnNsaWNlKDEpIDogUyk7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IHguY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoYikpIDogeDtcbiAgICB9LCBmLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHIgPyByICsgeCA6IHgsIFMgPSB0aGlzLl9ldmVudHNbYl07XG4gICAgICBpZiAoIVMpIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmZuKSByZXR1cm4gW1MuZm5dO1xuICAgICAgZm9yICh2YXIgVCA9IDAsIEMgPSBTLmxlbmd0aCwgUCA9IG5ldyBBcnJheShDKTsgVCA8IEM7IFQrKylcbiAgICAgICAgUFtUXSA9IFNbVF0uZm47XG4gICAgICByZXR1cm4gUDtcbiAgICB9LCBmLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGIgPSByID8gciArIHggOiB4LCBTID0gdGhpcy5fZXZlbnRzW2JdO1xuICAgICAgcmV0dXJuIFMgPyBTLmZuID8gMSA6IFMubGVuZ3RoIDogMDtcbiAgICB9LCBmLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oeCwgYiwgUywgVCwgQywgUCkge1xuICAgICAgdmFyIEIgPSByID8gciArIHggOiB4O1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHNbQl0pIHJldHVybiAhMTtcbiAgICAgIHZhciBSID0gdGhpcy5fZXZlbnRzW0JdLCB6ID0gYXJndW1lbnRzLmxlbmd0aCwgSywgWjtcbiAgICAgIGlmIChSLmZuKSB7XG4gICAgICAgIHN3aXRjaCAoUi5vbmNlICYmIHRoaXMucmVtb3ZlTGlzdGVuZXIoeCwgUi5mbiwgdm9pZCAwLCAhMCksIHopIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gUi5mbi5jYWxsKFIuY29udGV4dCksICEwO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBSLmZuLmNhbGwoUi5jb250ZXh0LCBiKSwgITA7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIFIuZm4uY2FsbChSLmNvbnRleHQsIGIsIFMpLCAhMDtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gUi5mbi5jYWxsKFIuY29udGV4dCwgYiwgUywgVCksICEwO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBSLmZuLmNhbGwoUi5jb250ZXh0LCBiLCBTLCBULCBDKSwgITA7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIFIuZm4uY2FsbChSLmNvbnRleHQsIGIsIFMsIFQsIEMsIFApLCAhMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFogPSAxLCBLID0gbmV3IEFycmF5KHogLSAxKTsgWiA8IHo7IForKylcbiAgICAgICAgICBLW1ogLSAxXSA9IGFyZ3VtZW50c1taXTtcbiAgICAgICAgUi5mbi5hcHBseShSLmNvbnRleHQsIEspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFEgPSBSLmxlbmd0aCwgajtcbiAgICAgICAgZm9yIChaID0gMDsgWiA8IFE7IForKylcbiAgICAgICAgICBzd2l0Y2ggKFJbWl0ub25jZSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKHgsIFJbWl0uZm4sIHZvaWQgMCwgITApLCB6KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIFJbWl0uZm4uY2FsbChSW1pdLmNvbnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgUltaXS5mbi5jYWxsKFJbWl0uY29udGV4dCwgYik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBSW1pdLmZuLmNhbGwoUltaXS5jb250ZXh0LCBiLCBTKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIFJbWl0uZm4uY2FsbChSW1pdLmNvbnRleHQsIGIsIFMsIFQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICghSykgZm9yIChqID0gMSwgSyA9IG5ldyBBcnJheSh6IC0gMSk7IGogPCB6OyBqKyspXG4gICAgICAgICAgICAgICAgS1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgICAgIFJbWl0uZm4uYXBwbHkoUltaXS5jb250ZXh0LCBLKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgZi5wcm90b3R5cGUub24gPSBmdW5jdGlvbih4LCBiLCBTKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLCB4LCBiLCBTLCAhMSk7XG4gICAgfSwgZi5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHgsIGIsIFMpIHtcbiAgICAgIHJldHVybiBpKHRoaXMsIHgsIGIsIFMsICEwKTtcbiAgICB9LCBmLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHgsIGIsIFMsIFQpIHtcbiAgICAgIHZhciBDID0gciA/IHIgKyB4IDogeDtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW0NdKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghYilcbiAgICAgICAgcmV0dXJuIGModGhpcywgQyksIHRoaXM7XG4gICAgICB2YXIgUCA9IHRoaXMuX2V2ZW50c1tDXTtcbiAgICAgIGlmIChQLmZuKVxuICAgICAgICBQLmZuID09PSBiICYmICghVCB8fCBQLm9uY2UpICYmICghUyB8fCBQLmNvbnRleHQgPT09IFMpICYmIGModGhpcywgQyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgQiA9IDAsIFIgPSBbXSwgeiA9IFAubGVuZ3RoOyBCIDwgejsgQisrKVxuICAgICAgICAgIChQW0JdLmZuICE9PSBiIHx8IFQgJiYgIVBbQl0ub25jZSB8fCBTICYmIFBbQl0uY29udGV4dCAhPT0gUykgJiYgUi5wdXNoKFBbQl0pO1xuICAgICAgICBSLmxlbmd0aCA/IHRoaXMuX2V2ZW50c1tDXSA9IFIubGVuZ3RoID09PSAxID8gUlswXSA6IFIgOiBjKHRoaXMsIEMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgZi5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGI7XG4gICAgICByZXR1cm4geCA/IChiID0gciA/IHIgKyB4IDogeCwgdGhpcy5fZXZlbnRzW2JdICYmIGModGhpcywgYikpIDogKHRoaXMuX2V2ZW50cyA9IG5ldyBuKCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMCksIHRoaXM7XG4gICAgfSwgZi5wcm90b3R5cGUub2ZmID0gZi5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIsIGYucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZi5wcm90b3R5cGUub24sIGYucHJlZml4ZWQgPSByLCBmLkV2ZW50RW1pdHRlciA9IGYsIHQuZXhwb3J0cyA9IGY7XG4gIH0obW8pKSwgbW8uZXhwb3J0cztcbn1cbnZhciB1MSA9IGExKCk7XG5jb25zdCBEYyA9IC8qIEBfX1BVUkVfXyAqLyBRbyh1MSk7XG5jbGFzcyAkYyBleHRlbmRzIHVjIHtcbiAgY29uc3RydWN0b3IoZSwgcikge1xuICAgIHN1cGVyKCksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgTDAoZSk7XG4gICAgY29uc3QgbiA9IG9hKHIpO1xuICAgIGlmICh0aGlzLmlIYXNoID0gZS5jcmVhdGUoKSwgdHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaFwiKTtcbiAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbiwgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICBjb25zdCBvID0gdGhpcy5ibG9ja0xlbiwgaSA9IG5ldyBVaW50OEFycmF5KG8pO1xuICAgIGkuc2V0KG4ubGVuZ3RoID4gbyA/IGUuY3JlYXRlKCkudXBkYXRlKG4pLmRpZ2VzdCgpIDogbik7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpLmxlbmd0aDsgYysrKVxuICAgICAgaVtjXSBePSA1NDtcbiAgICB0aGlzLmlIYXNoLnVwZGF0ZShpKSwgdGhpcy5vSGFzaCA9IGUuY3JlYXRlKCk7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpLmxlbmd0aDsgYysrKVxuICAgICAgaVtjXSBePSAxMDY7XG4gICAgdGhpcy5vSGFzaC51cGRhdGUoaSksIE9uKGkpO1xuICB9XG4gIHVwZGF0ZShlKSB7XG4gICAgcmV0dXJuIHBzKHRoaXMpLCB0aGlzLmlIYXNoLnVwZGF0ZShlKSwgdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKGUpIHtcbiAgICBwcyh0aGlzKSwgYXIoZSwgdGhpcy5vdXRwdXRMZW4pLCB0aGlzLmZpbmlzaGVkID0gITAsIHRoaXMuaUhhc2guZGlnZXN0SW50byhlKSwgdGhpcy5vSGFzaC51cGRhdGUoZSksIHRoaXMub0hhc2guZGlnZXN0SW50byhlKSwgdGhpcy5kZXN0cm95KCk7XG4gIH1cbiAgZGlnZXN0KCkge1xuICAgIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhlKSwgZTtcbiAgfVxuICBfY2xvbmVJbnRvKGUpIHtcbiAgICBlIHx8IChlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgY29uc3QgeyBvSGFzaDogciwgaUhhc2g6IG4sIGZpbmlzaGVkOiBvLCBkZXN0cm95ZWQ6IGksIGJsb2NrTGVuOiBjLCBvdXRwdXRMZW46IGYgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGUgPSBlLCBlLmZpbmlzaGVkID0gbywgZS5kZXN0cm95ZWQgPSBpLCBlLmJsb2NrTGVuID0gYywgZS5vdXRwdXRMZW4gPSBmLCBlLm9IYXNoID0gci5fY2xvbmVJbnRvKGUub0hhc2gpLCBlLmlIYXNoID0gbi5fY2xvbmVJbnRvKGUuaUhhc2gpLCBlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMub0hhc2guZGVzdHJveSgpLCB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgfVxufVxuY29uc3QgemMgPSAodCwgZSwgcikgPT4gbmV3ICRjKHQsIGUpLnVwZGF0ZShyKS5kaWdlc3QoKTtcbnpjLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgJGModCwgZSk7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5mdW5jdGlvbiBjdSh0KSB7XG4gIHQubG93UyAhPT0gdm9pZCAwICYmIGZuKFwibG93U1wiLCB0Lmxvd1MpLCB0LnByZWhhc2ggIT09IHZvaWQgMCAmJiBmbihcInByZWhhc2hcIiwgdC5wcmVoYXNoKTtcbn1cbmNsYXNzIGMxIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlID0gXCJcIikge1xuICAgIHN1cGVyKGUpO1xuICB9XG59XG5jb25zdCBtciA9IHtcbiAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gIEVycjogYzEsXG4gIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcbiAgX3Rsdjoge1xuICAgIGVuY29kZTogKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IHsgRXJyOiByIH0gPSBtcjtcbiAgICAgIGlmICh0IDwgMCB8fCB0ID4gMjU2KVxuICAgICAgICB0aHJvdyBuZXcgcihcInRsdi5lbmNvZGU6IHdyb25nIHRhZ1wiKTtcbiAgICAgIGlmIChlLmxlbmd0aCAmIDEpXG4gICAgICAgIHRocm93IG5ldyByKFwidGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YVwiKTtcbiAgICAgIGNvbnN0IG4gPSBlLmxlbmd0aCAvIDIsIG8gPSBLaShuKTtcbiAgICAgIGlmIChvLmxlbmd0aCAvIDIgJiAxMjgpXG4gICAgICAgIHRocm93IG5ldyByKFwidGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnXCIpO1xuICAgICAgY29uc3QgaSA9IG4gPiAxMjcgPyBLaShvLmxlbmd0aCAvIDIgfCAxMjgpIDogXCJcIjtcbiAgICAgIHJldHVybiBLaSh0KSArIGkgKyBvICsgZTtcbiAgICB9LFxuICAgIC8vIHYgLSB2YWx1ZSwgbCAtIGxlZnQgYnl0ZXMgKHVucGFyc2VkKVxuICAgIGRlY29kZSh0LCBlKSB7XG4gICAgICBjb25zdCB7IEVycjogciB9ID0gbXI7XG4gICAgICBsZXQgbiA9IDA7XG4gICAgICBpZiAodCA8IDAgfHwgdCA+IDI1NilcbiAgICAgICAgdGhyb3cgbmV3IHIoXCJ0bHYuZW5jb2RlOiB3cm9uZyB0YWdcIik7XG4gICAgICBpZiAoZS5sZW5ndGggPCAyIHx8IGVbbisrXSAhPT0gdClcbiAgICAgICAgdGhyb3cgbmV3IHIoXCJ0bHYuZGVjb2RlOiB3cm9uZyB0bHZcIik7XG4gICAgICBjb25zdCBvID0gZVtuKytdLCBpID0gISEobyAmIDEyOCk7XG4gICAgICBsZXQgYyA9IDA7XG4gICAgICBpZiAoIWkpXG4gICAgICAgIGMgPSBvO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHYgPSBvICYgMTI3O1xuICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgdGhyb3cgbmV3IHIoXCJ0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICBpZiAodiA+IDQpXG4gICAgICAgICAgdGhyb3cgbmV3IHIoXCJ0bHYuZGVjb2RlKGxvbmcpOiBieXRlIGxlbmd0aCBpcyB0b28gYmlnXCIpO1xuICAgICAgICBjb25zdCB4ID0gZS5zdWJhcnJheShuLCBuICsgdik7XG4gICAgICAgIGlmICh4Lmxlbmd0aCAhPT0gdilcbiAgICAgICAgICB0aHJvdyBuZXcgcihcInRsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGVcIik7XG4gICAgICAgIGlmICh4WzBdID09PSAwKVxuICAgICAgICAgIHRocm93IG5ldyByKFwidGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgeClcbiAgICAgICAgICBjID0gYyA8PCA4IHwgYjtcbiAgICAgICAgaWYgKG4gKz0gdiwgYyA8IDEyOClcbiAgICAgICAgICB0aHJvdyBuZXcgcihcInRsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZiA9IGUuc3ViYXJyYXkobiwgbiArIGMpO1xuICAgICAgaWYgKGYubGVuZ3RoICE9PSBjKVxuICAgICAgICB0aHJvdyBuZXcgcihcInRsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aFwiKTtcbiAgICAgIHJldHVybiB7IHY6IGYsIGw6IGUuc3ViYXJyYXkobiArIGMpIH07XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gIF9pbnQ6IHtcbiAgICBlbmNvZGUodCkge1xuICAgICAgY29uc3QgeyBFcnI6IGUgfSA9IG1yO1xuICAgICAgaWYgKHQgPCBpaSlcbiAgICAgICAgdGhyb3cgbmV3IGUoXCJpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgICBsZXQgciA9IEtpKHQpO1xuICAgICAgaWYgKE51bWJlci5wYXJzZUludChyWzBdLCAxNikgJiA4ICYmIChyID0gXCIwMFwiICsgciksIHIubGVuZ3RoICYgMSlcbiAgICAgICAgdGhyb3cgbmV3IGUoXCJ1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4XCIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICBkZWNvZGUodCkge1xuICAgICAgY29uc3QgeyBFcnI6IGUgfSA9IG1yO1xuICAgICAgaWYgKHRbMF0gJiAxMjgpXG4gICAgICAgIHRocm93IG5ldyBlKFwiaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmVcIik7XG4gICAgICBpZiAodFswXSA9PT0gMCAmJiAhKHRbMV0gJiAxMjgpKVxuICAgICAgICB0aHJvdyBuZXcgZShcImludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVyb1wiKTtcbiAgICAgIHJldHVybiBMcyh0KTtcbiAgICB9XG4gIH0sXG4gIHRvU2lnKHQpIHtcbiAgICBjb25zdCB7IEVycjogZSwgX2ludDogciwgX3RsdjogbiB9ID0gbXIsIG8gPSB2dChcInNpZ25hdHVyZVwiLCB0KSwgeyB2OiBpLCBsOiBjIH0gPSBuLmRlY29kZSg0OCwgbyk7XG4gICAgaWYgKGMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IGUoXCJpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nXCIpO1xuICAgIGNvbnN0IHsgdjogZiwgbDogdiB9ID0gbi5kZWNvZGUoMiwgaSksIHsgdjogeCwgbDogYiB9ID0gbi5kZWNvZGUoMiwgdik7XG4gICAgaWYgKGIubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IGUoXCJpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nXCIpO1xuICAgIHJldHVybiB7IHI6IHIuZGVjb2RlKGYpLCBzOiByLmRlY29kZSh4KSB9O1xuICB9LFxuICBoZXhGcm9tU2lnKHQpIHtcbiAgICBjb25zdCB7IF90bHY6IGUsIF9pbnQ6IHIgfSA9IG1yLCBuID0gZS5lbmNvZGUoMiwgci5lbmNvZGUodC5yKSksIG8gPSBlLmVuY29kZSgyLCByLmVuY29kZSh0LnMpKSwgaSA9IG4gKyBvO1xuICAgIHJldHVybiBlLmVuY29kZSg0OCwgaSk7XG4gIH1cbn0sIGlpID0gQmlnSW50KDApLCBzaSA9IEJpZ0ludCgxKSwgbDEgPSBCaWdJbnQoMiksIFlpID0gQmlnSW50KDMpLCBmMSA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIGgxKHQsIGUsIHIpIHtcbiAgZnVuY3Rpb24gbihvKSB7XG4gICAgY29uc3QgaSA9IHQuc3FyKG8pLCBjID0gdC5tdWwoaSwgbyk7XG4gICAgcmV0dXJuIHQuYWRkKHQuYWRkKGMsIHQubXVsKG8sIGUpKSwgcik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBxYyh0LCBlLCByKSB7XG4gIGNvbnN0IHsgQllURVM6IG4gfSA9IHQ7XG4gIGZ1bmN0aW9uIG8oaSkge1xuICAgIGxldCBjO1xuICAgIGlmICh0eXBlb2YgaSA9PSBcImJpZ2ludFwiKVxuICAgICAgYyA9IGk7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgZiA9IHZ0KFwicHJpdmF0ZSBrZXlcIiwgaSk7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBpZiAoIWUuaW5jbHVkZXMoZi5sZW5ndGggKiAyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHByaXZhdGUga2V5XCIpO1xuICAgICAgICBjb25zdCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICAgIHYuc2V0KGYsIHYubGVuZ3RoIC0gZi5sZW5ndGgpLCBmID0gdjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGMgPSB0LmZyb21CeXRlcyhmKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHJpdmF0ZSBrZXk6IGV4cGVjdGVkIHVpOGEgb2Ygc2l6ZSAke259LCBnb3QgJHt0eXBlb2YgaX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHIgJiYgKGMgPSB0LmNyZWF0ZShjKSksICF0LmlzVmFsaWROb3QwKGMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwcml2YXRlIGtleTogb3V0IG9mIHJhbmdlIFsxLi5OLTFdXCIpO1xuICAgIHJldHVybiBjO1xuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gZDEodCwgZSA9IHt9KSB7XG4gIGNvbnN0IHsgRnA6IHIsIEZuOiBuIH0gPSBTYyhcIndlaWVyc3RyYXNzXCIsIHQsIGUpLCB7IGg6IG8sIG46IGkgfSA9IHQ7XG4gIFVpKGUsIHt9LCB7XG4gICAgYWxsb3dJbmZpbml0eVBvaW50OiBcImJvb2xlYW5cIixcbiAgICBjbGVhckNvZmFjdG9yOiBcImZ1bmN0aW9uXCIsXG4gICAgaXNUb3JzaW9uRnJlZTogXCJmdW5jdGlvblwiLFxuICAgIGZyb21CeXRlczogXCJmdW5jdGlvblwiLFxuICAgIHRvQnl0ZXM6IFwiZnVuY3Rpb25cIixcbiAgICBlbmRvOiBcIm9iamVjdFwiLFxuICAgIHdyYXBQcml2YXRlS2V5OiBcImJvb2xlYW5cIlxuICB9KTtcbiAgY29uc3QgeyBlbmRvOiBjIH0gPSBlO1xuICBpZiAoYyAmJiAoIXIuaXMwKHQuYSkgfHwgdHlwZW9mIGMuYmV0YSAhPSBcImJpZ2ludFwiIHx8IHR5cGVvZiBjLnNwbGl0U2NhbGFyICE9IFwiZnVuY3Rpb25cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IGV4cGVjdGVkIFwiYmV0YVwiOiBiaWdpbnQgYW5kIFwic3BsaXRTY2FsYXJcIjogZnVuY3Rpb24nKTtcbiAgZnVuY3Rpb24gZigpIHtcbiAgICBpZiAoIXIuaXNPZGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkOiBGaWVsZCBkb2VzIG5vdCBoYXZlIC5pc09kZCgpXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHYoRywgTiwgTykge1xuICAgIGNvbnN0IHsgeDogTCwgeTogRiB9ID0gTi50b0FmZmluZSgpLCBkID0gci50b0J5dGVzKEwpO1xuICAgIGlmIChmbihcImlzQ29tcHJlc3NlZFwiLCBPKSwgTykge1xuICAgICAgZigpO1xuICAgICAgY29uc3QgcyA9ICFyLmlzT2RkKEYpO1xuICAgICAgcmV0dXJuIHZyKFpjKHMpLCBkKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiB2cihVaW50OEFycmF5Lm9mKDQpLCBkLCByLnRvQnl0ZXMoRikpO1xuICB9XG4gIGZ1bmN0aW9uIHgoRykge1xuICAgIGFyKEcpO1xuICAgIGNvbnN0IE4gPSByLkJZVEVTLCBPID0gTiArIDEsIEwgPSAyICogTiArIDEsIEYgPSBHLmxlbmd0aCwgZCA9IEdbMF0sIHMgPSBHLnN1YmFycmF5KDEpO1xuICAgIGlmIChGID09PSBPICYmIChkID09PSAyIHx8IGQgPT09IDMpKSB7XG4gICAgICBjb25zdCB1ID0gci5mcm9tQnl0ZXMocyk7XG4gICAgICBpZiAoIXIuaXNWYWxpZCh1KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHBvaW50OiBpcyBub3Qgb24gY3VydmUsIHdyb25nIHhcIik7XG4gICAgICBjb25zdCBoID0gVCh1KTtcbiAgICAgIGxldCBnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZyA9IHIuc3FydChoKTtcbiAgICAgIH0gY2F0Y2ggKEEpIHtcbiAgICAgICAgY29uc3QgcCA9IEEgaW5zdGFuY2VvZiBFcnJvciA/IFwiOiBcIiArIEEubWVzc2FnZSA6IFwiXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogaXMgbm90IG9uIGN1cnZlLCBzcXJ0IGVycm9yXCIgKyBwKTtcbiAgICAgIH1cbiAgICAgIGYoKTtcbiAgICAgIGNvbnN0IHcgPSByLmlzT2RkKGcpO1xuICAgICAgcmV0dXJuIChkICYgMSkgPT09IDEgIT09IHcgJiYgKGcgPSByLm5lZyhnKSksIHsgeDogdSwgeTogZyB9O1xuICAgIH0gZWxzZSBpZiAoRiA9PT0gTCAmJiBkID09PSA0KSB7XG4gICAgICBjb25zdCB1ID0gci5mcm9tQnl0ZXMocy5zdWJhcnJheShOICogMCwgTiAqIDEpKSwgaCA9IHIuZnJvbUJ5dGVzKHMuc3ViYXJyYXkoTiAqIDEsIE4gKiAyKSk7XG4gICAgICBpZiAoIUModSwgaCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogaXMgbm90IG9uIGN1cnZlXCIpO1xuICAgICAgcmV0dXJuIHsgeDogdSwgeTogaCB9O1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgcG9pbnQ6IGdvdCBsZW5ndGggJHtGfSwgZXhwZWN0ZWQgY29tcHJlc3NlZD0ke099IG9yIHVuY29tcHJlc3NlZD0ke0x9YCk7XG4gIH1cbiAgY29uc3QgYiA9IGUudG9CeXRlcyB8fCB2LCBTID0gZS5mcm9tQnl0ZXMgfHwgeCwgVCA9IGgxKHIsIHQuYSwgdC5iKTtcbiAgZnVuY3Rpb24gQyhHLCBOKSB7XG4gICAgY29uc3QgTyA9IHIuc3FyKE4pLCBMID0gVChHKTtcbiAgICByZXR1cm4gci5lcWwoTywgTCk7XG4gIH1cbiAgaWYgKCFDKHQuR3gsIHQuR3kpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludFwiKTtcbiAgY29uc3QgUCA9IHIubXVsKHIucG93KHQuYSwgWWkpLCBmMSksIEIgPSByLm11bChyLnNxcih0LmIpLCBCaWdJbnQoMjcpKTtcbiAgaWYgKHIuaXMwKHIuYWRkKFAsIEIpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY3VydmUgcGFyYW1zOiBhIG9yIGJcIik7XG4gIGZ1bmN0aW9uIFIoRywgTiwgTyA9ICExKSB7XG4gICAgaWYgKCFyLmlzVmFsaWQoTikgfHwgTyAmJiByLmlzMChOKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIHBvaW50IGNvb3JkaW5hdGUgJHtHfWApO1xuICAgIHJldHVybiBOO1xuICB9XG4gIGZ1bmN0aW9uIHooRykge1xuICAgIGlmICghKEcgaW5zdGFuY2VvZiBqKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2plY3RpdmVQb2ludCBleHBlY3RlZFwiKTtcbiAgfVxuICBjb25zdCBLID0gbXMoKEcsIE4pID0+IHtcbiAgICBjb25zdCB7IHB4OiBPLCBweTogTCwgcHo6IEYgfSA9IEc7XG4gICAgaWYgKHIuZXFsKEYsIHIuT05FKSlcbiAgICAgIHJldHVybiB7IHg6IE8sIHk6IEwgfTtcbiAgICBjb25zdCBkID0gRy5pczAoKTtcbiAgICBOID09IG51bGwgJiYgKE4gPSBkID8gci5PTkUgOiByLmludihGKSk7XG4gICAgY29uc3QgcyA9IHIubXVsKE8sIE4pLCB1ID0gci5tdWwoTCwgTiksIGggPSByLm11bChGLCBOKTtcbiAgICBpZiAoZClcbiAgICAgIHJldHVybiB7IHg6IHIuWkVSTywgeTogci5aRVJPIH07XG4gICAgaWYgKCFyLmVxbChoLCByLk9ORSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZaIHdhcyBpbnZhbGlkXCIpO1xuICAgIHJldHVybiB7IHg6IHMsIHk6IHUgfTtcbiAgfSksIFogPSBtcygoRykgPT4ge1xuICAgIGlmIChHLmlzMCgpKSB7XG4gICAgICBpZiAoZS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIXIuaXMwKEcucHkpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IFpFUk9cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgeDogTiwgeTogTyB9ID0gRy50b0FmZmluZSgpO1xuICAgIGlmICghci5pc1ZhbGlkKE4pIHx8ICFyLmlzVmFsaWQoTykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IHggb3IgeSBub3QgZmllbGQgZWxlbWVudHNcIik7XG4gICAgaWYgKCFDKE4sIE8pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0XCIpO1xuICAgIGlmICghRy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cFwiKTtcbiAgICByZXR1cm4gITA7XG4gIH0pO1xuICBmdW5jdGlvbiBRKEcsIE4sIE8sIEwsIEYpIHtcbiAgICByZXR1cm4gTyA9IG5ldyBqKHIubXVsKE8ucHgsIEcpLCBPLnB5LCBPLnB6KSwgTiA9IG5pKEwsIE4pLCBPID0gbmkoRiwgTyksIE4uYWRkKE8pO1xuICB9XG4gIGNsYXNzIGoge1xuICAgIC8qKiBEb2VzIE5PVCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgdmFsaWQuIFVzZSBgLmFzc2VydFZhbGlkaXR5KClgLiAqL1xuICAgIGNvbnN0cnVjdG9yKE4sIE8sIEwpIHtcbiAgICAgIHRoaXMucHggPSBSKFwieFwiLCBOKSwgdGhpcy5weSA9IFIoXCJ5XCIsIE8sICEwKSwgdGhpcy5weiA9IFIoXCJ6XCIsIEwpLCBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvKiogRG9lcyBOT1QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIHZhbGlkLiBVc2UgYC5hc3NlcnRWYWxpZGl0eSgpYC4gKi9cbiAgICBzdGF0aWMgZnJvbUFmZmluZShOKSB7XG4gICAgICBjb25zdCB7IHg6IE8sIHk6IEwgfSA9IE4gfHwge307XG4gICAgICBpZiAoIU4gfHwgIXIuaXNWYWxpZChPKSB8fCAhci5pc1ZhbGlkKEwpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFmZmluZSBwb2ludFwiKTtcbiAgICAgIGlmIChOIGluc3RhbmNlb2YgailcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZFwiKTtcbiAgICAgIHJldHVybiByLmlzMChPKSAmJiByLmlzMChMKSA/IGouWkVSTyA6IG5ldyBqKE8sIEwsIHIuT05FKTtcbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWihOKSB7XG4gICAgICByZXR1cm4gYmMoaiwgXCJwelwiLCBOKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhOKSB7XG4gICAgICByZXR1cm4gYXIoTiksIGouZnJvbUhleChOKTtcbiAgICB9XG4gICAgLyoqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuICovXG4gICAgc3RhdGljIGZyb21IZXgoTikge1xuICAgICAgY29uc3QgTyA9IGouZnJvbUFmZmluZShTKHZ0KFwicG9pbnRIZXhcIiwgTikpKTtcbiAgICAgIHJldHVybiBPLmFzc2VydFZhbGlkaXR5KCksIE87XG4gICAgfVxuICAgIC8qKiBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LiAqL1xuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShOKSB7XG4gICAgICBjb25zdCBPID0gcWMobiwgZS5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMsIGUud3JhcFByaXZhdGVLZXkpO1xuICAgICAgcmV0dXJuIGouQkFTRS5tdWx0aXBseShPKE4pKTtcbiAgICB9XG4gICAgLyoqIE11bHRpc2NhbGFyIE11bHRpcGxpY2F0aW9uICovXG4gICAgc3RhdGljIG1zbShOLCBPKSB7XG4gICAgICByZXR1cm4gQ2MoaiwgbiwgTiwgTyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpbmRvd1NpemVcbiAgICAgKiBAcGFyYW0gaXNMYXp5IHRydWUgd2lsbCBkZWZlciB0YWJsZSBjb21wdXRhdGlvbiB1bnRpbCB0aGUgZmlyc3QgbXVsdGlwbGljYXRpb25cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHByZWNvbXB1dGUoTiA9IDgsIE8gPSAhMCkge1xuICAgICAgcmV0dXJuIGVlLnNldFdpbmRvd1NpemUodGhpcywgTiksIE8gfHwgdGhpcy5tdWx0aXBseShZaSksIHRoaXM7XG4gICAgfVxuICAgIC8qKiBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseSAqL1xuICAgIF9zZXRXaW5kb3dTaXplKE4pIHtcbiAgICAgIHRoaXMucHJlY29tcHV0ZShOKTtcbiAgICB9XG4gICAgLy8gVE9ETzogcmV0dXJuIGB0aGlzYFxuICAgIC8qKiBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLiAqL1xuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgWih0aGlzKTtcbiAgICB9XG4gICAgaGFzRXZlblkoKSB7XG4gICAgICBjb25zdCB7IHk6IE4gfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgIGlmICghci5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgcmV0dXJuICFyLmlzT2RkKE4pO1xuICAgIH1cbiAgICAvKiogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci4gKi9cbiAgICBlcXVhbHMoTikge1xuICAgICAgeihOKTtcbiAgICAgIGNvbnN0IHsgcHg6IE8sIHB5OiBMLCBwejogRiB9ID0gdGhpcywgeyBweDogZCwgcHk6IHMsIHB6OiB1IH0gPSBOLCBoID0gci5lcWwoci5tdWwoTywgdSksIHIubXVsKGQsIEYpKSwgZyA9IHIuZXFsKHIubXVsKEwsIHUpLCByLm11bChzLCBGKSk7XG4gICAgICByZXR1cm4gaCAmJiBnO1xuICAgIH1cbiAgICAvKiogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuICovXG4gICAgbmVnYXRlKCkge1xuICAgICAgcmV0dXJuIG5ldyBqKHRoaXMucHgsIHIubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICB9XG4gICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgIGRvdWJsZSgpIHtcbiAgICAgIGNvbnN0IHsgYTogTiwgYjogTyB9ID0gdCwgTCA9IHIubXVsKE8sIFlpKSwgeyBweDogRiwgcHk6IGQsIHB6OiBzIH0gPSB0aGlzO1xuICAgICAgbGV0IHUgPSByLlpFUk8sIGggPSByLlpFUk8sIGcgPSByLlpFUk8sIHcgPSByLm11bChGLCBGKSwgXyA9IHIubXVsKGQsIGQpLCBBID0gci5tdWwocywgcyksIHAgPSByLm11bChGLCBkKTtcbiAgICAgIHJldHVybiBwID0gci5hZGQocCwgcCksIGcgPSByLm11bChGLCBzKSwgZyA9IHIuYWRkKGcsIGcpLCB1ID0gci5tdWwoTiwgZyksIGggPSByLm11bChMLCBBKSwgaCA9IHIuYWRkKHUsIGgpLCB1ID0gci5zdWIoXywgaCksIGggPSByLmFkZChfLCBoKSwgaCA9IHIubXVsKHUsIGgpLCB1ID0gci5tdWwocCwgdSksIGcgPSByLm11bChMLCBnKSwgQSA9IHIubXVsKE4sIEEpLCBwID0gci5zdWIodywgQSksIHAgPSByLm11bChOLCBwKSwgcCA9IHIuYWRkKHAsIGcpLCBnID0gci5hZGQodywgdyksIHcgPSByLmFkZChnLCB3KSwgdyA9IHIuYWRkKHcsIEEpLCB3ID0gci5tdWwodywgcCksIGggPSByLmFkZChoLCB3KSwgQSA9IHIubXVsKGQsIHMpLCBBID0gci5hZGQoQSwgQSksIHcgPSByLm11bChBLCBwKSwgdSA9IHIuc3ViKHUsIHcpLCBnID0gci5tdWwoQSwgXyksIGcgPSByLmFkZChnLCBnKSwgZyA9IHIuYWRkKGcsIGcpLCBuZXcgaih1LCBoLCBnKTtcbiAgICB9XG4gICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICBhZGQoTikge1xuICAgICAgeihOKTtcbiAgICAgIGNvbnN0IHsgcHg6IE8sIHB5OiBMLCBwejogRiB9ID0gdGhpcywgeyBweDogZCwgcHk6IHMsIHB6OiB1IH0gPSBOO1xuICAgICAgbGV0IGggPSByLlpFUk8sIGcgPSByLlpFUk8sIHcgPSByLlpFUk87XG4gICAgICBjb25zdCBfID0gdC5hLCBBID0gci5tdWwodC5iLCBZaSk7XG4gICAgICBsZXQgcCA9IHIubXVsKE8sIGQpLCBhID0gci5tdWwoTCwgcyksIGwgPSByLm11bChGLCB1KSwgTSA9IHIuYWRkKE8sIEwpLCBrID0gci5hZGQoZCwgcyk7XG4gICAgICBNID0gci5tdWwoTSwgayksIGsgPSByLmFkZChwLCBhKSwgTSA9IHIuc3ViKE0sIGspLCBrID0gci5hZGQoTywgRik7XG4gICAgICBsZXQgJCA9IHIuYWRkKGQsIHUpO1xuICAgICAgcmV0dXJuIGsgPSByLm11bChrLCAkKSwgJCA9IHIuYWRkKHAsIGwpLCBrID0gci5zdWIoaywgJCksICQgPSByLmFkZChMLCBGKSwgaCA9IHIuYWRkKHMsIHUpLCAkID0gci5tdWwoJCwgaCksIGggPSByLmFkZChhLCBsKSwgJCA9IHIuc3ViKCQsIGgpLCB3ID0gci5tdWwoXywgayksIGggPSByLm11bChBLCBsKSwgdyA9IHIuYWRkKGgsIHcpLCBoID0gci5zdWIoYSwgdyksIHcgPSByLmFkZChhLCB3KSwgZyA9IHIubXVsKGgsIHcpLCBhID0gci5hZGQocCwgcCksIGEgPSByLmFkZChhLCBwKSwgbCA9IHIubXVsKF8sIGwpLCBrID0gci5tdWwoQSwgayksIGEgPSByLmFkZChhLCBsKSwgbCA9IHIuc3ViKHAsIGwpLCBsID0gci5tdWwoXywgbCksIGsgPSByLmFkZChrLCBsKSwgcCA9IHIubXVsKGEsIGspLCBnID0gci5hZGQoZywgcCksIHAgPSByLm11bCgkLCBrKSwgaCA9IHIubXVsKE0sIGgpLCBoID0gci5zdWIoaCwgcCksIHAgPSByLm11bChNLCBhKSwgdyA9IHIubXVsKCQsIHcpLCB3ID0gci5hZGQodywgcCksIG5ldyBqKGgsIGcsIHcpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChOKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoTi5uZWdhdGUoKSk7XG4gICAgfVxuICAgIGlzMCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVxdWFscyhqLlpFUk8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAqL1xuICAgIG11bHRpcGx5KE4pIHtcbiAgICAgIGNvbnN0IHsgZW5kbzogTyB9ID0gZTtcbiAgICAgIGlmICghbi5pc1ZhbGlkTm90MChOKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzY2FsYXI6IG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCBMLCBGO1xuICAgICAgY29uc3QgZCA9IChzKSA9PiBlZS53TkFGQ2FjaGVkKHRoaXMsIHMsIGoubm9ybWFsaXplWik7XG4gICAgICBpZiAoTykge1xuICAgICAgICBjb25zdCB7IGsxbmVnOiBzLCBrMTogdSwgazJuZWc6IGgsIGsyOiBnIH0gPSBPLnNwbGl0U2NhbGFyKE4pLCB7IHA6IHcsIGY6IF8gfSA9IGQodSksIHsgcDogQSwgZjogcCB9ID0gZChnKTtcbiAgICAgICAgRiA9IF8uYWRkKHApLCBMID0gUShPLmJldGEsIHcsIEEsIHMsIGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBwOiBzLCBmOiB1IH0gPSBkKE4pO1xuICAgICAgICBMID0gcywgRiA9IHU7XG4gICAgICB9XG4gICAgICByZXR1cm4gai5ub3JtYWxpemVaKFtMLCBGXSlbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICovXG4gICAgbXVsdGlwbHlVbnNhZmUoTikge1xuICAgICAgY29uc3QgeyBlbmRvOiBPIH0gPSBlLCBMID0gdGhpcztcbiAgICAgIGlmICghbi5pc1ZhbGlkKE4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNjYWxhcjogb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgaWYgKE4gPT09IGlpIHx8IEwuaXMwKCkpXG4gICAgICAgIHJldHVybiBqLlpFUk87XG4gICAgICBpZiAoTiA9PT0gc2kpXG4gICAgICAgIHJldHVybiBMO1xuICAgICAgaWYgKGVlLmhhc1ByZWNvbXB1dGVzKHRoaXMpKVxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShOKTtcbiAgICAgIGlmIChPKSB7XG4gICAgICAgIGNvbnN0IHsgazFuZWc6IEYsIGsxOiBkLCBrMm5lZzogcywgazI6IHUgfSA9IE8uc3BsaXRTY2FsYXIoTiksIHsgcDE6IGgsIHAyOiBnIH0gPSBnaChqLCBMLCBkLCB1KTtcbiAgICAgICAgcmV0dXJuIFEoTy5iZXRhLCBoLCBnLCBGLCBzKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gZWUud05BRkNhY2hlZFVuc2FmZShMLCBOKTtcbiAgICB9XG4gICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoTiwgTywgTCkge1xuICAgICAgY29uc3QgRiA9IHRoaXMubXVsdGlwbHlVbnNhZmUoTykuYWRkKE4ubXVsdGlwbHlVbnNhZmUoTCkpO1xuICAgICAgcmV0dXJuIEYuaXMwKCkgPyB2b2lkIDAgOiBGO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIGludmVydGVkWiBaXi0xIChpbnZlcnRlZCB6ZXJvKSAtIG9wdGlvbmFsLCBwcmVjb21wdXRhdGlvbiBpcyB1c2VmdWwgZm9yIGludmVydEJhdGNoXG4gICAgICovXG4gICAgdG9BZmZpbmUoTikge1xuICAgICAgcmV0dXJuIEsodGhpcywgTik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIFBvaW50IGlzIGZyZWUgb2YgdG9yc2lvbiBlbGVtZW50cyAoaXMgaW4gcHJpbWUgc3ViZ3JvdXApLlxuICAgICAqIEFsd2F5cyB0b3JzaW9uLWZyZWUgZm9yIGNvZmFjdG9yPTEgY3VydmVzLlxuICAgICAqL1xuICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICBjb25zdCB7IGlzVG9yc2lvbkZyZWU6IE4gfSA9IGU7XG4gICAgICByZXR1cm4gbyA9PT0gc2kgPyAhMCA6IE4gPyBOKGosIHRoaXMpIDogZWUud05BRkNhY2hlZFVuc2FmZSh0aGlzLCBpKS5pczAoKTtcbiAgICB9XG4gICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgIGNvbnN0IHsgY2xlYXJDb2ZhY3RvcjogTiB9ID0gZTtcbiAgICAgIHJldHVybiBvID09PSBzaSA/IHRoaXMgOiBOID8gTihqLCB0aGlzKSA6IHRoaXMubXVsdGlwbHlVbnNhZmUobyk7XG4gICAgfVxuICAgIHRvQnl0ZXMoTiA9ICEwKSB7XG4gICAgICByZXR1cm4gZm4oXCJpc0NvbXByZXNzZWRcIiwgTiksIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSwgYihqLCB0aGlzLCBOKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdG9CeXRlc2AgKi9cbiAgICB0b1Jhd0J5dGVzKE4gPSAhMCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcyhOKTtcbiAgICB9XG4gICAgdG9IZXgoTiA9ICEwKSB7XG4gICAgICByZXR1cm4gTm4odGhpcy50b0J5dGVzKE4pKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYDxQb2ludCAke3RoaXMuaXMwKCkgPyBcIlpFUk9cIiA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICB9XG4gIH1cbiAgai5CQVNFID0gbmV3IGoodC5HeCwgdC5HeSwgci5PTkUpLCBqLlpFUk8gPSBuZXcgaihyLlpFUk8sIHIuT05FLCByLlpFUk8pLCBqLkZwID0gciwgai5GbiA9IG47XG4gIGNvbnN0IFYgPSBuLkJJVFMsIGVlID0gTWMoaiwgZS5lbmRvID8gTWF0aC5jZWlsKFYgLyAyKSA6IFYpO1xuICByZXR1cm4gajtcbn1cbmZ1bmN0aW9uIFpjKHQpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkub2YodCA/IDIgOiAzKTtcbn1cbmZ1bmN0aW9uIHAxKHQsIGUsIHIgPSB7fSkge1xuICBVaShlLCB7IGhhc2g6IFwiZnVuY3Rpb25cIiB9LCB7XG4gICAgaG1hYzogXCJmdW5jdGlvblwiLFxuICAgIGxvd1M6IFwiYm9vbGVhblwiLFxuICAgIHJhbmRvbUJ5dGVzOiBcImZ1bmN0aW9uXCIsXG4gICAgYml0czJpbnQ6IFwiZnVuY3Rpb25cIixcbiAgICBiaXRzMmludF9tb2ROOiBcImZ1bmN0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IG4gPSBlLnJhbmRvbUJ5dGVzIHx8IGxjLCBvID0gZS5obWFjIHx8ICgoTCwgLi4uRikgPT4gemMoZS5oYXNoLCBMLCB2ciguLi5GKSkpLCB7IEZwOiBpLCBGbjogYyB9ID0gdCwgeyBPUkRFUjogZiwgQklUUzogdiB9ID0gYztcbiAgZnVuY3Rpb24geChMKSB7XG4gICAgY29uc3QgRiA9IGYgPj4gc2k7XG4gICAgcmV0dXJuIEwgPiBGO1xuICB9XG4gIGZ1bmN0aW9uIGIoTCkge1xuICAgIHJldHVybiB4KEwpID8gYy5uZWcoTCkgOiBMO1xuICB9XG4gIGZ1bmN0aW9uIFMoTCwgRikge1xuICAgIGlmICghYy5pc1ZhbGlkTm90MChGKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzaWduYXR1cmUgJHtMfTogb3V0IG9mIHJhbmdlIDEuLkNVUlZFLm5gKTtcbiAgfVxuICBjbGFzcyBUIHtcbiAgICBjb25zdHJ1Y3RvcihGLCBkLCBzKSB7XG4gICAgICBTKFwiclwiLCBGKSwgUyhcInNcIiwgZCksIHRoaXMuciA9IEYsIHRoaXMucyA9IGQsIHMgIT0gbnVsbCAmJiAodGhpcy5yZWNvdmVyeSA9IHMpLCBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgIHN0YXRpYyBmcm9tQ29tcGFjdChGKSB7XG4gICAgICBjb25zdCBkID0gYy5CWVRFUywgcyA9IHZ0KFwiY29tcGFjdFNpZ25hdHVyZVwiLCBGLCBkICogMik7XG4gICAgICByZXR1cm4gbmV3IFQoYy5mcm9tQnl0ZXMocy5zdWJhcnJheSgwLCBkKSksIGMuZnJvbUJ5dGVzKHMuc3ViYXJyYXkoZCwgZCAqIDIpKSk7XG4gICAgfVxuICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICBzdGF0aWMgZnJvbURFUihGKSB7XG4gICAgICBjb25zdCB7IHI6IGQsIHMgfSA9IG1yLnRvU2lnKHZ0KFwiREVSXCIsIEYpKTtcbiAgICAgIHJldHVybiBuZXcgVChkLCBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRvZG8gcmVtb3ZlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICB9XG4gICAgYWRkUmVjb3ZlcnlCaXQoRikge1xuICAgICAgcmV0dXJuIG5ldyBUKHRoaXMuciwgdGhpcy5zLCBGKTtcbiAgICB9XG4gICAgLy8gUHJvalBvaW50VHlwZTxiaWdpbnQ+XG4gICAgcmVjb3ZlclB1YmxpY0tleShGKSB7XG4gICAgICBjb25zdCBkID0gaS5PUkRFUiwgeyByOiBzLCBzOiB1LCByZWNvdmVyeTogaCB9ID0gdGhpcztcbiAgICAgIGlmIChoID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVjb3ZlcnkgaWQgaW52YWxpZFwiKTtcbiAgICAgIGlmIChmICogbDEgPCBkICYmIGggPiAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWNvdmVyeSBpZCBpcyBhbWJpZ3VvdXMgZm9yIGg+MSBjdXJ2ZVwiKTtcbiAgICAgIGNvbnN0IHcgPSBoID09PSAyIHx8IGggPT09IDMgPyBzICsgZiA6IHM7XG4gICAgICBpZiAoIWkuaXNWYWxpZCh3KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWRcIik7XG4gICAgICBjb25zdCBfID0gaS50b0J5dGVzKHcpLCBBID0gdC5mcm9tSGV4KHZyKFpjKChoICYgMSkgPT09IDApLCBfKSksIHAgPSBjLmludih3KSwgYSA9IFoodnQoXCJtc2dIYXNoXCIsIEYpKSwgbCA9IGMuY3JlYXRlKC1hICogcCksIE0gPSBjLmNyZWF0ZSh1ICogcCksIGsgPSB0LkJBU0UubXVsdGlwbHlVbnNhZmUobCkuYWRkKEEubXVsdGlwbHlVbnNhZmUoTSkpO1xuICAgICAgaWYgKGsuaXMwKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvaW50IGF0IGluZmluaWZ5XCIpO1xuICAgICAgcmV0dXJuIGsuYXNzZXJ0VmFsaWRpdHkoKSwgaztcbiAgICB9XG4gICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgIGhhc0hpZ2hTKCkge1xuICAgICAgcmV0dXJuIHgodGhpcy5zKTtcbiAgICB9XG4gICAgbm9ybWFsaXplUygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgVCh0aGlzLnIsIGMubmVnKHRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICB9XG4gICAgdG9CeXRlcyhGKSB7XG4gICAgICBpZiAoRiA9PT0gXCJjb21wYWN0XCIpXG4gICAgICAgIHJldHVybiB2cihjLnRvQnl0ZXModGhpcy5yKSwgYy50b0J5dGVzKHRoaXMucykpO1xuICAgICAgaWYgKEYgPT09IFwiZGVyXCIpXG4gICAgICAgIHJldHVybiBzYShtci5oZXhGcm9tU2lnKHRoaXMpKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xuICAgIH1cbiAgICAvLyBERVItZW5jb2RlZFxuICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0J5dGVzKFwiZGVyXCIpO1xuICAgIH1cbiAgICB0b0RFUkhleCgpIHtcbiAgICAgIHJldHVybiBObih0aGlzLnRvQnl0ZXMoXCJkZXJcIikpO1xuICAgIH1cbiAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcyhcImNvbXBhY3RcIik7XG4gICAgfVxuICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgIHJldHVybiBObih0aGlzLnRvQnl0ZXMoXCJjb21wYWN0XCIpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgQyA9IHFjKGMsIHIuYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzLCByLndyYXBQcml2YXRlS2V5KSwgUCA9IHtcbiAgICBpc1ZhbGlkUHJpdmF0ZUtleShMKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gQyhMKSwgITA7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogQyxcbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAqL1xuICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgIGNvbnN0IEwgPSBmO1xuICAgICAgcmV0dXJuIGRoKG4oeGMoTCkpLCBMKTtcbiAgICB9LFxuICAgIHByZWNvbXB1dGUoTCA9IDgsIEYgPSB0LkJBU0UpIHtcbiAgICAgIHJldHVybiBGLnByZWNvbXB1dGUoTCwgITEpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gQihMLCBGID0gITApIHtcbiAgICByZXR1cm4gdC5mcm9tUHJpdmF0ZUtleShMKS50b0J5dGVzKEYpO1xuICB9XG4gIGZ1bmN0aW9uIFIoTCkge1xuICAgIGlmICh0eXBlb2YgTCA9PSBcImJpZ2ludFwiKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChMIGluc3RhbmNlb2YgdClcbiAgICAgIHJldHVybiAhMDtcbiAgICBjb25zdCBkID0gdnQoXCJrZXlcIiwgTCkubGVuZ3RoLCBzID0gaS5CWVRFUywgdSA9IHMgKyAxLCBoID0gMiAqIHMgKyAxO1xuICAgIGlmICghKHIuYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIHx8IGMuQllURVMgPT09IHUpKVxuICAgICAgcmV0dXJuIGQgPT09IHUgfHwgZCA9PT0gaDtcbiAgfVxuICBmdW5jdGlvbiB6KEwsIEYsIGQgPSAhMCkge1xuICAgIGlmIChSKEwpID09PSAhMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5XCIpO1xuICAgIGlmIChSKEYpID09PSAhMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5XCIpO1xuICAgIHJldHVybiB0LmZyb21IZXgoRikubXVsdGlwbHkoQyhMKSkudG9CeXRlcyhkKTtcbiAgfVxuICBjb25zdCBLID0gZS5iaXRzMmludCB8fCBmdW5jdGlvbihMKSB7XG4gICAgaWYgKEwubGVuZ3RoID4gODE5MilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0IGlzIHRvbyBsYXJnZVwiKTtcbiAgICBjb25zdCBGID0gTHMoTCksIGQgPSBMLmxlbmd0aCAqIDggLSB2O1xuICAgIHJldHVybiBkID4gMCA/IEYgPj4gQmlnSW50KGQpIDogRjtcbiAgfSwgWiA9IGUuYml0czJpbnRfbW9kTiB8fCBmdW5jdGlvbihMKSB7XG4gICAgcmV0dXJuIGMuY3JlYXRlKEsoTCkpO1xuICB9LCBRID0gTnModik7XG4gIGZ1bmN0aW9uIGooTCkge1xuICAgIHJldHVybiBTbihcIm51bSA8IDJeXCIgKyB2LCBMLCBpaSwgUSksIGMudG9CeXRlcyhMKTtcbiAgfVxuICBmdW5jdGlvbiBWKEwsIEYsIGQgPSBlZSkge1xuICAgIGlmIChbXCJyZWNvdmVyZWRcIiwgXCJjYW5vbmljYWxcIl0uc29tZSgoTSkgPT4gTSBpbiBkKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIGNvbnN0IHsgaGFzaDogcyB9ID0gZTtcbiAgICBsZXQgeyBsb3dTOiB1LCBwcmVoYXNoOiBoLCBleHRyYUVudHJvcHk6IGcgfSA9IGQ7XG4gICAgdSA9PSBudWxsICYmICh1ID0gITApLCBMID0gdnQoXCJtc2dIYXNoXCIsIEwpLCBjdShkKSwgaCAmJiAoTCA9IHZ0KFwicHJlaGFzaGVkIG1zZ0hhc2hcIiwgcyhMKSkpO1xuICAgIGNvbnN0IHcgPSBaKEwpLCBfID0gQyhGKSwgQSA9IFtqKF8pLCBqKHcpXTtcbiAgICBpZiAoZyAhPSBudWxsICYmIGcgIT09ICExKSB7XG4gICAgICBjb25zdCBNID0gZyA9PT0gITAgPyBuKGkuQllURVMpIDogZztcbiAgICAgIEEucHVzaCh2dChcImV4dHJhRW50cm9weVwiLCBNKSk7XG4gICAgfVxuICAgIGNvbnN0IHAgPSB2ciguLi5BKSwgYSA9IHc7XG4gICAgZnVuY3Rpb24gbChNKSB7XG4gICAgICBjb25zdCBrID0gSyhNKTtcbiAgICAgIGlmICghYy5pc1ZhbGlkTm90MChrKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgJCA9IGMuaW52KGspLCBYID0gdC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCksIHJlID0gYy5jcmVhdGUoWC54KTtcbiAgICAgIGlmIChyZSA9PT0gaWkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHNlID0gYy5jcmVhdGUoJCAqIGMuY3JlYXRlKGEgKyByZSAqIF8pKTtcbiAgICAgIGlmIChzZSA9PT0gaWkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCB1dCA9IChYLnggPT09IHJlID8gMCA6IDIpIHwgTnVtYmVyKFgueSAmIHNpKSwgeGUgPSBzZTtcbiAgICAgIHJldHVybiB1ICYmIHgoc2UpICYmICh4ZSA9IGIoc2UpLCB1dCBePSAxKSwgbmV3IFQocmUsIHhlLCB1dCk7XG4gICAgfVxuICAgIHJldHVybiB7IHNlZWQ6IHAsIGsyc2lnOiBsIH07XG4gIH1cbiAgY29uc3QgZWUgPSB7IGxvd1M6IGUubG93UywgcHJlaGFzaDogITEgfSwgRyA9IHsgbG93UzogZS5sb3dTLCBwcmVoYXNoOiAhMSB9O1xuICBmdW5jdGlvbiBOKEwsIEYsIGQgPSBlZSkge1xuICAgIGNvbnN0IHsgc2VlZDogcywgazJzaWc6IHUgfSA9IFYoTCwgRiwgZCk7XG4gICAgcmV0dXJuIG5oKGUuaGFzaC5vdXRwdXRMZW4sIGMuQllURVMsIG8pKHMsIHUpO1xuICB9XG4gIHQuQkFTRS5wcmVjb21wdXRlKDgpO1xuICBmdW5jdGlvbiBPKEwsIEYsIGQsIHMgPSBHKSB7XG4gICAgY29uc3QgdSA9IEw7XG4gICAgRiA9IHZ0KFwibXNnSGFzaFwiLCBGKSwgZCA9IHZ0KFwicHVibGljS2V5XCIsIGQpLCBjdShzKTtcbiAgICBjb25zdCB7IGxvd1M6IGgsIHByZWhhc2g6IGcsIGZvcm1hdDogdyB9ID0gcztcbiAgICBpZiAoXCJzdHJpY3RcIiBpbiBzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93U1wiKTtcbiAgICBpZiAodyAhPT0gdm9pZCAwICYmICFbXCJjb21wYWN0XCIsIFwiZGVyXCIsIFwianNcIl0uaW5jbHVkZXModykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBtdXN0IGJlIFwiY29tcGFjdFwiLCBcImRlclwiIG9yIFwianNcIicpO1xuICAgIGNvbnN0IF8gPSB0eXBlb2YgdSA9PSBcInN0cmluZ1wiIHx8IGlhKHUpLCBBID0gIV8gJiYgIXcgJiYgdHlwZW9mIHUgPT0gXCJvYmplY3RcIiAmJiB1ICE9PSBudWxsICYmIHR5cGVvZiB1LnIgPT0gXCJiaWdpbnRcIiAmJiB0eXBlb2YgdS5zID09IFwiYmlnaW50XCI7XG4gICAgaWYgKCFfICYmICFBKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUsIGV4cGVjdGVkIFVpbnQ4QXJyYXksIGhleCBzdHJpbmcgb3IgU2lnbmF0dXJlIGluc3RhbmNlXCIpO1xuICAgIGxldCBwLCBhO1xuICAgIHRyeSB7XG4gICAgICBpZiAoQSlcbiAgICAgICAgaWYgKHcgPT09IHZvaWQgMCB8fCB3ID09PSBcImpzXCIpXG4gICAgICAgICAgcCA9IG5ldyBUKHUuciwgdS5zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xuICAgICAgaWYgKF8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3ICE9PSBcImNvbXBhY3RcIiAmJiAocCA9IFQuZnJvbURFUih1KSk7XG4gICAgICAgIH0gY2F0Y2ggKHhlKSB7XG4gICAgICAgICAgaWYgKCEoeGUgaW5zdGFuY2VvZiBtci5FcnIpKVxuICAgICAgICAgICAgdGhyb3cgeGU7XG4gICAgICAgIH1cbiAgICAgICAgIXAgJiYgdyAhPT0gXCJkZXJcIiAmJiAocCA9IFQuZnJvbUNvbXBhY3QodSkpO1xuICAgICAgfVxuICAgICAgYSA9IHQuZnJvbUhleChkKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgaWYgKCFwIHx8IGggJiYgcC5oYXNIaWdoUygpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGcgJiYgKEYgPSBlLmhhc2goRikpO1xuICAgIGNvbnN0IHsgcjogbCwgczogTSB9ID0gcCwgayA9IFooRiksICQgPSBjLmludihNKSwgWCA9IGMuY3JlYXRlKGsgKiAkKSwgcmUgPSBjLmNyZWF0ZShsICogJCksIHNlID0gdC5CQVNFLm11bHRpcGx5VW5zYWZlKFgpLmFkZChhLm11bHRpcGx5VW5zYWZlKHJlKSk7XG4gICAgcmV0dXJuIHNlLmlzMCgpID8gITEgOiBjLmNyZWF0ZShzZS54KSA9PT0gbDtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZ2V0UHVibGljS2V5OiBCLFxuICAgIGdldFNoYXJlZFNlY3JldDogeixcbiAgICBzaWduOiBOLFxuICAgIHZlcmlmeTogTyxcbiAgICB1dGlsczogUCxcbiAgICBQb2ludDogdCxcbiAgICBTaWduYXR1cmU6IFRcbiAgfSk7XG59XG5mdW5jdGlvbiBtMSh0KSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgYTogdC5hLFxuICAgIGI6IHQuYixcbiAgICBwOiB0LkZwLk9SREVSLFxuICAgIG46IHQubixcbiAgICBoOiB0LmgsXG4gICAgR3g6IHQuR3gsXG4gICAgR3k6IHQuR3lcbiAgfSwgciA9IHQuRnAsIG4gPSAkbihlLm4sIHQubkJpdExlbmd0aCksIG8gPSB7XG4gICAgRnA6IHIsXG4gICAgRm46IG4sXG4gICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiB0LmFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyxcbiAgICBhbGxvd0luZmluaXR5UG9pbnQ6IHQuYWxsb3dJbmZpbml0eVBvaW50LFxuICAgIGVuZG86IHQuZW5kbyxcbiAgICB3cmFwUHJpdmF0ZUtleTogdC53cmFwUHJpdmF0ZUtleSxcbiAgICBpc1RvcnNpb25GcmVlOiB0LmlzVG9yc2lvbkZyZWUsXG4gICAgY2xlYXJDb2ZhY3RvcjogdC5jbGVhckNvZmFjdG9yLFxuICAgIGZyb21CeXRlczogdC5mcm9tQnl0ZXMsXG4gICAgdG9CeXRlczogdC50b0J5dGVzXG4gIH07XG4gIHJldHVybiB7IENVUlZFOiBlLCBjdXJ2ZU9wdHM6IG8gfTtcbn1cbmZ1bmN0aW9uIGcxKHQpIHtcbiAgY29uc3QgeyBDVVJWRTogZSwgY3VydmVPcHRzOiByIH0gPSBtMSh0KSwgbiA9IHtcbiAgICBoYXNoOiB0Lmhhc2gsXG4gICAgaG1hYzogdC5obWFjLFxuICAgIHJhbmRvbUJ5dGVzOiB0LnJhbmRvbUJ5dGVzLFxuICAgIGxvd1M6IHQubG93UyxcbiAgICBiaXRzMmludDogdC5iaXRzMmludCxcbiAgICBiaXRzMmludF9tb2ROOiB0LmJpdHMyaW50X21vZE5cbiAgfTtcbiAgcmV0dXJuIHsgQ1VSVkU6IGUsIGN1cnZlT3B0czogciwgZWNkc2FPcHRzOiBuIH07XG59XG5mdW5jdGlvbiB5MSh0LCBlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBlLCB7XG4gICAgUHJvamVjdGl2ZVBvaW50OiBlLlBvaW50LFxuICAgIENVUlZFOiB0XG4gIH0pO1xufVxuZnVuY3Rpb24gdjEodCkge1xuICBjb25zdCB7IENVUlZFOiBlLCBjdXJ2ZU9wdHM6IHIsIGVjZHNhT3B0czogbiB9ID0gZzEodCksIG8gPSBkMShlLCByKSwgaSA9IHAxKG8sIG4sIHIpO1xuICByZXR1cm4geTEodCwgaSk7XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5mdW5jdGlvbiB3MSh0LCBlKSB7XG4gIGNvbnN0IHIgPSAobikgPT4gdjEoeyAuLi50LCBoYXNoOiBuIH0pO1xuICByZXR1cm4geyAuLi5yKGUpLCBjcmVhdGU6IHIgfTtcbn1cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IGJzID0ge1xuICBwOiBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmZcIiksXG4gIG46IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKSxcbiAgaDogQmlnSW50KDEpLFxuICBhOiBCaWdJbnQoMCksXG4gIGI6IEJpZ0ludCg3KSxcbiAgR3g6IEJpZ0ludChcIjB4NzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OFwiKSxcbiAgR3k6IEJpZ0ludChcIjB4NDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOFwiKVxufTtcbkJpZ0ludCgwKTtcbmNvbnN0IHgxID0gQmlnSW50KDEpLCBPbyA9IEJpZ0ludCgyKSwgbHUgPSAodCwgZSkgPT4gKHQgKyBlIC8gT28pIC8gZTtcbmZ1bmN0aW9uIGIxKHQpIHtcbiAgY29uc3QgZSA9IGJzLnAsIHIgPSBCaWdJbnQoMyksIG4gPSBCaWdJbnQoNiksIG8gPSBCaWdJbnQoMTEpLCBpID0gQmlnSW50KDIyKSwgYyA9IEJpZ0ludCgyMyksIGYgPSBCaWdJbnQoNDQpLCB2ID0gQmlnSW50KDg4KSwgeCA9IHQgKiB0ICogdCAlIGUsIGIgPSB4ICogeCAqIHQgJSBlLCBTID0gcHQoYiwgciwgZSkgKiBiICUgZSwgVCA9IHB0KFMsIHIsIGUpICogYiAlIGUsIEMgPSBwdChULCBPbywgZSkgKiB4ICUgZSwgUCA9IHB0KEMsIG8sIGUpICogQyAlIGUsIEIgPSBwdChQLCBpLCBlKSAqIFAgJSBlLCBSID0gcHQoQiwgZiwgZSkgKiBCICUgZSwgeiA9IHB0KFIsIHYsIGUpICogUiAlIGUsIEsgPSBwdCh6LCBmLCBlKSAqIEIgJSBlLCBaID0gcHQoSywgciwgZSkgKiBiICUgZSwgUSA9IHB0KFosIGMsIGUpICogUCAlIGUsIGogPSBwdChRLCBuLCBlKSAqIHggJSBlLCBWID0gcHQoaiwgT28sIGUpO1xuICBpZiAoIU5vLmVxbChOby5zcXIoViksIHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICByZXR1cm4gVjtcbn1cbmNvbnN0IE5vID0gJG4oYnMucCwgdm9pZCAwLCB2b2lkIDAsIHsgc3FydDogYjEgfSksIF8xID0gdzEoe1xuICAuLi5icyxcbiAgRnA6IE5vLFxuICBsb3dTOiAhMCxcbiAgLy8gQWxsb3cgb25seSBsb3ctUyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQgaW4gc2lnbigpIGFuZCB2ZXJpZnkoKVxuICBlbmRvOiB7XG4gICAgLy8gRW5kb21vcnBoaXNtLCBzZWUgYWJvdmVcbiAgICBiZXRhOiBCaWdJbnQoXCIweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWVcIiksXG4gICAgc3BsaXRTY2FsYXI6ICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gYnMubiwgciA9IEJpZ0ludChcIjB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTVcIiksIG4gPSAteDEgKiBCaWdJbnQoXCIweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzXCIpLCBvID0gQmlnSW50KFwiMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDhcIiksIGkgPSByLCBjID0gQmlnSW50KFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiksIGYgPSBsdShpICogdCwgZSksIHYgPSBsdSgtbiAqIHQsIGUpO1xuICAgICAgbGV0IHggPSB3dCh0IC0gZiAqIHIgLSB2ICogbywgZSksIGIgPSB3dCgtZiAqIG4gLSB2ICogaSwgZSk7XG4gICAgICBjb25zdCBTID0geCA+IGMsIFQgPSBiID4gYztcbiAgICAgIGlmIChTICYmICh4ID0gZSAtIHgpLCBUICYmIChiID0gZSAtIGIpLCB4ID4gYyB8fCBiID4gYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9XCIgKyB0KTtcbiAgICAgIHJldHVybiB7IGsxbmVnOiBTLCBrMTogeCwgazJuZWc6IFQsIGsyOiBiIH07XG4gICAgfVxuICB9XG59LCBRMCk7XG5GaS51dGlscy5yYW5kb21Qcml2YXRlS2V5O1xuRmkuZ2V0UHVibGljS2V5O1xuZnVuY3Rpb24gZnUodCkge1xuICB0cnkge1xuICAgIHJldHVybiBGaS5FeHRlbmRlZFBvaW50LmZyb21IZXgodCksICEwO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNvbnN0IFZjID0gKHQsIGUpID0+IEZpLnNpZ24odCwgZS5zbGljZSgwLCAzMikpLCBFMSA9IEZpLnZlcmlmeSwgZGEgPSAodCkgPT4gZXQuQnVmZmVyLmlzQnVmZmVyKHQpID8gdCA6IHQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gZXQuQnVmZmVyLmZyb20odC5idWZmZXIsIHQuYnl0ZU9mZnNldCwgdC5ieXRlTGVuZ3RoKSA6IGV0LkJ1ZmZlci5mcm9tKHQpO1xuY2xhc3MgTTEge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBlKTtcbiAgfVxuICBlbmNvZGUoKSB7XG4gICAgcmV0dXJuIGV0LkJ1ZmZlci5mcm9tKG9vLnNlcmlhbGl6ZShpcywgdGhpcykpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGUoZSkge1xuICAgIHJldHVybiBvby5kZXNlcmlhbGl6ZShpcywgdGhpcywgZSk7XG4gIH1cbiAgc3RhdGljIGRlY29kZVVuY2hlY2tlZChlKSB7XG4gICAgcmV0dXJuIG9vLmRlc2VyaWFsaXplVW5jaGVja2VkKGlzLCB0aGlzLCBlKTtcbiAgfVxufVxuY29uc3QgaXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIEhjO1xuY29uc3QgQzEgPSAzMiwgUnIgPSAzMjtcbmZ1bmN0aW9uIFMxKHQpIHtcbiAgcmV0dXJuIHQuX2JuICE9PSB2b2lkIDA7XG59XG5sZXQgaHUgPSAxO1xuY2xhc3MgUmUgZXh0ZW5kcyBNMSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUHVibGljS2V5IG9iamVjdFxuICAgKiBAcGFyYW0gdmFsdWUgZWQyNTUxOSBwdWJsaWMga2V5IGFzIGJ1ZmZlciBvciBiYXNlLTU4IGVuY29kZWQgc3RyaW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgaWYgKHN1cGVyKHt9KSwgdGhpcy5fYm4gPSB2b2lkIDAsIFMxKGUpKVxuICAgICAgdGhpcy5fYm4gPSBlLl9ibjtcbiAgICBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHIgPSBOdC5kZWNvZGUoZSk7XG4gICAgICAgIGlmIChyLmxlbmd0aCAhPSBScilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHB1YmxpYyBrZXkgaW5wdXRcIik7XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEthKHIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEthKGUpO1xuICAgICAgaWYgKHRoaXMuX2JuLmJ5dGVMZW5ndGgoKSA+IFJyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHB1YmxpYyBrZXkgaW5wdXRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIFB1YmxpY0tleSBmb3IgdGVzdHMgYW5kIGJlbmNobWFya3MgdXNpbmcgYSBjb3VudGVyXG4gICAqL1xuICBzdGF0aWMgdW5pcXVlKCkge1xuICAgIGNvbnN0IGUgPSBuZXcgUmUoaHUpO1xuICAgIHJldHVybiBodSArPSAxLCBuZXcgUmUoZS50b0J1ZmZlcigpKTtcbiAgfVxuICAvKipcbiAgICogRGVmYXVsdCBwdWJsaWMga2V5IHZhbHVlLiBUaGUgYmFzZTU4LWVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGlzIGFsbCBvbmVzIChhcyBzZWVuIGJlbG93KVxuICAgKiBUaGUgdW5kZXJseWluZyBCTiBudW1iZXIgaXMgMzIgYnl0ZXMgdGhhdCBhcmUgYWxsIHplcm9zXG4gICAqL1xuICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBwdWJsaWNLZXlzIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYm4uZXEoZS5fYm4pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvQmFzZTU4KCkge1xuICAgIHJldHVybiBOdC5lbmNvZGUodGhpcy50b0J5dGVzKCkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0Jhc2U1OCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgKi9cbiAgdG9CeXRlcygpIHtcbiAgICBjb25zdCBlID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShlLmJ1ZmZlciwgZS5ieXRlT2Zmc2V0LCBlLmJ5dGVMZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J1ZmZlcigpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYm4udG9BcnJheUxpa2UoZXQuQnVmZmVyKTtcbiAgICBpZiAoZS5sZW5ndGggPT09IFJyKVxuICAgICAgcmV0dXJuIGU7XG4gICAgY29uc3QgciA9IGV0LkJ1ZmZlci5hbGxvYygzMik7XG4gICAgcmV0dXJuIGUuY29weShyLCAzMiAtIGUubGVuZ3RoKSwgcjtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIGBQdWJsaWNLZXkoJHt0aGlzLnRvU3RyaW5nKCl9KWA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYmFzZS01OCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuICAvKipcbiAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIGFub3RoZXIga2V5LCBhIHNlZWQsIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqIFRoZSBwcm9ncmFtIElEIHdpbGwgYWxzbyBzZXJ2ZSBhcyB0aGUgb3duZXIgb2YgdGhlIHB1YmxpYyBrZXksIGdpdmluZ1xuICAgKiBpdCBwZXJtaXNzaW9uIHRvIHdyaXRlIGRhdGEgdG8gdGhlIGFjY291bnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVXaXRoU2VlZChlLCByLCBuKSB7XG4gICAgY29uc3QgbyA9IGV0LkJ1ZmZlci5jb25jYXQoW2UudG9CdWZmZXIoKSwgZXQuQnVmZmVyLmZyb20ociksIG4udG9CdWZmZXIoKV0pLCBpID0gWGEobyk7XG4gICAgcmV0dXJuIG5ldyBSZShpKTtcbiAgfVxuICAvKipcbiAgICogRGVyaXZlIGEgcHJvZ3JhbSBhZGRyZXNzIGZyb20gc2VlZHMgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhlLCByKSB7XG4gICAgbGV0IG4gPSBldC5CdWZmZXIuYWxsb2MoMCk7XG4gICAgZS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIGlmIChpLmxlbmd0aCA+IEMxKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWF4IHNlZWQgbGVuZ3RoIGV4Y2VlZGVkXCIpO1xuICAgICAgbiA9IGV0LkJ1ZmZlci5jb25jYXQoW24sIGRhKGkpXSk7XG4gICAgfSksIG4gPSBldC5CdWZmZXIuY29uY2F0KFtuLCByLnRvQnVmZmVyKCksIGV0LkJ1ZmZlci5mcm9tKFwiUHJvZ3JhbURlcml2ZWRBZGRyZXNzXCIpXSk7XG4gICAgY29uc3QgbyA9IFhhKG4pO1xuICAgIGlmIChmdShvKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VlZHMsIGFkZHJlc3MgbXVzdCBmYWxsIG9mZiB0aGUgY3VydmVcIik7XG4gICAgcmV0dXJuIG5ldyBSZShvKTtcbiAgfVxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVQcm9ncmFtQWRkcmVzcyhlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKGUsIHIpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGEgdmFsaWQgcHJvZ3JhbSBhZGRyZXNzXG4gICAqXG4gICAqIFZhbGlkIHByb2dyYW0gYWRkcmVzc2VzIG11c3QgZmFsbCBvZmYgdGhlIGVkMjU1MTkgY3VydmUuICBUaGlzIGZ1bmN0aW9uXG4gICAqIGl0ZXJhdGVzIGEgbm9uY2UgdW50aWwgaXQgZmluZHMgb25lIHRoYXQgd2hlbiBjb21iaW5lZCB3aXRoIHRoZSBzZWVkc1xuICAgKiByZXN1bHRzIGluIGEgdmFsaWQgcHJvZ3JhbSBhZGRyZXNzLlxuICAgKi9cbiAgc3RhdGljIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoZSwgcikge1xuICAgIGxldCBuID0gMjU1LCBvO1xuICAgIGZvciAoOyBuICE9IDA7ICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaSA9IGUuY29uY2F0KGV0LkJ1ZmZlci5mcm9tKFtuXSkpO1xuICAgICAgICBvID0gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoaSwgcik7XG4gICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgIGlmIChpIGluc3RhbmNlb2YgVHlwZUVycm9yKVxuICAgICAgICAgIHRocm93IGk7XG4gICAgICAgIG4tLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW28sIG5dO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBhIHZpYWJsZSBwcm9ncmFtIGFkZHJlc3Mgbm9uY2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIEFzeW5jIHZlcnNpb24gb2YgZmluZFByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZFByb2dyYW1BZGRyZXNzKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kUHJvZ3JhbUFkZHJlc3NTeW5jKGUsIHIpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayB0aGF0IGEgcHVia2V5IGlzIG9uIHRoZSBlZDI1NTE5IGN1cnZlLlxuICAgKi9cbiAgc3RhdGljIGlzT25DdXJ2ZShlKSB7XG4gICAgY29uc3QgciA9IG5ldyBSZShlKTtcbiAgICByZXR1cm4gZnUoci50b0J5dGVzKCkpO1xuICB9XG59XG5IYyA9IFJlO1xuUmUuZGVmYXVsdCA9IG5ldyBIYyhcIjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xuaXMuc2V0KFJlLCB7XG4gIGtpbmQ6IFwic3RydWN0XCIsXG4gIGZpZWxkczogW1tcIl9iblwiLCBcInUyNTZcIl1dXG59KTtcbm5ldyBSZShcIkJQRkxvYWRlcjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5jb25zdCBCbiA9IDEyMzIsIHBhID0gMTI3LCBfcyA9IDY0O1xuY2xhc3MgRXMge1xuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMCwgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdm9pZCAwLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gZSwgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gcjtcbiAgfVxuICBrZXlTZWdtZW50cygpIHtcbiAgICBjb25zdCBlID0gW3RoaXMuc3RhdGljQWNjb3VudEtleXNdO1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgJiYgKGUucHVzaCh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUpLCBlLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5KSksIGU7XG4gIH1cbiAgZ2V0KGUpIHtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5rZXlTZWdtZW50cygpKSB7XG4gICAgICBpZiAoZSA8IHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcltlXTtcbiAgICAgIGUgLT0gci5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkubGVuZ3RoO1xuICB9XG4gIGNvbXBpbGVJbnN0cnVjdGlvbnMoZSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDI1NilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgaW5kZXggb3ZlcmZsb3cgZW5jb3VudGVyZWQgZHVyaW5nIGNvbXBpbGF0aW9uXCIpO1xuICAgIGNvbnN0IG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkuZm9yRWFjaCgoaSwgYykgPT4ge1xuICAgICAgbi5zZXQoaS50b0Jhc2U1OCgpLCBjKTtcbiAgICB9KTtcbiAgICBjb25zdCBvID0gKGkpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBuLmdldChpLnRvQmFzZTU4KCkpO1xuICAgICAgaWYgKGMgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwiRW5jb3VudGVyZWQgYW4gdW5rbm93biBpbnN0cnVjdGlvbiBhY2NvdW50IGtleSBkdXJpbmcgY29tcGlsYXRpb25cIik7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICAgIHJldHVybiBlLm1hcCgoaSkgPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBvKGkucHJvZ3JhbUlkKSxcbiAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpLmtleXMubWFwKChjKSA9PiBvKGMucHVia2V5KSksXG4gICAgICBkYXRhOiBpLmRhdGFcbiAgICB9KSk7XG4gIH1cbn1cbmNvbnN0IHR0ID0gKHQgPSBcInB1YmxpY0tleVwiKSA9PiBELmJsb2IoMzIsIHQpLCBBMSA9ICh0ID0gXCJzaWduYXR1cmVcIikgPT4gRC5ibG9iKDY0LCB0KSwgQW4gPSAodCA9IFwic3RyaW5nXCIpID0+IHtcbiAgY29uc3QgZSA9IEQuc3RydWN0KFtELnUzMihcImxlbmd0aFwiKSwgRC51MzIoXCJsZW5ndGhQYWRkaW5nXCIpLCBELmJsb2IoRC5vZmZzZXQoRC51MzIoKSwgLTgpLCBcImNoYXJzXCIpXSwgdCksIHIgPSBlLmRlY29kZS5iaW5kKGUpLCBuID0gZS5lbmNvZGUuYmluZChlKSwgbyA9IGU7XG4gIHJldHVybiBvLmRlY29kZSA9IChpLCBjKSA9PiByKGksIGMpLmNoYXJzLnRvU3RyaW5nKCksIG8uZW5jb2RlID0gKGksIGMsIGYpID0+IHtcbiAgICBjb25zdCB2ID0ge1xuICAgICAgY2hhcnM6IGV0LkJ1ZmZlci5mcm9tKGksIFwidXRmOFwiKVxuICAgIH07XG4gICAgcmV0dXJuIG4odiwgYywgZik7XG4gIH0sIG8uYWxsb2MgPSAoaSkgPT4gRC51MzIoKS5zcGFuICsgRC51MzIoKS5zcGFuICsgZXQuQnVmZmVyLmZyb20oaSwgXCJ1dGY4XCIpLmxlbmd0aCwgbztcbn0sIGsxID0gKHQgPSBcImF1dGhvcml6ZWRcIikgPT4gRC5zdHJ1Y3QoW3R0KFwic3Rha2VyXCIpLCB0dChcIndpdGhkcmF3ZXJcIildLCB0KSwgSTEgPSAodCA9IFwibG9ja3VwXCIpID0+IEQuc3RydWN0KFtELm5zNjQoXCJ1bml4VGltZXN0YW1wXCIpLCBELm5zNjQoXCJlcG9jaFwiKSwgdHQoXCJjdXN0b2RpYW5cIildLCB0KSwgQjEgPSAodCA9IFwidm90ZUluaXRcIikgPT4gRC5zdHJ1Y3QoW3R0KFwibm9kZVB1YmtleVwiKSwgdHQoXCJhdXRob3JpemVkVm90ZXJcIiksIHR0KFwiYXV0aG9yaXplZFdpdGhkcmF3ZXJcIiksIEQudTgoXCJjb21taXNzaW9uXCIpXSwgdCksIFIxID0gKHQgPSBcInZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3NcIikgPT4gRC5zdHJ1Y3QoW0QudTMyKFwidm90ZUF1dGhvcml6YXRpb25UeXBlXCIpLCB0dChcImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXlcIiksIEFuKFwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkXCIpLCB0dChcIm5ld0F1dGhvcml6ZWRcIildLCB0KTtcbmZ1bmN0aW9uICR0KHQpIHtcbiAgbGV0IGUgPSAwLCByID0gMDtcbiAgZm9yICg7IDsgKSB7XG4gICAgbGV0IG4gPSB0LnNoaWZ0KCk7XG4gICAgaWYgKGUgfD0gKG4gJiAxMjcpIDw8IHIgKiA3LCByICs9IDEsIChuICYgMTI4KSA9PT0gMClcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24genQodCwgZSkge1xuICBsZXQgciA9IGU7XG4gIGZvciAoOyA7ICkge1xuICAgIGxldCBuID0gciAmIDEyNztcbiAgICBpZiAociA+Pj0gNywgciA9PSAwKSB7XG4gICAgICB0LnB1c2gobik7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2VcbiAgICAgIG4gfD0gMTI4LCB0LnB1c2gobik7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ0KHQsIGUpIHtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBFcnJvcihlIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKTtcbn1cbmNsYXNzICRzIHtcbiAgY29uc3RydWN0b3IoZSwgcikge1xuICAgIHRoaXMucGF5ZXIgPSB2b2lkIDAsIHRoaXMua2V5TWV0YU1hcCA9IHZvaWQgMCwgdGhpcy5wYXllciA9IGUsIHRoaXMua2V5TWV0YU1hcCA9IHI7XG4gIH1cbiAgc3RhdGljIGNvbXBpbGUoZSwgcikge1xuICAgIGNvbnN0IG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBvID0gKGMpID0+IHtcbiAgICAgIGNvbnN0IGYgPSBjLnRvQmFzZTU4KCk7XG4gICAgICBsZXQgdiA9IG4uZ2V0KGYpO1xuICAgICAgcmV0dXJuIHYgPT09IHZvaWQgMCAmJiAodiA9IHtcbiAgICAgICAgaXNTaWduZXI6ICExLFxuICAgICAgICBpc1dyaXRhYmxlOiAhMSxcbiAgICAgICAgaXNJbnZva2VkOiAhMVxuICAgICAgfSwgbi5zZXQoZiwgdikpLCB2O1xuICAgIH0sIGkgPSBvKHIpO1xuICAgIGkuaXNTaWduZXIgPSAhMCwgaS5pc1dyaXRhYmxlID0gITA7XG4gICAgZm9yIChjb25zdCBjIG9mIGUpIHtcbiAgICAgIG8oYy5wcm9ncmFtSWQpLmlzSW52b2tlZCA9ICEwO1xuICAgICAgZm9yIChjb25zdCBmIG9mIGMua2V5cykge1xuICAgICAgICBjb25zdCB2ID0gbyhmLnB1YmtleSk7XG4gICAgICAgIHYuaXNTaWduZXIgfHwgKHYuaXNTaWduZXIgPSBmLmlzU2lnbmVyKSwgdi5pc1dyaXRhYmxlIHx8ICh2LmlzV3JpdGFibGUgPSBmLmlzV3JpdGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3ICRzKHIsIG4pO1xuICB9XG4gIGdldE1lc3NhZ2VDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IGUgPSBbLi4udGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKV07XG4gICAgYnQoZS5sZW5ndGggPD0gMjU2LCBcIk1heCBzdGF0aWMgYWNjb3VudCBrZXlzIGxlbmd0aCBleGNlZWRlZFwiKTtcbiAgICBjb25zdCByID0gZS5maWx0ZXIoKFssIHZdKSA9PiB2LmlzU2lnbmVyICYmIHYuaXNXcml0YWJsZSksIG4gPSBlLmZpbHRlcigoWywgdl0pID0+IHYuaXNTaWduZXIgJiYgIXYuaXNXcml0YWJsZSksIG8gPSBlLmZpbHRlcigoWywgdl0pID0+ICF2LmlzU2lnbmVyICYmIHYuaXNXcml0YWJsZSksIGkgPSBlLmZpbHRlcigoWywgdl0pID0+ICF2LmlzU2lnbmVyICYmICF2LmlzV3JpdGFibGUpLCBjID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiByLmxlbmd0aCArIG4ubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogbi5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGkubGVuZ3RoXG4gICAgfTtcbiAgICB7XG4gICAgICBidChyLmxlbmd0aCA+IDAsIFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHdyaXRhYmxlIHNpZ25lciBrZXlcIik7XG4gICAgICBjb25zdCBbdl0gPSByWzBdO1xuICAgICAgYnQodiA9PT0gdGhpcy5wYXllci50b0Jhc2U1OCgpLCBcIkV4cGVjdGVkIGZpcnN0IHdyaXRhYmxlIHNpZ25lciBrZXkgdG8gYmUgdGhlIGZlZSBwYXllclwiKTtcbiAgICB9XG4gICAgY29uc3QgZiA9IFsuLi5yLm1hcCgoW3ZdKSA9PiBuZXcgUmUodikpLCAuLi5uLm1hcCgoW3ZdKSA9PiBuZXcgUmUodikpLCAuLi5vLm1hcCgoW3ZdKSA9PiBuZXcgUmUodikpLCAuLi5pLm1hcCgoW3ZdKSA9PiBuZXcgUmUodikpXTtcbiAgICByZXR1cm4gW2MsIGZdO1xuICB9XG4gIGV4dHJhY3RUYWJsZUxvb2t1cChlKSB7XG4gICAgY29uc3QgW3IsIG5dID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUoZS5zdGF0ZS5hZGRyZXNzZXMsIChjKSA9PiAhYy5pc1NpZ25lciAmJiAhYy5pc0ludm9rZWQgJiYgYy5pc1dyaXRhYmxlKSwgW28sIGldID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUoZS5zdGF0ZS5hZGRyZXNzZXMsIChjKSA9PiAhYy5pc1NpZ25lciAmJiAhYy5pc0ludm9rZWQgJiYgIWMuaXNXcml0YWJsZSk7XG4gICAgaWYgKCEoci5sZW5ndGggPT09IDAgJiYgby5sZW5ndGggPT09IDApKVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGFjY291bnRLZXk6IGUua2V5LFxuICAgICAgICB3cml0YWJsZUluZGV4ZXM6IHIsXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlczogb1xuICAgICAgfSwge1xuICAgICAgICB3cml0YWJsZTogbixcbiAgICAgICAgcmVhZG9ubHk6IGlcbiAgICAgIH1dO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGUsIHIpIHtcbiAgICBjb25zdCBuID0gbmV3IEFycmF5KCksIG8gPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IFtpLCBjXSBvZiB0aGlzLmtleU1ldGFNYXAuZW50cmllcygpKVxuICAgICAgaWYgKHIoYykpIHtcbiAgICAgICAgY29uc3QgZiA9IG5ldyBSZShpKSwgdiA9IGUuZmluZEluZGV4KCh4KSA9PiB4LmVxdWFscyhmKSk7XG4gICAgICAgIHYgPj0gMCAmJiAoYnQodiA8IDI1NiwgXCJNYXggbG9va3VwIHRhYmxlIGluZGV4IGV4Y2VlZGVkXCIpLCBuLnB1c2godiksIG8ucHVzaChmKSwgdGhpcy5rZXlNZXRhTWFwLmRlbGV0ZShpKSk7XG4gICAgICB9XG4gICAgcmV0dXJuIFtuLCBvXTtcbiAgfVxufVxuY29uc3QgS2MgPSBcIlJlYWNoZWQgZW5kIG9mIGJ1ZmZlciB1bmV4cGVjdGVkbHlcIjtcbmZ1bmN0aW9uIHlyKHQpIHtcbiAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihLYyk7XG4gIHJldHVybiB0LnNoaWZ0KCk7XG59XG5mdW5jdGlvbiBxdCh0LCAuLi5lKSB7XG4gIGNvbnN0IFtyXSA9IGU7XG4gIGlmIChlLmxlbmd0aCA9PT0gMiA/IHIgKyAoZVsxXSA/PyAwKSA+IHQubGVuZ3RoIDogciA+PSB0Lmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoS2MpO1xuICByZXR1cm4gdC5zcGxpY2UoLi4uZSk7XG59XG5jbGFzcyBGbiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMCwgdGhpcy5hY2NvdW50S2V5cyA9IHZvaWQgMCwgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDAsIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwLCB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5oZWFkZXIgPSBlLmhlYWRlciwgdGhpcy5hY2NvdW50S2V5cyA9IGUuYWNjb3VudEtleXMubWFwKChyKSA9PiBuZXcgUmUocikpLCB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGUucmVjZW50QmxvY2toYXNoLCB0aGlzLmluc3RydWN0aW9ucyA9IGUuaW5zdHJ1Y3Rpb25zLCB0aGlzLmluc3RydWN0aW9ucy5mb3JFYWNoKChyKSA9PiB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnNldChyLnByb2dyYW1JZEluZGV4LCB0aGlzLmFjY291bnRLZXlzW3IucHJvZ3JhbUlkSW5kZXhdKSk7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIFwibGVnYWN5XCI7XG4gIH1cbiAgZ2V0IHN0YXRpY0FjY291bnRLZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzO1xuICB9XG4gIGdldCBjb21waWxlZEluc3RydWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnMubWFwKChlKSA9PiAoe1xuICAgICAgcHJvZ3JhbUlkSW5kZXg6IGUucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50S2V5SW5kZXhlczogZS5hY2NvdW50cyxcbiAgICAgIGRhdGE6IE50LmRlY29kZShlLmRhdGEpXG4gICAgfSkpO1xuICB9XG4gIGdldCBhZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gbmV3IEVzKHRoaXMuc3RhdGljQWNjb3VudEtleXMpO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGUpIHtcbiAgICBjb25zdCByID0gJHMuY29tcGlsZShlLmluc3RydWN0aW9ucywgZS5wYXllcktleSksIFtuLCBvXSA9IHIuZ2V0TWVzc2FnZUNvbXBvbmVudHMoKSwgYyA9IG5ldyBFcyhvKS5jb21waWxlSW5zdHJ1Y3Rpb25zKGUuaW5zdHJ1Y3Rpb25zKS5tYXAoKGYpID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogZi5wcm9ncmFtSWRJbmRleCxcbiAgICAgIGFjY291bnRzOiBmLmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgZGF0YTogTnQuZW5jb2RlKGYuZGF0YSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIG5ldyBGbih7XG4gICAgICBoZWFkZXI6IG4sXG4gICAgICBhY2NvdW50S2V5czogbyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogZS5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IGNcbiAgICB9KTtcbiAgfVxuICBpc0FjY291bnRTaWduZXIoZSkge1xuICAgIHJldHVybiBlIDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGlmIChlID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgbiA9IGUgLSByLCBpID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGggLSByIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIG4gPCBpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuID0gciAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gZSA8IG47XG4gICAgfVxuICB9XG4gIGlzUHJvZ3JhbUlkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5oYXMoZSk7XG4gIH1cbiAgcHJvZ3JhbUlkcygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuaW5kZXhUb1Byb2dyYW1JZHMudmFsdWVzKCldO1xuICB9XG4gIG5vblByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudEtleXMuZmlsdGVyKChlLCByKSA9PiAhdGhpcy5pc1Byb2dyYW1JZChyKSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aDtcbiAgICBsZXQgciA9IFtdO1xuICAgIHp0KHIsIGUpO1xuICAgIGNvbnN0IG4gPSB0aGlzLmluc3RydWN0aW9ucy5tYXAoKFMpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHM6IFQsXG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBDXG4gICAgICB9ID0gUywgUCA9IEFycmF5LmZyb20oTnQuZGVjb2RlKFMuZGF0YSkpO1xuICAgICAgbGV0IEIgPSBbXTtcbiAgICAgIHp0KEIsIFQubGVuZ3RoKTtcbiAgICAgIGxldCBSID0gW107XG4gICAgICByZXR1cm4genQoUiwgUC5sZW5ndGgpLCB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBDLFxuICAgICAgICBrZXlJbmRpY2VzQ291bnQ6IGV0LkJ1ZmZlci5mcm9tKEIpLFxuICAgICAgICBrZXlJbmRpY2VzOiBULFxuICAgICAgICBkYXRhTGVuZ3RoOiBldC5CdWZmZXIuZnJvbShSKSxcbiAgICAgICAgZGF0YTogUFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgbyA9IFtdO1xuICAgIHp0KG8sIG4ubGVuZ3RoKTtcbiAgICBsZXQgaSA9IGV0LkJ1ZmZlci5hbGxvYyhCbik7XG4gICAgZXQuQnVmZmVyLmZyb20obykuY29weShpKTtcbiAgICBsZXQgYyA9IG8ubGVuZ3RoO1xuICAgIG4uZm9yRWFjaCgoUykgPT4ge1xuICAgICAgY29uc3QgQyA9IEQuc3RydWN0KFtELnU4KFwicHJvZ3JhbUlkSW5kZXhcIiksIEQuYmxvYihTLmtleUluZGljZXNDb3VudC5sZW5ndGgsIFwia2V5SW5kaWNlc0NvdW50XCIpLCBELnNlcShELnU4KFwia2V5SW5kZXhcIiksIFMua2V5SW5kaWNlcy5sZW5ndGgsIFwia2V5SW5kaWNlc1wiKSwgRC5ibG9iKFMuZGF0YUxlbmd0aC5sZW5ndGgsIFwiZGF0YUxlbmd0aFwiKSwgRC5zZXEoRC51OChcInVzZXJkYXR1bVwiKSwgUy5kYXRhLmxlbmd0aCwgXCJkYXRhXCIpXSkuZW5jb2RlKFMsIGksIGMpO1xuICAgICAgYyArPSBDO1xuICAgIH0pLCBpID0gaS5zbGljZSgwLCBjKTtcbiAgICBjb25zdCBmID0gRC5zdHJ1Y3QoW0QuYmxvYigxLCBcIm51bVJlcXVpcmVkU2lnbmF0dXJlc1wiKSwgRC5ibG9iKDEsIFwibnVtUmVhZG9ubHlTaWduZWRBY2NvdW50c1wiKSwgRC5ibG9iKDEsIFwibnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXCIpLCBELmJsb2Ioci5sZW5ndGgsIFwia2V5Q291bnRcIiksIEQuc2VxKHR0KFwia2V5XCIpLCBlLCBcImtleXNcIiksIHR0KFwicmVjZW50QmxvY2toYXNoXCIpXSksIHYgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGV0LkJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXNdKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IGV0LkJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzXSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGV0LkJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNdKSxcbiAgICAgIGtleUNvdW50OiBldC5CdWZmZXIuZnJvbShyKSxcbiAgICAgIGtleXM6IHRoaXMuYWNjb3VudEtleXMubWFwKChTKSA9PiBkYShTLnRvQnl0ZXMoKSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBOdC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpXG4gICAgfTtcbiAgICBsZXQgeCA9IGV0LkJ1ZmZlci5hbGxvYygyMDQ4KTtcbiAgICBjb25zdCBiID0gZi5lbmNvZGUodiwgeCk7XG4gICAgcmV0dXJuIGkuY29weSh4LCBiKSwgeC5zbGljZSgwLCBiICsgaS5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21waWxlZCBtZXNzYWdlIGludG8gYSBNZXNzYWdlIG9iamVjdC5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGUpIHtcbiAgICBsZXQgciA9IFsuLi5lXTtcbiAgICBjb25zdCBuID0geXIocik7XG4gICAgaWYgKG4gIT09IChuICYgcGEpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbmVkIG1lc3NhZ2VzIG11c3QgYmUgZGVzZXJpYWxpemVkIHdpdGggVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZSgpXCIpO1xuICAgIGNvbnN0IG8gPSB5cihyKSwgaSA9IHlyKHIpLCBjID0gJHQocik7XG4gICAgbGV0IGYgPSBbXTtcbiAgICBmb3IgKGxldCBUID0gMDsgVCA8IGM7IFQrKykge1xuICAgICAgY29uc3QgQyA9IHF0KHIsIDAsIFJyKTtcbiAgICAgIGYucHVzaChuZXcgUmUoZXQuQnVmZmVyLmZyb20oQykpKTtcbiAgICB9XG4gICAgY29uc3QgdiA9IHF0KHIsIDAsIFJyKSwgeCA9ICR0KHIpO1xuICAgIGxldCBiID0gW107XG4gICAgZm9yIChsZXQgVCA9IDA7IFQgPCB4OyBUKyspIHtcbiAgICAgIGNvbnN0IEMgPSB5cihyKSwgUCA9ICR0KHIpLCBCID0gcXQociwgMCwgUCksIFIgPSAkdChyKSwgeiA9IHF0KHIsIDAsIFIpLCBLID0gTnQuZW5jb2RlKGV0LkJ1ZmZlci5mcm9tKHopKTtcbiAgICAgIGIucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBDLFxuICAgICAgICBhY2NvdW50czogQixcbiAgICAgICAgZGF0YTogS1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IFMgPSB7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBuLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBvLFxuICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGlcbiAgICAgIH0sXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IE50LmVuY29kZShldC5CdWZmZXIuZnJvbSh2KSksXG4gICAgICBhY2NvdW50S2V5czogZixcbiAgICAgIGluc3RydWN0aW9uczogYlxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBGbihTKTtcbiAgfVxufVxuY2xhc3MgTXMge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDAsIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDAsIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwLCB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gdm9pZCAwLCB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMgPSB2b2lkIDAsIHRoaXMuaGVhZGVyID0gZS5oZWFkZXIsIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBlLnN0YXRpY0FjY291bnRLZXlzLCB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGUucmVjZW50QmxvY2toYXNoLCB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gZS5jb21waWxlZEluc3RydWN0aW9ucywgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gZS5hZGRyZXNzVGFibGVMb29rdXBzO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzKCkge1xuICAgIGxldCBlID0gMDtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKVxuICAgICAgZSArPSByLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGggKyByLndyaXRhYmxlSW5kZXhlcy5sZW5ndGg7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoZSkge1xuICAgIGxldCByO1xuICAgIGlmIChlICYmIFwiYWNjb3VudEtleXNGcm9tTG9va3Vwc1wiIGluIGUgJiYgZS5hY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgICBpZiAodGhpcy5udW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzICE9IGUuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5sZW5ndGggKyBlLmFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGFjY291bnQga2V5cyBiZWNhdXNlIG9mIGEgbWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBhY2NvdW50IGtleXMgZnJvbSBsb29rdXBzXCIpO1xuICAgICAgciA9IGUuYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgICB9IGVsc2UgaWYgKGUgJiYgXCJhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50c1wiIGluIGUgJiYgZS5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cylcbiAgICAgIHIgPSB0aGlzLnJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzKGUuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpO1xuICAgIGVsc2UgaWYgKHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBhZGRyZXNzIHRhYmxlIGxvb2t1cHMgd2VyZSBub3QgcmVzb2x2ZWRcIik7XG4gICAgcmV0dXJuIG5ldyBFcyh0aGlzLnN0YXRpY0FjY291bnRLZXlzLCByKTtcbiAgfVxuICBpc0FjY291bnRTaWduZXIoZSkge1xuICAgIHJldHVybiBlIDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLCBuID0gdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgaWYgKGUgPj0gbikge1xuICAgICAgY29uc3QgbyA9IGUgLSBuLCBpID0gdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLnJlZHVjZSgoYywgZikgPT4gYyArIGYud3JpdGFibGVJbmRleGVzLmxlbmd0aCwgMCk7XG4gICAgICByZXR1cm4gbyA8IGk7XG4gICAgfSBlbHNlIGlmIChlID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgbyA9IGUgLSByLCBjID0gbiAtIHIgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gbyA8IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG8gPSByIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiBlIDwgbztcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoZSkge1xuICAgIGNvbnN0IHIgPSB7XG4gICAgICB3cml0YWJsZTogW10sXG4gICAgICByZWFkb25seTogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvbnN0IG8gPSBlLmZpbmQoKGkpID0+IGkua2V5LmVxdWFscyhuLmFjY291bnRLZXkpKTtcbiAgICAgIGlmICghbylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBhY2NvdW50IGZvciB0YWJsZSBrZXkgJHtuLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBuLndyaXRhYmxlSW5kZXhlcylcbiAgICAgICAgaWYgKGkgPCBvLnN0YXRlLmFkZHJlc3Nlcy5sZW5ndGgpXG4gICAgICAgICAgci53cml0YWJsZS5wdXNoKG8uc3RhdGUuYWRkcmVzc2VzW2ldKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBmb3IgaW5kZXggJHtpfSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke24uYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgZm9yIChjb25zdCBpIG9mIG4ucmVhZG9ubHlJbmRleGVzKVxuICAgICAgICBpZiAoaSA8IG8uc3RhdGUuYWRkcmVzc2VzLmxlbmd0aClcbiAgICAgICAgICByLnJlYWRvbmx5LnB1c2goby5zdGF0ZS5hZGRyZXNzZXNbaV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2l9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7bi5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGUpIHtcbiAgICBjb25zdCByID0gJHMuY29tcGlsZShlLmluc3RydWN0aW9ucywgZS5wYXllcktleSksIG4gPSBuZXcgQXJyYXkoKSwgbyA9IHtcbiAgICAgIHdyaXRhYmxlOiBuZXcgQXJyYXkoKSxcbiAgICAgIHJlYWRvbmx5OiBuZXcgQXJyYXkoKVxuICAgIH0sIGkgPSBlLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIHx8IFtdO1xuICAgIGZvciAoY29uc3QgYiBvZiBpKSB7XG4gICAgICBjb25zdCBTID0gci5leHRyYWN0VGFibGVMb29rdXAoYik7XG4gICAgICBpZiAoUyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IFtULCB7XG4gICAgICAgICAgd3JpdGFibGU6IEMsXG4gICAgICAgICAgcmVhZG9ubHk6IFBcbiAgICAgICAgfV0gPSBTO1xuICAgICAgICBuLnB1c2goVCksIG8ud3JpdGFibGUucHVzaCguLi5DKSwgby5yZWFkb25seS5wdXNoKC4uLlApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbYywgZl0gPSByLmdldE1lc3NhZ2VDb21wb25lbnRzKCksIHggPSBuZXcgRXMoZiwgbykuY29tcGlsZUluc3RydWN0aW9ucyhlLmluc3RydWN0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBNcyh7XG4gICAgICBoZWFkZXI6IGMsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogZixcbiAgICAgIHJlY2VudEJsb2NraGFzaDogZS5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9uczogeCxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG5cbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5KCk7XG4gICAgenQoZSwgdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgpO1xuICAgIGNvbnN0IHIgPSB0aGlzLnNlcmlhbGl6ZUluc3RydWN0aW9ucygpLCBuID0gQXJyYXkoKTtcbiAgICB6dChuLCB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG4gICAgY29uc3QgbyA9IHRoaXMuc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpLCBpID0gQXJyYXkoKTtcbiAgICB6dChpLCB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoKTtcbiAgICBjb25zdCBjID0gRC5zdHJ1Y3QoW0QudTgoXCJwcmVmaXhcIiksIEQuc3RydWN0KFtELnU4KFwibnVtUmVxdWlyZWRTaWduYXR1cmVzXCIpLCBELnU4KFwibnVtUmVhZG9ubHlTaWduZWRBY2NvdW50c1wiKSwgRC51OChcIm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1wiKV0sIFwiaGVhZGVyXCIpLCBELmJsb2IoZS5sZW5ndGgsIFwic3RhdGljQWNjb3VudEtleXNMZW5ndGhcIiksIEQuc2VxKHR0KCksIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoLCBcInN0YXRpY0FjY291bnRLZXlzXCIpLCB0dChcInJlY2VudEJsb2NraGFzaFwiKSwgRC5ibG9iKG4ubGVuZ3RoLCBcImluc3RydWN0aW9uc0xlbmd0aFwiKSwgRC5ibG9iKHIubGVuZ3RoLCBcInNlcmlhbGl6ZWRJbnN0cnVjdGlvbnNcIiksIEQuYmxvYihpLmxlbmd0aCwgXCJhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoXCIpLCBELmJsb2Ioby5sZW5ndGgsIFwic2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHNcIildKSwgZiA9IG5ldyBVaW50OEFycmF5KEJuKSwgeCA9IGMuZW5jb2RlKHtcbiAgICAgIHByZWZpeDogMTI4LFxuICAgICAgaGVhZGVyOiB0aGlzLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlKSxcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiB0aGlzLnN0YXRpY0FjY291bnRLZXlzLm1hcCgoYikgPT4gYi50b0J5dGVzKCkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBOdC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpLFxuICAgICAgaW5zdHJ1Y3Rpb25zTGVuZ3RoOiBuZXcgVWludDhBcnJheShuKSxcbiAgICAgIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnM6IHIsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoOiBuZXcgVWludDhBcnJheShpKSxcbiAgICAgIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzOiBvXG4gICAgfSwgZik7XG4gICAgcmV0dXJuIGYuc2xpY2UoMCwgeCk7XG4gIH1cbiAgc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCkge1xuICAgIGxldCBlID0gMDtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoQm4pO1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBjb25zdCBvID0gQXJyYXkoKTtcbiAgICAgIHp0KG8sIG4uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGkgPSBBcnJheSgpO1xuICAgICAgenQoaSwgbi5kYXRhLmxlbmd0aCk7XG4gICAgICBjb25zdCBjID0gRC5zdHJ1Y3QoW0QudTgoXCJwcm9ncmFtSWRJbmRleFwiKSwgRC5ibG9iKG8ubGVuZ3RoLCBcImVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aFwiKSwgRC5zZXEoRC51OCgpLCBuLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCwgXCJhY2NvdW50S2V5SW5kZXhlc1wiKSwgRC5ibG9iKGkubGVuZ3RoLCBcImVuY29kZWREYXRhTGVuZ3RoXCIpLCBELmJsb2Iobi5kYXRhLmxlbmd0aCwgXCJkYXRhXCIpXSk7XG4gICAgICBlICs9IGMuZW5jb2RlKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IG4ucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkobyksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBuLmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICBlbmNvZGVkRGF0YUxlbmd0aDogbmV3IFVpbnQ4QXJyYXkoaSksXG4gICAgICAgIGRhdGE6IG4uZGF0YVxuICAgICAgfSwgciwgZSk7XG4gICAgfVxuICAgIHJldHVybiByLnNsaWNlKDAsIGUpO1xuICB9XG4gIHNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKSB7XG4gICAgbGV0IGUgPSAwO1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShCbik7XG4gICAgZm9yIChjb25zdCBuIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgbyA9IEFycmF5KCk7XG4gICAgICB6dChvLCBuLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgaSA9IEFycmF5KCk7XG4gICAgICB6dChpLCBuLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgYyA9IEQuc3RydWN0KFt0dChcImFjY291bnRLZXlcIiksIEQuYmxvYihvLmxlbmd0aCwgXCJlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoXCIpLCBELnNlcShELnU4KCksIG4ud3JpdGFibGVJbmRleGVzLmxlbmd0aCwgXCJ3cml0YWJsZUluZGV4ZXNcIiksIEQuYmxvYihpLmxlbmd0aCwgXCJlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoXCIpLCBELnNlcShELnU4KCksIG4ucmVhZG9ubHlJbmRleGVzLmxlbmd0aCwgXCJyZWFkb25seUluZGV4ZXNcIildKTtcbiAgICAgIGUgKz0gYy5lbmNvZGUoe1xuICAgICAgICBhY2NvdW50S2V5OiBuLmFjY291bnRLZXkudG9CeXRlcygpLFxuICAgICAgICBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShvKSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzOiBuLndyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoaSksXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlczogbi5yZWFkb25seUluZGV4ZXNcbiAgICAgIH0sIHIsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gci5zbGljZSgwLCBlKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZSkge1xuICAgIGxldCByID0gWy4uLmVdO1xuICAgIGNvbnN0IG4gPSB5cihyKSwgbyA9IG4gJiBwYTtcbiAgICBidChuICE9PSBvLCBcIkV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIGJ1dCByZWNlaXZlZCBsZWdhY3kgbWVzc2FnZVwiKTtcbiAgICBjb25zdCBpID0gbztcbiAgICBidChpID09PSAwLCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2Ugd2l0aCB2ZXJzaW9uIDAgYnV0IGZvdW5kIHZlcnNpb24gJHtpfWApO1xuICAgIGNvbnN0IGMgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IHlyKHIpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogeXIociksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IHlyKHIpXG4gICAgfSwgZiA9IFtdLCB2ID0gJHQocik7XG4gICAgZm9yIChsZXQgUCA9IDA7IFAgPCB2OyBQKyspXG4gICAgICBmLnB1c2gobmV3IFJlKHF0KHIsIDAsIFJyKSkpO1xuICAgIGNvbnN0IHggPSBOdC5lbmNvZGUocXQociwgMCwgUnIpKSwgYiA9ICR0KHIpLCBTID0gW107XG4gICAgZm9yIChsZXQgUCA9IDA7IFAgPCBiOyBQKyspIHtcbiAgICAgIGNvbnN0IEIgPSB5cihyKSwgUiA9ICR0KHIpLCB6ID0gcXQociwgMCwgUiksIEsgPSAkdChyKSwgWiA9IG5ldyBVaW50OEFycmF5KHF0KHIsIDAsIEspKTtcbiAgICAgIFMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBCLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogeixcbiAgICAgICAgZGF0YTogWlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IFQgPSAkdChyKSwgQyA9IFtdO1xuICAgIGZvciAobGV0IFAgPSAwOyBQIDwgVDsgUCsrKSB7XG4gICAgICBjb25zdCBCID0gbmV3IFJlKHF0KHIsIDAsIFJyKSksIFIgPSAkdChyKSwgeiA9IHF0KHIsIDAsIFIpLCBLID0gJHQociksIFogPSBxdChyLCAwLCBLKTtcbiAgICAgIEMucHVzaCh7XG4gICAgICAgIGFjY291bnRLZXk6IEIsXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlczogeixcbiAgICAgICAgcmVhZG9ubHlJbmRleGVzOiBaXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNcyh7XG4gICAgICBoZWFkZXI6IGMsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogZixcbiAgICAgIHJlY2VudEJsb2NraGFzaDogeCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zOiBTLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3VwczogQ1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBtYSA9IHtcbiAgZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbih0KSB7XG4gICAgY29uc3QgZSA9IHRbMF0sIHIgPSBlICYgcGE7XG4gICAgcmV0dXJuIHIgPT09IGUgPyBcImxlZ2FjeVwiIDogcjtcbiAgfSxcbiAgZGVzZXJpYWxpemU6ICh0KSA9PiB7XG4gICAgY29uc3QgZSA9IG1hLmRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24odCk7XG4gICAgaWYgKGUgPT09IFwibGVnYWN5XCIpXG4gICAgICByZXR1cm4gRm4uZnJvbSh0KTtcbiAgICBpZiAoZSA9PT0gMClcbiAgICAgIHJldHVybiBNcy5kZXNlcmlhbGl6ZSh0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIG1lc3NhZ2UgdmVyc2lvbiAke2V9IGRlc2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cbn0sIFQxID0gZXQuQnVmZmVyLmFsbG9jKF9zKS5maWxsKDApO1xuY2xhc3MgZHUge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5rZXlzID0gdm9pZCAwLCB0aGlzLnByb2dyYW1JZCA9IHZvaWQgMCwgdGhpcy5kYXRhID0gZXQuQnVmZmVyLmFsbG9jKDApLCB0aGlzLnByb2dyYW1JZCA9IGUucHJvZ3JhbUlkLCB0aGlzLmtleXMgPSBlLmtleXMsIGUuZGF0YSAmJiAodGhpcy5kYXRhID0gZS5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IHRoaXMua2V5cy5tYXAoKHtcbiAgICAgICAgcHVia2V5OiBlLFxuICAgICAgICBpc1NpZ25lcjogcixcbiAgICAgICAgaXNXcml0YWJsZTogblxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgcHVia2V5OiBlLnRvSlNPTigpLFxuICAgICAgICBpc1NpZ25lcjogcixcbiAgICAgICAgaXNXcml0YWJsZTogblxuICAgICAgfSkpLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZC50b0pTT04oKSxcbiAgICAgIGRhdGE6IFsuLi50aGlzLmRhdGFdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgQ3Mge1xuICAvKipcbiAgICogVGhlIGZpcnN0IChwYXllcikgVHJhbnNhY3Rpb24gc2lnbmF0dXJlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXIgfCBudWxsfSBCdWZmZXIgb2YgcGF5ZXIncyBzaWduYXR1cmVcbiAgICovXG4gIGdldCBzaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwID8gdGhpcy5zaWduYXR1cmVzWzBdLnNpZ25hdHVyZSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXJcbiAgICovXG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHdpdGggYSBibG9ja2hhc2ggYW5kIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHVzaW5nIGEgZHVyYWJsZSBub25jZVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYFRyYW5zYWN0aW9uQ3RvckZpZWxkc2AgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqIFBsZWFzZSBzdXBwbHkgYSBgVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yYCBpbnN0ZWFkLlxuICAgKi9cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBlbXB0eSBUcmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGlmICh0aGlzLnNpZ25hdHVyZXMgPSBbXSwgdGhpcy5mZWVQYXllciA9IHZvaWQgMCwgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXSwgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDAsIHRoaXMubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSB2b2lkIDAsIHRoaXMubm9uY2VJbmZvID0gdm9pZCAwLCB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSB2b2lkIDAsIHRoaXMuX21lc3NhZ2UgPSB2b2lkIDAsIHRoaXMuX2pzb24gPSB2b2lkIDAsICEhZSlcbiAgICAgIGlmIChlLmZlZVBheWVyICYmICh0aGlzLmZlZVBheWVyID0gZS5mZWVQYXllciksIGUuc2lnbmF0dXJlcyAmJiAodGhpcy5zaWduYXR1cmVzID0gZS5zaWduYXR1cmVzKSwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwibm9uY2VJbmZvXCIpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtaW5Db250ZXh0U2xvdDogcixcbiAgICAgICAgICBub25jZUluZm86IG5cbiAgICAgICAgfSA9IGU7XG4gICAgICAgIHRoaXMubWluTm9uY2VDb250ZXh0U2xvdCA9IHIsIHRoaXMubm9uY2VJbmZvID0gbjtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwibGFzdFZhbGlkQmxvY2tIZWlnaHRcIikpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJsb2NraGFzaDogcixcbiAgICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogblxuICAgICAgICB9ID0gZTtcbiAgICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSByLCB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZWNlbnRCbG9ja2hhc2g6IHIsXG4gICAgICAgICAgbm9uY2VJbmZvOiBuXG4gICAgICAgIH0gPSBlO1xuICAgICAgICBuICYmICh0aGlzLm5vbmNlSW5mbyA9IG4pLCB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHI7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoIHx8IG51bGwsXG4gICAgICBmZWVQYXllcjogdGhpcy5mZWVQYXllciA/IHRoaXMuZmVlUGF5ZXIudG9KU09OKCkgOiBudWxsLFxuICAgICAgbm9uY2VJbmZvOiB0aGlzLm5vbmNlSW5mbyA/IHtcbiAgICAgICAgbm9uY2U6IHRoaXMubm9uY2VJbmZvLm5vbmNlLFxuICAgICAgICBub25jZUluc3RydWN0aW9uOiB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLnRvSlNPTigpXG4gICAgICB9IDogbnVsbCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnMubWFwKChlKSA9PiBlLnRvSlNPTigpKSxcbiAgICAgIHNpZ25lcnM6IHRoaXMuc2lnbmF0dXJlcy5tYXAoKHtcbiAgICAgICAgcHVibGljS2V5OiBlXG4gICAgICB9KSA9PiBlLnRvSlNPTigpKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBvbmUgb3IgbW9yZSBpbnN0cnVjdGlvbnMgdG8gdGhpcyBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PCBUcmFuc2FjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uQ3RvckZpZWxkcyA+fSBpdGVtcyAtIEluc3RydWN0aW9ucyB0byBhZGQgdG8gdGhlIFRyYW5zYWN0aW9uXG4gICAqL1xuICBhZGQoLi4uZSkge1xuICAgIGlmIChlLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGluc3RydWN0aW9uc1wiKTtcbiAgICByZXR1cm4gZS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBcImluc3RydWN0aW9uc1wiIGluIHIgPyB0aGlzLmluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLmNvbmNhdChyLmluc3RydWN0aW9ucykgOiBcImRhdGFcIiBpbiByICYmIFwicHJvZ3JhbUlkXCIgaW4gciAmJiBcImtleXNcIiBpbiByID8gdGhpcy5pbnN0cnVjdGlvbnMucHVzaChyKSA6IHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IGR1KHIpKTtcbiAgICB9KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBjb21waWxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5fbWVzc2FnZSAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKSA9PT0gSlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbikpXG4gICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICBsZXQgZSwgcjtcbiAgICBpZiAodGhpcy5ub25jZUluZm8gPyAoZSA9IHRoaXMubm9uY2VJbmZvLm5vbmNlLCB0aGlzLmluc3RydWN0aW9uc1swXSAhPSB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uID8gciA9IFt0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLCAuLi50aGlzLmluc3RydWN0aW9uc10gOiByID0gdGhpcy5pbnN0cnVjdGlvbnMpIDogKGUgPSB0aGlzLnJlY2VudEJsb2NraGFzaCwgciA9IHRoaXMuaW5zdHJ1Y3Rpb25zKSwgIWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiByZWNlbnRCbG9ja2hhc2ggcmVxdWlyZWRcIik7XG4gICAgci5sZW5ndGggPCAxICYmIGNvbnNvbGUud2FybihcIk5vIGluc3RydWN0aW9ucyBwcm92aWRlZFwiKTtcbiAgICBsZXQgbjtcbiAgICBpZiAodGhpcy5mZWVQYXllcilcbiAgICAgIG4gPSB0aGlzLmZlZVBheWVyO1xuICAgIGVsc2UgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXkpXG4gICAgICBuID0gdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBmZWUgcGF5ZXIgcmVxdWlyZWRcIik7XG4gICAgZm9yIChsZXQgQiA9IDA7IEIgPCByLmxlbmd0aDsgQisrKVxuICAgICAgaWYgKHJbQl0ucHJvZ3JhbUlkID09PSB2b2lkIDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gaW5kZXggJHtCfSBoYXMgdW5kZWZpbmVkIHByb2dyYW0gaWRgKTtcbiAgICBjb25zdCBvID0gW10sIGkgPSBbXTtcbiAgICByLmZvckVhY2goKEIpID0+IHtcbiAgICAgIEIua2V5cy5mb3JFYWNoKCh6KSA9PiB7XG4gICAgICAgIGkucHVzaCh7XG4gICAgICAgICAgLi4uelxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgUiA9IEIucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgICBvLmluY2x1ZGVzKFIpIHx8IG8ucHVzaChSKTtcbiAgICB9KSwgby5mb3JFYWNoKChCKSA9PiB7XG4gICAgICBpLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG5ldyBSZShCKSxcbiAgICAgICAgaXNTaWduZXI6ICExLFxuICAgICAgICBpc1dyaXRhYmxlOiAhMVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgYyA9IFtdO1xuICAgIGkuZm9yRWFjaCgoQikgPT4ge1xuICAgICAgY29uc3QgUiA9IEIucHVia2V5LnRvU3RyaW5nKCksIHogPSBjLmZpbmRJbmRleCgoSykgPT4gSy5wdWJrZXkudG9TdHJpbmcoKSA9PT0gUik7XG4gICAgICB6ID4gLTEgPyAoY1t6XS5pc1dyaXRhYmxlID0gY1t6XS5pc1dyaXRhYmxlIHx8IEIuaXNXcml0YWJsZSwgY1t6XS5pc1NpZ25lciA9IGNbel0uaXNTaWduZXIgfHwgQi5pc1NpZ25lcikgOiBjLnB1c2goQik7XG4gICAgfSksIGMuc29ydChmdW5jdGlvbihCLCBSKSB7XG4gICAgICBpZiAoQi5pc1NpZ25lciAhPT0gUi5pc1NpZ25lcilcbiAgICAgICAgcmV0dXJuIEIuaXNTaWduZXIgPyAtMSA6IDE7XG4gICAgICBpZiAoQi5pc1dyaXRhYmxlICE9PSBSLmlzV3JpdGFibGUpXG4gICAgICAgIHJldHVybiBCLmlzV3JpdGFibGUgPyAtMSA6IDE7XG4gICAgICBjb25zdCB6ID0ge1xuICAgICAgICBsb2NhbGVNYXRjaGVyOiBcImJlc3QgZml0XCIsXG4gICAgICAgIHVzYWdlOiBcInNvcnRcIixcbiAgICAgICAgc2Vuc2l0aXZpdHk6IFwidmFyaWFudFwiLFxuICAgICAgICBpZ25vcmVQdW5jdHVhdGlvbjogITEsXG4gICAgICAgIG51bWVyaWM6ICExLFxuICAgICAgICBjYXNlRmlyc3Q6IFwibG93ZXJcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBCLnB1YmtleS50b0Jhc2U1OCgpLmxvY2FsZUNvbXBhcmUoUi5wdWJrZXkudG9CYXNlNTgoKSwgXCJlblwiLCB6KTtcbiAgICB9KTtcbiAgICBjb25zdCBmID0gYy5maW5kSW5kZXgoKEIpID0+IEIucHVia2V5LmVxdWFscyhuKSk7XG4gICAgaWYgKGYgPiAtMSkge1xuICAgICAgY29uc3QgW0JdID0gYy5zcGxpY2UoZiwgMSk7XG4gICAgICBCLmlzU2lnbmVyID0gITAsIEIuaXNXcml0YWJsZSA9ICEwLCBjLnVuc2hpZnQoQik7XG4gICAgfSBlbHNlXG4gICAgICBjLnVuc2hpZnQoe1xuICAgICAgICBwdWJrZXk6IG4sXG4gICAgICAgIGlzU2lnbmVyOiAhMCxcbiAgICAgICAgaXNXcml0YWJsZTogITBcbiAgICAgIH0pO1xuICAgIGZvciAoY29uc3QgQiBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IFIgPSBjLmZpbmRJbmRleCgoeikgPT4gei5wdWJrZXkuZXF1YWxzKEIucHVibGljS2V5KSk7XG4gICAgICBpZiAoUiA+IC0xKVxuICAgICAgICBjW1JdLmlzU2lnbmVyIHx8IChjW1JdLmlzU2lnbmVyID0gITAsIGNvbnNvbGUud2FybihcIlRyYW5zYWN0aW9uIHJlZmVyZW5jZXMgYSBzaWduYXR1cmUgdGhhdCBpcyB1bm5lY2Vzc2FyeSwgb25seSB0aGUgZmVlIHBheWVyIGFuZCBpbnN0cnVjdGlvbiBzaWduZXIgYWNjb3VudHMgc2hvdWxkIHNpZ24gYSB0cmFuc2FjdGlvbi4gVGhpcyBiZWhhdmlvciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gcmVsZWFzZS5cIikpO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke0IucHVibGljS2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGxldCB2ID0gMCwgeCA9IDAsIGIgPSAwO1xuICAgIGNvbnN0IFMgPSBbXSwgVCA9IFtdO1xuICAgIGMuZm9yRWFjaCgoe1xuICAgICAgcHVia2V5OiBCLFxuICAgICAgaXNTaWduZXI6IFIsXG4gICAgICBpc1dyaXRhYmxlOiB6XG4gICAgfSkgPT4ge1xuICAgICAgUiA/IChTLnB1c2goQi50b1N0cmluZygpKSwgdiArPSAxLCB6IHx8ICh4ICs9IDEpKSA6IChULnB1c2goQi50b1N0cmluZygpKSwgeiB8fCAoYiArPSAxKSk7XG4gICAgfSk7XG4gICAgY29uc3QgQyA9IFMuY29uY2F0KFQpLCBQID0gci5tYXAoKEIpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YTogUixcbiAgICAgICAgcHJvZ3JhbUlkOiB6XG4gICAgICB9ID0gQjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBDLmluZGV4T2Yoei50b1N0cmluZygpKSxcbiAgICAgICAgYWNjb3VudHM6IEIua2V5cy5tYXAoKEspID0+IEMuaW5kZXhPZihLLnB1YmtleS50b1N0cmluZygpKSksXG4gICAgICAgIGRhdGE6IE50LmVuY29kZShSKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gUC5mb3JFYWNoKChCKSA9PiB7XG4gICAgICBidChCLnByb2dyYW1JZEluZGV4ID49IDApLCBCLmFjY291bnRzLmZvckVhY2goKFIpID0+IGJ0KFIgPj0gMCkpO1xuICAgIH0pLCBuZXcgRm4oe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogdixcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogeCxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBiXG4gICAgICB9LFxuICAgICAgYWNjb3VudEtleXM6IEMsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGUsXG4gICAgICBpbnN0cnVjdGlvbnM6IFBcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb21waWxlTWVzc2FnZSgpLCByID0gZS5hY2NvdW50S2V5cy5zbGljZSgwLCBlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID09PSByLmxlbmd0aCAmJiB0aGlzLnNpZ25hdHVyZXMuZXZlcnkoKG8sIGkpID0+IHJbaV0uZXF1YWxzKG8ucHVibGljS2V5KSkgfHwgKHRoaXMuc2lnbmF0dXJlcyA9IHIubWFwKChuKSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5OiBuXG4gICAgfSkpKSwgZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgYnVmZmVyIG9mIHRoZSBUcmFuc2FjdGlvbiBkYXRhIHRoYXQgbmVlZCB0byBiZSBjb3ZlcmVkIGJ5IHNpZ25hdHVyZXNcbiAgICovXG4gIHNlcmlhbGl6ZU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBpbGUoKS5zZXJpYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBlc3RpbWF0ZWQgZmVlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIFJQQyBFbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyIHwgbnVsbD59IFRoZSBlc3RpbWF0ZWQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldEVzdGltYXRlZEZlZShlKSB7XG4gICAgcmV0dXJuIChhd2FpdCBlLmdldEZlZUZvck1lc3NhZ2UodGhpcy5jb21waWxlTWVzc2FnZSgpKSkudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHB1YmxpYyBrZXlzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBzaWduIHRoZSBUcmFuc2FjdGlvbi5cbiAgICogVGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWQgYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBTaWduYXR1cmVzIGNhbiBiZSBhZGRlZCB3aXRoIGVpdGhlciBgcGFydGlhbFNpZ25gIG9yIGBhZGRTaWduYXR1cmVgXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjAuODQuMC4gT25seSB0aGUgZmVlIHBheWVyIG5lZWRzIHRvIGJlXG4gICAqIHNwZWNpZmllZCBhbmQgaXQgY2FuIGJlIHNldCBpbiB0aGUgVHJhbnNhY3Rpb24gY29uc3RydWN0b3Igb3Igd2l0aCB0aGVcbiAgICogYGZlZVBheWVyYCBwcm9wZXJ0eS5cbiAgICovXG4gIHNldFNpZ25lcnMoLi4uZSkge1xuICAgIGlmIChlLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lcnNcIik7XG4gICAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gZS5maWx0ZXIoKG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSBuLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gci5oYXMobykgPyAhMSA6IChyLmFkZChvKSwgITApO1xuICAgIH0pLm1hcCgobikgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleTogblxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAqIGJlIGFwcGxpZWQgdG8gYSBUcmFuc2FjdGlvbi4gVGhlIGZpcnN0IHNpZ25hdHVyZSBpcyBjb25zaWRlcmVkIFwicHJpbWFyeVwiXG4gICAqIGFuZCBpcyB1c2VkIGlkZW50aWZ5IGFuZCBjb25maXJtIHRyYW5zYWN0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIFRyYW5zYWN0aW9uIGBmZWVQYXllcmAgaXMgbm90IHNldCwgdGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBUcmFuc2FjdGlvbiBmaWVsZHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBhZnRlciB0aGUgZmlyc3QgY2FsbCB0byBgc2lnbmAsXG4gICAqIGFzIGRvaW5nIHNvIG1heSBpbnZhbGlkYXRlIHRoZSBzaWduYXR1cmUgYW5kIGNhdXNlIHRoZSBUcmFuc2FjdGlvbiB0byBiZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogVGhlIFRyYW5zYWN0aW9uIG11c3QgYmUgYXNzaWduZWQgYSB2YWxpZCBgcmVjZW50QmxvY2toYXNoYCBiZWZvcmUgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduKC4uLmUpIHtcbiAgICBpZiAoZS5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXJzXCIpO1xuICAgIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBuID0gW107XG4gICAgZm9yIChjb25zdCBpIG9mIGUpIHtcbiAgICAgIGNvbnN0IGMgPSBpLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgci5oYXMoYykgfHwgKHIuYWRkKGMpLCBuLnB1c2goaSkpO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBuLm1hcCgoaSkgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleTogaS5wdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgY29uc3QgbyA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihvLCAuLi5uKTtcbiAgfVxuICAvKipcbiAgICogUGFydGlhbGx5IHNpZ24gYSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgYWNjb3VudHMuIEFsbCBhY2NvdW50cyBtdXN0XG4gICAqIGNvcnJlc3BvbmQgdG8gZWl0aGVyIHRoZSBmZWUgcGF5ZXIgb3IgYSBzaWduZXIgYWNjb3VudCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKlxuICAgKiBBbGwgdGhlIGNhdmVhdHMgZnJvbSB0aGUgYHNpZ25gIG1ldGhvZCBhcHBseSB0byBgcGFydGlhbFNpZ25gXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVycyBBcnJheSBvZiBzaWduZXJzIHRoYXQgd2lsbCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgcGFydGlhbFNpZ24oLi4uZSkge1xuICAgIGlmIChlLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lcnNcIik7XG4gICAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgZSkge1xuICAgICAgY29uc3QgYyA9IGkucHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICByLmhhcyhjKSB8fCAoci5hZGQoYyksIG4ucHVzaChpKSk7XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obywgLi4ubik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3BhcnRpYWxTaWduKGUsIC4uLnIpIHtcbiAgICBjb25zdCBuID0gZS5zZXJpYWxpemUoKTtcbiAgICByLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBWYyhuLCBvLnNlY3JldEtleSk7XG4gICAgICB0aGlzLl9hZGRTaWduYXR1cmUoby5wdWJsaWNLZXksIGRhKGkpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkIGFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYSB0cmFuc2FjdGlvbi4gVGhlIHB1YmxpYyBrZXlcbiAgICogbXVzdCBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleSBQdWJsaWMga2V5IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmUgQW4gZXh0ZXJuYWxseSBjcmVhdGVkIHNpZ25hdHVyZSB0byBhZGQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYWRkU2lnbmF0dXJlKGUsIHIpIHtcbiAgICB0aGlzLl9jb21waWxlKCksIHRoaXMuX2FkZFNpZ25hdHVyZShlLCByKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYWRkU2lnbmF0dXJlKGUsIHIpIHtcbiAgICBidChyLmxlbmd0aCA9PT0gNjQpO1xuICAgIGNvbnN0IG4gPSB0aGlzLnNpZ25hdHVyZXMuZmluZEluZGV4KChvKSA9PiBlLmVxdWFscyhvLnB1YmxpY0tleSkpO1xuICAgIGlmIChuIDwgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzaWduZXI6ICR7ZS50b1N0cmluZygpfWApO1xuICAgIHRoaXMuc2lnbmF0dXJlc1tuXS5zaWduYXR1cmUgPSBldC5CdWZmZXIuZnJvbShyKTtcbiAgfVxuICAvKipcbiAgICogVmVyaWZ5IHNpZ25hdHVyZXMgb2YgYSBUcmFuc2FjdGlvblxuICAgKiBPcHRpb25hbCBwYXJhbWV0ZXIgc3BlY2lmaWVzIGlmIHdlJ3JlIGV4cGVjdGluZyBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBvciBhIHBhcnRpYWxseSBzaWduZWQgb25lLlxuICAgKiBJZiBubyBib29sZWFuIGlzIHByb3ZpZGVkLCB3ZSBleHBlY3QgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZUFsbFNpZ25hdHVyZXM9dHJ1ZV0gUmVxdWlyZSBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlcyhlID0gITApIHtcbiAgICByZXR1cm4gIXRoaXMuX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpLCBlKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMoZSwgcikge1xuICAgIGNvbnN0IG4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZTogbyxcbiAgICAgIHB1YmxpY0tleTogaVxuICAgIH0gb2YgdGhpcy5zaWduYXR1cmVzKVxuICAgICAgbyA9PT0gbnVsbCA/IHIgJiYgKG4ubWlzc2luZyB8fCAobi5taXNzaW5nID0gW10pKS5wdXNoKGkpIDogRTEobywgZSwgaS50b0J5dGVzKCkpIHx8IChuLmludmFsaWQgfHwgKG4uaW52YWxpZCA9IFtdKSkucHVzaChpKTtcbiAgICByZXR1cm4gbi5pbnZhbGlkIHx8IG4ubWlzc2luZyA/IG4gOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgVHJhbnNhY3Rpb24gaW4gdGhlIHdpcmUgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW2NvbmZpZ10gQ29uZmlnIG9mIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBTaWduYXR1cmUgb2YgdHJhbnNhY3Rpb24gaW4gd2lyZSBmb3JtYXQuXG4gICAqL1xuICBzZXJpYWxpemUoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiByLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlczogblxuICAgIH0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiAhMCxcbiAgICAgIHZlcmlmeVNpZ25hdHVyZXM6ICEwXG4gICAgfSwgZSksIG8gPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKTtcbiAgICBpZiAobikge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKG8sIHIpO1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgbGV0IGMgPSBcIlNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkLlwiO1xuICAgICAgICB0aHJvdyBpLmludmFsaWQgJiYgKGMgKz0gYFxuSW52YWxpZCBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke2kuaW52YWxpZC5sZW5ndGggPT09IDEgPyBcIlwiIDogXCIocylcIn0gW1xcYCR7aS5pbnZhbGlkLm1hcCgoZikgPT4gZi50b0Jhc2U1OCgpKS5qb2luKFwiYCwgYFwiKX1cXGBdLmApLCBpLm1pc3NpbmcgJiYgKGMgKz0gYFxuTWlzc2luZyBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke2kubWlzc2luZy5sZW5ndGggPT09IDEgPyBcIlwiIDogXCIocylcIn0gW1xcYCR7aS5taXNzaW5nLm1hcCgoZikgPT4gZi50b0Jhc2U1OCgpKS5qb2luKFwiYCwgYFwiKX1cXGBdLmApLCBuZXcgRXJyb3IoYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUobyk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZShlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmF0dXJlczogclxuICAgIH0gPSB0aGlzLCBuID0gW107XG4gICAgenQobiwgci5sZW5ndGgpO1xuICAgIGNvbnN0IG8gPSBuLmxlbmd0aCArIHIubGVuZ3RoICogNjQgKyBlLmxlbmd0aCwgaSA9IGV0LkJ1ZmZlci5hbGxvYyhvKTtcbiAgICByZXR1cm4gYnQoci5sZW5ndGggPCAyNTYpLCBldC5CdWZmZXIuZnJvbShuKS5jb3B5KGksIDApLCByLmZvckVhY2goKHtcbiAgICAgIHNpZ25hdHVyZTogY1xuICAgIH0sIGYpID0+IHtcbiAgICAgIGMgIT09IG51bGwgJiYgKGJ0KGMubGVuZ3RoID09PSA2NCwgXCJzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoXCIpLCBldC5CdWZmZXIuZnJvbShjKS5jb3B5KGksIG4ubGVuZ3RoICsgZiAqIDY0KSk7XG4gICAgfSksIGUuY29weShpLCBuLmxlbmd0aCArIHIubGVuZ3RoICogNjQpLCBidChpLmxlbmd0aCA8PSBCbiwgYFRyYW5zYWN0aW9uIHRvbyBsYXJnZTogJHtpLmxlbmd0aH0gPiAke0JufWApLCBpO1xuICB9XG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBrZXlzKCkge1xuICAgIHJldHVybiBidCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpLCB0aGlzLmluc3RydWN0aW9uc1swXS5rZXlzLm1hcCgoZSkgPT4gZS5wdWJrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBwcm9ncmFtSWQoKSB7XG4gICAgcmV0dXJuIGJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSksIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLnByb2dyYW1JZDtcbiAgfVxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gYnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKSwgdGhpcy5pbnN0cnVjdGlvbnNbMF0uZGF0YTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSB3aXJlIHRyYW5zYWN0aW9uIGludG8gYSBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj59IGJ1ZmZlciBTaWduYXR1cmUgb2Ygd2lyZSBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShlKSB7XG4gICAgbGV0IHIgPSBbLi4uZV07XG4gICAgY29uc3QgbiA9ICR0KHIpO1xuICAgIGxldCBvID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBxdChyLCAwLCBfcyk7XG4gICAgICBvLnB1c2goTnQuZW5jb2RlKGV0LkJ1ZmZlci5mcm9tKGMpKSk7XG4gICAgfVxuICAgIHJldHVybiBDcy5wb3B1bGF0ZShGbi5mcm9tKHIpLCBvKTtcbiAgfVxuICAvKipcbiAgICogUG9wdWxhdGUgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gbWVzc2FnZSBhbmQgc2lnbmF0dXJlc1xuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSBvZiB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNpZ25hdHVyZXMgTGlzdCBvZiBzaWduYXR1cmVzIHRvIGFzc2lnbiB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUaGUgcG9wdWxhdGVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgcG9wdWxhdGUoZSwgciA9IFtdKSB7XG4gICAgY29uc3QgbiA9IG5ldyBDcygpO1xuICAgIHJldHVybiBuLnJlY2VudEJsb2NraGFzaCA9IGUucmVjZW50QmxvY2toYXNoLCBlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMgPiAwICYmIChuLmZlZVBheWVyID0gZS5hY2NvdW50S2V5c1swXSksIHIuZm9yRWFjaCgobywgaSkgPT4ge1xuICAgICAgY29uc3QgYyA9IHtcbiAgICAgICAgc2lnbmF0dXJlOiBvID09IE50LmVuY29kZShUMSkgPyBudWxsIDogTnQuZGVjb2RlKG8pLFxuICAgICAgICBwdWJsaWNLZXk6IGUuYWNjb3VudEtleXNbaV1cbiAgICAgIH07XG4gICAgICBuLnNpZ25hdHVyZXMucHVzaChjKTtcbiAgICB9KSwgZS5pbnN0cnVjdGlvbnMuZm9yRWFjaCgobykgPT4ge1xuICAgICAgY29uc3QgaSA9IG8uYWNjb3VudHMubWFwKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGYgPSBlLmFjY291bnRLZXlzW2NdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHB1YmtleTogZixcbiAgICAgICAgICBpc1NpZ25lcjogbi5zaWduYXR1cmVzLnNvbWUoKHYpID0+IHYucHVibGljS2V5LnRvU3RyaW5nKCkgPT09IGYudG9TdHJpbmcoKSkgfHwgZS5pc0FjY291bnRTaWduZXIoYyksXG4gICAgICAgICAgaXNXcml0YWJsZTogZS5pc0FjY291bnRXcml0YWJsZShjKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBuLmluc3RydWN0aW9ucy5wdXNoKG5ldyBkdSh7XG4gICAgICAgIGtleXM6IGksXG4gICAgICAgIHByb2dyYW1JZDogZS5hY2NvdW50S2V5c1tvLnByb2dyYW1JZEluZGV4XSxcbiAgICAgICAgZGF0YTogTnQuZGVjb2RlKG8uZGF0YSlcbiAgICAgIH0pKTtcbiAgICB9KSwgbi5fbWVzc2FnZSA9IGUsIG4uX2pzb24gPSBuLnRvSlNPTigpLCBuO1xuICB9XG59XG5jbGFzcyBnYSB7XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UudmVyc2lvbjtcbiAgfVxuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcyA9IHZvaWQgMCwgdGhpcy5tZXNzYWdlID0gdm9pZCAwLCByICE9PSB2b2lkIDApXG4gICAgICBidChyLmxlbmd0aCA9PT0gZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLCBcIkV4cGVjdGVkIHNpZ25hdHVyZXMgbGVuZ3RoIHRvIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlc1wiKSwgdGhpcy5zaWduYXR1cmVzID0gcjtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG4gPSBbXTtcbiAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzOyBvKyspXG4gICAgICAgIG4ucHVzaChuZXcgVWludDhBcnJheShfcykpO1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gbjtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKSwgciA9IEFycmF5KCk7XG4gICAgenQociwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgbiA9IEQuc3RydWN0KFtELmJsb2Ioci5sZW5ndGgsIFwiZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGhcIiksIEQuc2VxKEExKCksIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgsIFwic2lnbmF0dXJlc1wiKSwgRC5ibG9iKGUubGVuZ3RoLCBcInNlcmlhbGl6ZWRNZXNzYWdlXCIpXSksIG8gPSBuZXcgVWludDhBcnJheSgyMDQ4KSwgaSA9IG4uZW5jb2RlKHtcbiAgICAgIGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShyKSxcbiAgICAgIHNpZ25hdHVyZXM6IHRoaXMuc2lnbmF0dXJlcyxcbiAgICAgIHNlcmlhbGl6ZWRNZXNzYWdlOiBlXG4gICAgfSwgbyk7XG4gICAgcmV0dXJuIG8uc2xpY2UoMCwgaSk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGUpIHtcbiAgICBsZXQgciA9IFsuLi5lXTtcbiAgICBjb25zdCBuID0gW10sIG8gPSAkdChyKTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IG87IGMrKylcbiAgICAgIG4ucHVzaChuZXcgVWludDhBcnJheShxdChyLCAwLCBfcykpKTtcbiAgICBjb25zdCBpID0gbWEuZGVzZXJpYWxpemUobmV3IFVpbnQ4QXJyYXkocikpO1xuICAgIHJldHVybiBuZXcgZ2EoaSwgbik7XG4gIH1cbiAgc2lnbihlKSB7XG4gICAgY29uc3QgciA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKSwgbiA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgZm9yIChjb25zdCBvIG9mIGUpIHtcbiAgICAgIGNvbnN0IGkgPSBuLmZpbmRJbmRleCgoYykgPT4gYy5lcXVhbHMoby5wdWJsaWNLZXkpKTtcbiAgICAgIGJ0KGkgPj0gMCwgYENhbm5vdCBzaWduIHdpdGggbm9uIHNpZ25lciBrZXkgJHtvLnB1YmxpY0tleS50b0Jhc2U1OCgpfWApLCB0aGlzLnNpZ25hdHVyZXNbaV0gPSBWYyhyLCBvLnNlY3JldEtleSk7XG4gICAgfVxuICB9XG4gIGFkZFNpZ25hdHVyZShlLCByKSB7XG4gICAgYnQoci5ieXRlTGVuZ3RoID09PSA2NCwgXCJTaWduYXR1cmUgbXVzdCBiZSA2NCBieXRlcyBsb25nXCIpO1xuICAgIGNvbnN0IG8gPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpLmZpbmRJbmRleCgoaSkgPT4gaS5lcXVhbHMoZSkpO1xuICAgIGJ0KG8gPj0gMCwgYENhbiBub3QgYWRkIHNpZ25hdHVyZTsgXFxgJHtlLnRvQmFzZTU4KCl9XFxgIGlzIG5vdCByZXF1aXJlZCB0byBzaWduIHRoaXMgdHJhbnNhY3Rpb25gKSwgdGhpcy5zaWduYXR1cmVzW29dID0gcjtcbiAgfVxufVxubmV3IFJlKFwiU3lzdmFyQzFvY2sxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbm5ldyBSZShcIlN5c3ZhckVwb2NoU2NoZWR1MWUxMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5uZXcgUmUoXCJTeXN2YXIxbnN0cnVjdGlvbnMxMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xubmV3IFJlKFwiU3lzdmFyUmVjZW50QjFvY2tIYXNoZXMxMTExMTExMTExMTExMTExMTExMVwiKTtcbm5ldyBSZShcIlN5c3ZhclJlbnQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5uZXcgUmUoXCJTeXN2YXJSZXdhcmRzMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xubmV3IFJlKFwiU3lzdmFyUzFvdEhhc2hlczExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbm5ldyBSZShcIlN5c3ZhclMxb3RIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5uZXcgUmUoXCJTeXN2YXJTdGFrZUhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xuY29uc3QgTDEgPSBELm51NjQoXCJsYW1wb3J0c1BlclNpZ25hdHVyZVwiKSwgTzEgPSBELnN0cnVjdChbRC51MzIoXCJ2ZXJzaW9uXCIpLCBELnUzMihcInN0YXRlXCIpLCB0dChcImF1dGhvcml6ZWRQdWJrZXlcIiksIHR0KFwibm9uY2VcIiksIEQuc3RydWN0KFtMMV0sIFwiZmVlQ2FsY3VsYXRvclwiKV0pO1xuTzEuc3BhbjtcbmZ1bmN0aW9uIFBuKHQpIHtcbiAgY29uc3QgZSA9IEQuYmxvYig4LCB0KSwgciA9IGUuZGVjb2RlLmJpbmQoZSksIG4gPSBlLmVuY29kZS5iaW5kKGUpLCBvID0gZSwgaSA9IFJkKCk7XG4gIHJldHVybiBvLmRlY29kZSA9IChjLCBmKSA9PiB7XG4gICAgY29uc3QgdiA9IHIoYywgZik7XG4gICAgcmV0dXJuIGkuZGVjb2RlKHYpO1xuICB9LCBvLmVuY29kZSA9IChjLCBmLCB2KSA9PiB7XG4gICAgY29uc3QgeCA9IGkuZW5jb2RlKGMpO1xuICAgIHJldHVybiBuKHgsIGYsIHYpO1xuICB9LCBvO1xufVxuT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIEQubnM2NChcImxhbXBvcnRzXCIpLCBELm5zNjQoXCJzcGFjZVwiKSwgdHQoXCJwcm9ncmFtSWRcIildKVxuICB9LFxuICBBc3NpZ246IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpLCB0dChcInByb2dyYW1JZFwiKV0pXG4gIH0sXG4gIFRyYW5zZmVyOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgUG4oXCJsYW1wb3J0c1wiKV0pXG4gIH0sXG4gIENyZWF0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgdHQoXCJiYXNlXCIpLCBBbihcInNlZWRcIiksIEQubnM2NChcImxhbXBvcnRzXCIpLCBELm5zNjQoXCJzcGFjZVwiKSwgdHQoXCJwcm9ncmFtSWRcIildKVxuICB9LFxuICBBZHZhbmNlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKV0pXG4gIH0sXG4gIFdpdGhkcmF3Tm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgRC5uczY0KFwibGFtcG9ydHNcIildKVxuICB9LFxuICBJbml0aWFsaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDYsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgdHQoXCJhdXRob3JpemVkXCIpXSlcbiAgfSxcbiAgQXV0aG9yaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgdHQoXCJhdXRob3JpemVkXCIpXSlcbiAgfSxcbiAgQWxsb2NhdGU6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpLCBELm5zNjQoXCJzcGFjZVwiKV0pXG4gIH0sXG4gIEFsbG9jYXRlV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOSxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpLCB0dChcImJhc2VcIiksIEFuKFwic2VlZFwiKSwgRC5uczY0KFwic3BhY2VcIiksIHR0KFwicHJvZ3JhbUlkXCIpXSlcbiAgfSxcbiAgQXNzaWduV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgdHQoXCJiYXNlXCIpLCBBbihcInNlZWRcIiksIHR0KFwicHJvZ3JhbUlkXCIpXSlcbiAgfSxcbiAgVHJhbnNmZXJXaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMSxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpLCBQbihcImxhbXBvcnRzXCIpLCBBbihcInNlZWRcIiksIHR0KFwicHJvZ3JhbUlkXCIpXSlcbiAgfSxcbiAgVXBncmFkZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiAxMixcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpXSlcbiAgfVxufSk7XG5uZXcgUmUoXCIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbm5ldyBSZShcIkJQRkxvYWRlcjIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5ELnN0cnVjdChbXG4gIEQudTMyKFwidHlwZUluZGV4XCIpLFxuICBQbihcImRlYWN0aXZhdGlvblNsb3RcIiksXG4gIEQubnU2NChcImxhc3RFeHRlbmRlZFNsb3RcIiksXG4gIEQudTgoXCJsYXN0RXh0ZW5kZWRTdGFydEluZGV4XCIpLFxuICBELnU4KCksXG4gIC8vIG9wdGlvblxuICBELnNlcSh0dCgpLCBELm9mZnNldChELnU4KCksIC0xKSwgXCJhdXRob3JpdHlcIilcbl0pO1xuY29uc3QgZ3QgPSAkaShmYShSZSksIGllKCksICh0KSA9PiBuZXcgUmUodCkpLCBXYyA9IGhhKFtpZSgpLCBkdChcImJhc2U2NFwiKV0pLCB5YSA9ICRpKGZhKGV0LkJ1ZmZlciksIFdjLCAodCkgPT4gZXQuQnVmZmVyLmZyb20odFswXSwgXCJiYXNlNjRcIikpO1xuZnVuY3Rpb24gR2ModCkge1xuICByZXR1cm4gVXQoW3RlKHtcbiAgICBqc29ucnBjOiBkdChcIjIuMFwiKSxcbiAgICBpZDogaWUoKSxcbiAgICByZXN1bHQ6IHRcbiAgfSksIHRlKHtcbiAgICBqc29ucnBjOiBkdChcIjIuMFwiKSxcbiAgICBpZDogaWUoKSxcbiAgICBlcnJvcjogdGUoe1xuICAgICAgY29kZTogem4oKSxcbiAgICAgIG1lc3NhZ2U6IGllKCksXG4gICAgICBkYXRhOiBFZShGZCgpKVxuICAgIH0pXG4gIH0pXSk7XG59XG5jb25zdCBOMSA9IEdjKHpuKCkpO1xuZnVuY3Rpb24gbHQodCkge1xuICByZXR1cm4gJGkoR2ModCksIE4xLCAoZSkgPT4gXCJlcnJvclwiIGluIGUgPyBlIDoge1xuICAgIC4uLmUsXG4gICAgcmVzdWx0OiB4aShlLnJlc3VsdCwgdClcbiAgfSk7XG59XG5mdW5jdGlvbiBYdCh0KSB7XG4gIHJldHVybiBsdCh0ZSh7XG4gICAgY29udGV4dDogdGUoe1xuICAgICAgc2xvdDogSigpXG4gICAgfSksXG4gICAgdmFsdWU6IHRcbiAgfSkpO1xufVxuZnVuY3Rpb24genModCkge1xuICByZXR1cm4gdGUoe1xuICAgIGNvbnRleHQ6IHRlKHtcbiAgICAgIHNsb3Q6IEooKVxuICAgIH0pLFxuICAgIHZhbHVlOiB0XG4gIH0pO1xufVxuY29uc3QgajEgPSB0ZSh7XG4gIGZvdW5kYXRpb246IEooKSxcbiAgZm91bmRhdGlvblRlcm06IEooKSxcbiAgaW5pdGlhbDogSigpLFxuICB0YXBlcjogSigpLFxuICB0ZXJtaW5hbDogSigpXG59KTtcbmx0KGZlKGhlKHRlKHtcbiAgZXBvY2g6IEooKSxcbiAgZWZmZWN0aXZlU2xvdDogSigpLFxuICBhbW91bnQ6IEooKSxcbiAgcG9zdEJhbGFuY2U6IEooKSxcbiAgY29tbWlzc2lvbjogRWUoaGUoSigpKSlcbn0pKSkpO1xuY29uc3QgVTEgPSBmZSh0ZSh7XG4gIHNsb3Q6IEooKSxcbiAgcHJpb3JpdGl6YXRpb25GZWU6IEooKVxufSkpLCBGMSA9IHRlKHtcbiAgdG90YWw6IEooKSxcbiAgdmFsaWRhdG9yOiBKKCksXG4gIGZvdW5kYXRpb246IEooKSxcbiAgZXBvY2g6IEooKVxufSksIFAxID0gdGUoe1xuICBlcG9jaDogSigpLFxuICBzbG90SW5kZXg6IEooKSxcbiAgc2xvdHNJbkVwb2NoOiBKKCksXG4gIGFic29sdXRlU2xvdDogSigpLFxuICBibG9ja0hlaWdodDogRWUoSigpKSxcbiAgdHJhbnNhY3Rpb25Db3VudDogRWUoSigpKVxufSksIEQxID0gdGUoe1xuICBzbG90c1BlckVwb2NoOiBKKCksXG4gIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDogSigpLFxuICB3YXJtdXA6IHVyKCksXG4gIGZpcnN0Tm9ybWFsRXBvY2g6IEooKSxcbiAgZmlyc3ROb3JtYWxTbG90OiBKKClcbn0pLCAkMSA9IE9jKGllKCksIGZlKEooKSkpLCBkbiA9IGhlKFV0KFt0ZSh7fSksIGllKCldKSksIHoxID0gdGUoe1xuICBlcnI6IGRuXG59KSwgcTEgPSBkdChcInJlY2VpdmVkU2lnbmF0dXJlXCIpO1xudGUoe1xuICBcInNvbGFuYS1jb3JlXCI6IGllKCksXG4gIFwiZmVhdHVyZS1zZXRcIjogRWUoSigpKVxufSk7XG5jb25zdCBaMSA9IHRlKHtcbiAgcHJvZ3JhbTogaWUoKSxcbiAgcHJvZ3JhbUlkOiBndCxcbiAgcGFyc2VkOiB6bigpXG59KSwgVjEgPSB0ZSh7XG4gIHByb2dyYW1JZDogZ3QsXG4gIGFjY291bnRzOiBmZShndCksXG4gIGRhdGE6IGllKClcbn0pO1xuWHQodGUoe1xuICBlcnI6IGhlKFV0KFt0ZSh7fSksIGllKCldKSksXG4gIGxvZ3M6IGhlKGZlKGllKCkpKSxcbiAgYWNjb3VudHM6IEVlKGhlKGZlKGhlKHRlKHtcbiAgICBleGVjdXRhYmxlOiB1cigpLFxuICAgIG93bmVyOiBpZSgpLFxuICAgIGxhbXBvcnRzOiBKKCksXG4gICAgZGF0YTogZmUoaWUoKSksXG4gICAgcmVudEVwb2NoOiBFZShKKCkpXG4gIH0pKSkpKSxcbiAgdW5pdHNDb25zdW1lZDogRWUoSigpKSxcbiAgcmV0dXJuRGF0YTogRWUoaGUodGUoe1xuICAgIHByb2dyYW1JZDogaWUoKSxcbiAgICBkYXRhOiBoYShbaWUoKSwgZHQoXCJiYXNlNjRcIildKVxuICB9KSkpLFxuICBpbm5lckluc3RydWN0aW9uczogRWUoaGUoZmUodGUoe1xuICAgIGluZGV4OiBKKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBmZShVdChbWjEsIFYxXSkpXG4gIH0pKSkpXG59KSk7XG5YdCh0ZSh7XG4gIGJ5SWRlbnRpdHk6IE9jKGllKCksIGZlKEooKSkpLFxuICByYW5nZTogdGUoe1xuICAgIGZpcnN0U2xvdDogSigpLFxuICAgIGxhc3RTbG90OiBKKClcbiAgfSlcbn0pKTtcbmx0KGoxKTtcbmx0KEYxKTtcbmx0KFUxKTtcbmx0KFAxKTtcbmx0KEQxKTtcbmx0KCQxKTtcbmx0KEooKSk7XG5YdCh0ZSh7XG4gIHRvdGFsOiBKKCksXG4gIGNpcmN1bGF0aW5nOiBKKCksXG4gIG5vbkNpcmN1bGF0aW5nOiBKKCksXG4gIG5vbkNpcmN1bGF0aW5nQWNjb3VudHM6IGZlKGd0KVxufSkpO1xuY29uc3QgSDEgPSB0ZSh7XG4gIGFtb3VudDogaWUoKSxcbiAgdWlBbW91bnQ6IGhlKEooKSksXG4gIGRlY2ltYWxzOiBKKCksXG4gIHVpQW1vdW50U3RyaW5nOiBFZShpZSgpKVxufSk7XG5YdChmZSh0ZSh7XG4gIGFkZHJlc3M6IGd0LFxuICBhbW91bnQ6IGllKCksXG4gIHVpQW1vdW50OiBoZShKKCkpLFxuICBkZWNpbWFsczogSigpLFxuICB1aUFtb3VudFN0cmluZzogRWUoaWUoKSlcbn0pKSk7XG5YdChmZSh0ZSh7XG4gIHB1YmtleTogZ3QsXG4gIGFjY291bnQ6IHRlKHtcbiAgICBleGVjdXRhYmxlOiB1cigpLFxuICAgIG93bmVyOiBndCxcbiAgICBsYW1wb3J0czogSigpLFxuICAgIGRhdGE6IHlhLFxuICAgIHJlbnRFcG9jaDogSigpXG4gIH0pXG59KSkpO1xuY29uc3Qgam8gPSB0ZSh7XG4gIHByb2dyYW06IGllKCksXG4gIHBhcnNlZDogem4oKSxcbiAgc3BhY2U6IEooKVxufSk7XG5YdChmZSh0ZSh7XG4gIHB1YmtleTogZ3QsXG4gIGFjY291bnQ6IHRlKHtcbiAgICBleGVjdXRhYmxlOiB1cigpLFxuICAgIG93bmVyOiBndCxcbiAgICBsYW1wb3J0czogSigpLFxuICAgIGRhdGE6IGpvLFxuICAgIHJlbnRFcG9jaDogSigpXG4gIH0pXG59KSkpO1xuWHQoZmUodGUoe1xuICBsYW1wb3J0czogSigpLFxuICBhZGRyZXNzOiBndFxufSkpKTtcbmNvbnN0IHZhID0gdGUoe1xuICBleGVjdXRhYmxlOiB1cigpLFxuICBvd25lcjogZ3QsXG4gIGxhbXBvcnRzOiBKKCksXG4gIGRhdGE6IHlhLFxuICByZW50RXBvY2g6IEooKVxufSk7XG50ZSh7XG4gIHB1YmtleTogZ3QsXG4gIGFjY291bnQ6IHZhXG59KTtcbmNvbnN0IEsxID0gJGkoVXQoW2ZhKGV0LkJ1ZmZlciksIGpvXSksIFV0KFtXYywgam9dKSwgKHQpID0+IEFycmF5LmlzQXJyYXkodCkgPyB4aSh0LCB5YSkgOiB0KSwgVzEgPSB0ZSh7XG4gIGV4ZWN1dGFibGU6IHVyKCksXG4gIG93bmVyOiBndCxcbiAgbGFtcG9ydHM6IEooKSxcbiAgZGF0YTogSzEsXG4gIHJlbnRFcG9jaDogSigpXG59KTtcbnRlKHtcbiAgcHVia2V5OiBndCxcbiAgYWNjb3VudDogVzFcbn0pO1xudGUoe1xuICBzdGF0ZTogVXQoW2R0KFwiYWN0aXZlXCIpLCBkdChcImluYWN0aXZlXCIpLCBkdChcImFjdGl2YXRpbmdcIiksIGR0KFwiZGVhY3RpdmF0aW5nXCIpXSksXG4gIGFjdGl2ZTogSigpLFxuICBpbmFjdGl2ZTogSigpXG59KTtcbmx0KGZlKHRlKHtcbiAgc2lnbmF0dXJlOiBpZSgpLFxuICBzbG90OiBKKCksXG4gIGVycjogZG4sXG4gIG1lbW86IGhlKGllKCkpLFxuICBibG9ja1RpbWU6IEVlKGhlKEooKSkpXG59KSkpO1xubHQoZmUodGUoe1xuICBzaWduYXR1cmU6IGllKCksXG4gIHNsb3Q6IEooKSxcbiAgZXJyOiBkbixcbiAgbWVtbzogaGUoaWUoKSksXG4gIGJsb2NrVGltZTogRWUoaGUoSigpKSlcbn0pKSk7XG50ZSh7XG4gIHN1YnNjcmlwdGlvbjogSigpLFxuICByZXN1bHQ6IHpzKHZhKVxufSk7XG5jb25zdCBHMSA9IHRlKHtcbiAgcHVia2V5OiBndCxcbiAgYWNjb3VudDogdmFcbn0pO1xudGUoe1xuICBzdWJzY3JpcHRpb246IEooKSxcbiAgcmVzdWx0OiB6cyhHMSlcbn0pO1xuY29uc3QgWTEgPSB0ZSh7XG4gIHBhcmVudDogSigpLFxuICBzbG90OiBKKCksXG4gIHJvb3Q6IEooKVxufSk7XG50ZSh7XG4gIHN1YnNjcmlwdGlvbjogSigpLFxuICByZXN1bHQ6IFkxXG59KTtcbmNvbnN0IEoxID0gVXQoW3RlKHtcbiAgdHlwZTogVXQoW2R0KFwiZmlyc3RTaHJlZFJlY2VpdmVkXCIpLCBkdChcImNvbXBsZXRlZFwiKSwgZHQoXCJvcHRpbWlzdGljQ29uZmlybWF0aW9uXCIpLCBkdChcInJvb3RcIildKSxcbiAgc2xvdDogSigpLFxuICB0aW1lc3RhbXA6IEooKVxufSksIHRlKHtcbiAgdHlwZTogZHQoXCJjcmVhdGVkQmFua1wiKSxcbiAgcGFyZW50OiBKKCksXG4gIHNsb3Q6IEooKSxcbiAgdGltZXN0YW1wOiBKKClcbn0pLCB0ZSh7XG4gIHR5cGU6IGR0KFwiZnJvemVuXCIpLFxuICBzbG90OiBKKCksXG4gIHRpbWVzdGFtcDogSigpLFxuICBzdGF0czogdGUoe1xuICAgIG51bVRyYW5zYWN0aW9uRW50cmllczogSigpLFxuICAgIG51bVN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnM6IEooKSxcbiAgICBudW1GYWlsZWRUcmFuc2FjdGlvbnM6IEooKSxcbiAgICBtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeTogSigpXG4gIH0pXG59KSwgdGUoe1xuICB0eXBlOiBkdChcImRlYWRcIiksXG4gIHNsb3Q6IEooKSxcbiAgdGltZXN0YW1wOiBKKCksXG4gIGVycjogaWUoKVxufSldKTtcbnRlKHtcbiAgc3Vic2NyaXB0aW9uOiBKKCksXG4gIHJlc3VsdDogSjFcbn0pO1xudGUoe1xuICBzdWJzY3JpcHRpb246IEooKSxcbiAgcmVzdWx0OiB6cyhVdChbejEsIHExXSkpXG59KTtcbnRlKHtcbiAgc3Vic2NyaXB0aW9uOiBKKCksXG4gIHJlc3VsdDogSigpXG59KTtcbnRlKHtcbiAgcHVia2V5OiBpZSgpLFxuICBnb3NzaXA6IGhlKGllKCkpLFxuICB0cHU6IGhlKGllKCkpLFxuICBycGM6IGhlKGllKCkpLFxuICB2ZXJzaW9uOiBoZShpZSgpKVxufSk7XG5jb25zdCBwdSA9IHRlKHtcbiAgdm90ZVB1YmtleTogaWUoKSxcbiAgbm9kZVB1YmtleTogaWUoKSxcbiAgYWN0aXZhdGVkU3Rha2U6IEooKSxcbiAgZXBvY2hWb3RlQWNjb3VudDogdXIoKSxcbiAgZXBvY2hDcmVkaXRzOiBmZShoYShbSigpLCBKKCksIEooKV0pKSxcbiAgY29tbWlzc2lvbjogSigpLFxuICBsYXN0Vm90ZTogSigpLFxuICByb290U2xvdDogaGUoSigpKVxufSk7XG5sdCh0ZSh7XG4gIGN1cnJlbnQ6IGZlKHB1KSxcbiAgZGVsaW5xdWVudDogZmUocHUpXG59KSk7XG5jb25zdCBYMSA9IFV0KFtkdChcInByb2Nlc3NlZFwiKSwgZHQoXCJjb25maXJtZWRcIiksIGR0KFwiZmluYWxpemVkXCIpXSksIFExID0gdGUoe1xuICBzbG90OiBKKCksXG4gIGNvbmZpcm1hdGlvbnM6IGhlKEooKSksXG4gIGVycjogZG4sXG4gIGNvbmZpcm1hdGlvblN0YXR1czogRWUoWDEpXG59KTtcblh0KGZlKGhlKFExKSkpO1xubHQoSigpKTtcbmNvbnN0IFljID0gdGUoe1xuICBhY2NvdW50S2V5OiBndCxcbiAgd3JpdGFibGVJbmRleGVzOiBmZShKKCkpLFxuICByZWFkb25seUluZGV4ZXM6IGZlKEooKSlcbn0pLCB3YSA9IHRlKHtcbiAgc2lnbmF0dXJlczogZmUoaWUoKSksXG4gIG1lc3NhZ2U6IHRlKHtcbiAgICBhY2NvdW50S2V5czogZmUoaWUoKSksXG4gICAgaGVhZGVyOiB0ZSh7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IEooKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IEooKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogSigpXG4gICAgfSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBmZSh0ZSh7XG4gICAgICBhY2NvdW50czogZmUoSigpKSxcbiAgICAgIGRhdGE6IGllKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogSigpXG4gICAgfSkpLFxuICAgIHJlY2VudEJsb2NraGFzaDogaWUoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBFZShmZShZYykpXG4gIH0pXG59KSwgSmMgPSB0ZSh7XG4gIHB1YmtleTogZ3QsXG4gIHNpZ25lcjogdXIoKSxcbiAgd3JpdGFibGU6IHVyKCksXG4gIHNvdXJjZTogRWUoVXQoW2R0KFwidHJhbnNhY3Rpb25cIiksIGR0KFwibG9va3VwVGFibGVcIildKSlcbn0pLCBYYyA9IHRlKHtcbiAgYWNjb3VudEtleXM6IGZlKEpjKSxcbiAgc2lnbmF0dXJlczogZmUoaWUoKSlcbn0pLCBRYyA9IHRlKHtcbiAgcGFyc2VkOiB6bigpLFxuICBwcm9ncmFtOiBpZSgpLFxuICBwcm9ncmFtSWQ6IGd0XG59KSwgZWwgPSB0ZSh7XG4gIGFjY291bnRzOiBmZShndCksXG4gIGRhdGE6IGllKCksXG4gIHByb2dyYW1JZDogZ3Rcbn0pLCBlcCA9IFV0KFtlbCwgUWNdKSwgdHAgPSBVdChbdGUoe1xuICBwYXJzZWQ6IHpuKCksXG4gIHByb2dyYW06IGllKCksXG4gIHByb2dyYW1JZDogaWUoKVxufSksIHRlKHtcbiAgYWNjb3VudHM6IGZlKGllKCkpLFxuICBkYXRhOiBpZSgpLFxuICBwcm9ncmFtSWQ6IGllKClcbn0pXSksIHRsID0gJGkoZXAsIHRwLCAodCkgPT4gXCJhY2NvdW50c1wiIGluIHQgPyB4aSh0LCBlbCkgOiB4aSh0LCBRYykpLCBybCA9IHRlKHtcbiAgc2lnbmF0dXJlczogZmUoaWUoKSksXG4gIG1lc3NhZ2U6IHRlKHtcbiAgICBhY2NvdW50S2V5czogZmUoSmMpLFxuICAgIGluc3RydWN0aW9uczogZmUodGwpLFxuICAgIHJlY2VudEJsb2NraGFzaDogaWUoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBFZShoZShmZShZYykpKVxuICB9KVxufSksIFNzID0gdGUoe1xuICBhY2NvdW50SW5kZXg6IEooKSxcbiAgbWludDogaWUoKSxcbiAgb3duZXI6IEVlKGllKCkpLFxuICBwcm9ncmFtSWQ6IEVlKGllKCkpLFxuICB1aVRva2VuQW1vdW50OiBIMVxufSksIG5sID0gdGUoe1xuICB3cml0YWJsZTogZmUoZ3QpLFxuICByZWFkb25seTogZmUoZ3QpXG59KSwgcXMgPSB0ZSh7XG4gIGVycjogZG4sXG4gIGZlZTogSigpLFxuICBpbm5lckluc3RydWN0aW9uczogRWUoaGUoZmUodGUoe1xuICAgIGluZGV4OiBKKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBmZSh0ZSh7XG4gICAgICBhY2NvdW50czogZmUoSigpKSxcbiAgICAgIGRhdGE6IGllKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogSigpXG4gICAgfSkpXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogZmUoSigpKSxcbiAgcG9zdEJhbGFuY2VzOiBmZShKKCkpLFxuICBsb2dNZXNzYWdlczogRWUoaGUoZmUoaWUoKSkpKSxcbiAgcHJlVG9rZW5CYWxhbmNlczogRWUoaGUoZmUoU3MpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBFZShoZShmZShTcykpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBFZShubCksXG4gIGNvbXB1dGVVbml0c0NvbnN1bWVkOiBFZShKKCkpXG59KSwgeGEgPSB0ZSh7XG4gIGVycjogZG4sXG4gIGZlZTogSigpLFxuICBpbm5lckluc3RydWN0aW9uczogRWUoaGUoZmUodGUoe1xuICAgIGluZGV4OiBKKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBmZSh0bClcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBmZShKKCkpLFxuICBwb3N0QmFsYW5jZXM6IGZlKEooKSksXG4gIGxvZ01lc3NhZ2VzOiBFZShoZShmZShpZSgpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBFZShoZShmZShTcykpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IEVlKGhlKGZlKFNzKSkpLFxuICBsb2FkZWRBZGRyZXNzZXM6IEVlKG5sKSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IEVlKEooKSlcbn0pLCBxbiA9IFV0KFtkdCgwKSwgZHQoXCJsZWdhY3lcIildKSwgcG4gPSB0ZSh7XG4gIHB1YmtleTogaWUoKSxcbiAgbGFtcG9ydHM6IEooKSxcbiAgcG9zdEJhbGFuY2U6IGhlKEooKSksXG4gIHJld2FyZFR5cGU6IGhlKGllKCkpLFxuICBjb21taXNzaW9uOiBFZShoZShKKCkpKVxufSk7XG5sdChoZSh0ZSh7XG4gIGJsb2NraGFzaDogaWUoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IGllKCksXG4gIHBhcmVudFNsb3Q6IEooKSxcbiAgdHJhbnNhY3Rpb25zOiBmZSh0ZSh7XG4gICAgdHJhbnNhY3Rpb246IHdhLFxuICAgIG1ldGE6IGhlKHFzKSxcbiAgICB2ZXJzaW9uOiBFZShxbilcbiAgfSkpLFxuICByZXdhcmRzOiBFZShmZShwbikpLFxuICBibG9ja1RpbWU6IGhlKEooKSksXG4gIGJsb2NrSGVpZ2h0OiBoZShKKCkpXG59KSkpO1xubHQoaGUodGUoe1xuICBibG9ja2hhc2g6IGllKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBpZSgpLFxuICBwYXJlbnRTbG90OiBKKCksXG4gIHJld2FyZHM6IEVlKGZlKHBuKSksXG4gIGJsb2NrVGltZTogaGUoSigpKSxcbiAgYmxvY2tIZWlnaHQ6IGhlKEooKSlcbn0pKSk7XG5sdChoZSh0ZSh7XG4gIGJsb2NraGFzaDogaWUoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IGllKCksXG4gIHBhcmVudFNsb3Q6IEooKSxcbiAgdHJhbnNhY3Rpb25zOiBmZSh0ZSh7XG4gICAgdHJhbnNhY3Rpb246IFhjLFxuICAgIG1ldGE6IGhlKHFzKSxcbiAgICB2ZXJzaW9uOiBFZShxbilcbiAgfSkpLFxuICByZXdhcmRzOiBFZShmZShwbikpLFxuICBibG9ja1RpbWU6IGhlKEooKSksXG4gIGJsb2NrSGVpZ2h0OiBoZShKKCkpXG59KSkpO1xubHQoaGUodGUoe1xuICBibG9ja2hhc2g6IGllKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBpZSgpLFxuICBwYXJlbnRTbG90OiBKKCksXG4gIHRyYW5zYWN0aW9uczogZmUodGUoe1xuICAgIHRyYW5zYWN0aW9uOiBybCxcbiAgICBtZXRhOiBoZSh4YSksXG4gICAgdmVyc2lvbjogRWUocW4pXG4gIH0pKSxcbiAgcmV3YXJkczogRWUoZmUocG4pKSxcbiAgYmxvY2tUaW1lOiBoZShKKCkpLFxuICBibG9ja0hlaWdodDogaGUoSigpKVxufSkpKTtcbmx0KGhlKHRlKHtcbiAgYmxvY2toYXNoOiBpZSgpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogaWUoKSxcbiAgcGFyZW50U2xvdDogSigpLFxuICB0cmFuc2FjdGlvbnM6IGZlKHRlKHtcbiAgICB0cmFuc2FjdGlvbjogWGMsXG4gICAgbWV0YTogaGUoeGEpLFxuICAgIHZlcnNpb246IEVlKHFuKVxuICB9KSksXG4gIHJld2FyZHM6IEVlKGZlKHBuKSksXG4gIGJsb2NrVGltZTogaGUoSigpKSxcbiAgYmxvY2tIZWlnaHQ6IGhlKEooKSlcbn0pKSk7XG5sdChoZSh0ZSh7XG4gIGJsb2NraGFzaDogaWUoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IGllKCksXG4gIHBhcmVudFNsb3Q6IEooKSxcbiAgcmV3YXJkczogRWUoZmUocG4pKSxcbiAgYmxvY2tUaW1lOiBoZShKKCkpLFxuICBibG9ja0hlaWdodDogaGUoSigpKVxufSkpKTtcbmx0KGhlKHRlKHtcbiAgYmxvY2toYXNoOiBpZSgpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogaWUoKSxcbiAgcGFyZW50U2xvdDogSigpLFxuICB0cmFuc2FjdGlvbnM6IGZlKHRlKHtcbiAgICB0cmFuc2FjdGlvbjogd2EsXG4gICAgbWV0YTogaGUocXMpXG4gIH0pKSxcbiAgcmV3YXJkczogRWUoZmUocG4pKSxcbiAgYmxvY2tUaW1lOiBoZShKKCkpXG59KSkpO1xubHQoaGUodGUoe1xuICBibG9ja2hhc2g6IGllKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBpZSgpLFxuICBwYXJlbnRTbG90OiBKKCksXG4gIHNpZ25hdHVyZXM6IGZlKGllKCkpLFxuICBibG9ja1RpbWU6IGhlKEooKSlcbn0pKSk7XG5sdChoZSh0ZSh7XG4gIHNsb3Q6IEooKSxcbiAgbWV0YTogaGUocXMpLFxuICBibG9ja1RpbWU6IEVlKGhlKEooKSkpLFxuICB0cmFuc2FjdGlvbjogd2EsXG4gIHZlcnNpb246IEVlKHFuKVxufSkpKTtcbmx0KGhlKHRlKHtcbiAgc2xvdDogSigpLFxuICB0cmFuc2FjdGlvbjogcmwsXG4gIG1ldGE6IGhlKHhhKSxcbiAgYmxvY2tUaW1lOiBFZShoZShKKCkpKSxcbiAgdmVyc2lvbjogRWUocW4pXG59KSkpO1xuWHQodGUoe1xuICBibG9ja2hhc2g6IGllKCksXG4gIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBKKClcbn0pKTtcblh0KHVyKCkpO1xuY29uc3QgcnAgPSB0ZSh7XG4gIHNsb3Q6IEooKSxcbiAgbnVtVHJhbnNhY3Rpb25zOiBKKCksXG4gIG51bVNsb3RzOiBKKCksXG4gIHNhbXBsZVBlcmlvZFNlY3M6IEooKVxufSk7XG5sdChmZShycCkpO1xuWHQoaGUodGUoe1xuICBmZWVDYWxjdWxhdG9yOiB0ZSh7XG4gICAgbGFtcG9ydHNQZXJTaWduYXR1cmU6IEooKVxuICB9KVxufSkpKTtcbmx0KGllKCkpO1xubHQoaWUoKSk7XG5jb25zdCBucCA9IHRlKHtcbiAgZXJyOiBkbixcbiAgbG9nczogZmUoaWUoKSksXG4gIHNpZ25hdHVyZTogaWUoKVxufSk7XG50ZSh7XG4gIHJlc3VsdDogenMobnApLFxuICBzdWJzY3JpcHRpb246IEooKVxufSk7XG5PYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpLCBQbihcInJlY2VudFNsb3RcIiksIEQudTgoXCJidW1wU2VlZFwiKV0pXG4gIH0sXG4gIEZyZWV6ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKV0pXG4gIH0sXG4gIEV4dGVuZExvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgUG4oKSwgRC5zZXEodHQoKSwgRC5vZmZzZXQoRC51MzIoKSwgLTgpLCBcImFkZHJlc3Nlc1wiKV0pXG4gIH0sXG4gIERlYWN0aXZhdGVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTMyKFwiaW5zdHJ1Y3Rpb25cIildKVxuICB9LFxuICBDbG9zZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKV0pXG4gIH1cbn0pO1xubmV3IFJlKFwiQWRkcmVzc0xvb2t1cFRhYjFlMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbk9iamVjdC5mcmVlemUoe1xuICBSZXF1ZXN0VW5pdHM6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnU4KFwiaW5zdHJ1Y3Rpb25cIiksIEQudTMyKFwidW5pdHNcIiksIEQudTMyKFwiYWRkaXRpb25hbEZlZVwiKV0pXG4gIH0sXG4gIFJlcXVlc3RIZWFwRnJhbWU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnU4KFwiaW5zdHJ1Y3Rpb25cIiksIEQudTMyKFwiYnl0ZXNcIildKVxuICB9LFxuICBTZXRDb21wdXRlVW5pdExpbWl0OiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51OChcImluc3RydWN0aW9uXCIpLCBELnUzMihcInVuaXRzXCIpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRQcmljZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTgoXCJpbnN0cnVjdGlvblwiKSwgUG4oXCJtaWNyb0xhbXBvcnRzXCIpXSlcbiAgfVxufSk7XG5uZXcgUmUoXCJDb21wdXRlQnVkZ2V0MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xuRC5zdHJ1Y3QoW0QudTgoXCJudW1TaWduYXR1cmVzXCIpLCBELnU4KFwicGFkZGluZ1wiKSwgRC51MTYoXCJzaWduYXR1cmVPZmZzZXRcIiksIEQudTE2KFwic2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleFwiKSwgRC51MTYoXCJwdWJsaWNLZXlPZmZzZXRcIiksIEQudTE2KFwicHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleFwiKSwgRC51MTYoXCJtZXNzYWdlRGF0YU9mZnNldFwiKSwgRC51MTYoXCJtZXNzYWdlRGF0YVNpemVcIiksIEQudTE2KFwibWVzc2FnZUluc3RydWN0aW9uSW5kZXhcIildKTtcbm5ldyBSZShcIkVkMjU1MTlTaWdWZXJpZnkxMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5fMS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleTtcbkQuc3RydWN0KFtELnU4KFwibnVtU2lnbmF0dXJlc1wiKSwgRC51MTYoXCJzaWduYXR1cmVPZmZzZXRcIiksIEQudTgoXCJzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4XCIpLCBELnUxNihcImV0aEFkZHJlc3NPZmZzZXRcIiksIEQudTgoXCJldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleFwiKSwgRC51MTYoXCJtZXNzYWdlRGF0YU9mZnNldFwiKSwgRC51MTYoXCJtZXNzYWdlRGF0YVNpemVcIiksIEQudTgoXCJtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleFwiKSwgRC5ibG9iKDIwLCBcImV0aEFkZHJlc3NcIiksIEQuYmxvYig2NCwgXCJzaWduYXR1cmVcIiksIEQudTgoXCJyZWNvdmVyeUlkXCIpXSk7XG5uZXcgUmUoXCJLZWNjYWtTZWNwMjU2azExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xudmFyIGlsO1xubmV3IFJlKFwiU3Rha2VDb25maWcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbmNsYXNzIHNsIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBMb2NrdXAgb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCByLCBuKSB7XG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdm9pZCAwLCB0aGlzLmVwb2NoID0gdm9pZCAwLCB0aGlzLmN1c3RvZGlhbiA9IHZvaWQgMCwgdGhpcy51bml4VGltZXN0YW1wID0gZSwgdGhpcy5lcG9jaCA9IHIsIHRoaXMuY3VzdG9kaWFuID0gbjtcbiAgfVxuICAvKipcbiAgICogRGVmYXVsdCwgaW5hY3RpdmUgTG9ja3VwIHZhbHVlXG4gICAqL1xufVxuaWwgPSBzbDtcbnNsLmRlZmF1bHQgPSBuZXcgaWwoMCwgMCwgUmUuZGVmYXVsdCk7XG5PYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIGsxKCksIEkxKCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpLCB0dChcIm5ld0F1dGhvcml6ZWRcIiksIEQudTMyKFwic3Rha2VBdXRob3JpemF0aW9uVHlwZVwiKV0pXG4gIH0sXG4gIERlbGVnYXRlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKV0pXG4gIH0sXG4gIFNwbGl0OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgRC5uczY0KFwibGFtcG9ydHNcIildKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIEQubnM2NChcImxhbXBvcnRzXCIpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZToge1xuICAgIGluZGV4OiA1LFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTMyKFwiaW5zdHJ1Y3Rpb25cIildKVxuICB9LFxuICBNZXJnZToge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTMyKFwiaW5zdHJ1Y3Rpb25cIildKVxuICB9LFxuICBBdXRob3JpemVXaXRoU2VlZDoge1xuICAgIGluZGV4OiA4LFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIHR0KFwibmV3QXV0aG9yaXplZFwiKSwgRC51MzIoXCJzdGFrZUF1dGhvcml6YXRpb25UeXBlXCIpLCBBbihcImF1dGhvcml0eVNlZWRcIiksIHR0KFwiYXV0aG9yaXR5T3duZXJcIildKVxuICB9XG59KTtcbm5ldyBSZShcIlN0YWtlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5PYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZUFjY291bnQ6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpLCBCMSgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgdHQoXCJuZXdBdXRob3JpemVkXCIpLCBELnUzMihcInZvdGVBdXRob3JpemF0aW9uVHlwZVwiKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBELnN0cnVjdChbRC51MzIoXCJpbnN0cnVjdGlvblwiKSwgRC5uczY0KFwibGFtcG9ydHNcIildKVxuICB9LFxuICBVcGRhdGVWYWxpZGF0b3JJZGVudGl0eToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogRC5zdHJ1Y3QoW0QudTMyKFwiaW5zdHJ1Y3Rpb25cIildKVxuICB9LFxuICBBdXRob3JpemVXaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMCxcbiAgICBsYXlvdXQ6IEQuc3RydWN0KFtELnUzMihcImluc3RydWN0aW9uXCIpLCBSMSgpXSlcbiAgfVxufSk7XG5uZXcgUmUoXCJWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xubmV3IFJlKFwiVmExaWRhdG9yMW5mbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbnRlKHtcbiAgbmFtZTogaWUoKSxcbiAgd2Vic2l0ZTogRWUoaWUoKSksXG4gIGRldGFpbHM6IEVlKGllKCkpLFxuICBpY29uVXJsOiBFZShpZSgpKSxcbiAga2V5YmFzZVVzZXJuYW1lOiBFZShpZSgpKVxufSk7XG5uZXcgUmUoXCJWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xuRC5zdHJ1Y3QoW1xuICB0dChcIm5vZGVQdWJrZXlcIiksXG4gIHR0KFwiYXV0aG9yaXplZFdpdGhkcmF3ZXJcIiksXG4gIEQudTgoXCJjb21taXNzaW9uXCIpLFxuICBELm51NjQoKSxcbiAgLy8gdm90ZXMubGVuZ3RoXG4gIEQuc2VxKEQuc3RydWN0KFtELm51NjQoXCJzbG90XCIpLCBELnUzMihcImNvbmZpcm1hdGlvbkNvdW50XCIpXSksIEQub2Zmc2V0KEQudTMyKCksIC04KSwgXCJ2b3Rlc1wiKSxcbiAgRC51OChcInJvb3RTbG90VmFsaWRcIiksXG4gIEQubnU2NChcInJvb3RTbG90XCIpLFxuICBELm51NjQoKSxcbiAgLy8gYXV0aG9yaXplZFZvdGVycy5sZW5ndGhcbiAgRC5zZXEoRC5zdHJ1Y3QoW0QubnU2NChcImVwb2NoXCIpLCB0dChcImF1dGhvcml6ZWRWb3RlclwiKV0pLCBELm9mZnNldChELnUzMigpLCAtOCksIFwiYXV0aG9yaXplZFZvdGVyc1wiKSxcbiAgRC5zdHJ1Y3QoW0Quc2VxKEQuc3RydWN0KFt0dChcImF1dGhvcml6ZWRQdWJrZXlcIiksIEQubnU2NChcImVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaFwiKSwgRC5udTY0KFwidGFyZ2V0RXBvY2hcIildKSwgMzIsIFwiYnVmXCIpLCBELm51NjQoXCJpZHhcIiksIEQudTgoXCJpc0VtcHR5XCIpXSwgXCJwcmlvclZvdGVyc1wiKSxcbiAgRC5udTY0KCksXG4gIC8vIGVwb2NoQ3JlZGl0cy5sZW5ndGhcbiAgRC5zZXEoRC5zdHJ1Y3QoW0QubnU2NChcImVwb2NoXCIpLCBELm51NjQoXCJjcmVkaXRzXCIpLCBELm51NjQoXCJwcmV2Q3JlZGl0c1wiKV0pLCBELm9mZnNldChELnUzMigpLCAtOCksIFwiZXBvY2hDcmVkaXRzXCIpLFxuICBELnN0cnVjdChbRC5udTY0KFwic2xvdFwiKSwgRC5udTY0KFwidGltZXN0YW1wXCIpXSwgXCJsYXN0VGltZXN0YW1wXCIpXG5dKTtcbmNvbnN0IGlwID0gKHQpID0+ICh7XG4gIHJlcXVlc3Q6IHQsXG4gIHNpZ25NZXNzYWdlOiAoZSkgPT4gdCh7IG1ldGhvZDogXCJzaWduTWVzc2FnZVwiLCBwYXJhbXM6IHsgbWVzc2FnZTogZSB9IH0pLFxuICBzaWduVHJhbnNhY3Rpb246IChlKSA9PiB0KHsgbWV0aG9kOiBcInNpZ25UcmFuc2FjdGlvblwiLCBwYXJhbXM6IHsgdHJhbnNhY3Rpb246IGUgfSB9KSxcbiAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogKGUpID0+IHQoe1xuICAgIG1ldGhvZDogXCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgcGFyYW1zOiBlXG4gIH0pXG59KTtcbmZ1bmN0aW9uIG11KHQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHQuc2VyaWFsaXplKHtcbiAgICB2ZXJpZnlTaWduYXR1cmVzOiAhMVxuICB9KSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG5mdW5jdGlvbiBzcCh0KSB7XG4gIGNvbnN0IGUgPSBCdWZmZXIuZnJvbSh0LCBcImJhc2U2NFwiKTtcbiAgcmV0dXJuIG1hLmRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oZSkgPT09IFwibGVnYWN5XCIgPyBnYS5kZXNlcmlhbGl6ZShlKSA6IENzLmZyb20oZSk7XG59XG5mdW5jdGlvbiBvcCh0KSB7XG4gIHJldHVybiBhc3luYyAocikgPT4ge1xuICAgIGlmIChyLm1ldGhvZCA9PT0gXCJjb25uZWN0XCIpXG4gICAgICByZXR1cm4gYXdhaXQgdChyKTtcbiAgICBpZiAoci5tZXRob2QgPT09IFwic2lnbk1lc3NhZ2VcIilcbiAgICAgIHJldHVybiBhd2FpdCB0KHIpO1xuICAgIGlmIChyLm1ldGhvZCA9PT0gXCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb246IG4sIG9wdGlvbnM6IG8gfSA9IHIucGFyYW1zLCBpID0ge1xuICAgICAgICB0cmFuc2FjdGlvbjogbXUobilcbiAgICAgIH07XG4gICAgICByZXR1cm4gYXdhaXQgdCh7XG4gICAgICAgIG1ldGhvZDogXCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHBhcmFtczogaVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyLm1ldGhvZCA9PT0gXCJzaWduVHJhbnNhY3Rpb25cIikge1xuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbjogbiB9ID0gci5wYXJhbXMsIG8gPSB7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBtdShuKVxuICAgICAgfSwgeyBzaWduZWRUcmFuc2FjdGlvbjogaSB9ID0gYXdhaXQgdCh7XG4gICAgICAgIG1ldGhvZDogXCJzaWduVHJhbnNhY3Rpb25cIixcbiAgICAgICAgcGFyYW1zOiBvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNpZ25lZFRyYW5zYWN0aW9uOiBzcChpKSB9O1xuICAgIH1cbiAgfTtcbn1cbmxldCBvbCA9IGNsYXNzIGFsIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlLCByID0ge30pIHtcbiAgICBjb25zdCBuID0gKCgpID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHIuY2F1c2UgaW5zdGFuY2VvZiBhbCkge1xuICAgICAgICBpZiAoci5jYXVzZS5kZXRhaWxzKVxuICAgICAgICAgIHJldHVybiByLmNhdXNlLmRldGFpbHM7XG4gICAgICAgIGlmIChyLmNhdXNlLnNob3J0TWVzc2FnZSlcbiAgICAgICAgICByZXR1cm4gci5jYXVzZS5zaG9ydE1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gci5jYXVzZSAmJiBcImRldGFpbHNcIiBpbiByLmNhdXNlICYmIHR5cGVvZiByLmNhdXNlLmRldGFpbHMgPT0gXCJzdHJpbmdcIiA/IHIuY2F1c2UuZGV0YWlscyA6IChpID0gci5jYXVzZSkgIT0gbnVsbCAmJiBpLm1lc3NhZ2UgPyByLmNhdXNlLm1lc3NhZ2UgOiByLmRldGFpbHM7XG4gICAgfSkoKSwgbyA9IFtcbiAgICAgIGUgfHwgXCJBbiBlcnJvciBvY2N1cnJlZC5cIixcbiAgICAgIC4uLnIubWV0YU1lc3NhZ2VzID8gW1wiXCIsIC4uLnIubWV0YU1lc3NhZ2VzXSA6IFtdLFxuICAgICAgLi4ubiA/IFtcbiAgICAgICAgXCJcIixcbiAgICAgICAgbiA/IGBEZXRhaWxzOiAke259YCA6IHZvaWQgMFxuICAgICAgXSA6IFtdXG4gICAgXS5maWx0ZXIoKGkpID0+IHR5cGVvZiBpID09IFwic3RyaW5nXCIpLmpvaW4oYFxuYCk7XG4gICAgc3VwZXIobywgci5jYXVzZSA/IHsgY2F1c2U6IHIuY2F1c2UgfSA6IHZvaWQgMCksIHRoaXMubmFtZSA9IFwiQmFzZUVycm9yXCIsIHRoaXMuY2F1c2UgPSByLmNhdXNlLCB0aGlzLmRldGFpbHMgPSBuLCB0aGlzLnNob3J0TWVzc2FnZSA9IGU7XG4gIH1cbn07XG5jbGFzcyB1bCBleHRlbmRzIG9sIHtcbiAgY29uc3RydWN0b3IoeyBzdGF0dXM6IGUgfSkge1xuICAgIHN1cGVyKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyAke2V9YCksIHRoaXMubmFtZSA9IFwiUmVxdWVzdEZhaWxlZEVycm9yXCI7XG4gIH1cbn1cbmNsYXNzIGFwIGV4dGVuZHMgb2wge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMubmFtZSA9IFwiSW52YWxpZFRva2VuXCI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwKHsgb3JpZ2luOiB0IH0pIHtcbiAgY29uc3QgZSA9IGF3YWl0IGZldGNoKGAke3R9L25vbmNlYCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgfSk7XG4gIGlmICghZS5vaylcbiAgICB0aHJvdyBuZXcgdWwoeyBzdGF0dXM6IGUuc3RhdHVzIH0pO1xuICByZXR1cm4gYXdhaXQgZS5qc29uKCk7XG59XG5hc3luYyBmdW5jdGlvbiBjcCh7IG9yaWdpbjogdCB9LCBlKSB7XG4gIGNvbnN0IHIgPSBhd2FpdCBmZXRjaChgJHt0fS92ZXJpZnktc2l3ZmAsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSksXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZSlcbiAgfSk7XG4gIGlmICghci5vaylcbiAgICB0aHJvdyBuZXcgdWwoeyBzdGF0dXM6IHIuc3RhdHVzIH0pO1xuICBjb25zdCBuID0gYXdhaXQgci5qc29uKCk7XG4gIGlmIChuLnZhbGlkID09PSAhMSlcbiAgICB0aHJvdyBuZXcgYXAobi5tZXNzYWdlID8/IFwidW5rbm93blwiKTtcbiAgcmV0dXJuIHsgdG9rZW46IG4udG9rZW4gfTtcbn1cbmZ1bmN0aW9uIGxwKHQgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIG9yaWdpbjogdC5vcmlnaW4gPz8gXCJodHRwczovL2F1dGguZmFyY2FzdGVyLnh5elwiXG4gIH07XG59XG5mdW5jdGlvbiBmcCh0ID0ge30pIHtcbiAgY29uc3QgZSA9IGxwKHQpO1xuICByZXR1cm4ge1xuICAgIGdlbmVyYXRlTm9uY2U6ICgpID0+IHVwKGUpLFxuICAgIHZlcmlmeVNpd2Y6IChyKSA9PiBjcChlLCByKVxuICB9O1xufVxuY29uc3QgaHAgPSBcIjAuMS4xXCI7XG5mdW5jdGlvbiBkcCgpIHtcbiAgcmV0dXJuIGhwO1xufVxubGV0IHBwID0gY2xhc3MgVW8gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGUsIHIgPSB7fSkge1xuICAgIGNvbnN0IG4gPSAoKCkgPT4ge1xuICAgICAgdmFyIHY7XG4gICAgICBpZiAoci5jYXVzZSBpbnN0YW5jZW9mIFVvKSB7XG4gICAgICAgIGlmIChyLmNhdXNlLmRldGFpbHMpXG4gICAgICAgICAgcmV0dXJuIHIuY2F1c2UuZGV0YWlscztcbiAgICAgICAgaWYgKHIuY2F1c2Uuc2hvcnRNZXNzYWdlKVxuICAgICAgICAgIHJldHVybiByLmNhdXNlLnNob3J0TWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAodiA9IHIuY2F1c2UpICE9IG51bGwgJiYgdi5tZXNzYWdlID8gci5jYXVzZS5tZXNzYWdlIDogci5kZXRhaWxzO1xuICAgIH0pKCksIG8gPSByLmNhdXNlIGluc3RhbmNlb2YgVW8gJiYgci5jYXVzZS5kb2NzUGF0aCB8fCByLmRvY3NQYXRoLCBjID0gYGh0dHBzOi8vb3hsaWIuc2gke28gPz8gXCJcIn1gLCBmID0gW1xuICAgICAgZSB8fCBcIkFuIGVycm9yIG9jY3VycmVkLlwiLFxuICAgICAgLi4uci5tZXRhTWVzc2FnZXMgPyBbXCJcIiwgLi4uci5tZXRhTWVzc2FnZXNdIDogW10sXG4gICAgICAuLi5uIHx8IG8gPyBbXG4gICAgICAgIFwiXCIsXG4gICAgICAgIG4gPyBgRGV0YWlsczogJHtufWAgOiB2b2lkIDAsXG4gICAgICAgIG8gPyBgU2VlOiAke2N9YCA6IHZvaWQgMFxuICAgICAgXSA6IFtdXG4gICAgXS5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ID09IFwic3RyaW5nXCIpLmpvaW4oYFxuYCk7XG4gICAgc3VwZXIoZiwgci5jYXVzZSA/IHsgY2F1c2U6IHIuY2F1c2UgfSA6IHZvaWQgMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRldGFpbHNcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1BhdGhcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiQmFzZUVycm9yXCJcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogYG94QCR7ZHAoKX1gXG4gICAgfSksIHRoaXMuY2F1c2UgPSByLmNhdXNlLCB0aGlzLmRldGFpbHMgPSBuLCB0aGlzLmRvY3MgPSBjLCB0aGlzLmRvY3NQYXRoID0gbywgdGhpcy5zaG9ydE1lc3NhZ2UgPSBlO1xuICB9XG4gIHdhbGsoZSkge1xuICAgIHJldHVybiBjbCh0aGlzLCBlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNsKHQsIGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiBlKHQpID8gdCA6IHQgJiYgdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiBcImNhdXNlXCIgaW4gdCAmJiB0LmNhdXNlID8gY2wodC5jYXVzZSwgZSkgOiBlID8gbnVsbCA6IHQ7XG59XG5jb25zdCBtcCA9IC9eKD86KD88c2NoZW1lPlthLXpBLVpdW2EtekEtWjAtOSstLl0qKTpcXC9cXC8pPyg/PGRvbWFpbj5bYS16QS1aMC05Ky0uXSooPzo6WzAtOV17MSw1fSk/KSAoPzp3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpcXG4pKD88YWRkcmVzcz4weFthLWZBLUYwLTldezQwfSlcXG5cXG4oPzooPzxzdGF0ZW1lbnQ+LiopXFxuXFxuKT8vLCBncCA9IC8oPzpVUkk6ICg/PHVyaT4uKykpXFxuKD86VmVyc2lvbjogKD88dmVyc2lvbj4uKykpXFxuKD86Q2hhaW4gSUQ6ICg/PGNoYWluSWQ+XFxkKykpXFxuKD86Tm9uY2U6ICg/PG5vbmNlPlthLXpBLVowLTldKykpXFxuKD86SXNzdWVkIEF0OiAoPzxpc3N1ZWRBdD4uKykpKD86XFxuRXhwaXJhdGlvbiBUaW1lOiAoPzxleHBpcmF0aW9uVGltZT4uKykpPyg/Olxcbk5vdCBCZWZvcmU6ICg/PG5vdEJlZm9yZT4uKykpPyg/OlxcblJlcXVlc3QgSUQ6ICg/PHJlcXVlc3RJZD4uKykpPy87XG5mdW5jdGlvbiB5cCh0KSB7XG4gIHZhciBTLCBULCBDO1xuICBjb25zdCB7IHNjaGVtZTogZSwgc3RhdGVtZW50OiByLCAuLi5uIH0gPSAoKFMgPSB0Lm1hdGNoKG1wKSkgPT0gbnVsbCA/IHZvaWQgMCA6IFMuZ3JvdXBzKSA/PyB7fSwgeyBjaGFpbklkOiBvLCBleHBpcmF0aW9uVGltZTogaSwgaXNzdWVkQXQ6IGMsIG5vdEJlZm9yZTogZiwgcmVxdWVzdElkOiB2LCAuLi54IH0gPSAoKFQgPSB0Lm1hdGNoKGdwKSkgPT0gbnVsbCA/IHZvaWQgMCA6IFQuZ3JvdXBzKSA/PyB7fSwgYiA9IChDID0gdC5zcGxpdChcIlJlc291cmNlczpcIilbMV0pID09IG51bGwgPyB2b2lkIDAgOiBDLnNwbGl0KGBcbi0gYCkuc2xpY2UoMSk7XG4gIHJldHVybiB7XG4gICAgLi4ubixcbiAgICAuLi54LFxuICAgIC4uLm8gPyB7IGNoYWluSWQ6IE51bWJlcihvKSB9IDoge30sXG4gICAgLi4uaSA/IHsgZXhwaXJhdGlvblRpbWU6IG5ldyBEYXRlKGkpIH0gOiB7fSxcbiAgICAuLi5jID8geyBpc3N1ZWRBdDogbmV3IERhdGUoYykgfSA6IHt9LFxuICAgIC4uLmYgPyB7IG5vdEJlZm9yZTogbmV3IERhdGUoZikgfSA6IHt9LFxuICAgIC4uLnYgPyB7IHJlcXVlc3RJZDogdiB9IDoge30sXG4gICAgLi4uYiA/IHsgcmVzb3VyY2VzOiBiIH0gOiB7fSxcbiAgICAuLi5lID8geyBzY2hlbWU6IGUgfSA6IHt9LFxuICAgIC4uLnIgPyB7IHN0YXRlbWVudDogciB9IDoge31cbiAgfTtcbn1cbmNvbnN0IHZwID0gKHsgZnJhbWVIb3N0OiB0LCBlbWl0dGVyOiBlIH0pID0+IHtcbiAgbGV0IHIsIG4gPSBudWxsO1xuICByZXR1cm4ge1xuICAgIHZpc2libGU6ICExLFxuICAgIGdldCBvbmJhY2soKSB7XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuICAgIHNldCBvbmJhY2sobykge1xuICAgICAgbiAmJiBlLnJlbW92ZUxpc3RlbmVyKFwiYmFja05hdmlnYXRpb25UcmlnZ2VyZWRcIiwgbiksIG4gPSBvLCBvICYmIGUuYWRkTGlzdGVuZXIoXCJiYWNrTmF2aWdhdGlvblRyaWdnZXJlZFwiLCBvKTtcbiAgICB9LFxuICAgIGFzeW5jIHNob3coKSB7XG4gICAgICBhd2FpdCB0LnVwZGF0ZUJhY2tTdGF0ZSh7XG4gICAgICAgIHZpc2libGU6ICEwXG4gICAgICB9KSwgdGhpcy52aXNpYmxlID0gITA7XG4gICAgfSxcbiAgICBhc3luYyBoaWRlKCkge1xuICAgICAgYXdhaXQgdC51cGRhdGVCYWNrU3RhdGUoe1xuICAgICAgICB2aXNpYmxlOiAhMVxuICAgICAgfSksIHRoaXMudmlzaWJsZSA9ICExO1xuICAgIH0sXG4gICAgYXN5bmMgZW5hYmxlV2ViTmF2aWdhdGlvbigpIHtcbiAgICAgIHIgPSB3cCh7XG4gICAgICAgIGJhY2s6IHRoaXMsXG4gICAgICAgIGVtaXR0ZXI6IGVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYXN5bmMgZGlzYWJsZVdlYk5hdmlnYXRpb24oKSB7XG4gICAgICByID09IG51bGwgfHwgcigpLCByID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiB3cCh7IGVtaXR0ZXI6IHQsIGJhY2s6IGUgfSkge1xuICBjb25zdCByID0geHAoKTtcbiAgaWYgKHIpXG4gICAgcmV0dXJuIGJwKHsgZW1pdHRlcjogdCwgYmFjazogZSwgbmF2aWdhdGlvbjogciB9KTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIilcbiAgICByZXR1cm4gX3AoeyBlbWl0dGVyOiB0LCBiYWNrOiBlLCB3aW5kb3cgfSk7XG59XG5mdW5jdGlvbiB4cCgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubmF2aWdhdGlvbiAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIGJwKHsgZW1pdHRlcjogdCwgYmFjazogZSwgbmF2aWdhdGlvbjogciB9KSB7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgci5jYW5Hb0JhY2sgPyBlLnNob3coKSA6IGUuaGlkZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgZS52aXNpYmxlICYmIHIuY2FuR29CYWNrICYmIHIuYmFjaygpO1xuICB9XG4gIHJldHVybiByLmFkZEV2ZW50TGlzdGVuZXIoXCJuYXZpZ2F0ZXN1Y2Nlc3NcIiwgbiksIHQuYWRkTGlzdGVuZXIoXCJiYWNrTmF2aWdhdGlvblRyaWdnZXJlZFwiLCBvKSwgKCkgPT4ge1xuICAgIHIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm5hdmlnYXRlc3VjY2Vzc1wiLCBuKSwgdC5yZW1vdmVMaXN0ZW5lcihcImJhY2tOYXZpZ2F0aW9uVHJpZ2dlcmVkXCIsIG8pO1xuICB9O1xufVxuZnVuY3Rpb24gX3AoeyBlbWl0dGVyOiB0LCBiYWNrOiBlLCB3aW5kb3c6IHIgfSkge1xuICBlLnNob3coKTtcbiAgZnVuY3Rpb24gbigpIHtcbiAgICBlLnZpc2libGUgJiYgci5oaXN0b3J5LmJhY2soKTtcbiAgfVxuICByZXR1cm4gdC5hZGRMaXN0ZW5lcihcImJhY2tOYXZpZ2F0aW9uVHJpZ2dlcmVkXCIsIG4pLCAoKSA9PiB7XG4gICAgdC5yZW1vdmVMaXN0ZW5lcihcImJhY2tOYXZpZ2F0aW9uVHJpZ2dlcmVkXCIsIG4pO1xuICB9O1xufVxuZnVuY3Rpb24gbGwodCwgZSA9IHt9KSB7XG4gIGNvbnN0IHsgcmF3OiByID0gITEgfSA9IGUsIG4gPSB0O1xuICBpZiAocilcbiAgICByZXR1cm4gdDtcbiAgaWYgKG4uZXJyb3IpIHtcbiAgICBjb25zdCB7IGNvZGU6IG8gfSA9IG4uZXJyb3IsIGkgPSBvID09PSBEbi5jb2RlID8gRG4gOiBvID09PSBiaS5jb2RlID8gYmkgOiBvID09PSBCaS5jb2RlID8gQmkgOiBvID09PSBraS5jb2RlID8ga2kgOiBvID09PSBTaS5jb2RlID8gU2kgOiBvID09PSBJaS5jb2RlID8gSWkgOiBvID09PSBDaS5jb2RlID8gQ2kgOiBvID09PSBSaS5jb2RlID8gUmkgOiBvID09PSBfaS5jb2RlID8gX2kgOiBvID09PSBFaS5jb2RlID8gRWkgOiBvID09PSBNaS5jb2RlID8gTWkgOiBvID09PSBBaS5jb2RlID8gQWkgOiBQdDtcbiAgICB0aHJvdyBuZXcgaShuLmVycm9yKTtcbiAgfVxuICByZXR1cm4gbi5yZXN1bHQ7XG59XG5jbGFzcyBQdCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGNvbnN0IHsgY29kZTogciwgbWVzc2FnZTogbiwgZGF0YTogbyB9ID0gZTtcbiAgICBzdXBlcihuKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5CYXNlRXJyb3JcIlxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSksIHRoaXMuY29kZSA9IHIsIHRoaXMuZGF0YSA9IG87XG4gIH1cbn1cbmNsYXNzIGJpIGV4dGVuZHMgUHQge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIk1pc3Npbmcgb3IgaW52YWxpZCBwYXJhbWV0ZXJzLlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IGJpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyZTNcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5JbnZhbGlkSW5wdXRFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShiaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMmUzXG59KTtcbmNsYXNzIF9pIGV4dGVuZHMgUHQge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIlJlcXVlc3RlZCByZXNvdXJjZSBub3QgZm91bmQuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogX2kuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzIwMDFcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5SZXNvdXJjZU5vdEZvdW5kRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX2ksIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiAtMzIwMDFcbn0pO1xuY2xhc3MgRWkgZXh0ZW5kcyBQdCB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lc3NhZ2U6IFwiUmVxdWVzdGVkIHJlc291cmNlIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogRWkuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzIwMDJcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5SZXNvdXJjZVVuYXZhaWxhYmxlRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRWksIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiAtMzIwMDJcbn0pO1xuY2xhc3MgTWkgZXh0ZW5kcyBQdCB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gY3JlYXRpb24gZmFpbGVkLlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IE1pLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyMDAzXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUnBjUmVzcG9uc2UuVHJhbnNhY3Rpb25SZWplY3RlZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pLCBcImNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogLTMyMDAzXG59KTtcbmNsYXNzIENpIGV4dGVuZHMgUHQge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIk1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogQ2kuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzIwMDRcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5NZXRob2ROb3RTdXBwb3J0ZWRFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMjAwNFxufSk7XG5jbGFzcyBTaSBleHRlbmRzIFB0IHtcbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVzc2FnZTogXCJSYXRlIGxpbWl0IGV4Y2VlZGVkLlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IFNpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyMDA1XG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUnBjUmVzcG9uc2UuTGltaXRFeGNlZWRlZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpLCBcImNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogLTMyMDA1XG59KTtcbmNsYXNzIEFpIGV4dGVuZHMgUHQge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIkpTT04tUlBDIHZlcnNpb24gbm90IHN1cHBvcnRlZC5cIixcbiAgICAgIC4uLmUsXG4gICAgICBjb2RlOiBBaS5jb2RlXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IC0zMjAwNlxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlJwY1Jlc3BvbnNlLlZlcnNpb25Ob3RTdXBwb3J0ZWRFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMjAwNlxufSk7XG5jbGFzcyBraSBleHRlbmRzIFB0IHtcbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVzc2FnZTogXCJJbnB1dCBpcyBub3QgYSB2YWxpZCBKU09OLVJQQyByZXF1ZXN0LlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IGtpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyNjAwXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUnBjUmVzcG9uc2UuSW52YWxpZFJlcXVlc3RFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShraSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMjYwMFxufSk7XG5jbGFzcyBJaSBleHRlbmRzIFB0IHtcbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVzc2FnZTogXCJNZXRob2QgZG9lcyBub3QgZXhpc3QuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogSWkuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzI2MDFcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5NZXRob2ROb3RGb3VuZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElpLCBcImNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogLTMyNjAxXG59KTtcbmNsYXNzIEJpIGV4dGVuZHMgUHQge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIkludmFsaWQgbWV0aG9kIHBhcmFtZXRlcnMuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogQmkuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzI2MDJcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5JbnZhbGlkUGFyYW1zRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmksIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiAtMzI2MDJcbn0pO1xuY2xhc3MgRG4gZXh0ZW5kcyBQdCB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogRG4uY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzI2MDNcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5JbnRlcm5hbEVycm9yRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG4sIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiAtMzI2MDNcbn0pO1xuY2xhc3MgUmkgZXh0ZW5kcyBQdCB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHBhcnNlIEpTT04tUlBDIHJlc3BvbnNlLlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IFJpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyNzAwXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUnBjUmVzcG9uc2UuUGFyc2VFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMjcwMFxufSk7XG5jbGFzcyBtbiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSwgcikge1xuICAgIHN1cGVyKHIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyUnBjRXJyb3JcIlxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV0YWlsc1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSksIHRoaXMuY29kZSA9IGUsIHRoaXMuZGV0YWlscyA9IHI7XG4gIH1cbn1cbmNsYXNzIGZsIGV4dGVuZHMgbW4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2U6IGUgPSBcIlRoZSB1c2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKDQwMDEsIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyLlVzZXJSZWplY3RlZFJlcXVlc3RFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbCwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IDQwMDFcbn0pO1xuY2xhc3MgaGwgZXh0ZW5kcyBtbiB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZTogZSA9IFwiVGhlIHJlcXVlc3RlZCBtZXRob2QgYW5kL29yIGFjY291bnQgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQgYnkgdGhlIHVzZXIuXCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoNDEwMCwgZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUHJvdmlkZXIuVW5hdXRob3JpemVkRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaGwsIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiA0MTAwXG59KTtcbmNsYXNzIGRsIGV4dGVuZHMgbW4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2U6IGUgPSBcIlRoZSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgbWV0aG9kLlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKDQyMDAsIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyLlVuc3VwcG9ydGVkTWV0aG9kRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZGwsIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiA0MjAwXG59KTtcbmNsYXNzIHBsIGV4dGVuZHMgbW4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2U6IGUgPSBcIlRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgY2hhaW5zLlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKDQ5MDAsIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyLkRpc2Nvbm5lY3RlZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsLCBcImNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogNDkwMFxufSk7XG5jbGFzcyBtbCBleHRlbmRzIG1uIHtcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlOiBlID0gXCJUaGUgcHJvdmlkZXIgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgcmVxdWVzdGVkIGNoYWluLlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKDQ5MDEsIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyLkNoYWluRGlzY29ubmVjdGVkRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkobWwsIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiA0OTAxXG59KTtcbmZ1bmN0aW9uIEVwKCkge1xuICBjb25zdCB0ID0gbmV3IERjKCk7XG4gIHJldHVybiB7XG4gICAgZ2V0IGV2ZW50TmFtZXMoKSB7XG4gICAgICByZXR1cm4gdC5ldmVudE5hbWVzLmJpbmQodCk7XG4gICAgfSxcbiAgICBnZXQgbGlzdGVuZXJDb3VudCgpIHtcbiAgICAgIHJldHVybiB0Lmxpc3RlbmVyQ291bnQuYmluZCh0KTtcbiAgICB9LFxuICAgIGdldCBsaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4gdC5saXN0ZW5lcnMuYmluZCh0KTtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyOiB0LmFkZExpc3RlbmVyLmJpbmQodCksXG4gICAgZW1pdDogdC5lbWl0LmJpbmQodCksXG4gICAgb2ZmOiB0Lm9mZi5iaW5kKHQpLFxuICAgIG9uOiB0Lm9uLmJpbmQodCksXG4gICAgb25jZTogdC5vbmNlLmJpbmQodCksXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiB0LnJlbW92ZUFsbExpc3RlbmVycy5iaW5kKHQpLFxuICAgIHJlbW92ZUxpc3RlbmVyOiB0LnJlbW92ZUxpc3RlbmVyLmJpbmQodClcbiAgfTtcbn1cbmZ1bmN0aW9uIE1wKHQsIGUgPSB7fSkge1xuICB2YXIgbiwgbztcbiAgY29uc3QgeyBpbmNsdWRlRXZlbnRzOiByID0gITAgfSA9IGU7XG4gIGlmICghdClcbiAgICB0aHJvdyBuZXcgQ3AoKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yID8ge1xuICAgICAgb246IChuID0gdC5vbikgPT0gbnVsbCA/IHZvaWQgMCA6IG4uYmluZCh0KSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiAobyA9IHQucmVtb3ZlTGlzdGVuZXIpID09IG51bGwgPyB2b2lkIDAgOiBvLmJpbmQodClcbiAgICB9IDoge30sXG4gICAgYXN5bmMgcmVxdWVzdChpKSB7XG4gICAgICBjb25zdCBjID0gYXdhaXQgdC5yZXF1ZXN0KGkpO1xuICAgICAgcmV0dXJuIGMgJiYgdHlwZW9mIGMgPT0gXCJvYmplY3RcIiAmJiBcImpzb25ycGNcIiBpbiBjID8gbGwoYykgOiBjO1xuICAgIH1cbiAgfTtcbn1cbmNsYXNzIENwIGV4dGVuZHMgcHAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImBwcm92aWRlcmAgaXMgdW5kZWZpbmVkLlwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJQcm92aWRlci5Jc1VuZGVmaW5lZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gU3AodCA9IHt9KSB7XG4gIGxldCBlID0gdC5pZCA/PyAwO1xuICByZXR1cm4ge1xuICAgIHByZXBhcmUocikge1xuICAgICAgcmV0dXJuIEFwKHtcbiAgICAgICAgaWQ6IGUrKyxcbiAgICAgICAgLi4uclxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQgaWQoKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBBcCh0KSB7XG4gIHJldHVybiB7XG4gICAgLi4udCxcbiAgICBqc29ucnBjOiBcIjIuMFwiXG4gIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBnbCA9IFN5bWJvbChcIkNvbWxpbmsucHJveHlcIiksIGtwID0gU3ltYm9sKFwiQ29tbGluay5lbmRwb2ludFwiKSwgSXAgPSBTeW1ib2woXCJDb21saW5rLnJlbGVhc2VQcm94eVwiKSwgZ28gPSBTeW1ib2woXCJDb21saW5rLmZpbmFsaXplclwiKSwgc3MgPSBTeW1ib2woXCJDb21saW5rLnRocm93blwiKSwgeWwgPSAodCkgPT4gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ICE9PSBudWxsIHx8IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiwgQnAgPSB7XG4gIGNhbkhhbmRsZTogKHQpID0+IHlsKHQpICYmIHRbZ2xdLFxuICBzZXJpYWxpemUodCkge1xuICAgIGNvbnN0IHsgcG9ydDE6IGUsIHBvcnQyOiByIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICByZXR1cm4gd2wodCwgZSksIFtyLCBbcl1dO1xuICB9LFxuICBkZXNlcmlhbGl6ZSh0KSB7XG4gICAgcmV0dXJuIHQuc3RhcnQoKSwgYmwodCk7XG4gIH1cbn0sIFJwID0ge1xuICBjYW5IYW5kbGU6ICh0KSA9PiB5bCh0KSAmJiBzcyBpbiB0LFxuICBzZXJpYWxpemUoeyB2YWx1ZTogdCB9KSB7XG4gICAgbGV0IGU7XG4gICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBFcnJvciA/IGUgPSB7XG4gICAgICBpc0Vycm9yOiAhMCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIG1lc3NhZ2U6IHQubWVzc2FnZSxcbiAgICAgICAgbmFtZTogdC5uYW1lLFxuICAgICAgICBzdGFjazogdC5zdGFja1xuICAgICAgfVxuICAgIH0gOiBlID0geyBpc0Vycm9yOiAhMSwgdmFsdWU6IHQgfSwgW2UsIFtdXTtcbiAgfSxcbiAgZGVzZXJpYWxpemUodCkge1xuICAgIHRocm93IHQuaXNFcnJvciA/IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHQudmFsdWUubWVzc2FnZSksIHQudmFsdWUpIDogdC52YWx1ZTtcbiAgfVxufSwgdmwgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcInByb3h5XCIsIEJwXSxcbiAgW1widGhyb3dcIiwgUnBdXG5dKTtcbmZ1bmN0aW9uIFRwKHQsIGUpIHtcbiAgZm9yIChjb25zdCByIG9mIHQpXG4gICAgaWYgKGUgPT09IHIgfHwgciA9PT0gXCIqXCIgfHwgciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByLnRlc3QoZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHdsKHQsIGUgPSBnbG9iYWxUaGlzLCByID0gW1wiKlwiXSkge1xuICBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIG4obykge1xuICAgIGlmICghbyB8fCAhby5kYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghVHAociwgby5vcmlnaW4pKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgb3JpZ2luICcke28ub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBpZDogaSwgdHlwZTogYywgcGF0aDogZiB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIG8uZGF0YSksIHYgPSAoby5kYXRhLmFyZ3VtZW50TGlzdCB8fCBbXSkubWFwKG5uKTtcbiAgICBsZXQgeDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYiA9IGYuc2xpY2UoMCwgLTEpLnJlZHVjZSgoVCwgQykgPT4gVFtDXSwgdCksIFMgPSBmLnJlZHVjZSgoVCwgQykgPT4gVFtDXSwgdCk7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgIHggPSBTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU0VUXCI6XG4gICAgICAgICAgYltmLnNsaWNlKC0xKVswXV0gPSBubihvLmRhdGEudmFsdWUpLCB4ID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBUFBMWVwiOlxuICAgICAgICAgIHggPSBTLmFwcGx5KGIsIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ09OU1RSVUNUXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgVCA9IG5ldyBTKC4uLnYpO1xuICAgICAgICAgICAgeCA9IEZwKFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkVORFBPSU5UXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgeyBwb3J0MTogVCwgcG9ydDI6IEMgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgd2wodCwgQyksIHggPSBVcChULCBbVF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJFTEVBU0VcIjpcbiAgICAgICAgICB4ID0gdm9pZCAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChiKSB7XG4gICAgICB4ID0geyB2YWx1ZTogYiwgW3NzXTogMCB9O1xuICAgIH1cbiAgICBQcm9taXNlLnJlc29sdmUoeCkuY2F0Y2goKGIpID0+ICh7IHZhbHVlOiBiLCBbc3NdOiAwIH0pKS50aGVuKChiKSA9PiB7XG4gICAgICBjb25zdCBbUywgVF0gPSBJcyhiKTtcbiAgICAgIGUucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBTKSwgeyBpZDogaSB9KSwgVCksIGMgPT09IFwiUkVMRUFTRVwiICYmIChlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG4pLCB4bChlKSwgZ28gaW4gdCAmJiB0eXBlb2YgdFtnb10gPT0gXCJmdW5jdGlvblwiICYmIHRbZ29dKCkpO1xuICAgIH0pLmNhdGNoKChiKSA9PiB7XG4gICAgICBjb25zdCBbUywgVF0gPSBJcyh7XG4gICAgICAgIHZhbHVlOiBuZXcgVHlwZUVycm9yKFwiVW5zZXJpYWxpemFibGUgcmV0dXJuIHZhbHVlXCIpLFxuICAgICAgICBbc3NdOiAwXG4gICAgICB9KTtcbiAgICAgIGUucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBTKSwgeyBpZDogaSB9KSwgVCk7XG4gICAgfSk7XG4gIH0pLCBlLnN0YXJ0ICYmIGUuc3RhcnQoKTtcbn1cbmZ1bmN0aW9uIExwKHQpIHtcbiAgcmV0dXJuIHQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJNZXNzYWdlUG9ydFwiO1xufVxuZnVuY3Rpb24geGwodCkge1xuICBMcCh0KSAmJiB0LmNsb3NlKCk7XG59XG5mdW5jdGlvbiBibCh0LCBlKSB7XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihvKSB7XG4gICAgY29uc3QgeyBkYXRhOiBpIH0gPSBvO1xuICAgIGlmICghaSB8fCAhaS5pZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjID0gci5nZXQoaS5pZCk7XG4gICAgaWYgKGMpXG4gICAgICB0cnkge1xuICAgICAgICBjKGkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgci5kZWxldGUoaS5pZCk7XG4gICAgICB9XG4gIH0pLCBGbyh0LCByLCBbXSwgZSk7XG59XG5mdW5jdGlvbiBKaSh0KSB7XG4gIGlmICh0KVxuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZVwiKTtcbn1cbmZ1bmN0aW9uIF9sKHQpIHtcbiAgcmV0dXJuIE1uKHQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHtcbiAgICB0eXBlOiBcIlJFTEVBU0VcIlxuICB9KS50aGVuKCgpID0+IHtcbiAgICB4bCh0KTtcbiAgfSk7XG59XG5jb25zdCBBcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBrcyA9IFwiRmluYWxpemF0aW9uUmVnaXN0cnlcIiBpbiBnbG9iYWxUaGlzICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgodCkgPT4ge1xuICBjb25zdCBlID0gKEFzLmdldCh0KSB8fCAwKSAtIDE7XG4gIEFzLnNldCh0LCBlKSwgZSA9PT0gMCAmJiBfbCh0KTtcbn0pO1xuZnVuY3Rpb24gT3AodCwgZSkge1xuICBjb25zdCByID0gKEFzLmdldChlKSB8fCAwKSArIDE7XG4gIEFzLnNldChlLCByKSwga3MgJiYga3MucmVnaXN0ZXIodCwgZSwgdCk7XG59XG5mdW5jdGlvbiBOcCh0KSB7XG4gIGtzICYmIGtzLnVucmVnaXN0ZXIodCk7XG59XG5mdW5jdGlvbiBGbyh0LCBlLCByID0gW10sIG4gPSBmdW5jdGlvbigpIHtcbn0pIHtcbiAgbGV0IG8gPSAhMTtcbiAgY29uc3QgaSA9IG5ldyBQcm94eShuLCB7XG4gICAgZ2V0KGMsIGYpIHtcbiAgICAgIGlmIChKaShvKSwgZiA9PT0gSXApXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgTnAoaSksIF9sKHQpLCBlLmNsZWFyKCksIG8gPSAhMDtcbiAgICAgICAgfTtcbiAgICAgIGlmIChmID09PSBcInRoZW5cIikge1xuICAgICAgICBpZiAoci5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gaSB9O1xuICAgICAgICBjb25zdCB2ID0gTW4odCwgZSwge1xuICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgcGF0aDogci5tYXAoKHgpID0+IHgudG9TdHJpbmcoKSlcbiAgICAgICAgfSkudGhlbihubik7XG4gICAgICAgIHJldHVybiB2LnRoZW4uYmluZCh2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGbyh0LCBlLCBbLi4uciwgZl0pO1xuICAgIH0sXG4gICAgc2V0KGMsIGYsIHYpIHtcbiAgICAgIEppKG8pO1xuICAgICAgY29uc3QgW3gsIGJdID0gSXModik7XG4gICAgICByZXR1cm4gTW4odCwgZSwge1xuICAgICAgICB0eXBlOiBcIlNFVFwiLFxuICAgICAgICBwYXRoOiBbLi4uciwgZl0ubWFwKChTKSA9PiBTLnRvU3RyaW5nKCkpLFxuICAgICAgICB2YWx1ZTogeFxuICAgICAgfSwgYikudGhlbihubik7XG4gICAgfSxcbiAgICBhcHBseShjLCBmLCB2KSB7XG4gICAgICBKaShvKTtcbiAgICAgIGNvbnN0IHggPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoeCA9PT0ga3ApXG4gICAgICAgIHJldHVybiBNbih0LCBlLCB7XG4gICAgICAgICAgdHlwZTogXCJFTkRQT0lOVFwiXG4gICAgICAgIH0pLnRoZW4obm4pO1xuICAgICAgaWYgKHggPT09IFwiYmluZFwiKVxuICAgICAgICByZXR1cm4gRm8odCwgZSwgci5zbGljZSgwLCAtMSkpO1xuICAgICAgY29uc3QgW2IsIFNdID0gZ3Uodik7XG4gICAgICByZXR1cm4gTW4odCwgZSwge1xuICAgICAgICB0eXBlOiBcIkFQUExZXCIsXG4gICAgICAgIHBhdGg6IHIubWFwKChUKSA9PiBULnRvU3RyaW5nKCkpLFxuICAgICAgICBhcmd1bWVudExpc3Q6IGJcbiAgICAgIH0sIFMpLnRoZW4obm4pO1xuICAgIH0sXG4gICAgY29uc3RydWN0KGMsIGYpIHtcbiAgICAgIEppKG8pO1xuICAgICAgY29uc3QgW3YsIHhdID0gZ3UoZik7XG4gICAgICByZXR1cm4gTW4odCwgZSwge1xuICAgICAgICB0eXBlOiBcIkNPTlNUUlVDVFwiLFxuICAgICAgICBwYXRoOiByLm1hcCgoYikgPT4gYi50b1N0cmluZygpKSxcbiAgICAgICAgYXJndW1lbnRMaXN0OiB2XG4gICAgICB9LCB4KS50aGVuKG5uKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT3AoaSwgdCksIGk7XG59XG5mdW5jdGlvbiBqcCh0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0KTtcbn1cbmZ1bmN0aW9uIGd1KHQpIHtcbiAgY29uc3QgZSA9IHQubWFwKElzKTtcbiAgcmV0dXJuIFtlLm1hcCgocikgPT4gclswXSksIGpwKGUubWFwKChyKSA9PiByWzFdKSldO1xufVxuY29uc3QgRWwgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIFVwKHQsIGUpIHtcbiAgcmV0dXJuIEVsLnNldCh0LCBlKSwgdDtcbn1cbmZ1bmN0aW9uIEZwKHQpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odCwgeyBbZ2xdOiAhMCB9KTtcbn1cbmZ1bmN0aW9uIFBwKHQsIGUgPSBnbG9iYWxUaGlzLCByID0gXCIqXCIpIHtcbiAgcmV0dXJuIHtcbiAgICBwb3N0TWVzc2FnZTogKG4sIG8pID0+IHQucG9zdE1lc3NhZ2UobiwgciwgbyksXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZS5hZGRFdmVudExpc3RlbmVyLmJpbmQoZSksXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZS5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIElzKHQpIHtcbiAgZm9yIChjb25zdCBbZSwgcl0gb2YgdmwpXG4gICAgaWYgKHIuY2FuSGFuZGxlKHQpKSB7XG4gICAgICBjb25zdCBbbiwgb10gPSByLnNlcmlhbGl6ZSh0KTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIkhBTkRMRVJcIixcbiAgICAgICAgICBuYW1lOiBlLFxuICAgICAgICAgIHZhbHVlOiBuXG4gICAgICAgIH0sXG4gICAgICAgIG9cbiAgICAgIF07XG4gICAgfVxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiUkFXXCIsXG4gICAgICB2YWx1ZTogdFxuICAgIH0sXG4gICAgRWwuZ2V0KHQpIHx8IFtdXG4gIF07XG59XG5mdW5jdGlvbiBubih0KSB7XG4gIHN3aXRjaCAodC50eXBlKSB7XG4gICAgY2FzZSBcIkhBTkRMRVJcIjpcbiAgICAgIHJldHVybiB2bC5nZXQodC5uYW1lKS5kZXNlcmlhbGl6ZSh0LnZhbHVlKTtcbiAgICBjYXNlIFwiUkFXXCI6XG4gICAgICByZXR1cm4gdC52YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gTW4odCwgZSwgciwgbikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKG8pID0+IHtcbiAgICBjb25zdCBpID0gRHAoKTtcbiAgICBlLnNldChpLCBvKSwgdC5zdGFydCAmJiB0LnN0YXJ0KCksIHQucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7IGlkOiBpIH0sIHIpLCBuKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBEcCgpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKS5qb2luKFwiLVwiKTtcbn1cbmNvbnN0ICRwID0ge1xuICBwb3N0TWVzc2FnZSgpIHtcbiAgfSxcbiAgYWRkRXZlbnRMaXN0ZW5lcjogKCkgPT4ge1xuICB9LFxuICByZW1vdmVFdmVudExpc3RlbmVyOiAoKSA9PiB7XG4gIH1cbn0sIHpwID0ge1xuICBwb3N0TWVzc2FnZTogKHQpID0+IHtcbiAgICBjb25zb2xlLmRlYnVnKFwiW3dlYnZpZXc6cmVxXVwiLCB0KSwgd2luZG93LlJlYWN0TmF0aXZlV2ViVmlldy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh0KSk7XG4gIH0sXG4gIGFkZEV2ZW50TGlzdGVuZXI6ICh0LCBlLCAuLi5yKSA9PiB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkZhcmNhc3RlckZyYW1lQ2FsbGJhY2tcIiwgZSwgLi4ucik7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6ICh0LCBlKSA9PiB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkZhcmNhc3RlckZyYW1lQ2FsbGJhY2tcIiwgZSk7XG4gIH1cbn0sIHFwID0gdHlwZW9mIHdpbmRvdyA+IFwidVwiID8gJHAgOiB3aW5kb3cgIT0gbnVsbCAmJiB3aW5kb3cuUmVhY3ROYXRpdmVXZWJWaWV3ID8genAgOiBQcCgod2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cucGFyZW50KSA/PyB3aW5kb3cpLCBRZSA9IGJsKHFwKSwgYmEgPSBFcCgpLCBacCA9IFNwKCk7XG5mdW5jdGlvbiBWcCh7IGNvZGU6IHQsIGRldGFpbHM6IGUgfSkge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIDQwMDE6XG4gICAgICByZXR1cm4gbmV3IGZsKCk7XG4gICAgY2FzZSA0MTAwOlxuICAgICAgcmV0dXJuIG5ldyBobCgpO1xuICAgIGNhc2UgNDIwMDpcbiAgICAgIHJldHVybiBuZXcgZGwoKTtcbiAgICBjYXNlIDQ5MDA6XG4gICAgICByZXR1cm4gbmV3IHBsKCk7XG4gICAgY2FzZSA0OTAxOlxuICAgICAgcmV0dXJuIG5ldyBtbCgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IG1uKHQsIGUgPz8gXCJVbmtub3duIHByb3ZpZGVyIFJQQyBlcnJvclwiKTtcbiAgfVxufVxuY29uc3QgVGkgPSBNcCh7XG4gIC4uLmJhLFxuICBhc3luYyByZXF1ZXN0KHQpIHtcbiAgICBjb25zdCBlID0gWnAucHJlcGFyZSh0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgciA9IGF3YWl0IFFlLmV0aFByb3ZpZGVyUmVxdWVzdFYyKGUpLnRoZW4oKG4pID0+IGxsKG4sIHsgcmVxdWVzdDogZSwgcmF3OiAhMCB9KSk7XG4gICAgICBpZiAoci5lcnJvcilcbiAgICAgICAgdGhyb3cgVnAoci5lcnJvcik7XG4gICAgICByZXR1cm4gci5yZXN1bHQ7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgaWYgKHIgaW5zdGFuY2VvZiBFcnJvciAmJiByLm1lc3NhZ2UubWF0Y2goL2Nhbm5vdCByZWFkIHByb3BlcnR5ICdhcHBseScvaSkpXG4gICAgICAgIHJldHVybiBhd2FpdCBRZS5ldGhQcm92aWRlclJlcXVlc3QoZSk7XG4gICAgICB0aHJvdyByIGluc3RhbmNlb2YgbW4gfHwgciBpbnN0YW5jZW9mIFB0ID8gciA6IG5ldyBEbih7XG4gICAgICAgIG1lc3NhZ2U6IHIgaW5zdGFuY2VvZiBFcnJvciA/IHIubWVzc2FnZSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59KTtcbmFzeW5jIGZ1bmN0aW9uIEhwKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHQgPSBhd2FpdCBRZS5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICByZXR1cm4gIXQuaW5jbHVkZXMoXCJ3YWxsZXQuZ2V0RXRoZXJldW1Qcm92aWRlclwiKSAmJiAhdC5pbmNsdWRlcyhcIndhbGxldC5nZXRFdm1Qcm92aWRlclwiKSA/IHZvaWQgMCA6IFRpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gVGk7XG4gIH1cbn1cbmZ1bmN0aW9uIE1sKHQpIHtcbiAgY29uc3QgZSA9IG5ldyBDdXN0b21FdmVudChcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCB7IGRldGFpbDogT2JqZWN0LmZyZWV6ZSh0KSB9KTtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZSk7XG4gIGNvbnN0IHIgPSAoKSA9PiB3aW5kb3cuZGlzcGF0Y2hFdmVudChlKTtcbiAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZWlwNjk2MzpyZXF1ZXN0UHJvdmlkZXJcIiwgciksICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZWlwNjk2MzpyZXF1ZXN0UHJvdmlkZXJcIiwgcik7XG59XG50eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6cmVxdWVzdFByb3ZpZGVyXCIsICgpID0+IHtcbiAgUWUuZWlwNjk2M1JlcXVlc3RQcm92aWRlcigpO1xufSksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJGYXJjYXN0ZXJGcmFtZUV0aFByb3ZpZGVyRXZlbnRcIiwgKHQpID0+IHtcbiAgaWYgKHQgaW5zdGFuY2VvZiBNZXNzYWdlRXZlbnQpIHtcbiAgICBjb25zdCBlID0gdC5kYXRhO1xuICAgIGJhLmVtaXQoZS5ldmVudCwgLi4uZS5wYXJhbXMpO1xuICB9XG59KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkZhcmNhc3RlckZyYW1lRXZlbnRcIiwgKHQpID0+IHtcbiAgaWYgKHQgaW5zdGFuY2VvZiBNZXNzYWdlRXZlbnQpIHtcbiAgICBjb25zdCBlID0gdC5kYXRhO1xuICAgIGUuZXZlbnQgPT09IFwiZWlwNjk2Mzphbm5vdW5jZVByb3ZpZGVyXCIgJiYgTWwoe1xuICAgICAgaW5mbzogZS5pbmZvLFxuICAgICAgcHJvdmlkZXI6IFRpXG4gICAgfSk7XG4gIH1cbn0pKTtcbnR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOnJlcXVlc3RQcm92aWRlclwiLCAoKSA9PiB7XG4gIFFlLmVpcDY5NjNSZXF1ZXN0UHJvdmlkZXIoKTtcbn0pLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHQpID0+IHtcbiAgaWYgKHQgaW5zdGFuY2VvZiBNZXNzYWdlRXZlbnQgJiYgdC5kYXRhLnR5cGUgPT09IFwiZnJhbWVFdGhQcm92aWRlckV2ZW50XCIpIHtcbiAgICBjb25zdCBlID0gdC5kYXRhO1xuICAgIGJhLmVtaXQoZS5ldmVudCwgLi4uZS5wYXJhbXMpO1xuICB9XG59KSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh0KSA9PiB7XG4gIGlmICh0IGluc3RhbmNlb2YgTWVzc2FnZUV2ZW50ICYmIHQuZGF0YS50eXBlID09PSBcImZyYW1lRXZlbnRcIikge1xuICAgIGNvbnN0IGUgPSB0LmRhdGEuZXZlbnQ7XG4gICAgZS5ldmVudCA9PT0gXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiAmJiBNbCh7XG4gICAgICBpbmZvOiBlLmluZm8sXG4gICAgICBwcm92aWRlcjogVGlcbiAgICB9KTtcbiAgfVxufSkpO1xuZnVuY3Rpb24gS3AoKSB7XG4gIGNvbnN0IHQgPSBuZXcgRGMoKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgZXZlbnROYW1lcygpIHtcbiAgICAgIHJldHVybiB0LmV2ZW50TmFtZXMuYmluZCh0KTtcbiAgICB9LFxuICAgIGdldCBsaXN0ZW5lckNvdW50KCkge1xuICAgICAgcmV0dXJuIHQubGlzdGVuZXJDb3VudC5iaW5kKHQpO1xuICAgIH0sXG4gICAgZ2V0IGxpc3RlbmVycygpIHtcbiAgICAgIHJldHVybiB0Lmxpc3RlbmVycy5iaW5kKHQpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXI6IHQuYWRkTGlzdGVuZXIuYmluZCh0KSxcbiAgICBlbWl0OiB0LmVtaXQuYmluZCh0KSxcbiAgICBvZmY6IHQub2ZmLmJpbmQodCksXG4gICAgb246IHQub24uYmluZCh0KSxcbiAgICBvbmNlOiB0Lm9uY2UuYmluZCh0KSxcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IHQucmVtb3ZlQWxsTGlzdGVuZXJzLmJpbmQodCksXG4gICAgcmVtb3ZlTGlzdGVuZXI6IHQucmVtb3ZlTGlzdGVuZXIuYmluZCh0KVxuICB9O1xufVxuY29uc3QgVHQgPSBLcCgpLCB7IHNvbGFuYVByb3ZpZGVyUmVxdWVzdDogeXUgfSA9IFFlO1xubGV0IENsO1xueXUgJiYgKENsID0gaXAob3AoeXUpKSk7XG5hc3luYyBmdW5jdGlvbiB2dSgpIHtcbiAgbGV0IHQ7XG4gIHRyeSB7XG4gICAgdCA9IGF3YWl0IFFlLmdldENhcGFiaWxpdGllcygpO1xuICB9IGNhdGNoIHtcbiAgfVxuICBpZiAodCAhPSBudWxsICYmIHQuaW5jbHVkZXMoXCJ3YWxsZXQuZ2V0U29sYW5hUHJvdmlkZXJcIikpXG4gICAgcmV0dXJuIENsO1xufVxubGV0IHd1ID0gbnVsbDtcbmFzeW5jIGZ1bmN0aW9uIFdwKHQgPSA1MCkge1xuICBpZiAod3UgPT09ICEwKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPiBcInVcIiB8fCAhd2luZG93LlJlYWN0TmF0aXZlV2ViVmlldyAmJiB3aW5kb3cgPT09IHdpbmRvdy5wYXJlbnQpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICBRZS5jb250ZXh0LnRoZW4oKHIpID0+ICEhciksXG4gICAgLy8gQ2hlY2sgaWYgY29udGV4dCByZXNvbHZlcyB0byB0cnV0aHlcbiAgICBuZXcgUHJvbWlzZSgocikgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiByKCExKSwgdCk7XG4gICAgfSlcbiAgXSkuY2F0Y2goKCkgPT4gITEpO1xuICByZXR1cm4gZSAmJiAod3UgPSAhMCksIGU7XG59XG5jb25zdCB4dSA9IGFzeW5jICh0ID0ge30pID0+IHtcbiAgY29uc3QgZSA9IGZwKHtcbiAgICBvcmlnaW46IHQucXVpY2tBdXRoU2VydmVyT3JpZ2luXG4gIH0pLCB7IG5vbmNlOiByIH0gPSBhd2FpdCBlLmdlbmVyYXRlTm9uY2UoKSwgbiA9IGF3YWl0IFFlLnNpZ25Jbih7XG4gICAgbm9uY2U6IHIsXG4gICAgYWNjZXB0QXV0aEFkZHJlc3M6ICEwXG4gIH0pO1xuICBpZiAobi5yZXN1bHQpIHtcbiAgICBjb25zdCBvID0geXAobi5yZXN1bHQubWVzc2FnZSk7XG4gICAgaWYgKCFvLmRvbWFpbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZG9tYWluIG9uIFNJV0UgbWVzc2FnZVwiKTtcbiAgICByZXR1cm4gYXdhaXQgZS52ZXJpZnlTaXdmKHtcbiAgICAgIGRvbWFpbjogby5kb21haW4sXG4gICAgICBtZXNzYWdlOiBuLnJlc3VsdC5tZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlOiBuLnJlc3VsdC5zaWduYXR1cmVcbiAgICB9KTtcbiAgfVxuICB0aHJvdyBuLmVycm9yLnR5cGUgPT09IFwicmVqZWN0ZWRfYnlfdXNlclwiID8gbmV3IEh1KCkgOiBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbn0sIGJ1ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB0ID0gYXdhaXQgUWUuYWRkRnJhbWUoKTtcbiAgaWYgKHQucmVzdWx0KVxuICAgIHJldHVybiB0LnJlc3VsdDtcbiAgdGhyb3cgdC5lcnJvci50eXBlID09PSBcImludmFsaWRfZG9tYWluX21hbmlmZXN0XCIgPyBuZXcgbmYoKSA6IHQuZXJyb3IudHlwZSA9PT0gXCJyZWplY3RlZF9ieV91c2VyXCIgPyBuZXcgc2YoKSA6IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xufSwgeXQgPSB7XG4gIC4uLlR0LFxuICBnZXRDYXBhYmlsaXRpZXM6IFFlLmdldENhcGFiaWxpdGllcyxcbiAgZ2V0Q2hhaW5zOiBRZS5nZXRDaGFpbnMsXG4gIGlzSW5NaW5pQXBwOiBXcCxcbiAgY29udGV4dDogUWUuY29udGV4dCxcbiAgYmFjazogdnAoeyBmcmFtZUhvc3Q6IFFlLCBlbWl0dGVyOiBUdCB9KSxcbiAgYWN0aW9uczoge1xuICAgIHNldFByaW1hcnlCdXR0b246IFFlLnNldFByaW1hcnlCdXR0b24uYmluZChRZSksXG4gICAgcmVhZHk6IGFzeW5jICh0ID0ge30pID0+IGF3YWl0IFFlLnJlYWR5KHQpLFxuICAgIGNsb3NlOiBRZS5jbG9zZS5iaW5kKFFlKSxcbiAgICB2aWV3Q2FzdDogUWUudmlld0Nhc3QuYmluZChRZSksXG4gICAgdmlld1Byb2ZpbGU6IFFlLnZpZXdQcm9maWxlLmJpbmQoUWUpLFxuICAgIHNpZ25JbjogYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCBRZS5zaWduSW4odCk7XG4gICAgICBpZiAoZS5yZXN1bHQpXG4gICAgICAgIHJldHVybiBlLnJlc3VsdDtcbiAgICAgIHRocm93IGUuZXJyb3IudHlwZSA9PT0gXCJyZWplY3RlZF9ieV91c2VyXCIgPyBuZXcgSHUoKSA6IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICAgIH0sXG4gICAgb3BlblVybDogKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQudXJsO1xuICAgICAgcmV0dXJuIFFlLm9wZW5VcmwoZS50cmltKCkpO1xuICAgIH0sXG4gICAgYWRkRnJhbWU6IGJ1LFxuICAgIGFkZE1pbmlBcHA6IGJ1LFxuICAgIGNvbXBvc2VDYXN0KHQgPSB7fSkge1xuICAgICAgcmV0dXJuIFFlLmNvbXBvc2VDYXN0KHQpO1xuICAgIH0sXG4gICAgdmlld1Rva2VuOiBRZS52aWV3VG9rZW4uYmluZChRZSksXG4gICAgc2VuZFRva2VuOiBRZS5zZW5kVG9rZW4uYmluZChRZSksXG4gICAgc3dhcFRva2VuOiBRZS5zd2FwVG9rZW4uYmluZChRZSksXG4gICAgcXVpY2tBdXRoOiB4dVxuICB9LFxuICBleHBlcmltZW50YWw6IHtcbiAgICBnZXRTb2xhbmFQcm92aWRlcjogdnUsXG4gICAgcXVpY2tBdXRoOiB4dVxuICB9LFxuICB3YWxsZXQ6IHtcbiAgICBldGhQcm92aWRlcjogVGksXG4gICAgZ2V0RXRoZXJldW1Qcm92aWRlcjogSHAsXG4gICAgZ2V0U29sYW5hUHJvdmlkZXI6IHZ1XG4gIH0sXG4gIGhhcHRpY3M6IHtcbiAgICBpbXBhY3RPY2N1cnJlZDogUWUuaW1wYWN0T2NjdXJyZWQuYmluZChRZSksXG4gICAgbm90aWZpY2F0aW9uT2NjdXJyZWQ6IFFlLm5vdGlmaWNhdGlvbk9jY3VycmVkLmJpbmQoUWUpLFxuICAgIHNlbGVjdGlvbkNoYW5nZWQ6IFFlLnNlbGVjdGlvbkNoYW5nZWQuYmluZChRZSlcbiAgfVxufTtcbnR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJGYXJjYXN0ZXJGcmFtZUV2ZW50XCIsICh0KSA9PiB7XG4gIGlmICh0IGluc3RhbmNlb2YgTWVzc2FnZUV2ZW50KSB7XG4gICAgY29uc3QgZSA9IHQuZGF0YTtcbiAgICBlLmV2ZW50ID09PSBcInByaW1hcnlfYnV0dG9uX2NsaWNrZWRcIiA/IFR0LmVtaXQoXCJwcmltYXJ5QnV0dG9uQ2xpY2tlZFwiKSA6IGUuZXZlbnQgPT09IFwiZnJhbWVfYWRkZWRcIiA/IFR0LmVtaXQoXCJmcmFtZUFkZGVkXCIsIHtcbiAgICAgIG5vdGlmaWNhdGlvbkRldGFpbHM6IGUubm90aWZpY2F0aW9uRGV0YWlsc1xuICAgIH0pIDogZS5ldmVudCA9PT0gXCJmcmFtZV9hZGRfcmVqZWN0ZWRcIiA/IFR0LmVtaXQoXCJmcmFtZUFkZFJlamVjdGVkXCIsIHsgcmVhc29uOiBlLnJlYXNvbiB9KSA6IGUuZXZlbnQgPT09IFwiZnJhbWVfcmVtb3ZlZFwiID8gVHQuZW1pdChcImZyYW1lUmVtb3ZlZFwiKSA6IGUuZXZlbnQgPT09IFwibm90aWZpY2F0aW9uc19lbmFibGVkXCIgPyBUdC5lbWl0KFwibm90aWZpY2F0aW9uc0VuYWJsZWRcIiwge1xuICAgICAgbm90aWZpY2F0aW9uRGV0YWlsczogZS5ub3RpZmljYXRpb25EZXRhaWxzXG4gICAgfSkgOiBlLmV2ZW50ID09PSBcIm5vdGlmaWNhdGlvbnNfZGlzYWJsZWRcIiA/IFR0LmVtaXQoXCJub3RpZmljYXRpb25zRGlzYWJsZWRcIikgOiBlLmV2ZW50ID09PSBcImJhY2tfbmF2aWdhdGlvbl90cmlnZ2VyZWRcIiAmJiBUdC5lbWl0KFwiYmFja05hdmlnYXRpb25UcmlnZ2VyZWRcIik7XG4gIH1cbn0pO1xudHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAodCkgPT4ge1xuICBpZiAodCBpbnN0YW5jZW9mIE1lc3NhZ2VFdmVudCAmJiB0LmRhdGEudHlwZSA9PT0gXCJmcmFtZUV2ZW50XCIpIHtcbiAgICBjb25zdCBlID0gdC5kYXRhLmV2ZW50O1xuICAgIGUuZXZlbnQgPT09IFwicHJpbWFyeV9idXR0b25fY2xpY2tlZFwiID8gVHQuZW1pdChcInByaW1hcnlCdXR0b25DbGlja2VkXCIpIDogZS5ldmVudCA9PT0gXCJmcmFtZV9hZGRlZFwiID8gVHQuZW1pdChcImZyYW1lQWRkZWRcIiwge1xuICAgICAgbm90aWZpY2F0aW9uRGV0YWlsczogZS5ub3RpZmljYXRpb25EZXRhaWxzXG4gICAgfSkgOiBlLmV2ZW50ID09PSBcImZyYW1lX2FkZF9yZWplY3RlZFwiID8gVHQuZW1pdChcImZyYW1lQWRkUmVqZWN0ZWRcIiwgeyByZWFzb246IGUucmVhc29uIH0pIDogZS5ldmVudCA9PT0gXCJmcmFtZV9yZW1vdmVkXCIgPyBUdC5lbWl0KFwiZnJhbWVSZW1vdmVkXCIpIDogZS5ldmVudCA9PT0gXCJub3RpZmljYXRpb25zX2VuYWJsZWRcIiA/IFR0LmVtaXQoXCJub3RpZmljYXRpb25zRW5hYmxlZFwiLCB7XG4gICAgICBub3RpZmljYXRpb25EZXRhaWxzOiBlLm5vdGlmaWNhdGlvbkRldGFpbHNcbiAgICB9KSA6IGUuZXZlbnQgPT09IFwibm90aWZpY2F0aW9uc19kaXNhYmxlZFwiID8gVHQuZW1pdChcIm5vdGlmaWNhdGlvbnNEaXNhYmxlZFwiKSA6IGUuZXZlbnQgPT09IFwiYmFja19uYXZpZ2F0aW9uX3RyaWdnZXJlZFwiICYmIFR0LmVtaXQoXCJiYWNrTmF2aWdhdGlvblRyaWdnZXJlZFwiKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBHcCh0KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID4gXCJ1XCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBlID0gKHIpID0+IHQoci5kZXRhaWwpO1xuICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiwgZSksIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImVpcDY5NjM6cmVxdWVzdFByb3ZpZGVyXCIpKSwgKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiwgZSk7XG59XG5mdW5jdGlvbiBZcCgpIHtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBlID0gW107XG4gIGNvbnN0IHIgPSAoKSA9PiBHcCgobykgPT4ge1xuICAgIGUuc29tZSgoeyBpbmZvOiBpIH0pID0+IGkudXVpZCA9PT0gby5pbmZvLnV1aWQpIHx8IChlID0gWy4uLmUsIG9dLCB0LmZvckVhY2goKGkpID0+IGkoZSwgeyBhZGRlZDogW29dIH0pKSk7XG4gIH0pO1xuICBsZXQgbiA9IHIoKTtcbiAgcmV0dXJuIHtcbiAgICBfbGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgIHQuZm9yRWFjaCgobykgPT4gbyhbXSwgeyByZW1vdmVkOiBbLi4uZV0gfSkpLCBlID0gW107XG4gICAgfSxcbiAgICBkZXN0cm95KCkge1xuICAgICAgdGhpcy5jbGVhcigpLCB0LmNsZWFyKCksIG4gPT0gbnVsbCB8fCBuKCk7XG4gICAgfSxcbiAgICBmaW5kUHJvdmlkZXIoeyByZG5zOiBvIH0pIHtcbiAgICAgIHJldHVybiBlLmZpbmQoKGkpID0+IGkuaW5mby5yZG5zID09PSBvKTtcbiAgICB9LFxuICAgIGdldFByb3ZpZGVycygpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH0sXG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLmNsZWFyKCksIG4gPT0gbnVsbCB8fCBuKCksIG4gPSByKCk7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUobywgeyBlbWl0SW1tZWRpYXRlbHk6IGkgfSA9IHt9KSB7XG4gICAgICByZXR1cm4gdC5hZGQobyksIGkgJiYgbyhlLCB7IGFkZGVkOiBlIH0pLCAoKSA9PiB0LmRlbGV0ZShvKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBKcCh0LCBlID0ge30sIHIpIHtcbiAgY29uc3QgbiA9IHtcbiAgICBldmVudF90eXBlOiB0LFxuICAgIGFwaV9rZXk6IFwiMGM0ZmU0NjE3MWI5YmI4ZWNhMmNhNjFlYjcxZjJlMTlcIixcbiAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgIHVzZXJfaWQ6IHIsXG4gICAgLi4uT2JqZWN0LmtleXMoZSkubGVuZ3RoICYmIHtcbiAgICAgIGV2ZW50X3Byb3BlcnRpZXM6IGVcbiAgICB9XG4gIH07XG4gIGZldGNoKFwiaHR0cHM6Ly9hcGkyLmFtcGxpdHVkZS5jb20vMi9odHRwYXBpXCIsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhcGlfa2V5OiBcIjBjNGZlNDYxNzFiOWJiOGVjYTJjYTYxZWI3MWYyZTE5XCIsXG4gICAgICBldmVudHM6IFtuXVxuICAgIH0pXG4gIH0pLmNhdGNoKChvKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcIkFtcGxpdHVkZSB0cmFja2luZyBlcnJvcjpcIiwgbyk7XG4gIH0pO1xufVxuY29uc3QgWHAgPSBhdC5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiBRcCh0ID0gITEpIHtcbiAgY29uc3QgW2UsIHJdID0gcnQoITEpLCBbbiwgb10gPSBydChudWxsKSwgW2ksIGNdID0gcnQoITEpLCBbZiwgdl0gPSBydChudWxsKSwgW3gsIGJdID0gcnQoXCJcIiksIFtTLCBUXSA9IHJ0KHt9KSwgW0MsIFBdID0gcnQoXCJcIiksIEIgPSBfdCgoWiwgUSA9IHt9LCBqKSA9PiB7XG4gICAgdCAmJiBKcChaLCBRLCBqKTtcbiAgfSwgW3RdKSwgUiA9IF90KGFzeW5jIChaKSA9PiB7XG4gICAgYXdhaXQgeXQuaXNJbk1pbmlBcHAoKSA/IGF3YWl0IHl0LmFjdGlvbnMub3BlblVybChaKSA6IHdpbmRvdy5vcGVuKFosIFwiX2JsYW5rXCIpO1xuICB9LCBbeXRdKSwgeiA9IF90KGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB5dC5pc0luTWluaUFwcCgpID8gYXdhaXQgeXQuYWN0aW9ucy5jbG9zZSgpIDogd2luZG93LmNsb3NlKCk7XG4gIH0sIFt5dF0pLCBLID0gX3QoYXN5bmMgKFosIFEpID0+IChRICYmIHQgJiYgQihcImNhc3QuY29tcG9zZWRcIiwge1xuICAgIC4uLlMsXG4gICAgY2FzdFRleHQ6IFogPT0gbnVsbCA/IHZvaWQgMCA6IFoudGV4dCxcbiAgICBzb3VyY2U6IFFcbiAgfSwgQyksIHl0LmFjdGlvbnMuY29tcG9zZUNhc3QoWikpLCBbeXQsIHQsIEIsIFMsIENdKTtcbiAgcmV0dXJuIG10KCgpID0+IHtcbiAgICBjb25zdCBaID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIE8sIEw7XG4gICAgICBjb25zdCBRID0gYXdhaXQgeXQuY29udGV4dDtcbiAgICAgIG8oUSksIHIoITApO1xuICAgICAgY29uc3QgaiA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCksIFYgPSBqLmdldChcInV0bV9zb3VyY2VcIiksIGVlID0gai5nZXQoXCJ1dG1fbWVkaXVtXCIpLCBHID0gai5nZXQoXCJ1dG1fY2FtcGFpZ25cIik7XG4gICAgICBpZiAoViA9PT0gXCJuZXluYXJcIiAmJiAoZWUgIT0gbnVsbCAmJiBlZS5zdGFydHNXaXRoKFwic2hhcmUtY2FzdC1cIikpKSB7XG4gICAgICAgIGNvbnN0IEYgPSBlZS5yZXBsYWNlKFwic2hhcmUtY2FzdC1cIiwgXCJcIik7XG4gICAgICAgIChPID0gUSA9PSBudWxsID8gdm9pZCAwIDogUS51c2VyKSAhPSBudWxsICYmIE8uZmlkICYmIEIoXCJjYXN0LnNoYXJlZFwiLCB7XG4gICAgICAgICAgLi4uUyxcbiAgICAgICAgICBzaGFyZWRCeUZpZDogRlxuICAgICAgICB9LCBDKTtcbiAgICAgIH1cbiAgICAgIGlmIChWID09PSBcIm5leW5hclwiICYmIEcgJiYgKChMID0gUSA9PSBudWxsID8gdm9pZCAwIDogUS51c2VyKSAhPSBudWxsICYmIEwuZmlkKSkge1xuICAgICAgICBjb25zdCBGID0gYG5leW5hcl9ub3RpZmljYXRpb25fdHJhY2tlZF8ke0d9YDtcbiAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2UuZ2V0SXRlbShGKSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcyA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkubmV5bmFyLmNvbS92Mi9mYXJjYXN0ZXIvZnJhbWUvbm90aWZpY2F0aW9ucy9vcGVuXCIsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBjYW1wYWlnbl9pZDogRyxcbiAgICAgICAgICAgICAgICBmaWQ6IFEudXNlci5maWQsXG4gICAgICAgICAgICAgICAgYXBwX2ZpZDogUS5jbGllbnQuY2xpZW50RmlkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHMub2sgPyBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShGLCBcInRydWVcIikgOiBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIG1hcmsgbm90aWZpY2F0aW9uIGFzIG9wZW5lZDogXCIsIGF3YWl0IHMudGV4dCgpKTtcbiAgICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbWFya2luZyBub3RpZmljYXRpb24gYXMgb3BlbmVkOiBcIiwgcyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgeXQub24oXCJmcmFtZUFkZGVkXCIsICh7XG4gICAgICAgIG5vdGlmaWNhdGlvbkRldGFpbHM6IEZcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJGcmFtZSBhZGRlZFwiLCBGKSwgYyghMCksIHYoRiA/PyBudWxsKSwgYihcIkZyYW1lIGFkZGVkXCIpLCBCKFwiZnJhbWUuYWRkZWRcIiwgUywgQyk7XG4gICAgICB9KSwgeXQub24oXCJmcmFtZUFkZFJlamVjdGVkXCIsICh7XG4gICAgICAgIHJlYXNvbjogRlxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZyYW1lIGFkZCByZWplY3RlZFwiLCBGKSwgYyghMSksIGIoYEZyYW1lIGFkZCByZWplY3RlZDogJHtGfWApLCBCKFwiZnJhbWUuYWRkLnJlamVjdGVkXCIsIFMsIEMpO1xuICAgICAgfSksIHl0Lm9uKFwiZnJhbWVSZW1vdmVkXCIsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJGcmFtZSByZW1vdmVkXCIpLCBjKCExKSwgYihcIkZyYW1lIHJlbW92ZWRcIiksIEIoXCJmcmFtZS5yZW1vdmVkXCIsIFMsIEMpO1xuICAgICAgfSksIHl0Lm9uKFwibm90aWZpY2F0aW9uc0VuYWJsZWRcIiwgKHtcbiAgICAgICAgbm90aWZpY2F0aW9uRGV0YWlsczogRlxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbnMgZW5hYmxlZFwiLCBGKSwgdihGID8/IG51bGwpLCBiKFwiTm90aWZpY2F0aW9ucyBlbmFibGVkXCIpLCBCKFwibm90aWZpY2F0aW9ucy5lbmFibGVkXCIsIFMsIEMpO1xuICAgICAgfSksIHl0Lm9uKFwibm90aWZpY2F0aW9uc0Rpc2FibGVkXCIsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJOb3RpZmljYXRpb25zIGRpc2FibGVkXCIpLCB2KG51bGwpLCBiKFwiTm90aWZpY2F0aW9ucyBkaXNhYmxlZFwiKSwgQihcIm5vdGlmaWNhdGlvbnMuZGlzYWJsZWRcIiwgUywgQyk7XG4gICAgICB9KSwgeXQub24oXCJwcmltYXJ5QnV0dG9uQ2xpY2tlZFwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJpbWFyeSBidXR0b24gY2xpY2tlZFwiKSwgYihcIlByaW1hcnkgYnV0dG9uIGNsaWNrZWRcIiksIEIoXCJwcmltYXJ5LWJ1dHRvbi5jbGlja2VkXCIsIFMsIEMpO1xuICAgICAgfSksIGNvbnNvbGUubG9nKFwiQ2FsbGluZyByZWFkeVwiKSwgeXQuYWN0aW9ucy5yZWFkeSh7fSksIFlwKCkuc3Vic2NyaWJlKChGKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUFJPVklERVIgREVUQUlMU1wiLCBGKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHl0ICYmICFlKVxuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiQ2FsbGluZyBsb2FkXCIpLCByKCEwKSwgWigpLCAoKSA9PiB7XG4gICAgICAgIHl0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfTtcbiAgfSwgW3l0LCBTLCBDLCBlLCBCXSksIG10KCgpID0+IHtcbiAgICBuICE9IG51bGwgJiYgbi51c2VyICYmIChuICE9IG51bGwgJiYgbi5jbGllbnQpICYmIChUKHtcbiAgICAgIHVzZXJuYW1lOiBuLnVzZXIudXNlcm5hbWUsXG4gICAgICBjbGllbnRGaWQ6IG4uY2xpZW50LmNsaWVudEZpZFxuICAgIH0pLCBQKGAke24udXNlci5maWR9YCksIEIoXCJmcmFtZS5vcGVuZWRcIiwge1xuICAgICAgdXNlcm5hbWU6IG4udXNlci51c2VybmFtZSxcbiAgICAgIGNsaWVudEZpZDogbi5jbGllbnQuY2xpZW50RmlkLFxuICAgICAgbG9jYXRpb246IG4ubG9jYXRpb24sXG4gICAgICBhZGRlZDogbi5jbGllbnQuYWRkZWRcbiAgICB9LCBgJHtuLnVzZXIuZmlkfWApKTtcbiAgfSwgW24sIEJdKSwge1xuICAgIC4uLnl0LFxuICAgIGlzU0RLTG9hZGVkOiBlLFxuICAgIGNvbnRleHQ6IG4sXG4gICAgYWRkZWQ6IGksXG4gICAgbm90aWZpY2F0aW9uRGV0YWlsczogZixcbiAgICBsYXN0RXZlbnQ6IHgsXG4gICAgYWN0aW9uczoge1xuICAgICAgLi4ueXQuYWN0aW9ucyxcbiAgICAgIG9wZW5Vcmw6IFIsXG4gICAgICBjbG9zZTogeixcbiAgICAgIGNvbXBvc2VDYXN0OiBLXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3koe1xuICBjaGlsZHJlbjogdCxcbiAgYW5hbHl0aWNzRW5hYmxlZDogZSA9ICExXG59KSB7XG4gIGNvbnN0IHIgPSBRcChlKTtcbiAgcmV0dXJuIHIuaXNTREtMb2FkZWQgPyAvKiBAX19QVVJFX18gKi8gVS5qc3goWHAuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcixcbiAgICBjaGlsZHJlbjogdFxuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IFwiTG9hZGluZy4uLlwiXG4gIH0pO1xufVxudmFyIFNsID0gLyogQF9fUFVSRV9fICovICgodCkgPT4gKHQuTGlnaHQgPSBcImxpZ2h0XCIsIHQuRGFyayA9IFwiZGFya1wiLCB0KSkoU2wgfHwge30pLCB3ciA9IC8qIEBfX1BVUkVfXyAqLyAoKHQpID0+ICh0LkZBUkNBU1RFUiA9IFwiZmFyY2FzdGVyXCIsIHQuTkVZTkFSID0gXCJuZXluYXJcIiwgdC5XQVJQQ0FTVCA9IFwid2FycGNhc3RcIiwgdCkpKHdyIHx8IHt9KTtcbmZ1bmN0aW9uIF9hKHQsIGUgPSBcIlwiLCB7XG4gIHNlcmlhbGl6ZTogciA9IEpTT04uc3RyaW5naWZ5LFxuICBkZXNlcmlhbGl6ZTogbiA9IEpTT04ucGFyc2Vcbn0gPSB7fSkge1xuICBjb25zdCBbbywgaV0gPSBydCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPiBcInVcIilcbiAgICAgIHJldHVybiBlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKHQpO1xuICAgICAgcmV0dXJuIHYgPyBuKHYpIDogZTtcbiAgICB9IGNhdGNoICh2KSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIHJlYWRpbmcgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgdiksIGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtvLCAodikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB4ID0gdiBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gdihvKSA6IHY7XG4gICAgICBpKHgpLCB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHQsIHIoeCkpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3cml0aW5nIHRvIGxvY2FsU3RvcmFnZVwiLCB4KTtcbiAgICB9XG4gIH0sICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHQpLCBpKGUpO1xuICAgIH0gY2F0Y2ggKHYpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZW1vdmluZyBmcm9tIGxvY2FsU3RvcmFnZVwiLCB2KTtcbiAgICB9XG4gIH1dO1xufVxudmFyIFpuID0gLyogQF9fUFVSRV9fICovICgodCkgPT4gKHQuTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUiA9IFwibmV5bmFyX2F1dGhlbnRpY2F0ZWRfdXNlclwiLCB0KSkoWm4gfHwge30pO1xuY29uc3QgQWwgPSBKbyh2b2lkIDApLCBlbSA9ICh7XG4gIGNoaWxkcmVuOiB0LFxuICBfc2V0SXNBdXRoZW50aWNhdGVkOiBlLFxuICBfc2V0VXNlcjogcixcbiAgX29uQXV0aFN1Y2Nlc3M6IG4sXG4gIF9vblNpZ25vdXQ6IG9cbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGlzQXV0aGVudGljYXRlZDogaVxuICB9ID0gbHIoKSwgW2MsIGZdID0gcnQoITEpLCBbdiwgeF0gPSBydChudWxsKSwgW2JdID0gX2EoWm4uTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUik7XG4gIG10KCgpID0+IHtcbiAgICBlKGMpO1xuICB9LCBbY10pLCBtdCgoKSA9PiB7XG4gICAgZihpKTtcbiAgfSwgW2ldKSwgbXQoKCkgPT4ge1xuICAgIGIgPyAoeChiKSwgZighMCkpIDogKHgobnVsbCksIGYoITEpKTtcbiAgfSwgW10pLCBtdCgoKSA9PiB7XG4gICAgcih2KTtcbiAgfSwgW3ZdKTtcbiAgY29uc3QgUyA9IChQKSA9PiB7XG4gICAgbiAmJiBuKFApO1xuICB9LCBUID0gKFApID0+IHtcbiAgICBvICYmIG8oUCk7XG4gIH0sIEMgPSBUcigoKSA9PiAoe1xuICAgIGlzQXV0aGVudGljYXRlZDogYyxcbiAgICB1c2VyOiB2LFxuICAgIHNldElzQXV0aGVudGljYXRlZDogZixcbiAgICBzZXRVc2VyOiB4LFxuICAgIG9uQXV0aFN1Y2Nlc3M6IFMsXG4gICAgb25TaWdub3V0OiBUXG4gIH0pLCBbYywgdl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFUuanN4KEFsLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IEMsXG4gICAgY2hpbGRyZW46IHRcbiAgfSk7XG59LCBrbCA9ICgpID0+IHtcbiAgY29uc3QgdCA9IFhvKEFsKTtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZUF1dGggbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEF1dGhDb250ZXh0UHJvdmlkZXJcIik7XG4gIHJldHVybiB0O1xufSwgdG0gPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ0YmFvbTdjXCJdXG59KSwgcm0gPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ0MWZmNDR6aVwiXSxcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiXG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwidDFmZjQ0emktMVwiXG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgdHlwZTogXCJlcnJvclwiXG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwidDFmZjQ0emktMlwiXG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgdHlwZTogXCJ3YXJuaW5nXCJcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJ0MWZmNDR6aS0zXCJcbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICB0eXBlOiBcImluZm9cIlxuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBcInQxZmY0NHppLTRcIlxuICB9XVxufSk7XG52YXIgSWwgPSAvKiBAX19QVVJFX18gKi8gKCh0KSA9PiAodC5TdWNjZXNzID0gXCJzdWNjZXNzXCIsIHQuRXJyb3IgPSBcImVycm9yXCIsIHQuV2FybmluZyA9IFwid2FybmluZ1wiLCB0LkluZm8gPSBcImluZm9cIiwgdCkpKElsIHx8IHt9KTtcbmNvbnN0IEJsID0gSm8odm9pZCAwKSwgb3kgPSAoe1xuICBjaGlsZHJlbjogdCxcbiAgc2V0dGluZ3M6IHtcbiAgICBjbGllbnRJZDogZSxcbiAgICBkZWZhdWx0VGhlbWU6IHIgPSBTbC5MaWdodCxcbiAgICBldmVudHNDYWxsYmFja3M6IG5cbiAgfVxufSkgPT4ge1xuICBjb25zdCBbb10gPSBydChlKSwgW2ksIGNdID0gcnQoITEpLCBbZiwgdl0gPSBydChyKSwgW3gsIGJdID0gcnQoW10pLCBbUywgVF0gPSBydChudWxsKSwgQyA9IChaLCBRKSA9PiB7XG4gICAgY29uc3QgaiA9IHtcbiAgICAgIHR5cGU6IFosXG4gICAgICBtZXNzYWdlOiBRXG4gICAgfTtcbiAgICBiKChWKSA9PiBbLi4uViwgal0pLCBzZXRUaW1lb3V0KCgpID0+IFAoaiksIDVlMyk7XG4gIH0sIFAgPSAoWikgPT4ge1xuICAgIGIoKFEpID0+IFEuZmlsdGVyKChqKSA9PiBqICE9PSBaKSk7XG4gIH07XG4gIG10KCgpID0+IHtcbiAgICBjb25zdCBaID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpyb290XCIpO1xuICAgIFogJiYgKGYgPT09IFwibGlnaHRcIiA/IChaLmNsYXNzTGlzdC5hZGQoXCJ0aGVtZS1saWdodFwiKSwgWi5jbGFzc0xpc3QucmVtb3ZlKFwidGhlbWUtZGFya1wiKSkgOiBmID09PSBcImRhcmtcIiAmJiAoWi5jbGFzc0xpc3QuYWRkKFwidGhlbWUtZGFya1wiKSwgWi5jbGFzc0xpc3QucmVtb3ZlKFwidGhlbWUtbGlnaHRcIikpKTtcbiAgfSwgW2ZdKTtcbiAgY29uc3QgQiA9IChaKSA9PiB7XG4gICAgYyhaKTtcbiAgfSwgUiA9IChaKSA9PiB7XG4gICAgVChaKTtcbiAgfSwgeiA9ICgpID0+IHtcbiAgICBpZiAoUykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduZXJfdXVpZDogWixcbiAgICAgICAgLi4uUVxuICAgICAgfSA9IFM7XG4gICAgICBUKG51bGwpLCBjKCExKSwgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oWm4uTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUiksIG4gIT0gbnVsbCAmJiBuLm9uU2lnbm91dCAmJiBuLm9uU2lnbm91dChRKTtcbiAgICB9XG4gIH0sIEsgPSBUcigoKSA9PiAoe1xuICAgIGNsaWVudF9pZDogbyxcbiAgICB0aGVtZTogZixcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IGksXG4gICAgdXNlcjogUyxcbiAgICBzZXRUaGVtZTogdixcbiAgICBzaG93VG9hc3Q6IEMsXG4gICAgbG9nb3V0VXNlcjogelxuICB9KSwgW28sIGYsIGksIFMsIHYsIEMsIHpdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChCbC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBLLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKGVtLCB7XG4gICAgICBfc2V0SXNBdXRoZW50aWNhdGVkOiBCLFxuICAgICAgX3NldFVzZXI6IFIsXG4gICAgICBfb25BdXRoU3VjY2VzczogbiA9PSBudWxsID8gdm9pZCAwIDogbi5vbkF1dGhTdWNjZXNzLFxuICAgICAgX29uU2lnbm91dDogbiA9PSBudWxsID8gdm9pZCAwIDogbi5vblNpZ25vdXQsXG4gICAgICBjaGlsZHJlbjogW3QsIC8qIEBfX1BVUkVfXyAqLyBVLmpzeCh0bSwge1xuICAgICAgICBjaGlsZHJlbjogeC5tYXAoKFosIFEpID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChybSwge1xuICAgICAgICAgIHR5cGU6IFoudHlwZSxcbiAgICAgICAgICBjaGlsZHJlbjogWi5tZXNzYWdlXG4gICAgICAgIH0sIFEpKVxuICAgICAgfSldXG4gICAgfSlcbiAgfSk7XG59LCBsciA9ICgpID0+IHtcbiAgY29uc3QgdCA9IFhvKEJsKTtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZU5leW5hckNvbnRleHQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIE5leW5hckNvbnRleHRQcm92aWRlclwiKTtcbiAgcmV0dXJuIHQ7XG59LCBubSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoXCJzdmdcIiwge1xuICB3aWR0aDogXCIxOFwiLFxuICBoZWlnaHQ6IFwiMTdcIixcbiAgdmlld0JveDogXCIwIDAgMTggMTdcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTMuNzIyMiAwSDQuMjc3NzhDMi4xOTEzNyAwIDAuNSAxLjY5MTM3IDAuNSAzLjc3Nzc4VjEzLjIyMjJDMC41IDE1LjMwODYgMi4xOTEzNyAxNyA0LjI3Nzc4IDE3SDEzLjcyMjJDMTUuODA4NiAxNyAxNy41IDE1LjMwODYgMTcuNSAxMy4yMjIyVjMuNzc3NzhDMTcuNSAxLjY5MTM3IDE1LjgwODYgMCAxMy43MjIyIDBaXCIsXG4gICAgZmlsbDogXCIjODU1RENEXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTQuODgyODEgMi42NDQ1M0gxMy4xMTg0VjE0LjM1NTZIMTEuOTA5NVY4Ljk5MTJIMTEuODk3NkMxMS43NjQgNy41MDg1OSAxMC41MTggNi4zNDY3NSA5LjAwMDU5IDYuMzQ2NzVDNy40ODMyIDYuMzQ2NzUgNi4yMzcxNyA3LjUwODU5IDYuMTAzNTYgOC45OTEySDYuMDkxN1YxNC4zNTU2SDQuODgyODFWMi42NDQ1M1pcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTIuNjkxNDEgNC4zMDY2NEwzLjE4MjUyIDUuOTY4ODZIMy41OTgwN1YxMi42OTMzQzMuMzg5NDMgMTIuNjkzMyAzLjIyMDMgMTIuODYyNSAzLjIyMDMgMTMuMDcxMVYxMy41MjQ0SDMuMTQ0NzRDMi45MzYxIDEzLjUyNDQgMi43NjY5NiAxMy42OTM2IDIuNzY2OTYgMTMuOTAyMlYxNC4zNTU1SDYuOTk4MDdWMTMuOTAyMkM2Ljk5ODA3IDEzLjY5MzYgNi44Mjg5MyAxMy41MjQ0IDYuNjIwMyAxMy41MjQ0SDYuNTQ0NzRWMTMuMDcxMUM2LjU0NDc0IDEyLjg2MjUgNi4zNzU2IDEyLjY5MzMgNi4xNjY5NiAxMi42OTMzSDUuNzEzNjNWNC4zMDY2NEgyLjY5MTQxWlwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTEuOTg1NCAxMi42OTMzQzExLjc3NjggMTIuNjkzMyAxMS42MDc2IDEyLjg2MjUgMTEuNjA3NiAxMy4wNzExVjEzLjUyNDRIMTEuNTMyMUMxMS4zMjM1IDEzLjUyNDQgMTEuMTU0MyAxMy42OTM2IDExLjE1NDMgMTMuOTAyMlYxNC4zNTU1SDE1LjM4NTRWMTMuOTAyMkMxNS4zODU0IDEzLjY5MzYgMTUuMjE2MiAxMy41MjQ0IDE1LjAwNzYgMTMuNTI0NEgxNC45MzIxVjEzLjA3MTFDMTQuOTMyMSAxMi44NjI1IDE0Ljc2MjkgMTIuNjkzMyAxNC41NTQzIDEyLjY5MzNWNS45Njg4NkgxNC45Njk5TDE1LjQ2MSA0LjMwNjY0SDEyLjQzODdWMTIuNjkzM0gxMS45ODU0WlwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KV1cbn0pLCBfdSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoXCJzdmdcIiwge1xuICB3aWR0aDogXCIzMlwiLFxuICBoZWlnaHQ6IFwiMTdcIixcbiAgdmlld0JveDogXCIwIDAgNTAgMjhcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0zOC4zNzQ0IDEzLjczMTFDMzguMzc0NCAxNi4xMjA5IDM3Ljc2MzkgMTguMzY4IDM2LjY5MDQgMjAuMzI1MkMzMi41Njg1IDE5Ljg1MjUgMjcuODQ3IDE4Ljk1MDMgMjIuODk5OSAxNy42MjQ3QzIwLjQwNTggMTYuOTU2NCAxOC4wMTUxIDE2LjIyMzYgMTUuNzY5NyAxNS40NDk1TDE1Ljc2OTMgMTUuNDQ4NkMxNS43NTc5IDE1LjQ0NSAxNS43NDY1IDE1LjQ0MTMgMTUuNzM1MSAxNS40Mzc2QzE1LjY0NDggMTUuNDA2NCAxNS41NTQ3IDE1LjM3NTIgMTUuNDY0OSAxNS4zNDM5QzEyLjg5NzggMTQuMzk5IDExLjIzNTYgMTIuMjA1NiAxMS40MTY4IDEwLjAzMTVMMTEuNDQ4MiAxMC4wMzk5TDExLjQyMTUgMTAuMDEzM0MxMy4wNDI3IDQuMjM2MTIgMTguMzQ4MyAwIDI0LjY0MzQgMEMzMi4yMjY4IDAgMzguMzc0NCA2LjE0NzYyIDM4LjM3NDQgMTMuNzMxMVpcIixcbiAgICBmaWxsOiBcImJsYWNrXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNMTEuMzgwNCAxNy4yOTg3QzEyLjQ4ODIgMTYuNTMxMyAxMy45NjU4IDE2LjE4MDQgMTUuNTAwMiAxNi4zOTUzQzE3Ljc3MzEgMTcuMTU2IDIwLjE2ODIgMTcuODc4MiAyMi42NTM1IDE4LjU0NDFDMjcuMzk3IDE5LjgxNTEgMzEuOTU4NCAyMC43NDQ0IDM2LjA4MzMgMjEuMzI3NUMzMy42MjMgMjUuMDI1MiAyOS40MTc3IDI3LjQ2MTkgMjQuNjQzNCAyNy40NjE5QzE4LjI5NCAyNy40NjE5IDEyLjk1MTEgMjMuMTUyNCAxMS4zODA0IDE3LjI5ODdaXCIsXG4gICAgZmlsbDogXCJibGFja1wiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTQzLjA5MTcgMTMuNDQ1OEM0MS42NDYxIDEyLjY2NDggMzkuOTc1NiAxMS44NzU5IDM4LjEyMzMgMTEuMTAyOUMzOC4wMzYzIDEwLjY1NDQgMzcuOTI3NSAxMC4yMTM2IDM3Ljc5ODEgOS43ODE3NEMzOS45ODA2IDEwLjY2NDggNDEuOTQwMyAxMS41NzUyIDQzLjYxMzkgMTIuNDc5NEM0NS43MDA3IDEzLjYwNjkgNDcuMzcwMyAxNC43Mzk0IDQ4LjQ3MTQgMTUuODE2QzQ5LjUzNTYgMTYuODU2NiA1MC4yMjk1IDE4LjAwNjMgNDkuOTMgMTkuMTI0MUM0OS42MzA0IDIwLjI0MTkgNDguNDU0NyAyMC44OTA2IDQ3LjAxMjggMjEuMjU5N0M0NS41MjA5IDIxLjY0MTUgNDMuNTA4NyAyMS43ODc1IDQxLjEzNzcgMjEuNzIwNkMzOS42MDQ2IDIxLjY3NzMgMzcuOTA4MiAyMS41NDQ0IDM2LjA4NjQgMjEuMzIzNEMzNi4zMDg2IDIwLjk4OTEgMzYuNTE2NSAyMC42NDQ2IDM2LjcwOTQgMjAuMjkwNkMzOC4zMTM0IDIwLjQ3MzMgMzkuODA5MSAyMC41ODQxIDQxLjE2ODcgMjAuNjIyNUM0My40OTQ2IDIwLjY4ODIgNDUuMzkwOCAyMC41NDA5IDQ2Ljc0MDQgMjAuMTk1NUM0OC4xNCAxOS44MzczIDQ4LjczODkgMTkuMzI0OSA0OC44Njg5IDE4LjgzOThDNDguOTk4OSAxOC4zNTQ3IDQ4LjczNjQgMTcuNjExNSA0Ny43MDM0IDE2LjYwMTVDNDYuNzA3MyAxNS42Mjc1IDQ1LjEzODggMTQuNTUxOSA0My4wOTE3IDEzLjQ0NThaTTguODYyMjkgMy4xNjc3MkMxMC43NTgzIDMuMjIxMjggMTIuOTAzOCAzLjQxMTc3IDE1LjIyNzggMy43MzY2MUMxNC44OTc0IDQuMDQ4MDMgMTQuNTgyNCA0LjM3NTY2IDE0LjI4NDEgNC43MTgyMkMxMi4zMDE2IDQuNDYzMTQgMTAuNDY3OCA0LjMxMiA4LjgzMTI3IDQuMjY1NzdDNi41MDU0MSA0LjIwMDA2IDQuNjA5MiA0LjM0NzM3IDMuMjU5NTggNC42OTI3OUMxLjg2MDAxIDUuMDUwOTkgMS4yNjEwNyA1LjU2MzQyIDEuMTMxMDkgNi4wNDg0OUMxLjAwMTEyIDYuNTMzNTYgMS4yNjM2IDcuMjc2ODEgMi4yOTY1NyA4LjI4NjhDMy4yOTI2NyA5LjI2MDc1IDQuODYxMTggMTAuMzM2NCA2LjkwODI4IDExLjQ0MjVDNi45NDE4MSAxMS40NjA2IDYuOTc1NDYgMTEuNDc4NyA3LjAwOTIzIDExLjQ5NjhDNi44NDI1MSAxMS41OTM4IDYuNzI1NzQgMTEuNzE2MSA2LjY2MzUzIDExLjg2NDVDNi41Nzc5MSAxMi4wNjg4IDYuNjAwMTMgMTIuMzEyMSA2LjcyMDEzIDEyLjU4NzRDNi42MDc1NyAxMi41Mjc5IDYuNDk2MjMgMTIuNDY4NCA2LjM4NjEyIDEyLjQwODlDNC4yOTkyNiAxMS4yODE0IDIuNjI5NzEgMTAuMTQ4OSAxLjUyODYgOS4wNzIyM0MwLjQ2NDM2NyA4LjAzMTY2IC0wLjIyOTQ4NSA2Ljg4MiAwLjA3MDAzNTQgNS43NjQxOEMwLjM2OTU1NiA0LjY0NjM1IDEuNTQ1MjggMy45OTc2NCAyLjk4NzIyIDMuNjI4NkM0LjQ3OTExIDMuMjQ2NzcgNi40OTEyNiAzLjEwMDc0IDguODYyMjkgMy4xNjc3MlpcIixcbiAgICBmaWxsOiBcImJsYWNrXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImVsbGlwc2VcIiwge1xuICAgIGN4OiBcIjUuOTQ4NjZcIixcbiAgICBjeTogXCIxMS41MzA5XCIsXG4gICAgcng6IFwiMy43NjAwOVwiLFxuICAgIHJ5OiBcIjAuNTc1ODMyXCIsXG4gICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgyOS4yODI0IDUuOTQ4NjYgMTEuNTMwOSlcIixcbiAgICBmaWxsOiBcImJsYWNrXCJcbiAgfSldXG59KSwgaW0gPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFwic3ZnXCIsIHtcbiAgd2lkdGg6IFwiMTdcIixcbiAgaGVpZ2h0OiBcIjE3XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDE3IDE3XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcIm1hc2tcIiwge1xuICAgIGlkOiBcIm1hc2swXzg3NV80OFwiLFxuICAgIG1hc2tVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLFxuICAgIHg6IFwiMFwiLFxuICAgIHk6IFwiMFwiLFxuICAgIHdpZHRoOiBcIjE3XCIsXG4gICAgaGVpZ2h0OiBcIjE3XCIsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTYuOTk0NyAwSDBWMTYuOTk0N0gxNi45OTQ3VjBaXCIsXG4gICAgICBmaWxsOiBcIndoaXRlXCJcbiAgICB9KVxuICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4cyhcImdcIiwge1xuICAgIG1hc2s6IFwidXJsKCNtYXNrMF84NzVfNDgpXCIsXG4gICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEyLjc4NzEgMTYuOTk0N0g0LjIwNzY1QzEuODg3NTUgMTYuOTk0NyAwIDE1LjEwNzMgMCAxMi43ODcxVjQuMjA3NzFDMCAxLjg4NzU2IDEuODg3NTUgMCA0LjIwNzY1IDBIMTIuNzg3MUMxNS4xMDcyIDAgMTYuOTk0NyAxLjg4NzU2IDE2Ljk5NDcgNC4yMDc3MVYxMi43ODcxQzE2Ljk5NDcgMTUuMTA3MyAxNS4xMDcyIDE2Ljk5NDcgMTIuNzg3MSAxNi45OTQ3WlwiLFxuICAgICAgZmlsbDogXCIjNDcyQTkxXCJcbiAgICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0xMS4xNTIzIDUuMzc4OTFMMTAuMzE0MyA4LjUyNjAxTDkuNDczNjQgNS4zNzg5MUg3LjUzODkzTDYuNjkwMTcgOC41NDkxOUw1Ljg0NDE5IDUuMzc4OTFIMy42NDA2Mkw1LjY4ODIzIDEyLjMzNzFINy41ODkzMUw4LjQ5ODM1IDkuMTA1OTlMOS40MDczNiAxMi4zMzcxSDExLjMxMjVMMTMuMzU1NyA1LjM3ODkxSDExLjE1MjNaXCIsXG4gICAgICBmaWxsOiBcIndoaXRlXCJcbiAgICB9KV1cbiAgfSldXG59KTtcbnZhciBzbSA9IHt9O1xuY29uc3QgUG8gPSAvKiBAX19QVVJFX18gKi8gdWUoXCJpbWdcIikoe1xuICBjbGFzc2VzOiBbXCJpcHBmc3FyXCJdXG59KSwgb20gPSAvKiBAX19QVVJFX18gKi8gdWUoXCJidXR0b25cIikoe1xuICBjbGFzc2VzOiBbXCJiMXl6c3NqYlwiXVxufSksIGFtID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wibTF4bjhiMmVcIl1cbn0pLCB1bSA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImJ1dHRvblwiKSh7XG4gIGNsYXNzZXM6IFtcIm13dWlxeWdcIl1cbn0pLCBjbSA9ICh0LCBlKSA9PiB7XG4gIGlmIChlKVxuICAgIHJldHVybiBlO1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIHdyLkZBUkNBU1RFUjpcbiAgICAgIHJldHVybiBcIlNpZ24gaW4gd2l0aCBGYXJjYXN0ZXJcIjtcbiAgICBjYXNlIHdyLk5FWU5BUjpcbiAgICAgIHJldHVybiBcIlNpZ24gaW4gd2l0aCBOZXluYXJcIjtcbiAgICBjYXNlIHdyLldBUlBDQVNUOlxuICAgICAgcmV0dXJuIFwiU2lnbiBpbiB3aXRoIFdhcnBjYXN0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlNpZ24gaW4gd2l0aCBOZXluYXJcIjtcbiAgfVxufSwgbG0gPSAodCwgZSwgcikgPT4ge1xuICBpZiAoZSlcbiAgICByZXR1cm4gZTtcbiAgaWYgKHIpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChQbywge1xuICAgICAgc3JjOiByLFxuICAgICAgYWx0OiBcIkN1c3RvbSBsb2dvXCJcbiAgICB9KTtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSB3ci5GQVJDQVNURVI6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFUuanN4KG5tLCB7fSk7XG4gICAgY2FzZSB3ci5ORVlOQVI6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFUuanN4KF91LCB7fSk7XG4gICAgY2FzZSB3ci5XQVJQQ0FTVDpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gVS5qc3goaW0sIHt9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChfdSwge30pO1xuICB9XG59LCBmbSA9ICh7XG4gIGNoaWxkcmVuOiB0LFxuICBsYWJlbDogZSxcbiAgdmFyaWFudDogciA9IHdyLk5FWU5BUixcbiAgaWNvbjogbixcbiAgY3VzdG9tTG9nb1VybDogbyxcbiAgbW9kYWxTdHlsZTogaSA9IHt9LFxuICBtb2RhbEJ1dHRvblN0eWxlOiBjID0ge30sXG4gIC4uLmZcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGNsaWVudF9pZDogdixcbiAgICB1c2VyOiB4LFxuICAgIGlzQXV0aGVudGljYXRlZDogYlxuICB9ID0gbHIoKSwge1xuICAgIHNldElzQXV0aGVudGljYXRlZDogUyxcbiAgICBzZXRVc2VyOiBULFxuICAgIG9uQXV0aFN1Y2Nlc3M6IEMsXG4gICAgb25TaWdub3V0OiBQXG4gIH0gPSBrbCgpLCBbQiwgUiwgel0gPSBfYShabi5ORVlOQVJfQVVUSEVOVElDQVRFRF9VU0VSKSwgW0ssIFpdID0gcnQoITEpLCBRID0gUnQobnVsbCksIGogPSBgJHtzbS5ORVlOQVJfTE9HSU5fVVJMID8/IFwiaHR0cHM6Ly9hcHAubmV5bmFyLmNvbS9sb2dpblwifT9jbGllbnRfaWQ9JHt2fWAsIFYgPSBuZXcgVVJMKGopLm9yaWdpbiwgZWUgPSBSdChudWxsKSwgRyA9IF90KGFzeW5jIChzKSA9PiB7XG4gICAgdmFyIHU7XG4gICAgaWYgKHMub3JpZ2luID09PSBWICYmIHMuZGF0YSAmJiBzLmRhdGEuaXNfYXV0aGVudGljYXRlZCkge1xuICAgICAgUyghMCksICh1ID0gUS5jdXJyZW50KSA9PSBudWxsIHx8IHUuY2xvc2UoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIEcpO1xuICAgICAgY29uc3QgaCA9IHtcbiAgICAgICAgc2lnbmVyX3V1aWQ6IHMuZGF0YS5zaWduZXJfdXVpZCxcbiAgICAgICAgLi4ucy5kYXRhLnVzZXJcbiAgICAgIH07XG4gICAgICBSKGgpLCBUKGgpLCBDKHtcbiAgICAgICAgdXNlcjogaFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbdiwgU10pLCBOID0gX3QoKCkgPT4ge1xuICAgIGNvbnN0IGggPSB3aW5kb3cuc2NyZWVuLndpZHRoIC8gMiAtIDMwMCwgdyA9IGB3aWR0aD02MDAsaGVpZ2h0PTcwMCx0b3A9JHt3aW5kb3cuc2NyZWVuLmhlaWdodCAvIDIgLSA3MDAgLyAyfSxsZWZ0PSR7aH1gO1xuICAgIGlmIChRLmN1cnJlbnQgPSB3aW5kb3cub3BlbihqLCBcIl9ibGFua1wiLCB3KSwgIVEuY3VycmVudCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBvcGVuIHRoZSBhdXRoZW50aWNhdGlvbiB3aW5kb3cuIFBsZWFzZSBjaGVjayB5b3VyIHBvcC11cCBibG9ja2VyIHNldHRpbmdzLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIEcsICExKTtcbiAgfSwgW3YsIEddKSwgTyA9ICgpID0+IHtcbiAgICBpZiAoeCkge1xuICAgICAgY29uc3QgcyA9IHg7XG4gICAgICB6KCksIFMoITEpLCBGKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpZ25lcl91dWlkOiB1LFxuICAgICAgICAuLi5oXG4gICAgICB9ID0gcztcbiAgICAgIFAoaCk7XG4gICAgfVxuICB9LCBMID0gKCkgPT4gWighMCksIEYgPSAoKSA9PiBaKCExKTtcbiAgbXQoKCkgPT4gKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBHKTtcbiAgfSwgW0ddKTtcbiAgY29uc3QgZCA9IF90KChzKSA9PiB7XG4gICAgZWUuY3VycmVudCAmJiAhZWUuY3VycmVudC5jb250YWlucyhzLnRhcmdldCkgJiYgRigpO1xuICB9LCBbXSk7XG4gIHJldHVybiBtdCgoKSA9PiAoSyA/IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZCkgOiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGQpLCAoKSA9PiB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBkKTtcbiAgfSksIFtLLCBkXSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoVS5GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbSyAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKGFtLCB7XG4gICAgICBzdHlsZTogaSxcbiAgICAgIHJlZjogZWUsXG4gICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChQbywge1xuICAgICAgICBzcmM6IHggPT0gbnVsbCA/IHZvaWQgMCA6IHgucGZwX3VybCxcbiAgICAgICAgYWx0OiB4ID09IG51bGwgPyB2b2lkIDAgOiB4LnVzZXJuYW1lXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4cyhcInNwYW5cIiwge1xuICAgICAgICBjaGlsZHJlbjogW1wiQFwiLCB4ID09IG51bGwgPyB2b2lkIDAgOiB4LnVzZXJuYW1lXVxuICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeCh1bSwge1xuICAgICAgICBzdHlsZTogYyxcbiAgICAgICAgb25DbGljazogTyxcbiAgICAgICAgY2hpbGRyZW46IFwiU2lnbiBvdXRcIlxuICAgICAgfSldXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChvbSwge1xuICAgICAgb25DbGljazogYiA/IEwgOiBOLFxuICAgICAgLi4uZixcbiAgICAgIGNoaWxkcmVuOiBiID8gLyogQF9fUFVSRV9fICovIFUuanN4cyhVLkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4KFBvLCB7XG4gICAgICAgICAgc3JjOiB4ID09IG51bGwgPyB2b2lkIDAgOiB4LnBmcF91cmwsXG4gICAgICAgICAgYWx0OiBgJHt4ID09IG51bGwgPyB2b2lkIDAgOiB4LnVzZXJuYW1lfSBwcm9maWxlIHBpY3R1cmVgXG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFwic3BhblwiLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IFwiMTBweFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogW1wiQFwiLCB4ID09IG51bGwgPyB2b2lkIDAgOiB4LnVzZXJuYW1lXVxuICAgICAgICB9KV1cbiAgICAgIH0pIDogLyogQF9fUFVSRV9fICovIFUuanN4cyhVLkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbbG0ociwgbiwgbyksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInNwYW5cIiwge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiBcIjVweFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogY20ociwgZSlcbiAgICAgICAgfSldXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn0sIEJzID0gLyogQF9fUFVSRV9fICovIHVlKFwiaW1nXCIpKHtcbiAgY2xhc3NlczogW1wiYTExcHQweHBcIl0sXG4gIHZhcnM6IHtcbiAgICBcImExMXB0MHhwLTBcIjogWyh0LCBlID0gcnIpID0+IHQud2lkdGggfHwgXCI0NXB4XCIsICExXSxcbiAgICBcImExMXB0MHhwLTFcIjogWyh0LCBlID0gcnIpID0+IHQud2lkdGggfHwgXCI0NXB4XCIsICExXVxuICB9XG59KSwgRXUgPSBcImh0dHBzOi8vZmFyY2FzdGVyLnh5elwiLCBSbCA9IC8oXnxcXHMpXFwvXFx3Ky9nLCBUbCA9IC9AXFx3KyhcXC5ldGgpPy9nLCBMbCA9IC8oKGh0dHBzPzpcXC9cXC8pPyhbYS16QS1aMC05Li1dK1xcLlthLXpBLVpdezIsfSkoXFwvW15cXHNdKik/KS9nLCBNdSA9IG5ldyBSZWdFeHAoYCgke1JsLnNvdXJjZX0pfCgke1RsLnNvdXJjZX0pfCgke0xsLnNvdXJjZX0pYCwgXCJnXCIpLCBobSA9ICh0KSA9PiBSbC50ZXN0KHQpID8gYCR7RXV9L34vY2hhbm5lbCR7dC50cmltKCl9YCA6IFRsLnRlc3QodCkgPyBgJHtFdX0vJHt0LnN1YnN0cmluZygxKX1gIDogTGwudGVzdCh0KSA/IHQuc3RhcnRzV2l0aChcImh0dHBcIikgPyB0IDogYGh0dHA6Ly8ke3R9YCA6IFwiXCIsIGRtID0gLyogQF9fUFVSRV9fICovIHVlKFwiYVwiKSh7XG4gIGNsYXNzZXM6IFtcInM0eHltcXNcIl1cbn0pLCBwbSA9ICh0KSA9PiB0LmZpbHRlcigoZSkgPT4gZS51cmwpLm1hcCgoZSkgPT4gZS51cmwpLCBtbSA9ICh0LCBlKSA9PiB7XG4gIGlmICghdCkgcmV0dXJuIFtdO1xuICBjb25zdCByID0gcG0oZSksIG4gPSBbXTtcbiAgbGV0IG8gPSAwLCBpO1xuICBmb3IgKDsgKGkgPSBNdS5leGVjKHQpKSAhPT0gbnVsbDsgKSB7XG4gICAgY29uc3QgYyA9IGkuaW5kZXg7XG4gICAgbyA8IGMgJiYgbi5wdXNoKHQuc2xpY2UobywgYykpO1xuICAgIGNvbnN0IGYgPSBpWzBdLnRyaW0oKTtcbiAgICBpZiAoci5pbmNsdWRlcyhmKSlcbiAgICAgIG4ucHVzaChmKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHYgPSBobShmKTtcbiAgICAgIG4ucHVzaCgvKiBAX19QVVJFX18gKi8gVS5qc3goZG0sIHtcbiAgICAgICAgaHJlZjogdixcbiAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICBjaGlsZHJlbjogZlxuICAgICAgfSwgYykpO1xuICAgIH1cbiAgICBvID0gTXUubGFzdEluZGV4O1xuICB9XG4gIHJldHVybiBvIDwgdC5sZW5ndGggJiYgbi5wdXNoKHQuc2xpY2UobykpLCBuO1xufSwgVnQgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJiZTg3bTBtXCJdLFxuICB2YXJzOiB7XG4gICAgXCJiZTg3bTBtLTBcIjogWyh0LCBlID0gcnIpID0+IHQuYWxpZ25JdGVtcyB8fCBcImZsZXgtc3RhcnRcIiwgITFdLFxuICAgIFwiYmU4N20wbS0xXCI6IFsodCwgZSA9IHJyKSA9PiB0Lmp1c3RpZnlDb250ZW50IHx8IFwiZmxleC1zdGFydFwiLCAhMV0sXG4gICAgXCJiZTg3bTBtLTJcIjogWyh0LCBlID0gcnIpID0+IHQuZmxleEdyb3cgfHwgXCJpbml0aWFsXCIsICEwXSxcbiAgICBcImJlODdtMG0tM1wiOiBbKHQsIGUgPSBycikgPT4gdC5mbGV4U2hyaW5rIHx8IFwiaW5pdGlhbFwiLCAhMF0sXG4gICAgXCJiZTg3bTBtLTRcIjogWyh0LCBlID0gcnIpID0+IHQuc3BhY2luZyA/PyB0LnNwYWNpbmdWZXJ0aWNhbCA/PyB0LnNwYWNpbmdUb3AgPz8gXCIwcHhcIiwgITFdLFxuICAgIFwiYmU4N20wbS01XCI6IFsodCwgZSA9IHJyKSA9PiB0LnNwYWNpbmcgPz8gdC5zcGFjaW5nSG9yaXpvbnRhbCA/PyB0LnNwYWNpbmdSaWdodCA/PyBcIjBweFwiLCAhMV0sXG4gICAgXCJiZTg3bTBtLTZcIjogWyh0LCBlID0gcnIpID0+IHQuc3BhY2luZyA/PyB0LnNwYWNpbmdWZXJ0aWNhbCA/PyB0LnNwYWNpbmdCb3R0b20gPz8gXCIwcHhcIiwgITFdLFxuICAgIFwiYmU4N20wbS03XCI6IFsodCwgZSA9IHJyKSA9PiB0LnNwYWNpbmcgPz8gdC5zcGFjaW5nSG9yaXpvbnRhbCA/PyB0LnNwYWNpbmdMZWZ0ID8/IFwiMHB4XCIsICExXVxuICB9XG59KSwgZ20gPSAoKSA9PiBWdCwgT2wgPSAvKiBAX19QVVJFX18gKi8gdWUoZ20oKSkoe1xuICBjbGFzc2VzOiBbXCJ2MWxyOGN2N1wiXVxufSksIHltID0gKCkgPT4gVnQsIEh0ID0gLyogQF9fUFVSRV9fICovIHVlKHltKCkpKHtcbiAgY2xhc3NlczogW1wiaGExZHZwaVwiXVxufSksIGduID0gXCJodHRwczovL3Nkay1hcGkubmV5bmFyLmNvbVwiLCB2bSA9IFwiaHR0cHM6Ly9hcGkuYWxsb3JpZ2lucy53aW4vZ2V0XCIsIExpID0gXCJodHRwczovL2kuaW1ndXIuY29tL2d4SDhhenkucG5nXCI7XG52YXIgd20gPSB7XG4gIFNES19WRVJTSU9OOiAnXCIxLjIuM1wiJ1xufTtcbmNvbnN0IHhtID0gd20uU0RLX1ZFUlNJT04sIHluID0gYXN5bmMgKHQsIGUgPSB7fSkgPT4gKGUuaGVhZGVycyA9IHtcbiAgLi4uZS5oZWFkZXJzLFxuICBcIngtc2RrXCI6IFwicmVhY3RcIixcbiAgXCJ4LXNkay12ZXJzaW9uXCI6IHhtXG59LCBmZXRjaCh0LCBlKSk7XG5hc3luYyBmdW5jdGlvbiBibSh7XG4gIHR5cGU6IHQsXG4gIGlkZW50aWZpZXI6IGUsXG4gIHZpZXdlckZpZDogcixcbiAgY2xpZW50X2lkOiBuXG59KSB7XG4gIHRyeSB7XG4gICAgbGV0IG8gPSBgJHtnbn0vdjIvZmFyY2FzdGVyL2Nhc3Q/dHlwZT0ke3R9JmlkZW50aWZpZXI9JHtlfSR7ciA/IGAmdmlld2VyX2ZpZD0ke3J9YCA6IFwiXCJ9JmNsaWVudF9pZD0ke259YDtcbiAgICBjb25zdCBjID0gYXdhaXQgKGF3YWl0IHluKG8pKS5qc29uKCk7XG4gICAgcmV0dXJuIChjID09IG51bGwgPyB2b2lkIDAgOiBjLmNhc3QpIHx8IG51bGw7XG4gIH0gY2F0Y2ggKG8pIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGNhc3QgYnkgaWRlbnRpZmllclwiLCBvKSwgbnVsbDtcbiAgfVxufVxuY29uc3QgX20gPSAoe1xuICB0eXBlOiB0LFxuICBpZGVudGlmaWVyOiBlLFxuICB2aWV3ZXJGaWQ6IHIsXG4gIGFsbG93UmVhY3Rpb25zOiBuID0gITEsXG4gIHJlbmRlckVtYmVkczogbyA9ICEwLFxuICByZW5kZXJGcmFtZXM6IGkgPSAhMSxcbiAgb25MaWtlQnRuUHJlc3M6IGMsXG4gIG9uUmVjYXN0QnRuUHJlc3M6IGYsXG4gIG9uQ29tbWVudEJ0blByZXNzOiB2LFxuICBvbkZyYW1lQnRuUHJlc3M6IHgsXG4gIGNvbnRhaW5lclN0eWxlczogYixcbiAgdGV4dFN0eWxlczogU1xufSkgPT4ge1xuICB2YXIgUTtcbiAgY29uc3Qge1xuICAgIGNsaWVudF9pZDogVFxuICB9ID0gbHIoKSwgW0MsIFBdID0gYXQudXNlU3RhdGUobnVsbCksIFtCLCBSXSA9IGF0LnVzZVN0YXRlKCEwKSwgW3osIEtdID0gYXQudXNlU3RhdGUobnVsbCksIFogPSAoQyA9PSBudWxsID8gdm9pZCAwIDogQy5hdXRob3IuZmlkKSA9PT0gcjtcbiAgcmV0dXJuIGF0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdCAmJiBlICYmIChSKCEwKSwgSyhudWxsKSwgYm0oe1xuICAgICAgdHlwZTogdCxcbiAgICAgIGlkZW50aWZpZXI6IGUsXG4gICAgICB2aWV3ZXJGaWQ6IHIsXG4gICAgICBjbGllbnRfaWQ6IFRcbiAgICB9KS50aGVuKChqKSA9PiB7XG4gICAgICBQKGopO1xuICAgIH0pLmNhdGNoKChqKSA9PiB7XG4gICAgICBLKGopO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgUighMSk7XG4gICAgfSkpO1xuICB9LCBbdCwgZSwgciwgVF0pLCBCID8gLyogQF9fUFVSRV9fICovIFUuanN4KFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogXCJMb2FkaW5nLi4uXCJcbiAgfSkgOiAhQyB8fCB6ID8gLyogQF9fUFVSRV9fICovIFUuanN4KFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogXCJFcnJvcjogY291bGQgbm90IGZldGNoIGNhc3QgZGF0YVwiXG4gIH0pIDogaSAmJiAheCA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IFwiRXJyb3I6IG9uRnJhbWVCdG5QcmVzcyBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gcmVuZGVyRW1iZWRzIGlzIHRydWUuXCJcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gVS5qc3goUnMsIHtcbiAgICB1c2VybmFtZTogQy5hdXRob3IudXNlcm5hbWUsXG4gICAgZGlzcGxheU5hbWU6IEMuYXV0aG9yLmRpc3BsYXlfbmFtZSxcbiAgICBhdmF0YXJJbWdVcmw6IEMuYXV0aG9yLnBmcF91cmwsXG4gICAgdGV4dDogQy50ZXh0LFxuICAgIGhhc2g6IEMuaGFzaCxcbiAgICByZWFjdGlvbnM6IEMucmVhY3Rpb25zLFxuICAgIHJlcGxpZXM6IEMucmVwbGllcy5jb3VudCxcbiAgICBlbWJlZHM6IEMuZW1iZWRzID8/IFtdLFxuICAgIGZyYW1lczogQy5mcmFtZXMgPz8gW10sXG4gICAgcmVuZGVyRW1iZWRzOiBvLFxuICAgIHJlbmRlckZyYW1lczogaSxcbiAgICBjaGFubmVsOiBDLmNoYW5uZWwgPyB7XG4gICAgICBpZDogQy5jaGFubmVsLmlkLFxuICAgICAgbmFtZTogQy5jaGFubmVsLm5hbWUsXG4gICAgICB1cmw6IEMucGFyZW50X3VybFxuICAgIH0gOiB2b2lkIDAsXG4gICAgdmlld2VyRmlkOiByLFxuICAgIGFsbG93UmVhY3Rpb25zOiBuLFxuICAgIGhhc1Bvd2VyQmFkZ2U6IEMuYXV0aG9yLnBvd2VyX2JhZGdlLFxuICAgIGFwcEF2YXRhckltZ1VybDogKChRID0gQy5hcHApID09IG51bGwgPyB2b2lkIDAgOiBRLnBmcF91cmwpIHx8IG51bGwsXG4gICAgaXNPd25Qcm9maWxlOiBaLFxuICAgIGNvbnRhaW5lclN0eWxlczogYixcbiAgICB0ZXh0U3R5bGVzOiBTLFxuICAgIG9uTGlrZUJ0blByZXNzOiBjLFxuICAgIG9uUmVjYXN0QnRuUHJlc3M6IGYsXG4gICAgb25Db21tZW50QnRuUHJlc3M6IHYsXG4gICAgb25GcmFtZUJ0blByZXNzOiB4LFxuICAgIHRpbWVzdGFtcDogQy50aW1lc3RhbXBcbiAgfSk7XG59LCBFbSA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImFcIikoe1xuICBjbGFzc2VzOiBbXCJzMXVvNGx4NFwiXVxufSksIHlvID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgWGkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBDdSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIFN1ID0gKHQpID0+IG5ldyBQcm9taXNlKChlKSA9PiBzZXRUaW1lb3V0KGUsIHQpKSwgTmwgPSBhc3luYyAodCwgZSA9IDApID0+IHtcbiAgY29uc3QgciA9IG5ldyBVUkwodCkuaG9zdG5hbWU7XG4gIGlmIChDdS5nZXQocikpXG4gICAgcmV0dXJuIHtcbiAgICAgIG9nSW1hZ2U6IFwiXCIsXG4gICAgICBvZ1RpdGxlOiBcIlwiLFxuICAgICAgb2dEZXNjcmlwdGlvbjogXCJcIlxuICAgIH07XG4gIGlmICh5by5oYXModCkpXG4gICAgcmV0dXJuIHlvLmdldCh0KTtcbiAgaWYgKFhpLmhhcyh0KSlcbiAgICByZXR1cm4gWGkuZ2V0KHQpO1xuICBjb25zdCBuID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgU3UoMTAwKTtcbiAgICAgIGNvbnN0IG8gPSBhd2FpdCBmZXRjaChgJHt2bX0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHQpfWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiXG4gICAgICB9KTtcbiAgICAgIGlmICghby5vaykge1xuICAgICAgICBpZiAoby5zdGF0dXMgPT09IDQyOSAmJiBlIDwgNSkge1xuICAgICAgICAgIGNvbnN0IFIgPSBNYXRoLnBvdygyLCBlKSAqIDFlMztcbiAgICAgICAgICByZXR1cm4gYXdhaXQgU3UoUiksIE5sKHQsIGUgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBDdS5zZXQociwgITApLCBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBPcGVuIEdyYXBoIGRhdGE6ICR7by5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgY29uc3QgaSA9IGF3YWl0IG8uanNvbigpLCBmID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhpLmNvbnRlbnRzLCBcInRleHQvaHRtbFwiKSwgdiA9IGYucXVlcnlTZWxlY3RvcignbWV0YVtwcm9wZXJ0eT1cIm9nOmltYWdlXCJdJyksIHggPSBmLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJvZzp0aXRsZVwiXScpLCBiID0gZi5xdWVyeVNlbGVjdG9yKCdtZXRhW3Byb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIl0nKSwgUyA9IGYucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpLCBUID0gdiAmJiB2LmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikgfHwgXCJcIiwgQyA9IHggPyB4LmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikgfHwgXCJcIiA6IFMgPyBTLmlubmVyVGV4dCA6IFwiXCIsIFAgPSBiICYmIGIuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKSB8fCBcIlwiLCBCID0ge1xuICAgICAgICBvZ0ltYWdlOiBULFxuICAgICAgICBvZ1RpdGxlOiBDLFxuICAgICAgICBvZ0Rlc2NyaXB0aW9uOiBQXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHlvLnNldCh0LCBCKSwgQjtcbiAgICB9IGNhdGNoIChvKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIE9wZW4gR3JhcGggZGF0YVwiLCBvKSwge1xuICAgICAgICBvZ0ltYWdlOiBcIlwiLFxuICAgICAgICBvZ1RpdGxlOiBcIlwiLFxuICAgICAgICBvZ0Rlc2NyaXB0aW9uOiBcIlwiXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBYaS5kZWxldGUodCk7XG4gICAgfVxuICB9KSgpO1xuICByZXR1cm4gWGkuc2V0KHQsIG4pLCBuO1xufSwgRG8gPSBbXTtcbmxldCB2byA9IDA7XG5jb25zdCBNbSA9IDUsIENtID0gKHQpID0+IHtcbiAgRG8ucHVzaCh0KSwgamwoKTtcbn0sIGpsID0gYXN5bmMgKCkgPT4ge1xuICBpZiAodm8gPj0gTW0gfHwgRG8ubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgdm8rKztcbiAgY29uc3QgdCA9IERvLnNoaWZ0KCk7XG4gIHQgJiYgYXdhaXQgdCgpLCB2by0tLCBqbCgpO1xufSwgU20gPSAoe1xuICBzcmM6IHQsXG4gIGFsdDogZSxcbiAgc3R5bGU6IHJcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImltZ1wiLCB7XG4gIHNyYzogdCxcbiAgYWx0OiBlLFxuICBzdHlsZToge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgIG1heEhlaWdodDogXCIxNTBweFwiLFxuICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgb2JqZWN0Rml0OiBcImNvdmVyXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCBncmV5XCIsXG4gICAgYm9yZGVyUmFkaXVzOiBcIjEwcHhcIixcbiAgICBtYXJnaW46IFwiNHB4IDBcIixcbiAgICAuLi5yXG4gIH1cbn0pLCBBbSA9ICh7XG4gIHVybDogdFxufSkgPT4ge1xuICBjb25zdCBlID0gYXQudXNlUmVmKG51bGwpO1xuICByZXR1cm4gYXQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZS5jdXJyZW50KVxuICAgICAgaWYgKFpzLmlzU3VwcG9ydGVkKCkgJiYgdC5lbmRzV2l0aChcIi5tM3U4XCIpKSB7XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgWnMoKTtcbiAgICAgICAgci5sb2FkU291cmNlKHQpLCByLmF0dGFjaE1lZGlhKGUuY3VycmVudCksIHIub24oWnMuRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgKCkgPT4ge1xuICAgICAgICAgIGUuY3VycmVudC5wbGF5KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGUuY3VycmVudC5zcmMgPSB0LCBlLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsICgpID0+IHtcbiAgICAgICAgICBlLmN1cnJlbnQucGxheSgpO1xuICAgICAgICB9KTtcbiAgfSwgW3RdKSwgLyogQF9fUFVSRV9fICovIFUuanN4KFwidmlkZW9cIiwge1xuICAgIHJlZjogZSxcbiAgICBjb250cm9sczogITAsXG4gICAgbXV0ZWQ6ICEwLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgICBtYXhIZWlnaHQ6IFwiNDAwcHhcIixcbiAgICAgIGJvcmRlclJhZGl1czogXCIxMHB4XCIsXG4gICAgICBtYXJnaW46IFwiMTBweCAwXCIsXG4gICAgICBvYmplY3RGaXQ6IFwiY29udGFpblwiXG4gICAgfVxuICB9KTtcbn0sIGttID0gKHQpID0+IC9cXC4oanBlZ3xqcGd8Z2lmfHBuZ3x3ZWJwfGJtcHxzdmcpJC8udGVzdCh0KSB8fCB0LnN0YXJ0c1dpdGgoXCJodHRwczovL2ltYWdlZGVsaXZlcnkubmV0XCIpLCBJbSA9ICh0LCBlLCByKSA9PiB7XG4gIGNvbnN0IFtuLCBvXSA9IGF0LnVzZVN0YXRlKFtdKSwgaSA9IGF0LnVzZUNhbGxiYWNrKGFzeW5jIChjKSA9PiAoYXdhaXQgUHJvbWlzZS5hbGwoYy5tYXAoYXN5bmMgKHYpID0+IHtcbiAgICBpZiAodi51cmwpIHtcbiAgICAgIGNvbnN0IHggPSB2LnVybDtcbiAgICAgIHJldHVybiBrbSh4KSA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChTbSwge1xuICAgICAgICBzcmM6IHgsXG4gICAgICAgIGFsdDogXCJFbWJlZGRlZCBpbWFnZVwiXG4gICAgICB9LCB4KSA6IHguZW5kc1dpdGgoXCIubTN1OFwiKSB8fCB4LmVuZHNXaXRoKFwiLm1wNFwiKSA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChBbSwge1xuICAgICAgICB1cmw6IHhcbiAgICAgIH0sIHgpIDogbmV3IFByb21pc2UoKGIpID0+IHtcbiAgICAgICAgQ20oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9nSW1hZ2U6IFMsXG4gICAgICAgICAgICBvZ1RpdGxlOiBUXG4gICAgICAgICAgfSA9IGF3YWl0IE5sKHgpLCBDID0gbmV3IFVSTCh4KS5ob3N0bmFtZS5yZXBsYWNlKFwid3d3LlwiLCBcIlwiKTtcbiAgICAgICAgICBiKC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoRW0sIHtcbiAgICAgICAgICAgIGhyZWY6IHgsXG4gICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICByZWw6IFwibm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtTICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICAgIHNyYzogUyxcbiAgICAgICAgICAgICAgYWx0OiBULFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBcIjUwcHhcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNTBweFwiLFxuICAgICAgICAgICAgICAgIG9iamVjdEZpdDogXCJjb3ZlclwiLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI1cHhcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4cyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBcIiwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBUIHx8IHhcbiAgICAgICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBcIiwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogXCJncmV5XCIsXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBDXG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgfSwgeCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodi5jYXN0X2lkKVxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgbWF4V2lkdGg6IFwiODUlXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChfbSwge1xuICAgICAgICAgIHR5cGU6IFwiaGFzaFwiLFxuICAgICAgICAgIGlkZW50aWZpZXI6IHYuY2FzdF9pZC5oYXNoLFxuICAgICAgICAgIHZpZXdlckZpZDogcixcbiAgICAgICAgICBhbGxvd1JlYWN0aW9uczogZSxcbiAgICAgICAgICByZW5kZXJFbWJlZHM6ICExXG4gICAgICAgIH0sIHYuY2FzdF9pZC5maWQpXG4gICAgICB9LCBgY2FzdC0ke3YuY2FzdF9pZC5oYXNofWApO1xuICAgIHJldHVybiBudWxsO1xuICB9KSkpLmZpbHRlcigodikgPT4gdiAhPT0gbnVsbCksIFtlLCByXSk7XG4gIHJldHVybiBhdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGkodCkudGhlbihvKTtcbiAgfSwgW3QsIGldKSwgbjtcbn0sIEJtID0gKHtcbiAgb25DbGljazogdFxufSkgPT4gLyogQF9fUFVSRV9fICovIFUuanN4KFwic3ZnXCIsIHtcbiAgd2lkdGg6IFwiMThcIixcbiAgaGVpZ2h0OiBcIjE3XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDE4IDE3XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICBvbkNsaWNrOiAoZSkgPT4gdCA/IHQoZSkgOiB2b2lkIDAsXG4gIHN0eWxlOiB7XG4gICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICB9LFxuICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNi4yMjg1NyAxMi42ODI4SDcuMDEyODVDNy4wMTI4NSAxMi4yNDk2IDYuNjYxNzIgMTEuODk4NSA2LjIyODU3IDExLjg5ODVWMTIuNjgyOFpNNi4yMjg1NyAxNS44MTk5SDUuNDQ0M0M1LjQ0NDMgMTYuMTEzNyA1LjYwODQ4IDE2LjM4MjggNS44Njk3IDE2LjUxNzJDNi4xMzA5MiAxNi42NTE3IDYuNDQ1MzcgMTYuNjI4OCA2LjY4NDQzIDE2LjQ1ODFMNi4yMjg1NyAxNS44MTk5Wk0xMC42MjA1IDEyLjY4MjhWMTEuODk4NUMxMC40NTcxIDExLjg5ODUgMTAuMjk3NyAxMS45NDk2IDEwLjE2NDcgMTIuMDQ0NkwxMC42MjA1IDEyLjY4MjhaTTEuNzg0MjggMy4yNzE0NkMxLjc4NDI4IDIuNTQ5NTUgMi4zNjk1IDEuOTY0MzMgMy4wOTE0MSAxLjk2NDMzVjAuMzk1Nzc3QzEuNTAzMjEgMC4zOTU3NzcgMC4yMTU3MjMgMS42ODMyNyAwLjIxNTcyMyAzLjI3MTQ2SDEuNzg0MjhaTTEuNzg0MjggMTAuNTkxNFYzLjI3MTQ2SDAuMjE1NzIzVjEwLjU5MTRIMS43ODQyOFpNMy4wOTE0IDExLjg5ODVDMi4zNjk1IDExLjg5ODUgMS43ODQyOCAxMS4zMTMzIDEuNzg0MjggMTAuNTkxNEgwLjIxNTcyM0MwLjIxNTcyMyAxMi4xNzk2IDEuNTAzMjEgMTMuNDY3MSAzLjA5MTQgMTMuNDY3MVYxMS44OTg1Wk02LjIyODU3IDExLjg5ODVIMy4wOTE0VjEzLjQ2NzFINi4yMjg1N1YxMS44OTg1Wk03LjAxMjg1IDE1LjgxOTlWMTIuNjgyOEg1LjQ0NDNWMTUuODE5OUg3LjAxMjg1Wk0xMC4xNjQ3IDEyLjA0NDZMNS43NzI3MiAxNS4xODE3TDYuNjg0NDMgMTYuNDU4MUwxMS4wNzY0IDEzLjMyMUwxMC4xNjQ3IDEyLjA0NDZaTTE0LjU5NDEgMTEuODk4NUgxMC42MjA1VjEzLjQ2NzFIMTQuNTk0MVYxMS44OTg1Wk0xNS45MDEzIDEwLjU5MTRDMTUuOTAxMyAxMS4zMTMzIDE1LjMxNiAxMS44OTg1IDE0LjU5NDEgMTEuODk4NVYxMy40NjcxQzE2LjE4MjMgMTMuNDY3MSAxNy40Njk4IDEyLjE3OTYgMTcuNDY5OCAxMC41OTE0SDE1LjkwMTNaTTE1LjkwMTMgMy4yNzE0NlYxMC41OTE0SDE3LjQ2OThWMy4yNzE0NkgxNS45MDEzWk0xNC41OTQxIDEuOTY0MzNDMTUuMzE2IDEuOTY0MzMgMTUuOTAxMyAyLjU0OTU1IDE1LjkwMTMgMy4yNzE0NkgxNy40Njk4QzE3LjQ2OTggMS42ODMyNiAxNi4xODIzIDAuMzk1Nzc3IDE0LjU5NDEgMC4zOTU3NzdWMS45NjQzM1pNMy4wOTE0MSAxLjk2NDMzSDE0LjU5NDFWMC4zOTU3NzdIMy4wOTE0MVYxLjk2NDMzWlwiLFxuICAgIGZpbGw6IFwiI0EwQTNBRFwiXG4gIH0pXG59KSwgUm0gPSAoe1xuICBmaWxsOiB0LFxuICBvbkNsaWNrOiBlXG59KSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFwic3ZnXCIsIHtcbiAgd2lkdGg6IFwiMTZcIixcbiAgaGVpZ2h0OiBcIjE1XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDE2IDE1XCIsXG4gIGZpbGw6IHQgfHwgXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIG9uQ2xpY2s6IChyKSA9PiBlID8gZShyKSA6IHZvaWQgMCxcbiAgc3R5bGU6IHtcbiAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gIH0sXG4gIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTQuOTI0NSAxNC4yNTA2QzE0LjcyNTggMTQuMjUwNiAxNC41MzUyIDE0LjE3MTYgMTQuMzk0NiAxNC4wMzExQzE0LjI1NDEgMTMuODkwNSAxNC4xNzUxIDEzLjY5OTkgMTQuMTc1MSAxMy41MDExVjEwLjUwMzRIMTEuMTc3NEMxMC45Nzg3IDEwLjUwMzQgMTAuNzg4MSAxMC40MjQ1IDEwLjY0NzUgMTAuMjgzOUMxMC41MDcgMTAuMTQzNCAxMC40MjggOS45NTI3OSAxMC40MjggOS43NTQwM0MxMC40MjggOS41NTUyNyAxMC41MDcgOS4zNjQ2NSAxMC42NDc1IDkuMjI0MTFDMTAuNzg4MSA5LjA4MzU3IDEwLjk3ODcgOS4wMDQ2MSAxMS4xNzc0IDkuMDA0NjFIMTQuOTI0NUMxNS4xMjMzIDkuMDA0NjEgMTUuMzEzOSA5LjA4MzU3IDE1LjQ1NDUgOS4yMjQxMUMxNS41OTUgOS4zNjQ2NSAxNS42NzQgOS41NTUyNyAxNS42NzQgOS43NTQwM1YxMy41MDExQzE1LjY3NCAxMy42OTk5IDE1LjU5NSAxMy44OTA1IDE1LjQ1NDUgMTQuMDMxMUMxNS4zMTM5IDE0LjE3MTYgMTUuMTIzMyAxNC4yNTA2IDE0LjkyNDUgMTQuMjUwNlpNNS4xODIwNyA2LjAwNjkzSDEuNDM0OTdDMS4yMzYyMSA2LjAwNjkzIDEuMDQ1NTkgNS45Mjc5NyAwLjkwNTA0NyA1Ljc4NzQzQzAuNzY0NTAzIDUuNjQ2ODggMC42ODU1NDcgNS40NTYyNyAwLjY4NTU0NyA1LjI1NzUxVjEuNTEwNDFDMC42ODU1NDcgMS4zMTE2NSAwLjc2NDUwMyAxLjEyMTAzIDAuOTA1MDQ3IDAuOTgwNDg2QzEuMDQ1NTkgMC44Mzk5NDMgMS4yMzYyMSAwLjc2MDk4NiAxLjQzNDk3IDAuNzYwOTg2QzEuNjMzNzMgMC43NjA5ODYgMS44MjQzNCAwLjgzOTk0MyAxLjk2NDg5IDAuOTgwNDg2QzIuMTA1NDMgMS4xMjEwMyAyLjE4NDM5IDEuMzExNjUgMi4xODQzOSAxLjUxMDQxVjQuNTA4MDlINS4xODIwN0M1LjM4MDgzIDQuNTA4MDkgNS41NzE0NSA0LjU4NzA0IDUuNzExOTkgNC43Mjc1OUM1Ljg1MjUzIDQuODY4MTMgNS45MzE0OSA1LjA1ODc1IDUuOTMxNDkgNS4yNTc1MUM1LjkzMTQ5IDUuNDU2MjcgNS44NTI1MyA1LjY0Njg4IDUuNzExOTkgNS43ODc0M0M1LjU3MTQ1IDUuOTI3OTcgNS4zODA4MyA2LjAwNjkzIDUuMTgyMDcgNi4wMDY5M1pcIixcbiAgICBmaWxsOiB0IHx8IFwiI0EwQTNBRFwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk04LjE3OTM0IDE1QzYuMzM1NTYgMTUuMDAwMyA0LjU1NjM3IDE0LjMyMDkgMy4xODIwNSAxMy4wOTE4QzEuODA3NzQgMTEuODYyNyAwLjkzNDc2NiAxMC4xNyAwLjczMDEwNiA4LjMzNzY1QzAuNzE5MjgxIDguMjM5MjMgMC43Mjc5NDUgOC4xMzk2NSAwLjc1NTYwNiA4LjA0NDU4QzAuNzgzMjY2IDcuOTQ5NTEgMC44MjkzOCA3Ljg2MDgzIDAuODkxMzE1IDcuNzgzNThDMS4wMTY0IDcuNjI3NTggMS4xOTgzMyA3LjUyNzY1IDEuMzk3MDkgNy41MDU3OUMxLjU5NTg1IDcuNDgzOTMgMS43OTUxNSA3LjU0MTkxIDEuOTUxMTYgNy42NjdDMi4xMDcxNiA3Ljc5MjA4IDIuMjA3MDggNy45NzQwMSAyLjIyODk1IDguMTcyNzdDMi4zNzcwOCA5LjUyMzc2IDIuOTc5ODMgMTAuNzg0MyAzLjkzODM4IDExLjc0NzhDNC44OTY5MiAxMi43MTEzIDYuMTU0MzggMTMuMzIwNSA3LjUwNDU5IDEzLjQ3NTVDOC44NTQ3OSAxMy42MzA2IDEwLjIxNzYgMTMuMzIyMyAxMS4zNjk2IDEyLjYwMTJDMTIuNTIxNiAxMS44ODAxIDEzLjM5NDQgMTAuNzg5IDEzLjg0NSA5LjUwNjc0QzEzLjg3MzEgOS40MDgxNyAxMy45MjExIDkuMzE2NDIgMTMuOTg2IDkuMjM3MTRDMTQuMDUxIDkuMTU3ODcgMTQuMTMxNiA5LjA5Mjc3IDE0LjIyMjcgOS4wNDU4NkMxNC4zMTM4IDguOTk4OTUgMTQuNDEzNiA4Ljk3MTIzIDE0LjUxNTkgOC45NjQ0MkMxNC42MTgxIDguOTU3NjEgMTQuNzIwNyA4Ljk3MTg1IDE0LjgxNzMgOS4wMDYyNUMxNC45MTM4IDkuMDQwNjYgMTUuMDAyMyA5LjA5NDUxIDE1LjA3NzIgOS4xNjQ0NkMxNS4xNTIxIDkuMjM0NDIgMTUuMjExOCA5LjMxODk5IDE1LjI1MjggOS40MTI5NkMxNS4yOTM3IDkuNTA2OTMgMTUuMzE0OSA5LjYwODMgMTUuMzE1MSA5LjcxMDc5QzE1LjMxNTMgOS44MTMyOSAxNS4yOTQ0IDkuOTE0NzMgMTUuMjUzOSAxMC4wMDg5QzE0LjczNTkgMTEuNDcwNSAxMy43Nzc0IDEyLjczNTUgMTIuNTEwMyAxMy42Mjk0QzExLjI0MzIgMTQuNTIzMyA5LjczMDAyIDE1LjAwMjIgOC4xNzkzNCAxNVpNMTQuODc5MiA3LjUwNTc5QzE0LjY5MzkgNy41MDY5MSAxNC41MTQ4IDcuNDM5MzcgMTQuMzc2NCA3LjMxNjJDMTQuMjM4IDcuMTkzMDIgMTQuMTUwMSA3LjAyMjk1IDE0LjEyOTcgNi44Mzg4QzEzLjk3NSA1LjQ5NDI5IDEzLjM2OTkgNC4yNDE2OSAxMi40MTI4IDMuMjg0NzZDMTEuNDU1OCAyLjMyNzgyIDEwLjIwMzEgMS43MjI4NSA4Ljg1ODU4IDEuNTY4MjRDNy41MTQwNSAxLjQxMzY0IDYuMTU2NzYgMS43MTg1IDUuMDA3NSAyLjQzMzI0QzMuODU4MjMgMy4xNDc5OCAyLjk4NDYgNC4yMzA1NCAyLjUyODcyIDUuNTA0ODRDMi41MDA2MiA1LjYwMzQgMi40NTI2IDUuNjk1MTYgMi4zODc2MyA1Ljc3NDQzQzIuMzIyNjYgNS44NTM3MSAyLjI0MjEyIDUuOTE4ODEgMi4xNTA5OSA1Ljk2NTcyQzIuMDU5ODcgNi4wMTI2MyAxLjk2MDA4IDYuMDQwMzUgMS44NTc4MSA2LjA0NzE2QzEuNzU1NTUgNi4wNTM5NyAxLjY1Mjk3IDYuMDM5NzMgMS41NTY0MiA2LjAwNTMyQzEuNDU5ODggNS45NzA5MiAxLjM3MTQxIDUuOTE3MDcgMS4yOTY1MSA1Ljg0NzEyQzEuMjIxNiA1Ljc3NzE2IDEuMTYxODMgNS42OTI1OCAxLjEyMDkxIDUuNTk4NjFDMS4wNzk5OSA1LjUwNDY0IDEuMDU4NzggNS40MDMyOCAxLjA1ODU5IDUuMzAwNzhDMS4wNTg0IDUuMTk4MjkgMS4wNzkyMyA1LjA5Njg1IDEuMTE5OCA1LjAwMjczQzEuNjg0MDYgMy40MDIwMiAyLjc3NDk3IDIuMDQwMjUgNC4yMTM5NyAxLjE0MDI5QzUuNjUyOTcgMC4yNDAzMzcgNy4zNTQ4NSAtMC4xNDQ1MDUgOS4wNDEwNiAwLjA0ODc1MjJDMTAuNzI3MyAwLjI0MjAwOSAxMi4yOTc5IDEuMDAxOTIgMTMuNDk2IDIuMjA0MTFDMTQuNjk0MSAzLjQwNjMgMTUuNDQ4NiA0Ljk3OTU4IDE1LjYzNjEgNi42NjY0NEMxNS42NTcxIDYuODYzMDYgMTUuNTk5NyA3LjA2MDA0IDE1LjQ3NjEgNy4yMTQ0NUMxNS4zNTI2IDcuMzY4ODcgMTUuMTczIDcuNDY4MiAxNC45NzY2IDcuNDkwOEwxNC44NzkyIDcuNTA1NzlaXCIsXG4gICAgZmlsbDogdCB8fCBcIiNBMEEzQURcIlxuICB9KV1cbn0pLCBUbSA9ICh7XG4gIGZpbGw6IHQsXG4gIG9uQ2xpY2s6IGVcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoXCJzdmdcIiwge1xuICB3aWR0aDogXCIxN1wiLFxuICBoZWlnaHQ6IFwiMTVcIixcbiAgdmlld0JveDogXCIwIDAgMTcgMTVcIixcbiAgZmlsbDogdCA/IFwicmVkXCIgOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgb25DbGljazogKHIpID0+IGUgPyBlKHIpIDogdm9pZCAwLFxuICBzdHlsZToge1xuICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgfSxcbiAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMy44NzE5IDIuMjUwNDJMMTQuMjk0NyAxLjU4OTg0TDEzLjg3MTkgMi4yNTA0MkMxNS4yNDY3IDMuMTMwMjIgMTUuNzY3NiA1LjIyMjA2IDE0Ljg4NTYgNy42MTMxN0MxNC4wNDM2IDkuODk1ODMgMTEuOTU1NSAxMi4yMzc0IDguNTE1NzMgMTMuMzY0OEM1LjA3NjA2IDEyLjIzNzQgMi45ODc5OSA5Ljg5NTg0IDIuMTQ1OTYgNy42MTMxNkMxLjI2MzkyIDUuMjIyMDMgMS43ODQ4IDMuMTMwMjIgMy4xNTk1MSAyLjI1MDQyTDMuMTU5NTEgMi4yNTA0MkM0LjU4NTQyIDEuMzM3ODMgNS42NDk5NyAxLjUyOTgzIDYuMzk5NDUgMS45MjUwM0M3LjIxMjcyIDIuMzUzODggNy43MzEwOCAzLjA3MTE0IDcuODYxNDMgMy4yNjgzOEw4LjUxNTczIDQuMjU4MzhMOS4xNzAwMiAzLjI2ODM4QzkuMzAwMzggMy4wNzExMyA5LjgxODczIDIuMzUzODggMTAuNjMyIDEuOTI1MDNDMTEuMzgxNSAxLjUyOTgzIDEyLjQ0NiAxLjMzNzgzIDEzLjg3MTkgMi4yNTA0MlpcIixcbiAgICBzdHJva2U6IHQgfHwgXCIjQTBBM0FEXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiMS41Njg1NVwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJtYXNrXCIsIHtcbiAgICBpZDogXCJwYXRoLTItaW5zaWRlLTFfMTg3XzEwNTFcIixcbiAgICBmaWxsOiBcIndoaXRlXCIsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNOC41ODQ0NCAxMy45Mzk3QzcuNzYxMzkgMTMuNjg2NCA3LjA1MzM0IDEzLjM5MzcgNi4yOTk3NiAxMi45ODI1QzUuOTU2MzMgMTIuNzk1MSA1LjYyMjg1IDEyLjU4OTUgNS4zMDAzIDEyLjM2ODFDNS4xNDQxNiAxMi4yNjA5IDQuOTkxMDggMTIuMTQ5MyA0Ljg0MDYzIDEyLjAzNDNDNC43ODEzMiAxMS45ODg5IDQuODgwMzggMTIuMDY1MiA0LjgyMTU2IDEyLjAxOTVDNC44MDM4OCAxMi4wMDU4IDQuNzg2MyAxMS45OTE5IDQuNzY4NjkgMTEuOTc4MUM0LjczMzY0IDExLjk1MDUgNC42OTg4NCAxMS45MjI1IDQuNjY0MTMgMTEuODk0NUM0LjU4OTQ4IDExLjgzNDIgNC41MTU4MiAxMS43NzI3IDQuNDQyOCAxMS43MTA1QzMuOTA0OTkgMTEuMjUyIDMuNDEzODEgMTAuNzM4OSAyLjk4MDE2IDEwLjE4MDlDMy4wMTg1NiAxMC4yMzAzIDIuOTc2NTEgMTAuMTc2IDIuOTcwNjQgMTAuMTY4M0MyLjk1ODMgMTAuMTUyMiAyLjk0NjA0IDEwLjEzNTkgMi45MzM4IDEwLjExOTdDMi45MDkzOSAxMC4wODc0IDIuODg1MjcgMTAuMDU0OCAyLjg2MTI2IDEwLjAyMjFDMi44MDk2MSA5Ljk1MTg5IDIuNzU5MDggOS44ODA4IDIuNzA5MzIgOS44MDkyQzIuNjE0OTIgOS42NzM0NSAyLjUyNDQxIDkuNTM1IDIuNDM3MSA5LjM5NDU3QzIuMjY3MyA5LjEyMTQ1IDIuMTEyMTMgOC44MzkyNiAxLjk3MTQ3IDguNTUwMDZDMS45Mzg0OSA4LjQ4MjI4IDEuOTA2NTcgOC40MTM5NiAxLjg3NTMxIDguMzQ1MzdDMS44NTk3OCA4LjMxMTMgMS44NDQ1OSA4LjI3NzA5IDEuODI5NDggOC4yNDI4NEMxLjgyMTk1IDguMjI1NzUgMS44MTQ1NiA4LjIwODY0IDEuODA3MTQgOC4xOTE1MkMxLjgwMTY3IDguMTc4ODkgMS43Njg1NiA4LjEwMDYxIDEuNzk2NjQgOC4xNjczNkMxLjczNzI4IDguMDI2MiAxLjY4MjA1IDcuODgzMjkgMS42MzAyOSA3LjczOTE2QzEuNTI5ODIgNy40NTk0MiAxLjQ0NDk4IDcuMTc0MDcgMS4zNzU3NSA2Ljg4NTAyQzEuMzQyMTggNi43NDQ5MiAxLjMxMzAxIDYuNjAzNzkgMS4yODc0NiA2LjQ2MjAyQzEuMjc1NCA2LjM5NTAyIDEuMjY0NSA2LjMyNzgyIDEuMjU0MyA2LjI2MDUyQzEuMjQ5MjUgNi4yMjcxMyAxLjI0NDUzIDYuMTkzNjkgMS4yMzk5NCA2LjE2MDIzQzEuMjUxMzYgNi4yNDM1OCAxLjIzNDk1IDYuMTE3NzIgMS4yMzIzMSA2LjA5NTMyQzEuMjAwNDIgNS44MjQ0NCAxLjE4NTM1IDUuNTUxNTggMS4xODcyMSA1LjI3ODg1QzEuMTg4MTEgNS4xNDY5MSAxLjE5Mzc0IDUuMDE1MDEgMS4yMDMzNCA0Ljg4MzQzQzEuMjA3ODggNC44MjEyOCAxLjIxMzY4IDQuNzU5MjIgMS4yMjAyMyA0LjY5NzI2QzEuMjIzNSA0LjY2NjUxIDEuMjI3MTMgNC42MzU4IDEuMjMwODkgNC42MDUxMUMxLjIzMjc4IDQuNTg5ODIgMS4yMzQ3NyA0LjU3NDU3IDEuMjM2NzggNC41NTkzQzEuMjI1NjIgNC42NDQyNSAxLjIzNTYzIDQuNTY5NTYgMS4yMzgyMyA0LjU1MTYzQzEuMjc0MjggNC4zMDQxOSAxLjMyODYxIDQuMDU5NDMgMS40MDA5NyAzLjgyMDA2QzEuNDM2MTQgMy43MDM3NSAxLjQ3NjM1IDMuNTg4OTkgMS41MjA3MiAzLjQ3NTg3QzEuNTMxMjUgMy40NDkgMS41NDIxOSAzLjQyMjI5IDEuNTUzMjYgMy4zOTU2NEMxLjUxOTQxIDMuNDc3MTYgMS41NTg4OSAzLjM4MzM0IDEuNTY3MTcgMy4zNjQ2NEMxLjU5MjI2IDMuMzA4MDMgMS42MTg4NiAzLjI1MjA5IDEuNjQ2NDMgMy4xOTY2NEMxLjc1MTAxIDIuOTg2MjQgMS44NzQ3NiAyLjc4NTQ5IDIuMDE1MzQgMi41OTcyNEMyLjAyMzcxIDIuNTg2MDMgMi4wMzIyMSAyLjU3NDkyIDIuMDQwNzEgMi41NjM4QzEuOTkyNzUgMi42MjY1NiAyLjAyNDQ2IDIuNTg0OTYgMi4wMzQ5MyAyLjU3MTY5QzIuMDUyMjMgMi41NDk3NCAyLjA2OTkzIDIuNTI4MDggMi4wODc3MyAyLjUwNjUzQzIuMTI2MzEgMi40NTk4NCAyLjE2NjI5IDIuNDE0MzQgMi4yMDcxMyAyLjM2OTYyQzIuMjg1ODcgMi4yODM0MSAyLjM2OTI2IDIuMjAxNTEgMi40NTYgMi4xMjMzOUMyLjQ5Nzg3IDIuMDg1NjggMi41NDA4NCAyLjA0OTIgMi41ODQ0MyAyLjAxMzUyQzIuNjA2MzEgMS45OTU2MSAyLjYyODUyIDEuOTc4MDggMi42NTA4NCAxLjk2MDdDMi41ODE2NCAyLjAxNDY2IDIuNjcxOTEgMS45NDU1NyAyLjY4OTYyIDEuOTMyNjVDMi44MzMzOCAxLjgyNzcgMi45ODU4NyAxLjczNDggMy4xNDAxMyAxLjY0NjNDMy41NDM5MyAxLjQxNDU5IDMuOTI0MzcgMS4yNTU2NyA0LjM4MzEgMS4xNTA3MkM0LjQ3NzE2IDEuMTI5MjEgNC41NzIxOSAxLjExMjA0IDQuNjY3NiAxLjA5NzcxQzQuNzQ0ODMgMS4wODYxMSA0LjYxNTI3IDEuMTAzOTkgNC42OTIxNyAxLjA5NDQ0QzQuNzE1MTMgMS4wOTE2IDQuNzM4MTcgMS4wODkxNyA0Ljc2MTE5IDEuMDg2NzdDNC44MTQwMyAxLjA4MTI0IDQuODY3MDQgMS4wNzczOSA0LjkyMDA3IDEuMDc0MjNDNS4xMDA4NCAxLjA2MzQ4IDUuMjgyMzcgMS4wNjg1MSA1LjQ2MjUyIDEuMDg2NEM1LjQ4MzM2IDEuMDg4NDYgNS41MDQxNyAxLjA5MDkyIDUuNTI0OTUgMS4wOTMzOEM1LjU5NTA4IDEuMTAxNjcgNS40Njk0MyAxLjA4NTI2IDUuNTM4OTkgMS4wOTUyMUM1LjU3OTY1IDEuMTAxMDMgNS42MjAxNiAxLjEwNzk1IDUuNjYwNTkgMS4xMTUyNEM1Ljc0NjQ3IDEuMTMwNzMgNS44MzE1OSAxLjE1MDMgNS45MTYwNCAxLjE3MjI3QzYuMDcyOCAxLjIxMzExIDYuMjI2MjEgMS4yNjYyMSA2LjM3NTk1IDEuMzI3ODZDNi4zMTExMSAxLjMwMTE1IDYuNDE4NzcgMS4zNDcwMiA2LjQzNTg0IDEuMzU0NzdDNi40Njk4NyAxLjM3MDIgNi41MDM1NiAxLjM4NjM5IDYuNTM3MTQgMS40MDI4QzYuNjA4NjUgMS40Mzc3OSA2LjY3ODg2IDEuNDc1NDMgNi43NDgxNyAxLjUxNDYyQzYuODc2NjIgMS41ODcyMyA3LjAwMDYyIDEuNjY3NTMgNy4xMjA5MiAxLjc1MjlDNy4xNDg4MiAxLjc3MjcxIDcuMTc2MzcgMS43OTI5NyA3LjIwMzgzIDEuODEzMzhDNy4yMTczOSAxLjgyMzQ4IDcuMjMwODcgMS44MzM3IDcuMjQ0MzIgMS44NDM5NkM3LjI5MTU4IDEuODc5OTIgNy4xOTg4IDEuODA4MzkgNy4yNDUyOSAxLjg0NDgyQzcuMzAxMDkgMS44ODg1MyA3LjM1NTY4IDEuOTMzNzUgNy40MDk0OSAxLjk3OTgyQzcuNTA2NTIgMi4wNjI4OCA3LjU5OTk0IDIuMTUwMDggNy42OTA1MyAyLjI0MDExQzcuODQwMDggMi4zODg3OSA3Ljk4MDQ0IDIuNTQ2NzcgOC4xMTE0OSAyLjcxMTk0QzguMTI1NzIgMi43Mjk4NyA4LjE3NTMzIDIuNzk0MTQgOC4xMTQ4NSAyLjcxNTdDOC4xMjYzNiAyLjczMDY1IDguMTM3NzYgMi43NDU2OCA4LjE0OTEgMi43NjA3NUM4LjE2OTQgMi43ODc2OSA4LjE4OTM0IDIuODE0OTEgOC4yMDkwNSAyLjg0MjNDOC4yMzgyNSAyLjg4Mjg2IDguMjY2NyAyLjkyMzk4IDguMjk0MjkgMi45NjU2NkM4LjQwMzc0IDMuMTMxIDguNjI4NiAzLjEzMSA4LjczODA1IDIuOTY1NjZDOC43NjcwNyAyLjkyMTgxIDguNzk3MTIgMi44Nzg2NiA4LjgyNzg1IDIuODM1OThDOC44NDc4MyAyLjgwODIzIDguODY4MTkgMi43ODA3NSA4Ljg4ODc1IDIuNzUzNDRDOC45MDI0MiAyLjczNTI5IDguOTQ5MjggMi42NzQ3NCA4Ljg4OTM1IDIuNzUyMTRDOC45MDQwOSAyLjczMzEyIDguOTE5IDIuNzE0MjQgOC45MzM5OSAyLjY5NTQyQzkuMDY3MSAyLjUyODM0IDkuMjEwNzEgMi4zNjk2OCA5LjM2MjYxIDIuMjE5NTRDOS40NTQxMSAyLjEyOTA3IDkuNTQ5MyAyLjA0MjM0IDkuNjQ3MzIgMS45NTg5N0M5LjY5NzM3IDEuOTE2NDEgOS43NDg0NyAxLjg3NTA3IDkuODAwMTcgMS44MzQ1NkM5LjczODggMS44ODI2MyA5LjgyNjk0IDEuODE0NTcgOS44NDIxMyAxLjgwMzI3QzkuODc0MjcgMS43NzkzNyA5LjkwNjgzIDEuNzU2MDYgOS45Mzk2IDEuNzMzMDFDMTAuMDYwOCAxLjY0NzczIDEwLjE4NjYgMS41NjkxNSAxMC4zMTU5IDEuNDk2ODJDMTAuMzgwMiAxLjQ2MDg0IDEwLjQ0NTcgMS40MjcwMyAxMC41MTE5IDEuMzk0NjdDMTAuNTQ1NSAxLjM3ODIzIDEwLjU3OTUgMS4zNjI1MSAxMC42MTM2IDEuMzQ3MDRDMTAuNjMwOCAxLjMzOTI2IDEwLjY0ODEgMS4zMzE3MSAxMC42NjU0IDEuMzI0MTdDMTAuNjkxNSAxLjMxMjk2IDEwLjY4ODUgMS4zMTQyIDEwLjY1NjQgMS4zMjc5QzEwLjY2ODEgMS4zMjMwMyAxMC42Nzk4IDEuMzE4MjIgMTAuNjkxNiAxLjMxMzQ5QzEwLjg0MjMgMS4yNTIzNSAxMC45OTczIDEuMjAyNDYgMTEuMTU0OCAxLjE2MjM5QzExLjIzMzIgMS4xNDI0OCAxMS4zMTIzIDEuMTI1OTkgMTEuMzkxOCAxLjExMTY2QzExLjQzMjMgMS4xMDQzNSAxMS40NzMgMS4wOTgxNSAxMS41MTM4IDEuMDkyMzFDMTEuNDQ3MSAxLjEwMTg2IDExLjUxNzEgMS4wOTIyNiAxMS41MjgxIDEuMDkwOTVDMTEuNTU1OSAxLjA4NzY3IDExLjU4MzggMS4wODQ5OSAxMS42MTE3IDEuMDgyNEMxMS43OTMgMS4wNjU1MyAxMS45NzU3IDEuMDY1MTMgMTIuMTU3MyAxLjA3NzFDMTIuMjAzIDEuMDgwMTEgMTIuMjQ4NSAxLjA4NDQ0IDEyLjI5NCAxLjA4OTIxQzEyLjMxNzIgMS4wOTE2MyAxMi4zNDAyIDEuMDk0NSAxMi4zNjMzIDEuMDk3MzRDMTIuMzAzNiAxLjA4OTk0IDEyLjM4MTMgMS4xMDAyMiAxMi4zODgxIDEuMTAxMjNDMTIuNDkyMSAxLjExNjg1IDEyLjU5NTIgMS4xMzc4NSAxMi42OTc1IDEuMTYxOTNDMTMuMTU4NiAxLjI3MDQ4IDEzLjUzNzggMS40NDAzNyAxMy45NDY0IDEuNjc3NjFDMTQuMDkwNCAxLjc2MTI5IDE0LjIzMTQgMS44NTA3IDE0LjM2NTYgMS45NDk1QzE0LjM3NyAxLjk1NzkxIDE0LjM4ODQgMS45NjY0OCAxNC4zOTk3IDEuOTc1MDNDMTQuNDQxOSAyLjAwNjg4IDE0LjM1MSAxLjkzNjk2IDE0LjM5MjYgMS45Njk0NUMxNC40MTQ5IDEuOTg2ODMgMTQuNDM2OSAyLjAwNDYyIDE0LjQ1ODggMi4wMjI1MkMxNC41MDU5IDIuMDYxMTUgMTQuNTUxOSAyLjEwMTMgMTQuNTk3MSAyLjE0MjI4QzE0LjY4MzUgMi4yMjA3MyAxNC43NjU2IDIuMzAzODggMTQuODQzOSAyLjM5MDM1QzE0Ljg4MTUgMi40MzE3NiAxNC45MTc4IDIuNDc0MjcgMTQuOTUzNCAyLjUxNzM2QzE0Ljk3MTIgMi41Mzg5MSAxNC45ODg3IDIuNTYwNzcgMTUuMDA2IDIuNTgyNzRDMTUuMDM4NCAyLjYyMzg4IDE0Ljk2ODIgMi41MzMzNSAxNSAyLjU3NUMxNS4wMTE0IDIuNTg5ODMgMTUuMDIyNSAyLjYwNDc5IDE1LjAzMzYgMi42MTk3OEMxNS4xNzM2IDIuODA4NzEgMTUuMjk0NiAzLjAxMTQyIDE1LjM5ODUgMy4yMjIyNEMxNS40MjM4IDMuMjczNTYgMTUuNDQ3NyAzLjMyNTUzIDE1LjQ3MDkgMy4zNzc4MkMxNS40NzY3IDMuMzkwOTYgMTUuNDgyNCAzLjQwNDE0IDE1LjQ4ODEgMy40MTczNEMxNS41MDkzIDMuNDY2NTYgMTUuNDY0IDMuMzU5NDUgMTUuNDg0NSAzLjQwOTAyQzE1LjQ5NzUgMy40NDAxMyAxNS41MDk5IDMuNDcxNDggMTUuNTIyMSAzLjUwMjg5QzE1LjU2NjEgMy42MTYzMiAxNS42MDQ5IDMuNzMxNzUgMTUuNjM5OCAzLjg0ODMzQzE1LjcxMTUgNC4wODgzMiAxNS43NjMgNC4zMzQxNiAxNS43OTg0IDQuNTgyMDRDMTUuODA2NCA0LjYzODA2IDE1Ljc5MDEgNC41MTg0MiAxNS43OTc1IDQuNTc0NjNDMTUuNzk5NSA0LjU4OTkyIDE1LjgwMTQgNC42MDUyMSAxNS44MDMzIDQuNjIwNUMxNS44MDcgNC42NTEyIDE1LjgxMDQgNC42ODE5NyAxNS44MTM3IDQuNzEyNzNDMTUuODIwOCA0Ljc3OTk0IDE1LjgyNjQgNC44NDczMiAxNS44MzEyIDQuOTE0NzRDMTUuODQwNCA1LjA0NjU4IDE1Ljg0NDcgNS4xNzg3NiAxNS44NDUzIDUuMzEwOTNDMTUuODQ2NCA1LjU4NDE4IDE1LjgyODcgNS44NTczNyAxNS43OTYxIDYuMTI4NjJDMTUuNzk0MSA2LjE0NTI5IDE1Ljc5MTkgNi4xNjE5MiAxNS43ODk4IDYuMTc4NTZDMTUuNzgyMiA2LjIzODI3IDE1Ljc5ODMgNi4xMTcyMiAxNS43OTAxIDYuMTc2OTdDMTUuNzg1NSA2LjIxMDQ0IDE1Ljc4MDYgNi4yNDM4OSAxNS43NzU1IDYuMjc3MzFDMTUuNzY0NCA2LjM1MDMxIDE1Ljc1MiA2LjQyMzEgMTUuNzM4OCA2LjQ5NTczQzE1LjcxMjkgNi42Mzc2OSAxNS42ODIzIDYuNzc4OCAxNS42NDg0IDYuOTE5MDVDMTUuNTc4NCA3LjIwODQzIDE1LjQ5MDkgNy40OTM0OCAxNS4zODk3IDcuNzczNDNDMTUuMzY0OCA3Ljg0MjMyIDE1LjMzODggNy45MTA4IDE1LjMxMjEgNy45NzkwMkMxNS4yOTg3IDguMDEzMzggMTUuMjg0OSA4LjA0NzYgMTUuMjcxMSA4LjA4MTc5QzE1LjI2NDEgOC4wOTg5NiAxNS4yNTcgOC4xMTYwNCAxNS4yNSA4LjEzMzE1QzE1LjI0NTIgOC4xNDQ1OCAxNS4yNDA1IDguMTU1OTggMTUuMjM1NyA4LjE2NzM4QzE1LjI0OTYgOC4xMzQ1MyAxNS4yNTEgOC4xMzExNyAxNS4yMzk5IDguMTU3MzRDMTUuMTc4NiA4LjMwMTM3IDE1LjExMzEgOC40NDM1NSAxNS4wNDQzIDguNTg0MTZDMTQuOTAyOCA4Ljg3MzUxIDE0Ljc0NTEgOS4xNTQ4MyAxNC41NzQ1IDkuNDI3OTlDMTQuNDg2OCA5LjU2ODQ0IDE0LjM5NSA5LjcwNjM0IDE0LjMwMDIgOS44NDIxM0MxNC4yNTQgOS45MDgyMSAxNC4yMDY5IDkuOTczNTUgMTQuMTU5MiAxMC4wMzg1QzE0LjEzNTEgMTAuMDcxMSAxNC4xMTA4IDEwLjEwMzYgMTQuMDg2NCAxMC4xMzZDMTQuMDc0MSAxMC4xNTIyIDE0LjA2MTcgMTAuMTY4NCAxNC4wNDk0IDEwLjE4NDVDMTQuMDMxOSAxMC4yMDczIDE0LjAzMjkgMTAuMjA2MSAxNC4wNTIyIDEwLjE4MUMxNC4wNDM5IDEwLjE5MTggMTQuMDM1NSAxMC4yMDI1IDE0LjAyNzEgMTAuMjEzMkMxMy44MTM1IDEwLjQ4NjkgMTMuNTg0OSAxMC43NDg4IDEzLjM0NDUgMTAuOTk5MkMxMy4wOTQ4IDExLjI1OTQgMTIuODMwOSAxMS41MDU4IDEyLjU1NiAxMS43MzkxQzEyLjQ4ODQgMTEuNzk2NSAxMi40MTk5IDExLjg1MjggMTIuMzUwOSAxMS45MDg2QzEyLjMxNjIgMTEuOTM2NiAxMi4yODEyIDExLjk2NDMgMTIuMjQ2MSAxMS45OTJDMTIuMjI4NSAxMi4wMDU4IDEyLjIxMDggMTIuMDE5NiAxMi4xOTMxIDEyLjAzMzNDMTIuMjM3NyAxMS45OTg3IDEyLjE2MzYgMTIuMDU1OCAxMi4xNTYgMTIuMDYxNkMxMi4wMDUgMTIuMTc2NSAxMS44NTA4IDEyLjI4NzEgMTEuNjk0MiAxMi4zOTQxQzExLjM3MDYgMTIuNjE1MyAxMS4wMzQ4IDEyLjgxODUgMTAuNjkwNCAxMy4wMDU1QzEwLjUxMjIgMTMuMTAyMyAxMC4zMzEzIDEzLjE5MzkgMTAuMTQ4NCAxMy4yODE1QzEwLjA1OSAxMy4zMjQzIDkuOTY5MDQgMTMuMzY1OCA5Ljg3ODY4IDEzLjQwNjRDOS44MzMxIDEzLjQyNjkgOS43ODczMyAxMy40NDY5IDkuNzQxNTEgMTMuNDY2OUM5LjcxODUgMTMuNDc2OSA5LjY5NTQxIDEzLjQ4NjggOS42NzIzMyAxMy40OTY2QzkuNjQ0MiAxMy41MDg2IDkuNjQxNDYgMTMuNTA5OCA5LjY2NDE3IDEzLjUwMDJDOS42NDg2NCAxMy41MDY3IDkuNjMzMTMgMTMuNTEzMiA5LjYxNzU4IDEzLjUxOTZDOS4yMzQ5IDEzLjY3ODggOC44NDM5OCAxMy44MTc5IDguNDQ3ODYgMTMuOTM5OEM4LjMxNDA5IDEzLjk4MDkgOC4yMzA0IDE0LjExNzggOC4yNjgzOSAxNC4yNTU5QzguMzA0NyAxNC4zODc4IDguNDUwNjQgMTQuNDc2NSA4LjU4NDUgMTQuNDM1M0MxMC4xNTM0IDEzLjk1MjUgMTEuNjI2IDEzLjE4NzEgMTIuODg1NyAxMi4xMzFDMTMuOTQyNSAxMS4yNDUgMTQuODM0OSAxMC4xNDU2IDE1LjQ1NDMgOC45MTE2NUMxNS45OTQyIDcuODM2MDggMTYuMzM1NyA2LjY0NzQ0IDE2LjM1ODMgNS40Mzk2N0MxNi4zNzc0IDQuNDE2MjggMTYuMTQ5IDMuMzU3MDQgMTUuNTc0MiAyLjQ5Nzg5QzE1LjI5MjkgMi4wNzczMiAxNC45MzcxIDEuNzE4MTYgMTQuNTIwNSAxLjQzMTM0QzEzLjc5NTYgMC45MzIyOTUgMTIuOTI5NCAwLjU5MjgyMiAxMi4wNDUgMC41NTcyMTRDMTAuNzcxNyAwLjUwNTk0OSA5LjYwMTI2IDEuMTcxNTcgOC43Njk3IDIuMDk2ODVDOC41OTc3OSAyLjI4ODEzIDguNDM2MzQgMi40OTE3MiA4LjI5NDMxIDIuNzA2MjlDOC40NDIyMyAyLjcwNjI5IDguNTkwMTUgMi43MDYyOSA4LjczODA3IDIuNzA2MjlDOC4yMjQzNCAxLjkzMDIzIDcuNDgyNTUgMS4yNTMzOCA2LjYyNjQgMC44ODA0MjRDNS45MzA1IDAuNTc3MjU4IDUuMTg1NTUgMC40OTAxNjQgNC40MzcyMSAwLjYxNzE3OUMzLjk4NzY2IDAuNjkzNDggMy41NTU0NiAwLjg1NjUwOCAzLjE0ODQ5IDEuMDU5MTVDMi44MTk0NSAxLjIyMjk2IDIuNTA2NTMgMS40MTg0MiAyLjIyMTE1IDEuNjUwMTdDMS40NDkwNCAyLjI3NzEzIDAuOTczMDI2IDMuMjA5OTUgMC43ODM3MzIgNC4xNzUxOUMwLjU2NTA5IDUuMjkwMDQgMC42ODczNyA2LjQ1MzgxIDEuMDIwNTEgNy41MzMzOUMxLjQxMDg0IDguNzk4MjcgMi4wOTQwNyA5Ljk1OTE2IDIuOTU2NDEgMTAuOTU4OUMzLjk0NzU3IDEyLjEwODEgNS4xOTYxNCAxMy4wMzA2IDYuNTU4MiAxMy42OTMzQzcuMTY3MTIgMTMuOTg5NiA3LjgwMDggMTQuMjM2MiA4LjQ0Nzg4IDE0LjQzNTNDOC41ODE3NCAxNC40NzY1IDguNzI3NjggMTQuMzg3OCA4Ljc2Mzk5IDE0LjI1NTlDOC44MDE4OSAxNC4xMTc3IDguNzE4MjEgMTMuOTgwOSA4LjU4NDQ0IDEzLjkzOTdaXCJcbiAgICB9KVxuICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNOC41ODQ0NCAxMy45Mzk3QzcuNzYxMzkgMTMuNjg2NCA3LjA1MzM0IDEzLjM5MzcgNi4yOTk3NiAxMi45ODI1QzUuOTU2MzMgMTIuNzk1MSA1LjYyMjg1IDEyLjU4OTUgNS4zMDAzIDEyLjM2ODFDNS4xNDQxNiAxMi4yNjA5IDQuOTkxMDggMTIuMTQ5MyA0Ljg0MDYzIDEyLjAzNDNDNC43ODEzMiAxMS45ODg5IDQuODgwMzggMTIuMDY1MiA0LjgyMTU2IDEyLjAxOTVDNC44MDM4OCAxMi4wMDU4IDQuNzg2MyAxMS45OTE5IDQuNzY4NjkgMTEuOTc4MUM0LjczMzY0IDExLjk1MDUgNC42OTg4NCAxMS45MjI1IDQuNjY0MTMgMTEuODk0NUM0LjU4OTQ4IDExLjgzNDIgNC41MTU4MiAxMS43NzI3IDQuNDQyOCAxMS43MTA1QzMuOTA0OTkgMTEuMjUyIDMuNDEzODEgMTAuNzM4OSAyLjk4MDE2IDEwLjE4MDlDMy4wMTg1NiAxMC4yMzAzIDIuOTc2NTEgMTAuMTc2IDIuOTcwNjQgMTAuMTY4M0MyLjk1ODMgMTAuMTUyMiAyLjk0NjA0IDEwLjEzNTkgMi45MzM4IDEwLjExOTdDMi45MDkzOSAxMC4wODc0IDIuODg1MjcgMTAuMDU0OCAyLjg2MTI2IDEwLjAyMjFDMi44MDk2MSA5Ljk1MTg5IDIuNzU5MDggOS44ODA4IDIuNzA5MzIgOS44MDkyQzIuNjE0OTIgOS42NzM0NSAyLjUyNDQxIDkuNTM1IDIuNDM3MSA5LjM5NDU3QzIuMjY3MyA5LjEyMTQ1IDIuMTEyMTMgOC44MzkyNiAxLjk3MTQ3IDguNTUwMDZDMS45Mzg0OSA4LjQ4MjI4IDEuOTA2NTcgOC40MTM5NiAxLjg3NTMxIDguMzQ1MzdDMS44NTk3OCA4LjMxMTMgMS44NDQ1OSA4LjI3NzA5IDEuODI5NDggOC4yNDI4NEMxLjgyMTk1IDguMjI1NzUgMS44MTQ1NiA4LjIwODY0IDEuODA3MTQgOC4xOTE1MkMxLjgwMTY3IDguMTc4ODkgMS43Njg1NiA4LjEwMDYxIDEuNzk2NjQgOC4xNjczNkMxLjczNzI4IDguMDI2MiAxLjY4MjA1IDcuODgzMjkgMS42MzAyOSA3LjczOTE2QzEuNTI5ODIgNy40NTk0MiAxLjQ0NDk4IDcuMTc0MDcgMS4zNzU3NSA2Ljg4NTAyQzEuMzQyMTggNi43NDQ5MiAxLjMxMzAxIDYuNjAzNzkgMS4yODc0NiA2LjQ2MjAyQzEuMjc1NCA2LjM5NTAyIDEuMjY0NSA2LjMyNzgyIDEuMjU0MyA2LjI2MDUyQzEuMjQ5MjUgNi4yMjcxMyAxLjI0NDUzIDYuMTkzNjkgMS4yMzk5NCA2LjE2MDIzQzEuMjUxMzYgNi4yNDM1OCAxLjIzNDk1IDYuMTE3NzIgMS4yMzIzMSA2LjA5NTMyQzEuMjAwNDIgNS44MjQ0NCAxLjE4NTM1IDUuNTUxNTggMS4xODcyMSA1LjI3ODg1QzEuMTg4MTEgNS4xNDY5MSAxLjE5Mzc0IDUuMDE1MDEgMS4yMDMzNCA0Ljg4MzQzQzEuMjA3ODggNC44MjEyOCAxLjIxMzY4IDQuNzU5MjIgMS4yMjAyMyA0LjY5NzI2QzEuMjIzNSA0LjY2NjUxIDEuMjI3MTMgNC42MzU4IDEuMjMwODkgNC42MDUxMUMxLjIzMjc4IDQuNTg5ODIgMS4yMzQ3NyA0LjU3NDU3IDEuMjM2NzggNC41NTkzQzEuMjI1NjIgNC42NDQyNSAxLjIzNTYzIDQuNTY5NTYgMS4yMzgyMyA0LjU1MTYzQzEuMjc0MjggNC4zMDQxOSAxLjMyODYxIDQuMDU5NDMgMS40MDA5NyAzLjgyMDA2QzEuNDM2MTQgMy43MDM3NSAxLjQ3NjM1IDMuNTg4OTkgMS41MjA3MiAzLjQ3NTg3QzEuNTMxMjUgMy40NDkgMS41NDIxOSAzLjQyMjI5IDEuNTUzMjYgMy4zOTU2NEMxLjUxOTQxIDMuNDc3MTYgMS41NTg4OSAzLjM4MzM0IDEuNTY3MTcgMy4zNjQ2NEMxLjU5MjI2IDMuMzA4MDMgMS42MTg4NiAzLjI1MjA5IDEuNjQ2NDMgMy4xOTY2NEMxLjc1MTAxIDIuOTg2MjQgMS44NzQ3NiAyLjc4NTQ5IDIuMDE1MzQgMi41OTcyNEMyLjAyMzcxIDIuNTg2MDMgMi4wMzIyMSAyLjU3NDkyIDIuMDQwNzEgMi41NjM4QzEuOTkyNzUgMi42MjY1NiAyLjAyNDQ2IDIuNTg0OTYgMi4wMzQ5MyAyLjU3MTY5QzIuMDUyMjMgMi41NDk3NCAyLjA2OTkzIDIuNTI4MDggMi4wODc3MyAyLjUwNjUzQzIuMTI2MzEgMi40NTk4NCAyLjE2NjI5IDIuNDE0MzQgMi4yMDcxMyAyLjM2OTYyQzIuMjg1ODcgMi4yODM0MSAyLjM2OTI2IDIuMjAxNTEgMi40NTYgMi4xMjMzOUMyLjQ5Nzg3IDIuMDg1NjggMi41NDA4NCAyLjA0OTIgMi41ODQ0MyAyLjAxMzUyQzIuNjA2MzEgMS45OTU2MSAyLjYyODUyIDEuOTc4MDggMi42NTA4NCAxLjk2MDdDMi41ODE2NCAyLjAxNDY2IDIuNjcxOTEgMS45NDU1NyAyLjY4OTYyIDEuOTMyNjVDMi44MzMzOCAxLjgyNzcgMi45ODU4NyAxLjczNDggMy4xNDAxMyAxLjY0NjNDMy41NDM5MyAxLjQxNDU5IDMuOTI0MzcgMS4yNTU2NyA0LjM4MzEgMS4xNTA3MkM0LjQ3NzE2IDEuMTI5MjEgNC41NzIxOSAxLjExMjA0IDQuNjY3NiAxLjA5NzcxQzQuNzQ0ODMgMS4wODYxMSA0LjYxNTI3IDEuMTAzOTkgNC42OTIxNyAxLjA5NDQ0QzQuNzE1MTMgMS4wOTE2IDQuNzM4MTcgMS4wODkxNyA0Ljc2MTE5IDEuMDg2NzdDNC44MTQwMyAxLjA4MTI0IDQuODY3MDQgMS4wNzczOSA0LjkyMDA3IDEuMDc0MjNDNS4xMDA4NCAxLjA2MzQ4IDUuMjgyMzcgMS4wNjg1MSA1LjQ2MjUyIDEuMDg2NEM1LjQ4MzM2IDEuMDg4NDYgNS41MDQxNyAxLjA5MDkyIDUuNTI0OTUgMS4wOTMzOEM1LjU5NTA4IDEuMTAxNjcgNS40Njk0MyAxLjA4NTI2IDUuNTM4OTkgMS4wOTUyMUM1LjU3OTY1IDEuMTAxMDMgNS42MjAxNiAxLjEwNzk1IDUuNjYwNTkgMS4xMTUyNEM1Ljc0NjQ3IDEuMTMwNzMgNS44MzE1OSAxLjE1MDMgNS45MTYwNCAxLjE3MjI3QzYuMDcyOCAxLjIxMzExIDYuMjI2MjEgMS4yNjYyMSA2LjM3NTk1IDEuMzI3ODZDNi4zMTExMSAxLjMwMTE1IDYuNDE4NzcgMS4zNDcwMiA2LjQzNTg0IDEuMzU0NzdDNi40Njk4NyAxLjM3MDIgNi41MDM1NiAxLjM4NjM5IDYuNTM3MTQgMS40MDI4QzYuNjA4NjUgMS40Mzc3OSA2LjY3ODg2IDEuNDc1NDMgNi43NDgxNyAxLjUxNDYyQzYuODc2NjIgMS41ODcyMyA3LjAwMDYyIDEuNjY3NTMgNy4xMjA5MiAxLjc1MjlDNy4xNDg4MiAxLjc3MjcxIDcuMTc2MzcgMS43OTI5NyA3LjIwMzgzIDEuODEzMzhDNy4yMTczOSAxLjgyMzQ4IDcuMjMwODcgMS44MzM3IDcuMjQ0MzIgMS44NDM5NkM3LjI5MTU4IDEuODc5OTIgNy4xOTg4IDEuODA4MzkgNy4yNDUyOSAxLjg0NDgyQzcuMzAxMDkgMS44ODg1MyA3LjM1NTY4IDEuOTMzNzUgNy40MDk0OSAxLjk3OTgyQzcuNTA2NTIgMi4wNjI4OCA3LjU5OTk0IDIuMTUwMDggNy42OTA1MyAyLjI0MDExQzcuODQwMDggMi4zODg3OSA3Ljk4MDQ0IDIuNTQ2NzcgOC4xMTE0OSAyLjcxMTk0QzguMTI1NzIgMi43Mjk4NyA4LjE3NTMzIDIuNzk0MTQgOC4xMTQ4NSAyLjcxNTdDOC4xMjYzNiAyLjczMDY1IDguMTM3NzYgMi43NDU2OCA4LjE0OTEgMi43NjA3NUM4LjE2OTQgMi43ODc2OSA4LjE4OTM0IDIuODE0OTEgOC4yMDkwNSAyLjg0MjNDOC4yMzgyNSAyLjg4Mjg2IDguMjY2NyAyLjkyMzk4IDguMjk0MjkgMi45NjU2NkM4LjQwMzc0IDMuMTMxIDguNjI4NiAzLjEzMSA4LjczODA1IDIuOTY1NjZDOC43NjcwNyAyLjkyMTgxIDguNzk3MTIgMi44Nzg2NiA4LjgyNzg1IDIuODM1OThDOC44NDc4MyAyLjgwODIzIDguODY4MTkgMi43ODA3NSA4Ljg4ODc1IDIuNzUzNDRDOC45MDI0MiAyLjczNTI5IDguOTQ5MjggMi42NzQ3NCA4Ljg4OTM1IDIuNzUyMTRDOC45MDQwOSAyLjczMzEyIDguOTE5IDIuNzE0MjQgOC45MzM5OSAyLjY5NTQyQzkuMDY3MSAyLjUyODM0IDkuMjEwNzEgMi4zNjk2OCA5LjM2MjYxIDIuMjE5NTRDOS40NTQxMSAyLjEyOTA3IDkuNTQ5MyAyLjA0MjM0IDkuNjQ3MzIgMS45NTg5N0M5LjY5NzM3IDEuOTE2NDEgOS43NDg0NyAxLjg3NTA3IDkuODAwMTcgMS44MzQ1NkM5LjczODggMS44ODI2MyA5LjgyNjk0IDEuODE0NTcgOS44NDIxMyAxLjgwMzI3QzkuODc0MjcgMS43NzkzNyA5LjkwNjgzIDEuNzU2MDYgOS45Mzk2IDEuNzMzMDFDMTAuMDYwOCAxLjY0NzczIDEwLjE4NjYgMS41NjkxNSAxMC4zMTU5IDEuNDk2ODJDMTAuMzgwMiAxLjQ2MDg0IDEwLjQ0NTcgMS40MjcwMyAxMC41MTE5IDEuMzk0NjdDMTAuNTQ1NSAxLjM3ODIzIDEwLjU3OTUgMS4zNjI1MSAxMC42MTM2IDEuMzQ3MDRDMTAuNjMwOCAxLjMzOTI2IDEwLjY0ODEgMS4zMzE3MSAxMC42NjU0IDEuMzI0MTdDMTAuNjkxNSAxLjMxMjk2IDEwLjY4ODUgMS4zMTQyIDEwLjY1NjQgMS4zMjc5QzEwLjY2ODEgMS4zMjMwMyAxMC42Nzk4IDEuMzE4MjIgMTAuNjkxNiAxLjMxMzQ5QzEwLjg0MjMgMS4yNTIzNSAxMC45OTczIDEuMjAyNDYgMTEuMTU0OCAxLjE2MjM5QzExLjIzMzIgMS4xNDI0OCAxMS4zMTIzIDEuMTI1OTkgMTEuMzkxOCAxLjExMTY2QzExLjQzMjMgMS4xMDQzNSAxMS40NzMgMS4wOTgxNSAxMS41MTM4IDEuMDkyMzFDMTEuNDQ3MSAxLjEwMTg2IDExLjUxNzEgMS4wOTIyNiAxMS41MjgxIDEuMDkwOTVDMTEuNTU1OSAxLjA4NzY3IDExLjU4MzggMS4wODQ5OSAxMS42MTE3IDEuMDgyNEMxMS43OTMgMS4wNjU1MyAxMS45NzU3IDEuMDY1MTMgMTIuMTU3MyAxLjA3NzFDMTIuMjAzIDEuMDgwMTEgMTIuMjQ4NSAxLjA4NDQ0IDEyLjI5NCAxLjA4OTIxQzEyLjMxNzIgMS4wOTE2MyAxMi4zNDAyIDEuMDk0NSAxMi4zNjMzIDEuMDk3MzRDMTIuMzAzNiAxLjA4OTk0IDEyLjM4MTMgMS4xMDAyMiAxMi4zODgxIDEuMTAxMjNDMTIuNDkyMSAxLjExNjg1IDEyLjU5NTIgMS4xMzc4NSAxMi42OTc1IDEuMTYxOTNDMTMuMTU4NiAxLjI3MDQ4IDEzLjUzNzggMS40NDAzNyAxMy45NDY0IDEuNjc3NjFDMTQuMDkwNCAxLjc2MTI5IDE0LjIzMTQgMS44NTA3IDE0LjM2NTYgMS45NDk1QzE0LjM3NyAxLjk1NzkxIDE0LjM4ODQgMS45NjY0OCAxNC4zOTk3IDEuOTc1MDNDMTQuNDQxOSAyLjAwNjg4IDE0LjM1MSAxLjkzNjk2IDE0LjM5MjYgMS45Njk0NUMxNC40MTQ5IDEuOTg2ODMgMTQuNDM2OSAyLjAwNDYyIDE0LjQ1ODggMi4wMjI1MkMxNC41MDU5IDIuMDYxMTUgMTQuNTUxOSAyLjEwMTMgMTQuNTk3MSAyLjE0MjI4QzE0LjY4MzUgMi4yMjA3MyAxNC43NjU2IDIuMzAzODggMTQuODQzOSAyLjM5MDM1QzE0Ljg4MTUgMi40MzE3NiAxNC45MTc4IDIuNDc0MjcgMTQuOTUzNCAyLjUxNzM2QzE0Ljk3MTIgMi41Mzg5MSAxNC45ODg3IDIuNTYwNzcgMTUuMDA2IDIuNTgyNzRDMTUuMDM4NCAyLjYyMzg4IDE0Ljk2ODIgMi41MzMzNSAxNSAyLjU3NUMxNS4wMTE0IDIuNTg5ODMgMTUuMDIyNSAyLjYwNDc5IDE1LjAzMzYgMi42MTk3OEMxNS4xNzM2IDIuODA4NzEgMTUuMjk0NiAzLjAxMTQyIDE1LjM5ODUgMy4yMjIyNEMxNS40MjM4IDMuMjczNTYgMTUuNDQ3NyAzLjMyNTUzIDE1LjQ3MDkgMy4zNzc4MkMxNS40NzY3IDMuMzkwOTYgMTUuNDgyNCAzLjQwNDE0IDE1LjQ4ODEgMy40MTczNEMxNS41MDkzIDMuNDY2NTYgMTUuNDY0IDMuMzU5NDUgMTUuNDg0NSAzLjQwOTAyQzE1LjQ5NzUgMy40NDAxMyAxNS41MDk5IDMuNDcxNDggMTUuNTIyMSAzLjUwMjg5QzE1LjU2NjEgMy42MTYzMiAxNS42MDQ5IDMuNzMxNzUgMTUuNjM5OCAzLjg0ODMzQzE1LjcxMTUgNC4wODgzMiAxNS43NjMgNC4zMzQxNiAxNS43OTg0IDQuNTgyMDRDMTUuODA2NCA0LjYzODA2IDE1Ljc5MDEgNC41MTg0MiAxNS43OTc1IDQuNTc0NjNDMTUuNzk5NSA0LjU4OTkyIDE1LjgwMTQgNC42MDUyMSAxNS44MDMzIDQuNjIwNUMxNS44MDcgNC42NTEyIDE1LjgxMDQgNC42ODE5NyAxNS44MTM3IDQuNzEyNzNDMTUuODIwOCA0Ljc3OTk0IDE1LjgyNjQgNC44NDczMiAxNS44MzEyIDQuOTE0NzRDMTUuODQwNCA1LjA0NjU4IDE1Ljg0NDcgNS4xNzg3NiAxNS44NDUzIDUuMzEwOTNDMTUuODQ2NCA1LjU4NDE4IDE1LjgyODcgNS44NTczNyAxNS43OTYxIDYuMTI4NjJDMTUuNzk0MSA2LjE0NTI5IDE1Ljc5MTkgNi4xNjE5MiAxNS43ODk4IDYuMTc4NTZDMTUuNzgyMiA2LjIzODI3IDE1Ljc5ODMgNi4xMTcyMiAxNS43OTAxIDYuMTc2OTdDMTUuNzg1NSA2LjIxMDQ0IDE1Ljc4MDYgNi4yNDM4OSAxNS43NzU1IDYuMjc3MzFDMTUuNzY0NCA2LjM1MDMxIDE1Ljc1MiA2LjQyMzEgMTUuNzM4OCA2LjQ5NTczQzE1LjcxMjkgNi42Mzc2OSAxNS42ODIzIDYuNzc4OCAxNS42NDg0IDYuOTE5MDVDMTUuNTc4NCA3LjIwODQzIDE1LjQ5MDkgNy40OTM0OCAxNS4zODk3IDcuNzczNDNDMTUuMzY0OCA3Ljg0MjMyIDE1LjMzODggNy45MTA4IDE1LjMxMjEgNy45NzkwMkMxNS4yOTg3IDguMDEzMzggMTUuMjg0OSA4LjA0NzYgMTUuMjcxMSA4LjA4MTc5QzE1LjI2NDEgOC4wOTg5NiAxNS4yNTcgOC4xMTYwNCAxNS4yNSA4LjEzMzE1QzE1LjI0NTIgOC4xNDQ1OCAxNS4yNDA1IDguMTU1OTggMTUuMjM1NyA4LjE2NzM4QzE1LjI0OTYgOC4xMzQ1MyAxNS4yNTEgOC4xMzExNyAxNS4yMzk5IDguMTU3MzRDMTUuMTc4NiA4LjMwMTM3IDE1LjExMzEgOC40NDM1NSAxNS4wNDQzIDguNTg0MTZDMTQuOTAyOCA4Ljg3MzUxIDE0Ljc0NTEgOS4xNTQ4MyAxNC41NzQ1IDkuNDI3OTlDMTQuNDg2OCA5LjU2ODQ0IDE0LjM5NSA5LjcwNjM0IDE0LjMwMDIgOS44NDIxM0MxNC4yNTQgOS45MDgyMSAxNC4yMDY5IDkuOTczNTUgMTQuMTU5MiAxMC4wMzg1QzE0LjEzNTEgMTAuMDcxMSAxNC4xMTA4IDEwLjEwMzYgMTQuMDg2NCAxMC4xMzZDMTQuMDc0MSAxMC4xNTIyIDE0LjA2MTcgMTAuMTY4NCAxNC4wNDk0IDEwLjE4NDVDMTQuMDMxOSAxMC4yMDczIDE0LjAzMjkgMTAuMjA2MSAxNC4wNTIyIDEwLjE4MUMxNC4wNDM5IDEwLjE5MTggMTQuMDM1NSAxMC4yMDI1IDE0LjAyNzEgMTAuMjEzMkMxMy44MTM1IDEwLjQ4NjkgMTMuNTg0OSAxMC43NDg4IDEzLjM0NDUgMTAuOTk5MkMxMy4wOTQ4IDExLjI1OTQgMTIuODMwOSAxMS41MDU4IDEyLjU1NiAxMS43MzkxQzEyLjQ4ODQgMTEuNzk2NSAxMi40MTk5IDExLjg1MjggMTIuMzUwOSAxMS45MDg2QzEyLjMxNjIgMTEuOTM2NiAxMi4yODEyIDExLjk2NDMgMTIuMjQ2MSAxMS45OTJDMTIuMjI4NSAxMi4wMDU4IDEyLjIxMDggMTIuMDE5NiAxMi4xOTMxIDEyLjAzMzNDMTIuMjM3NyAxMS45OTg3IDEyLjE2MzYgMTIuMDU1OCAxMi4xNTYgMTIuMDYxNkMxMi4wMDUgMTIuMTc2NSAxMS44NTA4IDEyLjI4NzEgMTEuNjk0MiAxMi4zOTQxQzExLjM3MDYgMTIuNjE1MyAxMS4wMzQ4IDEyLjgxODUgMTAuNjkwNCAxMy4wMDU1QzEwLjUxMjIgMTMuMTAyMyAxMC4zMzEzIDEzLjE5MzkgMTAuMTQ4NCAxMy4yODE1QzEwLjA1OSAxMy4zMjQzIDkuOTY5MDQgMTMuMzY1OCA5Ljg3ODY4IDEzLjQwNjRDOS44MzMxIDEzLjQyNjkgOS43ODczMyAxMy40NDY5IDkuNzQxNTEgMTMuNDY2OUM5LjcxODUgMTMuNDc2OSA5LjY5NTQxIDEzLjQ4NjggOS42NzIzMyAxMy40OTY2QzkuNjQ0MiAxMy41MDg2IDkuNjQxNDYgMTMuNTA5OCA5LjY2NDE3IDEzLjUwMDJDOS42NDg2NCAxMy41MDY3IDkuNjMzMTMgMTMuNTEzMiA5LjYxNzU4IDEzLjUxOTZDOS4yMzQ5IDEzLjY3ODggOC44NDM5OCAxMy44MTc5IDguNDQ3ODYgMTMuOTM5OEM4LjMxNDA5IDEzLjk4MDkgOC4yMzA0IDE0LjExNzggOC4yNjgzOSAxNC4yNTU5QzguMzA0NyAxNC4zODc4IDguNDUwNjQgMTQuNDc2NSA4LjU4NDUgMTQuNDM1M0MxMC4xNTM0IDEzLjk1MjUgMTEuNjI2IDEzLjE4NzEgMTIuODg1NyAxMi4xMzFDMTMuOTQyNSAxMS4yNDUgMTQuODM0OSAxMC4xNDU2IDE1LjQ1NDMgOC45MTE2NUMxNS45OTQyIDcuODM2MDggMTYuMzM1NyA2LjY0NzQ0IDE2LjM1ODMgNS40Mzk2N0MxNi4zNzc0IDQuNDE2MjggMTYuMTQ5IDMuMzU3MDQgMTUuNTc0MiAyLjQ5Nzg5QzE1LjI5MjkgMi4wNzczMiAxNC45MzcxIDEuNzE4MTYgMTQuNTIwNSAxLjQzMTM0QzEzLjc5NTYgMC45MzIyOTUgMTIuOTI5NCAwLjU5MjgyMiAxMi4wNDUgMC41NTcyMTRDMTAuNzcxNyAwLjUwNTk0OSA5LjYwMTI2IDEuMTcxNTcgOC43Njk3IDIuMDk2ODVDOC41OTc3OSAyLjI4ODEzIDguNDM2MzQgMi40OTE3MiA4LjI5NDMxIDIuNzA2MjlDOC40NDIyMyAyLjcwNjI5IDguNTkwMTUgMi43MDYyOSA4LjczODA3IDIuNzA2MjlDOC4yMjQzNCAxLjkzMDIzIDcuNDgyNTUgMS4yNTMzOCA2LjYyNjQgMC44ODA0MjRDNS45MzA1IDAuNTc3MjU4IDUuMTg1NTUgMC40OTAxNjQgNC40MzcyMSAwLjYxNzE3OUMzLjk4NzY2IDAuNjkzNDggMy41NTU0NiAwLjg1NjUwOCAzLjE0ODQ5IDEuMDU5MTVDMi44MTk0NSAxLjIyMjk2IDIuNTA2NTMgMS40MTg0MiAyLjIyMTE1IDEuNjUwMTdDMS40NDkwNCAyLjI3NzEzIDAuOTczMDI2IDMuMjA5OTUgMC43ODM3MzIgNC4xNzUxOUMwLjU2NTA5IDUuMjkwMDQgMC42ODczNyA2LjQ1MzgxIDEuMDIwNTEgNy41MzMzOUMxLjQxMDg0IDguNzk4MjcgMi4wOTQwNyA5Ljk1OTE2IDIuOTU2NDEgMTAuOTU4OUMzLjk0NzU3IDEyLjEwODEgNS4xOTYxNCAxMy4wMzA2IDYuNTU4MiAxMy42OTMzQzcuMTY3MTIgMTMuOTg5NiA3LjgwMDggMTQuMjM2MiA4LjQ0Nzg4IDE0LjQzNTNDOC41ODE3NCAxNC40NzY1IDguNzI3NjggMTQuMzg3OCA4Ljc2Mzk5IDE0LjI1NTlDOC44MDE4OSAxNC4xMTc3IDguNzE4MjEgMTMuOTgwOSA4LjU4NDQ0IDEzLjkzOTdaXCIsXG4gICAgc3Ryb2tlOiB0IHx8IFwiI0EwQTNBRFwiLFxuICAgIHN0cm9rZVdpZHRoOiBcIjMuMTM3MTFcIixcbiAgICBtYXNrOiBcInVybCgjcGF0aC0yLWluc2lkZS0xXzE4N18xMDUxKVwiXG4gIH0pXVxufSk7XG5mdW5jdGlvbiBVbCh7XG4gIG9uQ2xpY2s6IHQsXG4gIHNpemU6IGUgPSAyNFxufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFUuanN4KFwic3ZnXCIsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgIHJvbGU6IFwiaW1nXCIsXG4gICAgdmlld0JveDogXCIwIDAgMTYgMTZcIixcbiAgICB3aWR0aDogZSxcbiAgICBoZWlnaHQ6IGUsXG4gICAgZmlsbDogXCIjNEE0QTRBXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC1ib3R0b21cIixcbiAgICAgIG92ZXJmbG93OiBcInZpc2libGVcIixcbiAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICBwYWRkaW5nOiBcIjRweFwiXG4gICAgfSxcbiAgICBvbkNsaWNrOiB0LFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTMuNzIgMy43MmEuNzUuNzUgMCAwIDEgMS4wNiAwTDggNi45NGwzLjIyLTMuMjJhLjc0OS43NDkgMCAwIDEgMS4yNzUuMzI2Ljc0OS43NDkgMCAwIDEtLjIxNS43MzRMOS4wNiA4bDMuMjIgMy4yMmEuNzQ5Ljc0OSAwIDAgMS0uMzI2IDEuMjc1Ljc0OS43NDkgMCAwIDEtLjczNC0uMjE1TDggOS4wNmwtMy4yMiAzLjIyYS43NTEuNzUxIDAgMCAxLTEuMDQyLS4wMTguNzUxLjc1MSAwIDAgMS0uMDE4LTEuMDQyTDYuOTQgOCAzLjcyIDQuNzhhLjc1Ljc1IDAgMCAxIDAtMS4wNlpcIlxuICAgIH0pXG4gIH0pO1xufVxuY29uc3QgTG0gPSAoKSA9PiBWdCwgT20gPSAvKiBAX19QVVJFX18gKi8gdWUoTG0oKSkoe1xuICBjbGFzc2VzOiBbXCJyZWN0N2U1XCJdXG59KSwgTm0gPSAoKSA9PiBWdCwgam0gPSAvKiBAX19QVVJFX18gKi8gdWUoTm0oKSkoe1xuICBjbGFzc2VzOiBbXCJwMTNtcW50dFwiXVxufSksIFVtID0gKCkgPT4gVnQsIEZtID0gLyogQF9fUFVSRV9fICovIHVlKFVtKCkpKHtcbiAgY2xhc3NlczogW1wicDFyNDdkejJcIl1cbn0pLCBQbSA9ICgpID0+IFZ0LCBEbSA9IC8qIEBfX1BVUkVfXyAqLyB1ZShQbSgpKSh7XG4gIGNsYXNzZXM6IFtcImNub2pwcXZcIl1cbn0pLCAkbSA9ICh7XG4gIGhhc2g6IHQsXG4gIHJlYWN0aW9uczogZSxcbiAgb25Db21tZW50OiByLFxuICBvblJlY2FzdDogbixcbiAgb25MaWtlOiBvLFxuICBpc0xpa2VkOiBpXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGllbnRfaWQ6IGMsXG4gICAgdXNlcjogZixcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IHZcbiAgfSA9IGxyKCksIFt4LCBiXSA9IGF0LnVzZVN0YXRlKCExKSwgW1MsIFRdID0gYXQudXNlU3RhdGUoe1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH0pLCBbQywgUF0gPSBhdC51c2VTdGF0ZShudWxsKSwgW0IsIFJdID0gYXQudXNlU3RhdGUoaSksIFt6LCBLXSA9IGF0LnVzZVN0YXRlKCExKSwgWiA9IGF0LnVzZVJlZihudWxsKSwgUSA9IGF0LnVzZVJlZih7XG4gICAgY29tbWVudDogbnVsbCxcbiAgICByZWNhc3Q6IG51bGwsXG4gICAgbGlrZTogbnVsbFxuICB9KTtcbiAgbXQoKCkgPT4ge1xuICAgIFIoZS5saWtlcy5zb21lKChWKSA9PiBWLmZpZCA9PT0gKGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZmlkKSkpLCBLKGUucmVjYXN0cy5zb21lKChWKSA9PiBWLmZpZCA9PT0gKGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZmlkKSkpO1xuICB9LCBbZSwgZl0pLCBtdCgoKSA9PiB7XG4gICAgY29uc3QgViA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFpuLk5FWU5BUl9BVVRIRU5USUNBVEVEX1VTRVIpO1xuICAgIGlmIChWKVxuICAgICAgdHJ5IHtcbiAgICAgICAgUChKU09OLnBhcnNlKFYpLnNpZ25lcl91dWlkKTtcbiAgICAgIH0gY2F0Y2ggKGVlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIEpTT04gZnJvbSBsb2NhbCBzdG9yYWdlOlwiLCBlZSksIFAobnVsbCk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgY29uc29sZS53YXJuKFwiTm8gTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUiBmb3VuZCBpbiBsb2NhbCBzdG9yYWdlLlwiKTtcbiAgfSwgW3ZdKSwgbXQoKCkgPT4ge1xuICAgIChDIHx8IHYpICYmIHggJiYgYighMSk7XG4gIH0sIFtDLCB2LCB4XSk7XG4gIGNvbnN0IGogPSBhc3luYyAoViwgZWUpID0+IHtcbiAgICBpZiAoQylcbiAgICAgIHN3aXRjaCAoZWUpIHtcbiAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICBpZiAocilcbiAgICAgICAgICAgIHIoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb21tZW50IGhhbmRsZXIgZnVuY3Rpb24gcHJvdmlkZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWNhc3RcIjpcbiAgICAgICAgICBpZiAobilcbiAgICAgICAgICAgIEsobigpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWNhc3QgaGFuZGxlciBmdW5jdGlvbiBwcm92aWRlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxpa2VcIjpcbiAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgIFIobygpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBsaWtlIGhhbmRsZXIgZnVuY3Rpb24gcHJvdmlkZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY29uc3QgRyA9IFEuY3VycmVudFtlZV07XG4gICAgaWYgKEcpIHtcbiAgICAgIGNvbnN0IE4gPSBHLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBPID0gWi5jdXJyZW50O1xuICAgICAgaWYgKE8pIHtcbiAgICAgICAgY29uc3QgTCA9IE8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIFQoe1xuICAgICAgICAgIHRvcDogTi50b3AgLSBMLmhlaWdodCAtIDEwLFxuICAgICAgICAgIGxlZnQ6IE4ubGVmdCArIE4ud2lkdGggLyAyIC0gTC53aWR0aCAvIDJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFUuanN4cyhPbSwge1xuICAgIGNoaWxkcmVuOiBbeCAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKGptLCB7XG4gICAgICByZWY6IFosXG4gICAgICBzdHlsZToge1xuICAgICAgICB0b3A6IFMudG9wLFxuICAgICAgICBsZWZ0OiBTLmxlZnRcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChGbSwge1xuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFUuanN4KGZtLCB7XG4gICAgICAgICAgdmFyaWFudDogd3IuTkVZTkFSXG4gICAgICAgIH0pXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4KERtLCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goVWwsIHtcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBiKCExKSxcbiAgICAgICAgICBzaXplOiAxNlxuICAgICAgICB9KVxuICAgICAgfSldXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChWdCwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFZ0LCB7XG4gICAgICAgIHNwYWNpbmdWZXJ0aWNhbDogXCIxNXB4XCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgZ2FwOiBcIjEwcHhcIlxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImRpdlwiLCB7XG4gICAgICAgICAgcmVmOiAoVikgPT4gUS5jdXJyZW50LmNvbW1lbnQgPSBWLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goQm0sIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IChWKSA9PiBqKFYsIFwiY29tbWVudFwiKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJkaXZcIiwge1xuICAgICAgICAgIHJlZjogKFYpID0+IFEuY3VycmVudC5yZWNhc3QgPSBWLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goUm0sIHtcbiAgICAgICAgICAgIGZpbGw6IHogPyBcImdyZWVuXCIgOiB2b2lkIDAsXG4gICAgICAgICAgICBvbkNsaWNrOiAoVikgPT4gaihWLCBcInJlY2FzdFwiKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJkaXZcIiwge1xuICAgICAgICAgIHJlZjogKFYpID0+IFEuY3VycmVudC5saWtlID0gVixcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFUuanN4KFRtLCB7XG4gICAgICAgICAgICBmaWxsOiBCID8gXCJyZWRcIiA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IChWKSA9PiBqKFYsIFwibGlrZVwiKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXVxuICAgICAgfSlcbiAgICB9KV1cbiAgfSk7XG59O1xuZnVuY3Rpb24gem0oe1xuICBvbkNsaWNrOiB0XG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJzdmdcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfSxcbiAgICB3aWR0aDogXCIxNlwiLFxuICAgIGhlaWdodDogXCIxNVwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDE2IDE1XCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBvbkNsaWNrOiAoZSkgPT4gdCA/IHQoZSkgOiB2b2lkIDAsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTUuMjAwMyA3LjQ5MDYzQzE0Ljc1MDQgNy40OTA2MyAxNC40NTA0IDcuNzkwNTcgMTQuNDUwNCA4LjI0MDQ4VjEyLjczOTZDMTQuNDUwNCAxMy4xODk1IDE0LjE1MDUgMTMuNDg5NCAxMy43MDA2IDEzLjQ4OTRIMy4yMDI2OEMyLjc1Mjc3IDEzLjQ4OTQgMi40NTI4MyAxMy4xODk1IDIuNDUyODMgMTIuNzM5NlY4LjI0MDQ4QzIuNDUyODMgNy43OTA1NyAyLjE1Mjg5IDcuNDkwNjMgMS43MDI5OCA3LjQ5MDYzQzEuMjUzMDcgNy40OTA2MyAwLjk1MzEyNSA3Ljc5MDU3IDAuOTUzMTI1IDguMjQwNDhWMTIuNzM5NkMwLjk1MzEyNSAxNC4wMTQzIDEuOTI3OTMgMTQuOTg5MSAzLjIwMjY4IDE0Ljk4OTFIMTMuNzAwNkMxNC45NzUzIDE0Ljk4OTEgMTUuOTUwMSAxNC4wMTQzIDE1Ljk1MDEgMTIuNzM5NlY4LjI0MDQ4QzE1Ljk1MDEgNy43OTA1NyAxNS42NTAyIDcuNDkwNjMgMTUuMjAwMyA3LjQ5MDYzWk01Ljk3NzEzIDQuMjY2MjdMNy43MDE3OCAyLjU0MTYxVjkuNzQwMThDNy43MDE3OCAxMC4xOTAxIDguMDAxNzIgMTAuNDkgOC40NTE2MyAxMC40OUM4LjkwMTU1IDEwLjQ5IDkuMjAxNDkgMTAuMTkwMSA5LjIwMTQ5IDkuNzQwMThWMi41NDE2MUwxMC45MjYxIDQuMjY2MjdDMTEuMjI2MSA0LjU2NjIxIDExLjY3NiA0LjU2NjIxIDExLjk3NTkgNC4yNjYyN0MxMi4yNzU5IDMuOTY2MzMgMTIuMjc1OSAzLjUxNjQyIDExLjk3NTkgMy4yMTY0OEw4Ljk3NjUzIDAuMjE3MDczQzguOTAxNTUgMC4xNDIwODggOC44MjY1NiAwLjA2NzEwMzEgOC43NTE1NyAwLjA2NzEwMzFDOC42MDE2IC0wLjAwNzg4MjAyIDguMzc2NjUgLTAuMDA3ODgyMDIgOC4xNTE2OSAwLjA2NzEwMzFDOC4wNzY3MSAwLjA2NzEwMzEgOC4wMDE3MiAwLjE0MjA4OCA3LjkyNjc0IDAuMjE3MDczTDQuOTI3MzQgMy4yMTY0OEM0LjYyNzM5IDMuNTE2NDIgNC42MjczOSAzLjk2NjMzIDQuOTI3MzQgNC4yNjYyN0M1LjIyNzI4IDQuNTY2MjEgNS42NzcxOSA0LjU2NjIxIDUuOTc3MTMgNC4yNjYyN1pcIixcbiAgICAgIGZpbGw6IFwiI0EwQTNBRFwiXG4gICAgfSlcbiAgfSk7XG59XG5jb25zdCBBdSA9ICh7XG4gIHVybDogdFxufSkgPT4ge1xuICBjb25zdCBbZSwgcl0gPSBhdC51c2VTdGF0ZSghMSksIG4gPSBhc3luYyAobykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0KSwgcighMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByKCExKTtcbiAgICAgIH0sIDJlMyk7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjb3B5IHRoZSB0ZXh0IHRvIGNsaXBib2FyZDpcIiwgaSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFUuanN4KFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogZSA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInN2Z1wiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICBmaWxsOiBcImdyZWVuXCJcbiAgICAgIH0sXG4gICAgICB3aWR0aDogXCIxNlwiLFxuICAgICAgaGVpZ2h0OiBcIjE1XCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCAxNiAxNVwiLFxuICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJwYXRoXCIsIHtcbiAgICAgICAgZDogXCJNNS45OTk2NyAxMi44MTM2TDEuNzE5NjcgOC41MzM2NEwwLjU1OTY3MyA5LjY5MzY0TDUuOTk5NjcgMTUuMTMzNkwxNi40Mzk3IDQuNjkzNjRMMTUuMjc5NyAzLjUzMzY0TDUuOTk5NjcgMTIuODEzNlpcIlxuICAgICAgfSlcbiAgICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBVLmpzeCh6bSwge1xuICAgICAgb25DbGljazogblxuICAgIH0pXG4gIH0pO1xufSwgcW0gPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFwic3ZnXCIsIHtcbiAgd2lkdGg6IFwiMTBcIixcbiAgaGVpZ2h0OiBcIjEwXCIsXG4gIHZpZXdCb3g6IFwiMCAwIDEwIDEwXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTUuODU4NTUgMC41NTU2NjRIOC4zMTI4MU04LjMxMjgxIDAuNTU1NjY0VjIuNzM3NTRNOC4zMTI4MSAwLjU1NTY2NEw0LjMxNDQ1IDQuMTExMjJcIixcbiAgICBzdHJva2U6IFwiI0ZGRkZGRlwiLFxuICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgXCJmaWxsLXJ1bGVcIjogXCJldmVub2RkXCIsXG4gICAgXCJjbGlwLXJ1bGVcIjogXCJldmVub2RkXCIsXG4gICAgZDogXCJNMy4zMTQ0NSAxSDEuMzE0NDVDMC43NjIxNjggMSAwLjMxNDQ1MyAxLjQ0NzcyIDAuMzE0NDUzIDJWOEMwLjMxNDQ1MyA4LjU1MjI4IDAuNzYyMTY4IDkgMS4zMTQ0NSA5SDcuMzE0NDVDNy44NjY3NCA5IDguMzE0NDUgOC41NTIyOCA4LjMxNDQ1IDhWNkg3LjMxNDQ1VjhIMS4zMTQ0NVYySDMuMzE0NDVWMVpcIixcbiAgICBmaWxsOiBcIiNGRkZGRkZcIlxuICB9KV1cbn0pLCBabSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInN2Z1wiLCB7XG4gIHdpZHRoOiBcIjEwXCIsXG4gIGhlaWdodDogXCIxNFwiLFxuICB2aWV3Qm94OiBcIjAgMCAxMCAxNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTUuMDE0NTEgMTIuNTE4N0w0Ljk2ODMzIDEyLjUxNzRMNC45MzkxNCAxMi41MjJDNC45MzExMyAxMi41MTYgNC45MjQwMiAxMi41MDg3IDQuOTE4MDggMTIuNTAwNUw0LjUxMjMxIDEyLjc5MjZMNC45MTgwOCAxMi41MDA1QzQuOTA0OSAxMi40ODIyIDQuODk4MjQgMTIuNDYgNC44OTkxMyAxMi40Mzc1TDQuODk5NTMgMTIuNDI3NVYxMi40MTc2VjguODExOTRWOC4zMTE5NEg0LjM5OTUzSDEuODg3NkgxLjg4NzUzQzEuNzYxODggOC4zMTE5NiAxLjYzODUzIDguMjc4MjUgMS41MzAzNiA4LjIxNDMzQzEuNDIyMTggOC4xNTA0IDEuMzMzMTUgOC4wNTg2MiAxLjI3MjU2IDcuOTQ4NTRDMS4yMTE5NiA3LjgzODQ3IDEuMTgyMDMgNy43MTQxNSAxLjE4NTg4IDcuNTg4NTZDMS4xODk3MyA3LjQ2MzAxIDEuMjI3MiA3LjM0MDc5IDEuMjk0MzggNy4yMzQ2NkMxLjI5NDQgNy4yMzQ2MyAxLjI5NDQyIDcuMjM0NTkgMS4yOTQ0NCA3LjIzNDU2TDQuOTAwMDEgMS41NDM3N0w0LjkwNTY3IDEuNTM0ODNMNC45MTA5NSAxLjUyNTY3QzQuOTIyMjcgMS41MDYwMSA0LjkzOTg4IDEuNDkwNzQgNC45NjA5NCAxLjQ4MjMyQzQuOTgyIDEuNDczODkgNS4wMDUyOCAxLjQ3MjgxIDUuMDI3MDMgMS40NzkyNEw1LjAyOTEyIDEuNDc5ODVDNS4wNTA3NyAxLjQ4NjE0IDUuMDY5NjkgMS40OTk1IDUuMDgyODYgMS41MTc4QzUuMDk2MDMgMS41MzYwOSA1LjEwMjcgMS41NTgyNyA1LjEwMTggMS41ODA3OUw1LjEwMTQxIDEuNTkwNzNWMS42MDA2N1Y1LjIwNjMxVjUuNzA2MzFINS42MDE0MUg4LjExMzMzSDguMTEzNEM4LjIzOTA1IDUuNzA2MjkgOC4zNjI0IDUuNzQgOC40NzA1OCA1LjgwMzkyQzguNTc4NzUgNS44Njc4NCA4LjY2Nzc4IDUuOTU5NjMgOC43MjgzOCA2LjA2OTcxQzguNzg4OTcgNi4xNzk3OCA4LjgxODkxIDYuMzA0MSA4LjgxNTA2IDYuNDI5NjlDOC44MTEyMSA2LjU1NTI4IDguNzczNzEgNi42Nzc1MyA4LjcwNjQ5IDYuNzgzNjlMNS4xMDIzMiAxMi40NzIzQzUuMTAyMTkgMTIuNDcyNSA1LjEwMjA1IDEyLjQ3MjcgNS4xMDE5MSAxMi40NzI5QzUuMDkyNTUgMTIuNDg3MyA1LjA3OTY5IDEyLjQ5OSA1LjA2NDUyIDEyLjUwN0M1LjA0OTE0IDEyLjUxNTIgNS4wMzE5MSAxMi41MTkyIDUuMDE0NTEgMTIuNTE4N1pcIixcbiAgICBzdHJva2U6IFwiI0ZGRkZGRlwiXG4gIH0pXG59KSwgVm0gPSAvKiBAX19QVVJFX18gKi8gdWUoXCJidXR0b25cIikoe1xuICBjbGFzc2VzOiBbXCJmMWhtY3JyZlwiXVxufSksIEhtID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiZjFraTRpbDZcIl1cbn0pLCBLbSA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImJnbnowdWRcIl1cbn0pLCBXbSA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImltZ1wiKSh7XG4gIGNsYXNzZXM6IFtcImYxZ2JnZXQ5XCJdXG59KSwgR20gPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJmNHJ3ZTRpXCJdXG59KSwgWW0gPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJmMXFlbGxnd1wiXVxufSksIEptID0gLyogQF9fUFVSRV9fICovIHVlKFwiaW5wdXRcIikoe1xuICBjbGFzc2VzOiBbXCJpMWhneHdoaVwiXVxufSksIFhtID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiczFhaGNmYXhcIl1cbn0pLCBRbSA9ICgpID0+IHtcbiAgY29uc3QgdCA9IFJ0KG51bGwpO1xuICByZXR1cm4gbXQoKCkgPT4ge1xuICAgIGlmICh0LmN1cnJlbnQpIHtcbiAgICAgIGxldCBlID0gMDtcbiAgICAgIGNvbnN0IHIgPSAoKSA9PiB7XG4gICAgICAgIGUgKz0gNiwgdC5jdXJyZW50ICYmICh0LmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gYHJvdGF0ZSgke2V9ZGVnKWApLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocik7XG4gICAgICB9O1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpO1xuICAgIH1cbiAgfSwgW10pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJzdmdcIiwge1xuICAgIHJlZjogdCxcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGNsYXNzTmFtZTogXCJzaXplLTYgdGV4dC13aGl0ZVwiLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogXCIyNHB4XCIsXG4gICAgICBoZWlnaHQ6IFwiMjRweFwiXG4gICAgfSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFUuanN4KFwicGF0aFwiLCB7XG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgZDogXCJNMTYuMDIzIDkuMzQ4aDQuOTkydi0uMDAxTTIuOTg1IDE5LjY0NHYtNC45OTJtMCAwaDQuOTkybS00Ljk5MyAwIDMuMTgxIDMuMTgzYTguMjUgOC4yNSAwIDAgMCAxMy44MDMtMy43TTQuMDMxIDkuODY1YTguMjUgOC4yNSAwIDAgMSAxMy44MDMtMy43bDMuMTgxIDMuMTgybTAtNC45OTF2NC45OVwiXG4gICAgfSlcbiAgfSk7XG59O1xuZnVuY3Rpb24gZWcoe1xuICBudW1iZXI6IHQsXG4gIHRleHQ6IGUsXG4gIGFjdGlvblR5cGU6IHIsXG4gIHRhcmdldDogbixcbiAgZnJhbWVVcmw6IG8sXG4gIGhhbmRsZU9uQ2xpY2s6IGlcbn0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoVm0sIHtcbiAgICBvbkNsaWNrOiAoKSA9PiBpKHQpLFxuICAgIGNoaWxkcmVuOiBbZSwgKHIgPT09IFwibGlua1wiIHx8IHIgPT09IFwicG9zdF9yZWRpcmVjdFwiIHx8IHIgPT09IFwibWludFwiKSAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3gocW0sIHt9KSwgciA9PT0gXCJ0eFwiICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChabSwge30pXVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRnKHtcbiAgZnJhbWU6IHQsXG4gIG9uRnJhbWVCdG5QcmVzczogZVxufSkge1xuICB2YXIgVDtcbiAgY29uc3QgW3IsIG5dID0gcnQodCksIFtvLCBpXSA9IHJ0KFwiXCIpLCBbYywgZl0gPSBydCghMSksIHYgPSAoKSA9PiB7XG4gICAgY29uc3QgQyA9IHIuYnV0dG9ucy5tYXAoKFApID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChlZywge1xuICAgICAgbnVtYmVyOiBQLmluZGV4LFxuICAgICAgdGV4dDogUC50aXRsZSxcbiAgICAgIGFjdGlvblR5cGU6IFAuYWN0aW9uX3R5cGUsXG4gICAgICB0YXJnZXQ6IFAudGFyZ2V0LFxuICAgICAgZnJhbWVVcmw6IHQuZnJhbWVzX3VybCxcbiAgICAgIGhhbmRsZU9uQ2xpY2s6IChCKSA9PiB7XG4gICAgICAgIGYoITApLCBlKEIsIHIsIG4sIG8pLmZpbmFsbHkoKCkgPT4gZighMSkpO1xuICAgICAgfVxuICAgIH0sIFAuaW5kZXgpKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFUuanN4KEttLCB7XG4gICAgICBjaGlsZHJlbjogQ1xuICAgIH0pO1xuICB9LCB4ID0gKEMpID0+IHtcbiAgICBpKEMpO1xuICB9LCBiID0gKEMpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoQykuaG9zdG5hbWUucmVwbGFjZShcInd3dy5cIiwgXCJcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH0sIFMgPSAoKSA9PiB7XG4gICAgc3dpdGNoIChyLmltYWdlX2FzcGVjdF9yYXRpbykge1xuICAgICAgY2FzZSBcIjE6MVwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFzcGVjdFJhdGlvOiBcIjEgLyAxXCJcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCIxLjkxOjFcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhc3BlY3RSYXRpbzogXCIxLjkxIC8gMVwiXG4gICAgICAgIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFzcGVjdFJhdGlvOiBcIjEuOTEgLyAxXCJcbiAgICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFUuRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoSG0sIHtcbiAgICAgIGNoaWxkcmVuOiBbYyAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3goWG0sIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChRbSwge30pXG4gICAgICB9KSwgci5mcmFtZXNfdXJsICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoVS5GcmFnbWVudCwge1xuICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImFcIiwge1xuICAgICAgICAgIGhyZWY6IHIuZnJhbWVzX3VybCxcbiAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFUuanN4KFdtLCB7XG4gICAgICAgICAgICBzcmM6IHIuaW1hZ2UsXG4gICAgICAgICAgICBhbHQ6IGBGcmFtZSBpbWFnZSBmb3IgJHtyLmZyYW1lc191cmx9YCxcbiAgICAgICAgICAgIHN0eWxlOiBTKClcbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgKChUID0gci5pbnB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IFQudGV4dCkgJiYgLyogQF9fUFVSRV9fICovIFUuanN4KEptLCB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IHIuaW5wdXQudGV4dCxcbiAgICAgICAgICB2YWx1ZTogbyxcbiAgICAgICAgICBvbkNoYW5nZTogKEMpID0+IHgoQy50YXJnZXQudmFsdWUpXG4gICAgICAgIH0pLCB2KCldXG4gICAgICB9KV1cbiAgICB9KSwgci5mcmFtZXNfdXJsICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChHbSwge1xuICAgICAgY2hpbGRyZW46IGIoci5mcmFtZXNfdXJsKVxuICAgIH0pXVxuICB9KTtcbn1cbmNvbnN0IHJnID0gKHtcbiAgZnJhbWU6IHQsXG4gIG9uRnJhbWVCdG5QcmVzczogZVxufSkgPT4gLyogQF9fUFVSRV9fICovIFUuanN4KFltLCB7XG4gIGNoaWxkcmVuOiB0ID8gLyogQF9fUFVSRV9fICovIFUuanN4KHRnLCB7XG4gICAgZnJhbWU6IHQsXG4gICAgb25GcmFtZUJ0blByZXNzOiBlXG4gIH0pIDogLyogQF9fUFVSRV9fICovIFUuanN4KFUuRnJhZ21lbnQsIHt9KVxufSksIG5nID0gKHtcbiAgdXJsOiB0LFxuICBvbkZyYW1lQnRuUHJlc3M6IGUsXG4gIGluaXRpYWxGcmFtZTogclxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xpZW50X2lkOiBuLFxuICAgIHNob3dUb2FzdDogb1xuICB9ID0gbHIoKSwgW2ldID0gX2EoWm4uTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUiwgbnVsbCksIFtjLCBmXSA9IHJ0KG51bGwpLCBbdiwgeF0gPSBydChyIHx8IG51bGwpLCBbYiwgU10gPSBydChudWxsKTtcbiAgbXQoKCkgPT4ge1xuICAgIGkgPyBmKGkuc2lnbmVyX3V1aWQpIDogY29uc29sZS53YXJuKFwiTm8gTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUiBmb3VuZCBpbiBsb2NhbCBzdG9yYWdlLlwiKTtcbiAgfSwgW2ldKSwgbXQoKCkgPT4ge1xuICAgIHIgfHwgKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IEIgPSBhd2FpdCBpZyhgJHtnbn0vdjIvZmFyY2FzdGVyL2ZyYW1lL2NyYXdsP3VybD0ke3R9JmNsaWVudF9pZD0ke259YCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKEIub2spIHtcbiAgICAgICAgICBjb25zdCB6ID0gKGF3YWl0IEIuanNvbigpKS5mcmFtZTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoeikubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZnJhbWUgZGF0YSBhdmFpbGFibGVcIik7XG4gICAgICAgICAgeCh6KSwgUyhudWxsKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7Qi5zdGF0dXN9YCk7XG4gICAgICB9IGNhdGNoIChCKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkOiAke0J9YCksIFMoYEZhaWxlZCB0byBmZXRjaDogJHtCLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfSwgW3QsIG8sIHJdKTtcbiAgY29uc3QgVCA9IChQKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBQICE9IFwib2JqZWN0XCIgfHwgUCA9PT0gbnVsbCkgcmV0dXJuICExO1xuICAgIGNvbnN0IEIgPSBbXCJ2ZXJzaW9uXCIsIFwiaW1hZ2VcIiwgXCJidXR0b25zXCIsIFwiZnJhbWVzX3VybFwiXTtcbiAgICBmb3IgKGNvbnN0IFIgb2YgQilcbiAgICAgIGlmICghKFIgaW4gUCkpIHJldHVybiAhMTtcbiAgICByZXR1cm4gISghQXJyYXkuaXNBcnJheShQLmJ1dHRvbnMpIHx8IFAuYnV0dG9ucy5zb21lKChSKSA9PiB0eXBlb2YgUi5pbmRleCAhPSBcIm51bWJlclwiKSk7XG4gIH0sIEMgPSBhc3luYyAoUCwgQiwgUiwgeikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBLID0gYXdhaXQgZShQLCBCLCBSLCB6KTtcbiAgICAgIGlmICghVChLKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBmcmFtZSBkYXRhIHJlY2VpdmVkXCIpO1xuICAgICAgUihLKTtcbiAgICB9IGNhdGNoIChLKSB7XG4gICAgICBvKElsLkVycm9yLCBgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcHJvY2Vzc2luZyB0aGUgYnV0dG9uIHByZXNzOiAke0t9YCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYiA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgcGFkZGluZzogXCIxMHB4XCIsXG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJlZFwiLFxuICAgICAgYm9yZGVyUmFkaXVzOiBcIjVweFwiXG4gICAgfSxcbiAgICBjaGlsZHJlbjogYlxuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChyZywge1xuICAgIGZyYW1lOiB2LFxuICAgIG9uRnJhbWVCdG5QcmVzczogQ1xuICB9KTtcbn07XG5mdW5jdGlvbiBpZyh0LCBlLCByID0gOGUzKSB7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3luKHQsIGUpLCBuZXcgUHJvbWlzZSgobiwgbykgPT4gc2V0VGltZW91dCgoKSA9PiBvKG5ldyBFcnJvcihcIlJlcXVlc3QgdGltZWQgb3V0XCIpKSwgcikpXSk7XG59XG5mdW5jdGlvbiBrdSh0KSB7XG4gIGNvbnN0IGUgPSBNYXRoLm1pbih0LCAxZTkpO1xuICByZXR1cm4gZSA+PSAxZTkgPyBNYXRoLmZsb29yKGUgLyAxZTgpIC8gMTAgKyBcIkJcIiA6IGUgPj0gMWU2ID8gTWF0aC5mbG9vcihlIC8gMWU1KSAvIDEwICsgXCJNXCIgOiBlID49IDFlMyA/IE1hdGguZmxvb3IoZSAvIDEwMCkgLyAxMCArIFwiS1wiIDogZS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gc2codCkge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogVGltZXN0YW1wIGlzIHVuZGVmaW5lZCBvciBlbXB0eS5cIiksIFwiSW52YWxpZCB0aW1lc3RhbXBcIjtcbiAgY29uc3QgZSA9IG5ldyBEYXRlKHQpO1xuICBpZiAoaXNOYU4oZS5nZXRUaW1lKCkpKVxuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3I6IEludmFsaWQgdGltZXN0YW1wIHByb3ZpZGVkOlwiLCB0KSwgXCJJbnZhbGlkIHRpbWVzdGFtcFwiO1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIG8gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh2b2lkIDAsIHtcbiAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIGhvdXIxMjogITBcbiAgfSkuZm9ybWF0KGUpLnJlcGxhY2UoXCIgXCIsIFwiXCIpLCBpID0gci50b0RhdGVTdHJpbmcoKSA9PT0gZS50b0RhdGVTdHJpbmcoKSwgYyA9IG5ldyBEYXRlKHIuc2V0RGF0ZShyLmdldERhdGUoKSAtIDEpKS50b0RhdGVTdHJpbmcoKSA9PT0gZS50b0RhdGVTdHJpbmcoKTtcbiAgaWYgKGkpXG4gICAgcmV0dXJuIGAke299LCB0b2RheWA7XG4gIGlmIChjKVxuICAgIHJldHVybiBgJHtvfSwgeWVzdGVyZGF5YDtcbiAgY29uc3QgZiA9IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSwgdiA9IGUuZ2V0RGF0ZSgpLCB4ID0gZltlLmdldE1vbnRoKCldLCBiID0gZS5nZXRGdWxsWWVhcigpLCBUID0gYCR7eH0gJHsoKEMpID0+IHtcbiAgICBpZiAoQyA+IDMgJiYgQyA8IDIxKSByZXR1cm4gYCR7Q310aGA7XG4gICAgY29uc3QgUCA9IFtcInN0XCIsIFwibmRcIiwgXCJyZFwiXSwgQiA9IEMgJSAxMDtcbiAgICByZXR1cm4gYCR7Q30ke1BbQiAtIDFdIHx8IFwidGhcIn1gO1xuICB9KSh2KX0gJHtifWA7XG4gIHJldHVybiBgJHtvfSwgJHtUfWA7XG59XG5jb25zdCBvZyA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInN4cXZ4dnFcIl1cbn0pLCBhZyA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImFcIikoe1xuICBjbGFzc2VzOiBbXCJzM2thbW92XCJdXG59KSwgdWcgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJtMXdydnZoa1wiXVxufSksIGNnID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1widDFsY2FxMjdcIl1cbn0pLCBsZyA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInVndHAxd2hcIl1cbn0pLCBmZyA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImwxZHFwbjRlXCJdXG59KSwgaGcgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJsMWJqbnYydFwiXVxufSksIEl1ID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiZTE1eWYxMjNcIl1cbn0pLCBkZyA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInJ4cmE5NGdcIl1cbn0pLCBCdSA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInMxd2hncXJzXCJdXG59KSwgUnMgPSBhdC5tZW1vKCh7XG4gIHVzZXJuYW1lOiB0LFxuICBkaXNwbGF5TmFtZTogZSxcbiAgYXZhdGFySW1nVXJsOiByLFxuICB0ZXh0OiBuID0gXCJcIixcbiAgaGFzaDogbyxcbiAgcmVhY3Rpb25zOiBpLFxuICByZXBsaWVzOiBjLFxuICBlbWJlZHM6IGYgPSBbXSxcbiAgZnJhbWVzOiB2ID0gW10sXG4gIGNoYW5uZWw6IHgsXG4gIHZpZXdlckZpZDogYixcbiAgaGFzUG93ZXJCYWRnZTogUyxcbiAgaXNFbWJlZDogVCA9ICEwLFxuICBhbGxvd1JlYWN0aW9uczogQyxcbiAgcmVuZGVyRW1iZWRzOiBQLFxuICByZW5kZXJGcmFtZXM6IEIsXG4gIG9uTGlrZUJ0blByZXNzOiBSLFxuICBvblJlY2FzdEJ0blByZXNzOiB6LFxuICBvbkNvbW1lbnRCdG5QcmVzczogSyxcbiAgb25GcmFtZUJ0blByZXNzOiBaLFxuICBkaXJlY3RfcmVwbGllczogUSxcbiAgY29udGFpbmVyU3R5bGVzOiBqLFxuICB0ZXh0U3R5bGVzOiBWLFxuICB0aW1lc3RhbXA6IGVlLFxuICBhcHBBdmF0YXJJbWdVcmw6IEdcbn0pID0+IHtcbiAgY29uc3QgW04sIE9dID0gcnQoaS5saWtlc19jb3VudCksIFtMLCBGXSA9IHJ0KGkubGlrZXMuc29tZSgoQSkgPT4gQS5maWQgPT09IGIpKSwgZCA9IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChoZywge1xuICAgIGNoaWxkcmVuOiBtbShuLCBmKVxuICB9KSwgcyA9IChmID09IG51bGwgPyB2b2lkIDAgOiBmLmxlbmd0aCkgPT09IDEsIHUgPSBUcigoKSA9PiB2Lm1hcCgoQSkgPT4gQS5mcmFtZXNfdXJsKSwgW3ZdKSwgaCA9IFRyKCgpID0+IGYuZmlsdGVyKChBKSA9PiAhdS5pbmNsdWRlcyhBLnVybCkpLCBbZiwgdV0pLCBnID0gX3QoKEEpID0+IHtcbiAgICBBLmN1cnJlbnRUYXJnZXQuc3JjID0gTGk7XG4gIH0sIFtdKTtcbiAgbXQoKCkgPT4ge1xuICAgIEYoaS5saWtlcy5zb21lKChBKSA9PiBBLmZpZCA9PT0gYikpO1xuICB9LCBbaS5saWtlcywgYl0pO1xuICBjb25zdCB3ID0gX3QoKCkgPT4gUiAmJiBSKCkgPyAoTygocCkgPT4gcCArIDEpLCBGKCFMKSwgITApIDogITEsIFtSXSksIF8gPSBJbShoLCBDLCBiKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChvZywge1xuICAgIHN0eWxlOiB7XG4gICAgICAuLi5qLFxuICAgICAgYm9yZGVyV2lkdGg6IFQgPyBcIjFweFwiIDogXCIwXCJcbiAgICB9LFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKEh0LCB7XG4gICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChWdCwge1xuICAgICAgICBzcGFjaW5nUmlnaHQ6IFwiMTBweFwiLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFUuanN4KEJzLCB7XG4gICAgICAgICAgc3JjOiByICYmIHIubGVuZ3RoID4gMCA/IHIgOiBMaSxcbiAgICAgICAgICBvbkVycm9yOiBnLFxuICAgICAgICAgIGxvYWRpbmc6IFwibGF6eVwiLFxuICAgICAgICAgIGFsdDogYCR7ZSA/PyBcIlNrZWxldG9uXCJ9IEF2YXRhcmBcbiAgICAgICAgfSlcbiAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3hzKHVnLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4KEh0LCB7XG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLFxuICAgICAgICAgIGZsZXhHcm93OiAxLFxuICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoT2wsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4cyhIdCwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInN0cm9uZ1wiLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGVcbiAgICAgICAgICAgICAgfSksIFwiIFwiLCBHICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChWdCwge1xuICAgICAgICAgICAgICAgIHNwYWNpbmdMZWZ0OiBcIjVweFwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJpbWdcIiwge1xuICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCIycHhcIixcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IFwiMC41cHhcIlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJib3JkZXItd2hpdGUgcm91bmRlZC1mdWxsXCIsXG4gICAgICAgICAgICAgICAgICBzcmM6IEcsXG4gICAgICAgICAgICAgICAgICB3aWR0aDogXCIxOFwiLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjE4XCIsXG4gICAgICAgICAgICAgICAgICBvbkVycm9yOiAoQSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBBLmN1cnJlbnRUYXJnZXQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoSHQsIHtcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3hzKGxnLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcIkBcIiwgdCwgXCIgwrdcIl1cbiAgICAgICAgICAgICAgfSksIFwiIFwiLCAvKiBAX19QVVJFX18gKi8gVS5qc3goY2csIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogc2coZWUpXG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChWdCwge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goZmcsIHtcbiAgICAgICAgICAgIHN0eWxlOiBWLFxuICAgICAgICAgICAgY2hpbGRyZW46IGRcbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgUCAmJiBoICYmIGgubGVuZ3RoID4gMCA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChJdSwge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBtYXJnaW46IHMgPyBcIjRweCAwXCIgOiBcIjBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IF8ubWFwKChBLCBwKSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJkaXZcIiwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IEFcbiAgICAgICAgICB9LCBwKSlcbiAgICAgICAgfSkgOiAvKiBAX19QVVJFX18gKi8gVS5qc3goVS5GcmFnbWVudCwge30pLCBCICYmIHYgJiYgdi5sZW5ndGggPiAwID8gLyogQF9fUFVSRV9fICovIFUuanN4KEl1LCB7XG4gICAgICAgICAgY2hpbGRyZW46IHYubWFwKChBKSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3gobmcsIHtcbiAgICAgICAgICAgIHVybDogQS5mcmFtZXNfdXJsLFxuICAgICAgICAgICAgaW5pdGlhbEZyYW1lOiBBLFxuICAgICAgICAgICAgb25GcmFtZUJ0blByZXNzOiBaXG4gICAgICAgICAgfSwgQS5mcmFtZXNfdXJsKSlcbiAgICAgICAgfSkgOiBudWxsLCAvKiBAX19QVVJFX18gKi8gVS5qc3hzKGRnLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBDID8gXCJzcGFjZS1iZXR3ZWVuXCIgOiBcImZsZXgtZW5kXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBbQyAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3goJG0sIHtcbiAgICAgICAgICAgIGhhc2g6IG8sXG4gICAgICAgICAgICByZWFjdGlvbnM6IGksXG4gICAgICAgICAgICBvbkNvbW1lbnQ6IEssXG4gICAgICAgICAgICBvblJlY2FzdDogeixcbiAgICAgICAgICAgIG9uTGlrZTogdyxcbiAgICAgICAgICAgIGlzTGlrZWQ6IExcbiAgICAgICAgICB9KSwgQyAmJiB0ICYmIG8gJiYgLyogQF9fUFVSRV9fICovIFUuanN4KEF1LCB7XG4gICAgICAgICAgICB1cmw6IGBodHRwczovL2ZhcmNhc3Rlci54eXovJHt0fS8ke28uc2xpY2UoMCwgMTApfWBcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoQnUsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IEMgPyBcIlwiIDogXCJzcGFjZS1iZXR3ZWVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4cyhCdSwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IEMgPyBcIlwiIDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgICAgICAgICAgIGdhcDogNlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4cyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbYywgXCIgcmVwbGllc1wiXVxuICAgICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImRpdlwiLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIsK3XCJcbiAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtOLCBcIiBsaWtlc1wiXVxuICAgICAgICAgICAgfSksIHggJiYgLyogQF9fUFVSRV9fICovIFUuanN4cyhVLkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4KFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCLCt1wiXG4gICAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goYWcsIHtcbiAgICAgICAgICAgICAgICBocmVmOiBgaHR0cHM6Ly9mYXJjYXN0ZXIueHl6L34vY2hhbm5lbC8ke3guaWR9YCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHguaWRcbiAgICAgICAgICAgICAgfSldXG4gICAgICAgICAgICB9KV1cbiAgICAgICAgICB9KSwgIUMgJiYgdCAmJiBvICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChBdSwge1xuICAgICAgICAgICAgdXJsOiBgaHR0cHM6Ly9mYXJjYXN0ZXIueHl6LyR7dH0vJHtvLnNsaWNlKDAsIDEwKX1gXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pXVxuICAgICAgfSldXG4gICAgfSlcbiAgfSk7XG59KSwgcGcgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJzMW02b2IxYVwiXVxufSksIFJ1ID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wicjFlc2V2YzdcIl1cbn0pLCBUdSA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInZ4YjFmMDBcIl1cbn0pLCBtZyA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImh0djBxejdcIl1cbn0pLCBMdSA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInJ6a3N5MlwiXVxufSk7XG5mdW5jdGlvbiBnZyh0KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gVS5qc3gocGcsIHtcbiAgICBjaGlsZHJlbjogdC5jYXN0cy5tYXAoKGUsIHIpID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoUnUsIHtcbiAgICAgIGNoaWxkcmVuOiBbciAhPT0gMCAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3goVHUsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBsZWZ0OiBcIjQycHhcIlxuICAgICAgICB9XG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4cyhMdSwge1xuICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChScywge1xuICAgICAgICAgIGlzRW1iZWQ6ICExLFxuICAgICAgICAgIC4uLmVcbiAgICAgICAgfSksIHIgPT09IDAgJiYgLyogQF9fUFVSRV9fICovIFUuanN4KG1nLCB7fSksIGUuZGlyZWN0X3JlcGxpZXMgJiYgZS5kaXJlY3RfcmVwbGllcy5sZW5ndGggPiAwICYmIGUuZGlyZWN0X3JlcGxpZXMubWFwKChuLCBvKSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFJ1LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3goVHUsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGxlZnQ6IFwiNDJweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChMdSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChScywge1xuICAgICAgICAgICAgICBpc0VtYmVkOiAhMSxcbiAgICAgICAgICAgICAgLi4ublxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSwgbykpXVxuICAgICAgfSldXG4gICAgfSwgcikpXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24geWcoe1xuICB0eXBlOiB0LFxuICBpZGVudGlmaWVyOiBlLFxuICByZXBseURlcHRoOiByID0gMixcbiAgaW5jbHVkZUNocm9ub2xvZ2ljYWxQYXJlbnRDYXN0czogbiA9ICExLFxuICBsaW1pdDogbyA9IDIwLFxuICB2aWV3ZXJGaWQ6IGksXG4gIGNsaWVudElkOiBjXG59KSB7XG4gIHRyeSB7XG4gICAgbGV0IGYgPSBgJHtnbn0vdjIvZmFyY2FzdGVyL2Nhc3QvY29udmVyc2F0aW9uP2lkZW50aWZpZXI9JHtlbmNvZGVVUklDb21wb25lbnQoZSl9JnR5cGU9JHt0fSZyZXBseV9kZXB0aD0ke3J9JmluY2x1ZGVfY2hyb25vbG9naWNhbF9wYXJlbnRfY2FzdHM9JHtufSZsaW1pdD0ke299JmNsaWVudF9pZD0ke2N9YDtcbiAgICByZXR1cm4gaSAmJiAoZiArPSBgJnZpZXdlcl9maWQ9JHtpfWApLCBhd2FpdCAoYXdhaXQgeW4oZiwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9XG4gICAgfSkpLmpzb24oKSB8fCBudWxsO1xuICB9IGNhdGNoIChmKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBjb252ZXJzYXRpb25cIiwgZiksIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIEZsKHQpIHtcbiAgcmV0dXJuIHtcbiAgICB1c2VybmFtZTogdC5hdXRob3IudXNlcm5hbWUsXG4gICAgZGlzcGxheU5hbWU6IHQuYXV0aG9yLmRpc3BsYXlfbmFtZSxcbiAgICBhdmF0YXJJbWdVcmw6IHQuYXV0aG9yLnBmcF91cmwsXG4gICAgdGV4dDogdC50ZXh0LFxuICAgIGhhc2g6IHQuaGFzaCxcbiAgICByZWFjdGlvbnM6IHQucmVhY3Rpb25zLFxuICAgIHJlcGxpZXM6IHQucmVwbGllcy5jb3VudCxcbiAgICBlbWJlZHM6IHQuZW1iZWRzLFxuICAgIGZyYW1lczogdC5mcmFtZXMsXG4gICAgcmVuZGVyRW1iZWRzOiB0LnJlbmRlckVtYmVkcyxcbiAgICBjaGFubmVsOiB0LmNoYW5uZWwsXG4gICAgdmlld2VyRmlkOiAyLFxuICAgIGhhc1Bvd2VyQmFkZ2U6IHQuYXV0aG9yLnBvd2VyX2JhZGdlLFxuICAgIGFwcEF2YXRhckltZ1VybDogdC5hcHAucGZwX3VybCxcbiAgICBpc093blByb2ZpbGU6ICExLFxuICAgIGFsbG93UmVhY3Rpb25zOiAhMCxcbiAgICByZW5kZXJGcmFtZXM6ICExLFxuICAgIGRpcmVjdF9yZXBsaWVzOiB0LmRpcmVjdF9yZXBsaWVzID8gdC5kaXJlY3RfcmVwbGllcy5tYXAoRmwpIDogW10sXG4gICAgdGltZXN0YW1wOiB0LnRpbWVzdGFtcFxuICB9O1xufVxuZnVuY3Rpb24gdmcodCkge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiB0LmNhc3QgJiYgZS5wdXNoKEZsKHQuY2FzdCkpLCBlO1xufVxuY29uc3QgYXkgPSAoe1xuICB0eXBlOiB0LFxuICBpZGVudGlmaWVyOiBlLFxuICByZXBseURlcHRoOiByID0gMixcbiAgaW5jbHVkZUNocm9ub2xvZ2ljYWxQYXJlbnRDYXN0czogbiA9ICExLFxuICBsaW1pdDogbyA9IDIwLFxuICB2aWV3ZXJGaWQ6IGlcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGNsaWVudF9pZDogY1xuICB9ID0gbHIoKSwgW2YsIHZdID0gYXQudXNlU3RhdGUobnVsbCksIFt4LCBiXSA9IGF0LnVzZVN0YXRlKCEwKSwgW1MsIFRdID0gYXQudXNlU3RhdGUobnVsbCk7XG4gIHJldHVybiBhdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGIoITApLCBUKG51bGwpLCB5Zyh7XG4gICAgICB0eXBlOiB0LFxuICAgICAgaWRlbnRpZmllcjogZSxcbiAgICAgIHJlcGx5RGVwdGg6IHIsXG4gICAgICBpbmNsdWRlQ2hyb25vbG9naWNhbFBhcmVudENhc3RzOiBuLFxuICAgICAgbGltaXQ6IG8sXG4gICAgICB2aWV3ZXJGaWQ6IGksXG4gICAgICBjbGllbnRJZDogY1xuICAgIH0pLnRoZW4oKEMpID0+IHtcbiAgICAgIHYoQyk7XG4gICAgfSkuY2F0Y2goKEMpID0+IHtcbiAgICAgIFQoQyk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBiKCExKTtcbiAgICB9KTtcbiAgfSwgW3QsIGUsIHIsIG4sIG8sIGksIGNdKSwgeCA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChVLkZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFwiIFwiXG4gIH0pIDogUyA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChVLkZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFwiIFwiXG4gIH0pIDogLyogQF9fUFVSRV9fICovIFUuanN4KGdnLCB7XG4gICAgY2FzdHM6IHZnKGYuY29udmVyc2F0aW9uKVxuICB9KTtcbn07XG52YXIgd28gPSB7IGV4cG9ydHM6IHt9IH0sIHhvID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgT3U7XG5mdW5jdGlvbiB3ZygpIHtcbiAgaWYgKE91KSByZXR1cm4geG87XG4gIE91ID0gMTtcbiAgdmFyIHQgPSBhdDtcbiAgZnVuY3Rpb24gZShTLCBUKSB7XG4gICAgcmV0dXJuIFMgPT09IFQgJiYgKFMgIT09IDAgfHwgMSAvIFMgPT09IDEgLyBUKSB8fCBTICE9PSBTICYmIFQgIT09IFQ7XG4gIH1cbiAgdmFyIHIgPSB0eXBlb2YgT2JqZWN0LmlzID09IFwiZnVuY3Rpb25cIiA/IE9iamVjdC5pcyA6IGUsIG4gPSB0LnVzZVN0YXRlLCBvID0gdC51c2VFZmZlY3QsIGkgPSB0LnVzZUxheW91dEVmZmVjdCwgYyA9IHQudXNlRGVidWdWYWx1ZTtcbiAgZnVuY3Rpb24gZihTLCBUKSB7XG4gICAgdmFyIEMgPSBUKCksIFAgPSBuKHsgaW5zdDogeyB2YWx1ZTogQywgZ2V0U25hcHNob3Q6IFQgfSB9KSwgQiA9IFBbMF0uaW5zdCwgUiA9IFBbMV07XG4gICAgcmV0dXJuIGkoXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgQi52YWx1ZSA9IEMsIEIuZ2V0U25hcHNob3QgPSBULCB2KEIpICYmIFIoeyBpbnN0OiBCIH0pO1xuICAgICAgfSxcbiAgICAgIFtTLCBDLCBUXVxuICAgICksIG8oXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHYoQikgJiYgUih7IGluc3Q6IEIgfSksIFMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdihCKSAmJiBSKHsgaW5zdDogQiB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW1NdXG4gICAgKSwgYyhDKSwgQztcbiAgfVxuICBmdW5jdGlvbiB2KFMpIHtcbiAgICB2YXIgVCA9IFMuZ2V0U25hcHNob3Q7XG4gICAgUyA9IFMudmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBDID0gVCgpO1xuICAgICAgcmV0dXJuICFyKFMsIEMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB4KFMsIFQpIHtcbiAgICByZXR1cm4gVCgpO1xuICB9XG4gIHZhciBiID0gdHlwZW9mIHdpbmRvdyA+IFwidVwiIHx8IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgPiBcInVcIiB8fCB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPiBcInVcIiA/IHggOiBmO1xuICByZXR1cm4geG8udXNlU3luY0V4dGVybmFsU3RvcmUgPSB0LnVzZVN5bmNFeHRlcm5hbFN0b3JlICE9PSB2b2lkIDAgPyB0LnVzZVN5bmNFeHRlcm5hbFN0b3JlIDogYiwgeG87XG59XG52YXIgTnU7XG5mdW5jdGlvbiB4ZygpIHtcbiAgcmV0dXJuIE51IHx8IChOdSA9IDEsIHdvLmV4cG9ydHMgPSB3ZygpKSwgd28uZXhwb3J0cztcbn1cbnZhciBQbCA9IHhnKCk7XG5jb25zdCBEbCA9IDAsICRsID0gMSwgemwgPSAyLCBqdSA9IDM7XG52YXIgVXUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gJG8odCwgZSkge1xuICB2YXIgciwgbjtcbiAgaWYgKHQgPT09IGUpIHJldHVybiAhMDtcbiAgaWYgKHQgJiYgZSAmJiAociA9IHQuY29uc3RydWN0b3IpID09PSBlLmNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKHIgPT09IERhdGUpIHJldHVybiB0LmdldFRpbWUoKSA9PT0gZS5nZXRUaW1lKCk7XG4gICAgaWYgKHIgPT09IFJlZ0V4cCkgcmV0dXJuIHQudG9TdHJpbmcoKSA9PT0gZS50b1N0cmluZygpO1xuICAgIGlmIChyID09PSBBcnJheSkge1xuICAgICAgaWYgKChuID0gdC5sZW5ndGgpID09PSBlLmxlbmd0aClcbiAgICAgICAgZm9yICg7IG4tLSAmJiAkbyh0W25dLCBlW25dKTsgKSA7XG4gICAgICByZXR1cm4gbiA9PT0gLTE7XG4gICAgfVxuICAgIGlmICghciB8fCB0eXBlb2YgdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGZvciAociBpbiB0KVxuICAgICAgICBpZiAoVXUuY2FsbCh0LCByKSAmJiArK24gJiYgIVV1LmNhbGwoZSwgcikgfHwgIShyIGluIGUpIHx8ICEkbyh0W3JdLCBlW3JdKSkgcmV0dXJuICExO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA9PT0gbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHQgIT09IHQgJiYgZSAhPT0gZTtcbn1cbmNvbnN0IG5yID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEJyID0gKCkgPT4ge1xufSwgRXQgPSAoXG4gIC8qI19fTk9JTkxJTkVfXyovXG4gIEJyKClcbiksIHpvID0gT2JqZWN0LCBZZSA9ICh0KSA9PiB0ID09PSBFdCwgS3QgPSAodCkgPT4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiLCBVciA9ICh0LCBlKSA9PiAoe1xuICAuLi50LFxuICAuLi5lXG59KSwgcWwgPSAodCkgPT4gS3QodC50aGVuKSwgYm8gPSB7fSwgUWkgPSB7fSwgRWEgPSBcInVuZGVmaW5lZFwiLCB6aSA9IHR5cGVvZiB3aW5kb3cgIT0gRWEsIHFvID0gdHlwZW9mIGRvY3VtZW50ICE9IEVhLCBiZyA9IHppICYmIFwiRGVub1wiIGluIHdpbmRvdywgX2cgPSAoKSA9PiB6aSAmJiB0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAhPSBFYSwga3IgPSAodCwgZSkgPT4ge1xuICBjb25zdCByID0gbnIuZ2V0KHQpO1xuICByZXR1cm4gW1xuICAgIC8vIEdldHRlclxuICAgICgpID0+ICFZZShlKSAmJiB0LmdldChlKSB8fCBibyxcbiAgICAvLyBTZXR0ZXJcbiAgICAobikgPT4ge1xuICAgICAgaWYgKCFZZShlKSkge1xuICAgICAgICBjb25zdCBvID0gdC5nZXQoZSk7XG4gICAgICAgIGUgaW4gUWkgfHwgKFFpW2VdID0gbyksIHJbNV0oZSwgVXIobywgbiksIG8gfHwgYm8pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gU3Vic2NyaWJlclxuICAgIHJbNl0sXG4gICAgLy8gR2V0IHNlcnZlciBjYWNoZSBzbmFwc2hvdFxuICAgICgpID0+ICFZZShlKSAmJiBlIGluIFFpID8gUWlbZV0gOiAhWWUoZSkgJiYgdC5nZXQoZSkgfHwgYm9cbiAgXTtcbn07XG5sZXQgWm8gPSAhMDtcbmNvbnN0IEVnID0gKCkgPT4gWm8sIFtWbywgSG9dID0gemkgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyBbXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyLmJpbmQod2luZG93KSxcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXG5dIDogW1xuICBCcixcbiAgQnJcbl0sIE1nID0gKCkgPT4ge1xuICBjb25zdCB0ID0gcW8gJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlO1xuICByZXR1cm4gWWUodCkgfHwgdCAhPT0gXCJoaWRkZW5cIjtcbn0sIENnID0gKHQpID0+IChxbyAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0KSwgVm8oXCJmb2N1c1wiLCB0KSwgKCkgPT4ge1xuICBxbyAmJiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0KSwgSG8oXCJmb2N1c1wiLCB0KTtcbn0pLCBTZyA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgWm8gPSAhMCwgdCgpO1xuICB9LCByID0gKCkgPT4ge1xuICAgIFpvID0gITE7XG4gIH07XG4gIHJldHVybiBWbyhcIm9ubGluZVwiLCBlKSwgVm8oXCJvZmZsaW5lXCIsIHIpLCAoKSA9PiB7XG4gICAgSG8oXCJvbmxpbmVcIiwgZSksIEhvKFwib2ZmbGluZVwiLCByKTtcbiAgfTtcbn0sIEFnID0ge1xuICBpc09ubGluZTogRWcsXG4gIGlzVmlzaWJsZTogTWdcbn0sIGtnID0ge1xuICBpbml0Rm9jdXM6IENnLFxuICBpbml0UmVjb25uZWN0OiBTZ1xufSwgRnUgPSAhYXQudXNlSWQsIE9pID0gIXppIHx8IGJnLCBJZyA9ICh0KSA9PiBfZygpID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0KSA6IHNldFRpbWVvdXQodCwgMSksIG9zID0gT2kgPyBtdCA6IFFsLCBfbyA9IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IuY29ubmVjdGlvbiwgUHUgPSAhT2kgJiYgX28gJiYgKFtcbiAgXCJzbG93LTJnXCIsXG4gIFwiMmdcIlxuXS5pbmNsdWRlcyhfby5lZmZlY3RpdmVUeXBlKSB8fCBfby5zYXZlRGF0YSksIGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEVvID0gKHQsIGUpID0+IHpvLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpID09PSBgW29iamVjdCAke2V9XWA7XG5sZXQgQmcgPSAwO1xuY29uc3QgS28gPSAodCkgPT4ge1xuICBjb25zdCBlID0gdHlwZW9mIHQsIHIgPSBFbyh0LCBcIkRhdGVcIiksIG4gPSBFbyh0LCBcIlJlZ0V4cFwiKSwgbyA9IEVvKHQsIFwiT2JqZWN0XCIpO1xuICBsZXQgaSwgYztcbiAgaWYgKHpvKHQpID09PSB0ICYmICFyICYmICFuKSB7XG4gICAgaWYgKGkgPSBlcy5nZXQodCksIGkpIHJldHVybiBpO1xuICAgIGlmIChpID0gKytCZyArIFwiflwiLCBlcy5zZXQodCwgaSksIEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgIGZvciAoaSA9IFwiQFwiLCBjID0gMDsgYyA8IHQubGVuZ3RoOyBjKyspXG4gICAgICAgIGkgKz0gS28odFtjXSkgKyBcIixcIjtcbiAgICAgIGVzLnNldCh0LCBpKTtcbiAgICB9XG4gICAgaWYgKG8pIHtcbiAgICAgIGkgPSBcIiNcIjtcbiAgICAgIGNvbnN0IGYgPSB6by5rZXlzKHQpLnNvcnQoKTtcbiAgICAgIGZvciAoOyAhWWUoYyA9IGYucG9wKCkpOyApXG4gICAgICAgIFllKHRbY10pIHx8IChpICs9IGMgKyBcIjpcIiArIEtvKHRbY10pICsgXCIsXCIpO1xuICAgICAgZXMuc2V0KHQsIGkpO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgaSA9IHIgPyB0LnRvSlNPTigpIDogZSA9PSBcInN5bWJvbFwiID8gdC50b1N0cmluZygpIDogZSA9PSBcInN0cmluZ1wiID8gSlNPTi5zdHJpbmdpZnkodCkgOiBcIlwiICsgdDtcbiAgcmV0dXJuIGk7XG59LCBOaSA9ICh0KSA9PiB7XG4gIGlmIChLdCh0KSlcbiAgICB0cnkge1xuICAgICAgdCA9IHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHQgPSBcIlwiO1xuICAgIH1cbiAgY29uc3QgZSA9IHQ7XG4gIHJldHVybiB0ID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQgOiAoQXJyYXkuaXNBcnJheSh0KSA/IHQubGVuZ3RoIDogdCkgPyBLbyh0KSA6IFwiXCIsIFtcbiAgICB0LFxuICAgIGVcbiAgXTtcbn07XG5sZXQgUmcgPSAwO1xuY29uc3QgV28gPSAoKSA9PiArK1JnO1xuYXN5bmMgZnVuY3Rpb24gWmwoLi4udCkge1xuICBjb25zdCBbZSwgciwgbiwgb10gPSB0LCBpID0gVXIoe1xuICAgIHBvcHVsYXRlQ2FjaGU6ICEwLFxuICAgIHRocm93T25FcnJvcjogITBcbiAgfSwgdHlwZW9mIG8gPT0gXCJib29sZWFuXCIgPyB7XG4gICAgcmV2YWxpZGF0ZTogb1xuICB9IDogbyB8fCB7fSk7XG4gIGxldCBjID0gaS5wb3B1bGF0ZUNhY2hlO1xuICBjb25zdCBmID0gaS5yb2xsYmFja09uRXJyb3I7XG4gIGxldCB2ID0gaS5vcHRpbWlzdGljRGF0YTtcbiAgY29uc3QgeCA9IChUKSA9PiB0eXBlb2YgZiA9PSBcImZ1bmN0aW9uXCIgPyBmKFQpIDogZiAhPT0gITEsIGIgPSBpLnRocm93T25FcnJvcjtcbiAgaWYgKEt0KHIpKSB7XG4gICAgY29uc3QgVCA9IHIsIEMgPSBbXSwgUCA9IGUua2V5cygpO1xuICAgIGZvciAoY29uc3QgQiBvZiBQKVxuICAgICAgLy8gU2tpcCB0aGUgc3BlY2lhbCB1c2VTV1JJbmZpbml0ZSBhbmQgdXNlU1dSU3Vic2NyaXB0aW9uIGtleXMuXG4gICAgICAhL15cXCQoaW5mfHN1YilcXCQvLnRlc3QoQikgJiYgVChlLmdldChCKS5faykgJiYgQy5wdXNoKEIpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChDLm1hcChTKSk7XG4gIH1cbiAgcmV0dXJuIFMocik7XG4gIGFzeW5jIGZ1bmN0aW9uIFMoVCkge1xuICAgIGNvbnN0IFtDXSA9IE5pKFQpO1xuICAgIGlmICghQykgcmV0dXJuO1xuICAgIGNvbnN0IFtQLCBCXSA9IGtyKGUsIEMpLCBbUiwgeiwgSywgWl0gPSBuci5nZXQoZSksIFEgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkID0gUltDXTtcbiAgICAgIHJldHVybiAoS3QoaS5yZXZhbGlkYXRlKSA/IGkucmV2YWxpZGF0ZShQKCkuZGF0YSwgVCkgOiBpLnJldmFsaWRhdGUgIT09ICExKSAmJiAoZGVsZXRlIEtbQ10sIGRlbGV0ZSBaW0NdLCBkICYmIGRbMF0pID8gZFswXSh6bCkudGhlbigoKSA9PiBQKCkuZGF0YSkgOiBQKCkuZGF0YTtcbiAgICB9O1xuICAgIGlmICh0Lmxlbmd0aCA8IDMpXG4gICAgICByZXR1cm4gUSgpO1xuICAgIGxldCBqID0gbiwgVjtcbiAgICBjb25zdCBlZSA9IFdvKCk7XG4gICAgeltDXSA9IFtcbiAgICAgIGVlLFxuICAgICAgMFxuICAgIF07XG4gICAgY29uc3QgRyA9ICFZZSh2KSwgTiA9IFAoKSwgTyA9IE4uZGF0YSwgTCA9IE4uX2MsIEYgPSBZZShMKSA/IE8gOiBMO1xuICAgIGlmIChHICYmICh2ID0gS3QodikgPyB2KEYsIE8pIDogdiwgQih7XG4gICAgICBkYXRhOiB2LFxuICAgICAgX2M6IEZcbiAgICB9KSksIEt0KGopKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaiA9IGooRik7XG4gICAgICB9IGNhdGNoIChkKSB7XG4gICAgICAgIFYgPSBkO1xuICAgICAgfVxuICAgIGlmIChqICYmIHFsKGopKVxuICAgICAgaWYgKGogPSBhd2FpdCBqLmNhdGNoKChkKSA9PiB7XG4gICAgICAgIFYgPSBkO1xuICAgICAgfSksIGVlICE9PSB6W0NdWzBdKSB7XG4gICAgICAgIGlmIChWKSB0aHJvdyBWO1xuICAgICAgICByZXR1cm4gajtcbiAgICAgIH0gZWxzZSBWICYmIEcgJiYgeChWKSAmJiAoYyA9ICEwLCBCKHtcbiAgICAgICAgZGF0YTogRixcbiAgICAgICAgX2M6IEV0XG4gICAgICB9KSk7XG4gICAgaWYgKGMgJiYgIVYpXG4gICAgICBpZiAoS3QoYykpIHtcbiAgICAgICAgY29uc3QgZCA9IGMoaiwgRik7XG4gICAgICAgIEIoe1xuICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgZXJyb3I6IEV0LFxuICAgICAgICAgIF9jOiBFdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBCKHtcbiAgICAgICAgICBkYXRhOiBqLFxuICAgICAgICAgIGVycm9yOiBFdCxcbiAgICAgICAgICBfYzogRXRcbiAgICAgICAgfSk7XG4gICAgaWYgKHpbQ11bMV0gPSBXbygpLCBQcm9taXNlLnJlc29sdmUoUSgpKS50aGVuKCgpID0+IHtcbiAgICAgIEIoe1xuICAgICAgICBfYzogRXRcbiAgICAgIH0pO1xuICAgIH0pLCBWKSB7XG4gICAgICBpZiAoYikgdGhyb3cgVjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGo7XG4gIH1cbn1cbmNvbnN0IER1ID0gKHQsIGUpID0+IHtcbiAgZm9yIChjb25zdCByIGluIHQpXG4gICAgdFtyXVswXSAmJiB0W3JdWzBdKGUpO1xufSwgVGcgPSAodCwgZSkgPT4ge1xuICBpZiAoIW5yLmhhcyh0KSkge1xuICAgIGNvbnN0IHIgPSBVcihrZywgZSksIG4gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgbyA9IFpsLmJpbmQoRXQsIHQpO1xuICAgIGxldCBpID0gQnI7XG4gICAgY29uc3QgYyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBmID0gKGIsIFMpID0+IHtcbiAgICAgIGNvbnN0IFQgPSBjW2JdIHx8IFtdO1xuICAgICAgcmV0dXJuIGNbYl0gPSBULCBULnB1c2goUyksICgpID0+IFQuc3BsaWNlKFQuaW5kZXhPZihTKSwgMSk7XG4gICAgfSwgdiA9IChiLCBTLCBUKSA9PiB7XG4gICAgICB0LnNldChiLCBTKTtcbiAgICAgIGNvbnN0IEMgPSBjW2JdO1xuICAgICAgaWYgKEMpXG4gICAgICAgIGZvciAoY29uc3QgUCBvZiBDKVxuICAgICAgICAgIFAoUywgVCk7XG4gICAgfSwgeCA9ICgpID0+IHtcbiAgICAgIGlmICghbnIuaGFzKHQpICYmIChuci5zZXQodCwgW1xuICAgICAgICBuLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBvLFxuICAgICAgICB2LFxuICAgICAgICBmXG4gICAgICBdKSwgIU9pKSkge1xuICAgICAgICBjb25zdCBiID0gci5pbml0Rm9jdXMoc2V0VGltZW91dC5iaW5kKEV0LCBEdS5iaW5kKEV0LCBuLCBEbCkpKSwgUyA9IHIuaW5pdFJlY29ubmVjdChzZXRUaW1lb3V0LmJpbmQoRXQsIER1LmJpbmQoRXQsIG4sICRsKSkpO1xuICAgICAgICBpID0gKCkgPT4ge1xuICAgICAgICAgIGIgJiYgYigpLCBTICYmIFMoKSwgbnIuZGVsZXRlKHQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHgoKSwgW1xuICAgICAgdCxcbiAgICAgIG8sXG4gICAgICB4LFxuICAgICAgaVxuICAgIF07XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0LFxuICAgIG5yLmdldCh0KVs0XVxuICBdO1xufSwgTGcgPSAodCwgZSwgciwgbiwgbykgPT4ge1xuICBjb25zdCBpID0gci5lcnJvclJldHJ5Q291bnQsIGMgPSBvLnJldHJ5Q291bnQsIGYgPSB+figoTWF0aC5yYW5kb20oKSArIDAuNSkgKiAoMSA8PCAoYyA8IDggPyBjIDogOCkpKSAqIHIuZXJyb3JSZXRyeUludGVydmFsO1xuICAhWWUoaSkgJiYgYyA+IGkgfHwgc2V0VGltZW91dChuLCBmLCBvKTtcbn0sIE9nID0gJG8sIFtNYSwgTmddID0gVGcoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIGpnID0gVXIoXG4gIHtcbiAgICAvLyBldmVudHNcbiAgICBvbkxvYWRpbmdTbG93OiBCcixcbiAgICBvblN1Y2Nlc3M6IEJyLFxuICAgIG9uRXJyb3I6IEJyLFxuICAgIG9uRXJyb3JSZXRyeTogTGcsXG4gICAgb25EaXNjYXJkZWQ6IEJyLFxuICAgIC8vIHN3aXRjaGVzXG4gICAgcmV2YWxpZGF0ZU9uRm9jdXM6ICEwLFxuICAgIHJldmFsaWRhdGVPblJlY29ubmVjdDogITAsXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6ICEwLFxuICAgIHNob3VsZFJldHJ5T25FcnJvcjogITAsXG4gICAgLy8gdGltZW91dHNcbiAgICBlcnJvclJldHJ5SW50ZXJ2YWw6IFB1ID8gMWU0IDogNWUzLFxuICAgIGZvY3VzVGhyb3R0bGVJbnRlcnZhbDogNSAqIDFlMyxcbiAgICBkZWR1cGluZ0ludGVydmFsOiAyICogMWUzLFxuICAgIGxvYWRpbmdUaW1lb3V0OiBQdSA/IDVlMyA6IDNlMyxcbiAgICAvLyBwcm92aWRlcnNcbiAgICBjb21wYXJlOiBPZyxcbiAgICBpc1BhdXNlZDogKCkgPT4gITEsXG4gICAgY2FjaGU6IE1hLFxuICAgIG11dGF0ZTogTmcsXG4gICAgZmFsbGJhY2s6IHt9XG4gIH0sXG4gIC8vIHVzZSB3ZWIgcHJlc2V0IGJ5IGRlZmF1bHRcbiAgQWdcbiksIFVnID0gKHQsIGUpID0+IHtcbiAgY29uc3QgciA9IFVyKHQsIGUpO1xuICBpZiAoZSkge1xuICAgIGNvbnN0IHsgdXNlOiBuLCBmYWxsYmFjazogbyB9ID0gdCwgeyB1c2U6IGksIGZhbGxiYWNrOiBjIH0gPSBlO1xuICAgIG4gJiYgaSAmJiAoci51c2UgPSBuLmNvbmNhdChpKSksIG8gJiYgYyAmJiAoci5mYWxsYmFjayA9IFVyKG8sIGMpKTtcbiAgfVxuICByZXR1cm4gcjtcbn0sIEZnID0gSm8oe30pLCBWbCA9IFwiJGluZiRcIiwgSGwgPSB6aSAmJiB3aW5kb3cuX19TV1JfREVWVE9PTFNfVVNFX18sIFBnID0gSGwgPyB3aW5kb3cuX19TV1JfREVWVE9PTFNfVVNFX18gOiBbXSwgRGcgPSAoKSA9PiB7XG4gIEhsICYmICh3aW5kb3cuX19TV1JfREVWVE9PTFNfUkVBQ1RfXyA9IGF0KTtcbn0sIEtsID0gKHQpID0+IEt0KHRbMV0pID8gW1xuICB0WzBdLFxuICB0WzFdLFxuICB0WzJdIHx8IHt9XG5dIDogW1xuICB0WzBdLFxuICBudWxsLFxuICAodFsxXSA9PT0gbnVsbCA/IHRbMl0gOiB0WzFdKSB8fCB7fVxuXSwgJGcgPSAoKSA9PiBVcihqZywgWG8oRmcpKSwgemcgPSAodCkgPT4gKGUsIHIsIG4pID0+IHQoZSwgciAmJiAoKC4uLmkpID0+IHtcbiAgY29uc3QgW2NdID0gTmkoZSksIFssICwgLCBmXSA9IG5yLmdldChNYSk7XG4gIGlmIChjLnN0YXJ0c1dpdGgoVmwpKVxuICAgIHJldHVybiByKC4uLmkpO1xuICBjb25zdCB2ID0gZltjXTtcbiAgcmV0dXJuIFllKHYpID8gciguLi5pKSA6IChkZWxldGUgZltjXSwgdik7XG59KSwgbiksIHFnID0gUGcuY29uY2F0KHpnKSwgWmcgPSAodCkgPT4gZnVuY3Rpb24oLi4ucikge1xuICBjb25zdCBuID0gJGcoKSwgW28sIGksIGNdID0gS2wociksIGYgPSBVZyhuLCBjKTtcbiAgbGV0IHYgPSB0O1xuICBjb25zdCB7IHVzZTogeCB9ID0gZiwgYiA9ICh4IHx8IFtdKS5jb25jYXQocWcpO1xuICBmb3IgKGxldCBTID0gYi5sZW5ndGg7IFMtLTsgKVxuICAgIHYgPSBiW1NdKHYpO1xuICByZXR1cm4gdihvLCBpIHx8IGYuZmV0Y2hlciB8fCBudWxsLCBmKTtcbn0sIFZnID0gKHQsIGUsIHIpID0+IHtcbiAgY29uc3QgbiA9IGVbdF0gfHwgKGVbdF0gPSBbXSk7XG4gIHJldHVybiBuLnB1c2gociksICgpID0+IHtcbiAgICBjb25zdCBvID0gbi5pbmRleE9mKHIpO1xuICAgIG8gPj0gMCAmJiAobltvXSA9IG5bbi5sZW5ndGggLSAxXSwgbi5wb3AoKSk7XG4gIH07XG59LCBIZyA9ICh0LCBlKSA9PiAoLi4ucikgPT4ge1xuICBjb25zdCBbbiwgbywgaV0gPSBLbChyKSwgYyA9IChpLnVzZSB8fCBbXSkuY29uY2F0KGUpO1xuICByZXR1cm4gdChuLCBvLCB7XG4gICAgLi4uaSxcbiAgICB1c2U6IGNcbiAgfSk7XG59O1xuRGcoKTtcbmNvbnN0IE1vID0gYXQudXNlIHx8IC8vIFRoaXMgZXh0cmEgZ2VuZXJpYyBpcyB0byBhdm9pZCBUeXBlU2NyaXB0IG1peGluZyB1cCB0aGUgZ2VuZXJpYyBhbmQgSlNYIHN5dGF4XG4vLyBhbmQgZW1pdHRpbmcgYW4gZXJyb3IuXG4vLyBXZSBhc3N1bWUgdGhhdCB0aGlzIGlzIG9ubHkgZm9yIHRoZSBgdXNlKHRoZW5hYmxlKWAgY2FzZSwgbm90IGB1c2UoY29udGV4dClgLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYWVkMDBkYWNmYjc5ZDE3YzUzMjE4NDA0YzUyYjFjN2FhNTljNGE4OS9wYWNrYWdlcy9yZWFjdC1zZXJ2ZXIvc3JjL1JlYWN0Rml6elRoZW5hYmxlLmpzI0w0NVxuKCh0KSA9PiB7XG4gIHN3aXRjaCAodC5zdGF0dXMpIHtcbiAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgdGhyb3cgdDtcbiAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICByZXR1cm4gdC52YWx1ZTtcbiAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgIHRocm93IHQucmVhc29uO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyB0LnN0YXR1cyA9IFwicGVuZGluZ1wiLCB0LnRoZW4oKGUpID0+IHtcbiAgICAgICAgdC5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiLCB0LnZhbHVlID0gZTtcbiAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgIHQuc3RhdHVzID0gXCJyZWplY3RlZFwiLCB0LnJlYXNvbiA9IGU7XG4gICAgICB9KSwgdDtcbiAgfVxufSksIENvID0ge1xuICBkZWR1cGU6ICEwXG59LCBLZyA9ICh0LCBlLCByKSA9PiB7XG4gIGNvbnN0IHsgY2FjaGU6IG4sIGNvbXBhcmU6IG8sIHN1c3BlbnNlOiBpLCBmYWxsYmFja0RhdGE6IGMsIHJldmFsaWRhdGVPbk1vdW50OiBmLCByZXZhbGlkYXRlSWZTdGFsZTogdiwgcmVmcmVzaEludGVydmFsOiB4LCByZWZyZXNoV2hlbkhpZGRlbjogYiwgcmVmcmVzaFdoZW5PZmZsaW5lOiBTLCBrZWVwUHJldmlvdXNEYXRhOiBUIH0gPSByLCBbQywgUCwgQiwgUl0gPSBuci5nZXQobiksIFt6LCBLXSA9IE5pKHQpLCBaID0gUnQoITEpLCBRID0gUnQoITEpLCBqID0gUnQoeiksIFYgPSBSdChlKSwgZWUgPSBSdChyKSwgRyA9ICgpID0+IGVlLmN1cnJlbnQsIE4gPSAoKSA9PiBHKCkuaXNWaXNpYmxlKCkgJiYgRygpLmlzT25saW5lKCksIFtPLCBMLCBGLCBkXSA9IGtyKG4sIHopLCBzID0gUnQoe30pLmN1cnJlbnQsIHUgPSBZZShjKSA/IFllKHIuZmFsbGJhY2spID8gRXQgOiByLmZhbGxiYWNrW3pdIDogYywgaCA9IChYZSwgYWUpID0+IHtcbiAgICBmb3IgKGNvbnN0IGdlIGluIHMpIHtcbiAgICAgIGNvbnN0IGl0ID0gZ2U7XG4gICAgICBpZiAoaXQgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgIGlmICghbyhYZVtpdF0sIGFlW2l0XSkgJiYgKCFZZShYZVtpdF0pIHx8ICFvKGssIGFlW2l0XSkpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0gZWxzZSBpZiAoYWVbaXRdICE9PSBYZVtpdF0pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9LCBnID0gVHIoKCkgPT4ge1xuICAgIGNvbnN0IFhlID0gIXogfHwgIWUgPyAhMSA6IFllKGYpID8gRygpLmlzUGF1c2VkKCkgfHwgaSA/ICExIDogdiAhPT0gITEgOiBmLCBhZSA9ICh5ZSkgPT4ge1xuICAgICAgY29uc3QgYmUgPSBVcih5ZSk7XG4gICAgICByZXR1cm4gZGVsZXRlIGJlLl9rLCBYZSA/IHtcbiAgICAgICAgaXNWYWxpZGF0aW5nOiAhMCxcbiAgICAgICAgaXNMb2FkaW5nOiAhMCxcbiAgICAgICAgLi4uYmVcbiAgICAgIH0gOiBiZTtcbiAgICB9LCBnZSA9IE8oKSwgaXQgPSBkKCksIHdlID0gYWUoZ2UpLCBNZSA9IGdlID09PSBpdCA/IHdlIDogYWUoaXQpO1xuICAgIGxldCBmdCA9IHdlO1xuICAgIHJldHVybiBbXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHllID0gYWUoTygpKTtcbiAgICAgICAgcmV0dXJuIGgoeWUsIGZ0KSA/IChmdC5kYXRhID0geWUuZGF0YSwgZnQuaXNMb2FkaW5nID0geWUuaXNMb2FkaW5nLCBmdC5pc1ZhbGlkYXRpbmcgPSB5ZS5pc1ZhbGlkYXRpbmcsIGZ0LmVycm9yID0geWUuZXJyb3IsIGZ0KSA6IChmdCA9IHllLCB5ZSk7XG4gICAgICB9LFxuICAgICAgKCkgPT4gTWVcbiAgICBdO1xuICB9LCBbXG4gICAgbixcbiAgICB6XG4gIF0pLCB3ID0gUGwudXNlU3luY0V4dGVybmFsU3RvcmUoX3QoXG4gICAgKFhlKSA9PiBGKHosIChhZSwgZ2UpID0+IHtcbiAgICAgIGgoZ2UsIGFlKSB8fCBYZSgpO1xuICAgIH0pLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICBuLFxuICAgICAgelxuICAgIF1cbiAgKSwgZ1swXSwgZ1sxXSksIF8gPSAhWi5jdXJyZW50LCBBID0gQ1t6XSAmJiBDW3pdLmxlbmd0aCA+IDAsIHAgPSB3LmRhdGEsIGEgPSBZZShwKSA/IHUgJiYgcWwodSkgPyBNbyh1KSA6IHUgOiBwLCBsID0gdy5lcnJvciwgTSA9IFJ0KGEpLCBrID0gVCA/IFllKHApID8gWWUoTS5jdXJyZW50KSA/IGEgOiBNLmN1cnJlbnQgOiBwIDogYSwgJCA9IEEgJiYgIVllKGwpID8gITEgOiBfICYmICFZZShmKSA/IGYgOiBHKCkuaXNQYXVzZWQoKSA/ICExIDogaSA/IFllKGEpID8gITEgOiB2IDogWWUoYSkgfHwgdiwgWCA9ICEhKHogJiYgZSAmJiBfICYmICQpLCByZSA9IFllKHcuaXNWYWxpZGF0aW5nKSA/IFggOiB3LmlzVmFsaWRhdGluZywgc2UgPSBZZSh3LmlzTG9hZGluZykgPyBYIDogdy5pc0xvYWRpbmcsIHV0ID0gX3QoXG4gICAgYXN5bmMgKFhlKSA9PiB7XG4gICAgICBjb25zdCBhZSA9IFYuY3VycmVudDtcbiAgICAgIGlmICgheiB8fCAhYWUgfHwgUS5jdXJyZW50IHx8IEcoKS5pc1BhdXNlZCgpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBsZXQgZ2UsIGl0LCB3ZSA9ICEwO1xuICAgICAgY29uc3QgTWUgPSBYZSB8fCB7fSwgZnQgPSAhQlt6XSB8fCAhTWUuZGVkdXBlLCB5ZSA9ICgpID0+IEZ1ID8gIVEuY3VycmVudCAmJiB6ID09PSBqLmN1cnJlbnQgJiYgWi5jdXJyZW50IDogeiA9PT0gai5jdXJyZW50LCBiZSA9IHtcbiAgICAgICAgaXNWYWxpZGF0aW5nOiAhMSxcbiAgICAgICAgaXNMb2FkaW5nOiAhMVxuICAgICAgfSwgeHQgPSAoKSA9PiB7XG4gICAgICAgIEwoYmUpO1xuICAgICAgfSwgU2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN0ID0gQlt6XTtcbiAgICAgICAgY3QgJiYgY3RbMV0gPT09IGl0ICYmIGRlbGV0ZSBCW3pdO1xuICAgICAgfSwga2UgPSB7XG4gICAgICAgIGlzVmFsaWRhdGluZzogITBcbiAgICAgIH07XG4gICAgICBZZShPKCkuZGF0YSkgJiYgKGtlLmlzTG9hZGluZyA9ICEwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChmdCAmJiAoTChrZSksIHIubG9hZGluZ1RpbWVvdXQgJiYgWWUoTygpLmRhdGEpICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHdlICYmIHllKCkgJiYgRygpLm9uTG9hZGluZ1Nsb3coeiwgcik7XG4gICAgICAgIH0sIHIubG9hZGluZ1RpbWVvdXQpLCBCW3pdID0gW1xuICAgICAgICAgIGFlKEspLFxuICAgICAgICAgIFdvKClcbiAgICAgICAgXSksIFtnZSwgaXRdID0gQlt6XSwgZ2UgPSBhd2FpdCBnZSwgZnQgJiYgc2V0VGltZW91dChTZSwgci5kZWR1cGluZ0ludGVydmFsKSwgIUJbel0gfHwgQlt6XVsxXSAhPT0gaXQpXG4gICAgICAgICAgcmV0dXJuIGZ0ICYmIHllKCkgJiYgRygpLm9uRGlzY2FyZGVkKHopLCAhMTtcbiAgICAgICAgYmUuZXJyb3IgPSBFdDtcbiAgICAgICAgY29uc3QgY3QgPSBQW3pdO1xuICAgICAgICBpZiAoIVllKGN0KSAmJiAvLyBjYXNlIDFcbiAgICAgICAgKGl0IDw9IGN0WzBdIHx8IC8vIGNhc2UgMlxuICAgICAgICBpdCA8PSBjdFsxXSB8fCAvLyBjYXNlIDNcbiAgICAgICAgY3RbMV0gPT09IDApKVxuICAgICAgICAgIHJldHVybiB4dCgpLCBmdCAmJiB5ZSgpICYmIEcoKS5vbkRpc2NhcmRlZCh6KSwgITE7XG4gICAgICAgIGNvbnN0IF9lID0gTygpLmRhdGE7XG4gICAgICAgIGJlLmRhdGEgPSBvKF9lLCBnZSkgPyBfZSA6IGdlLCBmdCAmJiB5ZSgpICYmIEcoKS5vblN1Y2Nlc3MoZ2UsIHosIHIpO1xuICAgICAgfSBjYXRjaCAoY3QpIHtcbiAgICAgICAgU2UoKTtcbiAgICAgICAgY29uc3QgX2UgPSBHKCksIHsgc2hvdWxkUmV0cnlPbkVycm9yOiBFIH0gPSBfZTtcbiAgICAgICAgX2UuaXNQYXVzZWQoKSB8fCAoYmUuZXJyb3IgPSBjdCwgZnQgJiYgeWUoKSAmJiAoX2Uub25FcnJvcihjdCwgeiwgX2UpLCAoRSA9PT0gITAgfHwgS3QoRSkgJiYgRShjdCkpICYmICghRygpLnJldmFsaWRhdGVPbkZvY3VzIHx8ICFHKCkucmV2YWxpZGF0ZU9uUmVjb25uZWN0IHx8IE4oKSkgJiYgX2Uub25FcnJvclJldHJ5KGN0LCB6LCBfZSwgKG0pID0+IHtcbiAgICAgICAgICBjb25zdCB5ID0gQ1t6XTtcbiAgICAgICAgICB5ICYmIHlbMF0gJiYgeVswXShqdSwgbSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICByZXRyeUNvdW50OiAoTWUucmV0cnlDb3VudCB8fCAwKSArIDEsXG4gICAgICAgICAgZGVkdXBlOiAhMFxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdlID0gITEsIHh0KCksICEwO1xuICAgIH0sXG4gICAgLy8gYHNldFN0YXRlYCBpcyBpbW11dGFibGUsIGFuZCBgZXZlbnRzQ2FsbGJhY2tgLCBgZm5BcmdgLCBhbmRcbiAgICAvLyBga2V5VmFsaWRhdGluZ2AgYXJlIGRlcGVuZGluZyBvbiBga2V5YCwgc28gd2UgY2FuIGV4Y2x1ZGUgdGhlbSBmcm9tXG4gICAgLy8gdGhlIGRlcHMgYXJyYXkuXG4gICAgLy9cbiAgICAvLyBGSVhNRTpcbiAgICAvLyBgZm5gIGFuZCBgY29uZmlnYCBtaWdodCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgbGlmZWN5Y2xlLFxuICAgIC8vIGJ1dCB0aGV5IG1pZ2h0IGJlIGNoYW5nZWQgZXZlcnkgcmVuZGVyIGxpa2UgdGhpcy5cbiAgICAvLyBgdXNlU1dSKCdrZXknLCAoKSA9PiBmZXRjaCgnL2FwaS8nKSwgeyBzdXNwZW5zZTogdHJ1ZSB9KWBcbiAgICAvLyBTbyB3ZSBvbWl0IHRoZSB2YWx1ZXMgZnJvbSB0aGUgZGVwcyBhcnJheVxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0IG1pZ2h0IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICB6LFxuICAgICAgblxuICAgIF1cbiAgKSwgeGUgPSBfdChcbiAgICAvLyBVc2UgY2FsbGJhY2sgdG8gbWFrZSBzdXJlIGBrZXlSZWYuY3VycmVudGAgcmV0dXJucyBsYXRlc3QgcmVzdWx0IGV2ZXJ5IHRpbWVcbiAgICAoLi4uWGUpID0+IFpsKG4sIGouY3VycmVudCwgLi4uWGUpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXVxuICApO1xuICBpZiAob3MoKCkgPT4ge1xuICAgIFYuY3VycmVudCA9IGUsIGVlLmN1cnJlbnQgPSByLCBZZShwKSB8fCAoTS5jdXJyZW50ID0gcCk7XG4gIH0pLCBvcygoKSA9PiB7XG4gICAgaWYgKCF6KSByZXR1cm47XG4gICAgY29uc3QgWGUgPSB1dC5iaW5kKEV0LCBDbyk7XG4gICAgbGV0IGFlID0gMDtcbiAgICBHKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiYgKGFlID0gRGF0ZS5ub3coKSArIEcoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWwpO1xuICAgIGNvbnN0IGl0ID0gVmcoeiwgQywgKHdlLCBNZSA9IHt9KSA9PiB7XG4gICAgICBpZiAod2UgPT0gRGwpIHtcbiAgICAgICAgY29uc3QgZnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBHKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiYgZnQgPiBhZSAmJiBOKCkgJiYgKGFlID0gZnQgKyBHKCkuZm9jdXNUaHJvdHRsZUludGVydmFsLCBYZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAod2UgPT0gJGwpXG4gICAgICAgIEcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgJiYgTigpICYmIFhlKCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHdlID09IHpsKVxuICAgICAgICAgIHJldHVybiB1dCgpO1xuICAgICAgICBpZiAod2UgPT0ganUpXG4gICAgICAgICAgcmV0dXJuIHV0KE1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUS5jdXJyZW50ID0gITEsIGouY3VycmVudCA9IHosIFouY3VycmVudCA9ICEwLCBMKHtcbiAgICAgIF9rOiBLXG4gICAgfSksICQgJiYgKFllKGEpIHx8IE9pID8gWGUoKSA6IElnKFhlKSksICgpID0+IHtcbiAgICAgIFEuY3VycmVudCA9ICEwLCBpdCgpO1xuICAgIH07XG4gIH0sIFtcbiAgICB6XG4gIF0pLCBvcygoKSA9PiB7XG4gICAgbGV0IFhlO1xuICAgIGZ1bmN0aW9uIGFlKCkge1xuICAgICAgY29uc3QgaXQgPSBLdCh4KSA/IHgoTygpLmRhdGEpIDogeDtcbiAgICAgIGl0ICYmIFhlICE9PSAtMSAmJiAoWGUgPSBzZXRUaW1lb3V0KGdlLCBpdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZSgpIHtcbiAgICAgICFPKCkuZXJyb3IgJiYgKGIgfHwgRygpLmlzVmlzaWJsZSgpKSAmJiAoUyB8fCBHKCkuaXNPbmxpbmUoKSkgPyB1dChDbykudGhlbihhZSkgOiBhZSgpO1xuICAgIH1cbiAgICByZXR1cm4gYWUoKSwgKCkgPT4ge1xuICAgICAgWGUgJiYgKGNsZWFyVGltZW91dChYZSksIFhlID0gLTEpO1xuICAgIH07XG4gIH0sIFtcbiAgICB4LFxuICAgIGIsXG4gICAgUyxcbiAgICB6XG4gIF0pLCBlZihrKSwgaSAmJiBZZShhKSAmJiB6KSB7XG4gICAgaWYgKCFGdSAmJiBPaSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhbGxiYWNrIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBTdXNwZW5zZSBpbiBTU1IuXCIpO1xuICAgIFYuY3VycmVudCA9IGUsIGVlLmN1cnJlbnQgPSByLCBRLmN1cnJlbnQgPSAhMTtcbiAgICBjb25zdCBYZSA9IFJbel07XG4gICAgaWYgKCFZZShYZSkpIHtcbiAgICAgIGNvbnN0IGFlID0geGUoWGUpO1xuICAgICAgTW8oYWUpO1xuICAgIH1cbiAgICBpZiAoWWUobCkpIHtcbiAgICAgIGNvbnN0IGFlID0gdXQoQ28pO1xuICAgICAgWWUoaykgfHwgKGFlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIsIGFlLnZhbHVlID0gITApLCBNbyhhZSk7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBsO1xuICB9XG4gIHJldHVybiB7XG4gICAgbXV0YXRlOiB4ZSxcbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgIHJldHVybiBzLmRhdGEgPSAhMCwgaztcbiAgICB9LFxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgIHJldHVybiBzLmVycm9yID0gITAsIGw7XG4gICAgfSxcbiAgICBnZXQgaXNWYWxpZGF0aW5nKCkge1xuICAgICAgcmV0dXJuIHMuaXNWYWxpZGF0aW5nID0gITAsIHJlO1xuICAgIH0sXG4gICAgZ2V0IGlzTG9hZGluZygpIHtcbiAgICAgIHJldHVybiBzLmlzTG9hZGluZyA9ICEwLCBzZTtcbiAgICB9XG4gIH07XG59LCBXZyA9IFpnKEtnKSwgR2cgPSAoKSA9PiB7XG59LCBZZyA9IChcbiAgLyojX19OT0lOTElORV9fKi9cbiAgR2coKVxuKSwgR28gPSBPYmplY3QsICR1ID0gKHQpID0+IHQgPT09IFlnLCBKZyA9ICh0KSA9PiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIsIHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFNvID0gKHQsIGUpID0+IEdvLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpID09PSBgW29iamVjdCAke2V9XWA7XG5sZXQgWGcgPSAwO1xuY29uc3QgWW8gPSAodCkgPT4ge1xuICBjb25zdCBlID0gdHlwZW9mIHQsIHIgPSBTbyh0LCBcIkRhdGVcIiksIG4gPSBTbyh0LCBcIlJlZ0V4cFwiKSwgbyA9IFNvKHQsIFwiT2JqZWN0XCIpO1xuICBsZXQgaSwgYztcbiAgaWYgKEdvKHQpID09PSB0ICYmICFyICYmICFuKSB7XG4gICAgaWYgKGkgPSB0cy5nZXQodCksIGkpIHJldHVybiBpO1xuICAgIGlmIChpID0gKytYZyArIFwiflwiLCB0cy5zZXQodCwgaSksIEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgIGZvciAoaSA9IFwiQFwiLCBjID0gMDsgYyA8IHQubGVuZ3RoOyBjKyspXG4gICAgICAgIGkgKz0gWW8odFtjXSkgKyBcIixcIjtcbiAgICAgIHRzLnNldCh0LCBpKTtcbiAgICB9XG4gICAgaWYgKG8pIHtcbiAgICAgIGkgPSBcIiNcIjtcbiAgICAgIGNvbnN0IGYgPSBHby5rZXlzKHQpLnNvcnQoKTtcbiAgICAgIGZvciAoOyAhJHUoYyA9IGYucG9wKCkpOyApXG4gICAgICAgICR1KHRbY10pIHx8IChpICs9IGMgKyBcIjpcIiArIFlvKHRbY10pICsgXCIsXCIpO1xuICAgICAgdHMuc2V0KHQsIGkpO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgaSA9IHIgPyB0LnRvSlNPTigpIDogZSA9PSBcInN5bWJvbFwiID8gdC50b1N0cmluZygpIDogZSA9PSBcInN0cmluZ1wiID8gSlNPTi5zdHJpbmdpZnkodCkgOiBcIlwiICsgdDtcbiAgcmV0dXJuIGk7XG59LCBRZyA9ICh0KSA9PiB7XG4gIGlmIChKZyh0KSlcbiAgICB0cnkge1xuICAgICAgdCA9IHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHQgPSBcIlwiO1xuICAgIH1cbiAgY29uc3QgZSA9IHQ7XG4gIHJldHVybiB0ID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQgOiAoQXJyYXkuaXNBcnJheSh0KSA/IHQubGVuZ3RoIDogdCkgPyBZbyh0KSA6IFwiXCIsIFtcbiAgICB0LFxuICAgIGVcbiAgXTtcbn0sIGUyID0gKHQpID0+IFFnKHQgPyB0KDAsIG51bGwpIDogbnVsbClbMF0sIEFvID0gUHJvbWlzZS5yZXNvbHZlKCksIHQyID0gKHQpID0+IChlLCByLCBuKSA9PiB7XG4gIGNvbnN0IG8gPSBSdCghMSksIHsgY2FjaGU6IGksIGluaXRpYWxTaXplOiBjID0gMSwgcmV2YWxpZGF0ZUFsbDogZiA9ICExLCBwZXJzaXN0U2l6ZTogdiA9ICExLCByZXZhbGlkYXRlRmlyc3RQYWdlOiB4ID0gITAsIHJldmFsaWRhdGVPbk1vdW50OiBiID0gITEsIHBhcmFsbGVsOiBTID0gITEgfSA9IG4sIFssICwgLCBUXSA9IG5yLmdldChNYSk7XG4gIGxldCBDO1xuICB0cnkge1xuICAgIEMgPSBlMihlKSwgQyAmJiAoQyA9IFZsICsgQyk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIGNvbnN0IFtQLCBCLCBSXSA9IGtyKGksIEMpLCB6ID0gX3QoKCkgPT4gWWUoUCgpLl9sKSA/IGMgOiBQKCkuX2wsIFtcbiAgICBpLFxuICAgIEMsXG4gICAgY1xuICBdKTtcbiAgUGwudXNlU3luY0V4dGVybmFsU3RvcmUoX3QoXG4gICAgKEcpID0+IEMgPyBSKEMsICgpID0+IHtcbiAgICAgIEcoKTtcbiAgICB9KSA6ICgpID0+IHtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICBpLFxuICAgICAgQ1xuICAgIF1cbiAgKSwgeiwgeik7XG4gIGNvbnN0IEsgPSBfdCgoKSA9PiB7XG4gICAgY29uc3QgRyA9IFAoKS5fbDtcbiAgICByZXR1cm4gWWUoRykgPyBjIDogRztcbiAgfSwgW1xuICAgIEMsXG4gICAgY1xuICBdKSwgWiA9IFJ0KEsoKSk7XG4gIG9zKCgpID0+IHtcbiAgICBpZiAoIW8uY3VycmVudCkge1xuICAgICAgby5jdXJyZW50ID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEMgJiYgQih7XG4gICAgICBfbDogdiA/IFouY3VycmVudCA6IEsoKVxuICAgIH0pO1xuICB9LCBbXG4gICAgQyxcbiAgICBpXG4gIF0pO1xuICBjb25zdCBRID0gYiAmJiAhby5jdXJyZW50LCBqID0gdChDLCBhc3luYyAoRykgPT4ge1xuICAgIGNvbnN0IE4gPSBQKCkuX2ksIE8gPSBQKCkuX3I7XG4gICAgQih7XG4gICAgICBfcjogRXRcbiAgICB9KTtcbiAgICBjb25zdCBMID0gW10sIEYgPSBLKCksIFtkXSA9IGtyKGksIEcpLCBzID0gZCgpLmRhdGEsIHUgPSBbXTtcbiAgICBsZXQgaCA9IG51bGw7XG4gICAgZm9yIChsZXQgZyA9IDA7IGcgPCBGOyArK2cpIHtcbiAgICAgIGNvbnN0IFt3LCBfXSA9IE5pKGUoZywgUyA/IG51bGwgOiBoKSk7XG4gICAgICBpZiAoIXcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29uc3QgW0EsIHBdID0ga3IoaSwgdyk7XG4gICAgICBsZXQgYSA9IEEoKS5kYXRhO1xuICAgICAgY29uc3QgbCA9IGYgfHwgTiB8fCBZZShhKSB8fCB4ICYmICFnICYmICFZZShzKSB8fCBRIHx8IHMgJiYgIVllKHNbZ10pICYmICFuLmNvbXBhcmUoc1tnXSwgYSk7XG4gICAgICBpZiAociAmJiAodHlwZW9mIE8gPT0gXCJmdW5jdGlvblwiID8gTyhhLCBfKSA6IGwpKSB7XG4gICAgICAgIGNvbnN0IE0gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKCEodyBpbiBUKSlcbiAgICAgICAgICAgIGEgPSBhd2FpdCByKF8pO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgJCA9IFRbd107XG4gICAgICAgICAgICBkZWxldGUgVFt3XSwgYSA9IGF3YWl0ICQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHAoe1xuICAgICAgICAgICAgZGF0YTogYSxcbiAgICAgICAgICAgIF9rOiBfXG4gICAgICAgICAgfSksIExbZ10gPSBhO1xuICAgICAgICB9O1xuICAgICAgICBTID8gdS5wdXNoKE0pIDogYXdhaXQgTSgpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIExbZ10gPSBhO1xuICAgICAgUyB8fCAoaCA9IGEpO1xuICAgIH1cbiAgICByZXR1cm4gUyAmJiBhd2FpdCBQcm9taXNlLmFsbCh1Lm1hcCgoZykgPT4gZygpKSksIEIoe1xuICAgICAgX2k6IEV0XG4gICAgfSksIEw7XG4gIH0sIG4pLCBWID0gX3QoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICBmdW5jdGlvbihHLCBOKSB7XG4gICAgICBjb25zdCBPID0gdHlwZW9mIE4gPT0gXCJib29sZWFuXCIgPyB7XG4gICAgICAgIHJldmFsaWRhdGU6IE5cbiAgICAgIH0gOiBOIHx8IHt9LCBMID0gTy5yZXZhbGlkYXRlICE9PSAhMTtcbiAgICAgIHJldHVybiBDID8gKEwgJiYgKFllKEcpID8gQih7XG4gICAgICAgIF9pOiAhMCxcbiAgICAgICAgX3I6IE8ucmV2YWxpZGF0ZVxuICAgICAgfSkgOiBCKHtcbiAgICAgICAgX2k6ICExLFxuICAgICAgICBfcjogTy5yZXZhbGlkYXRlXG4gICAgICB9KSksIGFyZ3VtZW50cy5sZW5ndGggPyBqLm11dGF0ZShHLCB7XG4gICAgICAgIC4uLk8sXG4gICAgICAgIHJldmFsaWRhdGU6IExcbiAgICAgIH0pIDogai5tdXRhdGUoKSkgOiBBbztcbiAgICB9LFxuICAgIC8vIHN3ci5tdXRhdGUgaXMgYWx3YXlzIHRoZSBzYW1lIHJlZmVyZW5jZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICBDLFxuICAgICAgaVxuICAgIF1cbiAgKSwgZWUgPSBfdChcbiAgICAoRykgPT4ge1xuICAgICAgaWYgKCFDKSByZXR1cm4gQW87XG4gICAgICBjb25zdCBbLCBOXSA9IGtyKGksIEMpO1xuICAgICAgbGV0IE87XG4gICAgICBpZiAoS3QoRykgPyBPID0gRyhLKCkpIDogdHlwZW9mIEcgPT0gXCJudW1iZXJcIiAmJiAoTyA9IEcpLCB0eXBlb2YgTyAhPSBcIm51bWJlclwiKSByZXR1cm4gQW87XG4gICAgICBOKHtcbiAgICAgICAgX2w6IE9cbiAgICAgIH0pLCBaLmN1cnJlbnQgPSBPO1xuICAgICAgY29uc3QgTCA9IFtdLCBbRl0gPSBrcihpLCBDKTtcbiAgICAgIGxldCBkID0gbnVsbDtcbiAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgTzsgKytzKSB7XG4gICAgICAgIGNvbnN0IFt1XSA9IE5pKGUocywgZCkpLCBbaF0gPSBrcihpLCB1KSwgZyA9IHUgPyBoKCkuZGF0YSA6IEV0O1xuICAgICAgICBpZiAoWWUoZykpXG4gICAgICAgICAgcmV0dXJuIFYoRigpLmRhdGEpO1xuICAgICAgICBMLnB1c2goZyksIGQgPSBnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFYoTCk7XG4gICAgfSxcbiAgICAvLyBleGNsdWRlIGdldEtleSBmcm9tIHRoZSBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgIEMsXG4gICAgICBpLFxuICAgICAgVixcbiAgICAgIEtcbiAgICBdXG4gICk7XG4gIHJldHVybiB7XG4gICAgc2l6ZTogSygpLFxuICAgIHNldFNpemU6IGVlLFxuICAgIG11dGF0ZTogVixcbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgIHJldHVybiBqLmRhdGE7XG4gICAgfSxcbiAgICBnZXQgZXJyb3IoKSB7XG4gICAgICByZXR1cm4gai5lcnJvcjtcbiAgICB9LFxuICAgIGdldCBpc1ZhbGlkYXRpbmcoKSB7XG4gICAgICByZXR1cm4gai5pc1ZhbGlkYXRpbmc7XG4gICAgfSxcbiAgICBnZXQgaXNMb2FkaW5nKCkge1xuICAgICAgcmV0dXJuIGouaXNMb2FkaW5nO1xuICAgIH1cbiAgfTtcbn0sIHIyID0gSGcoV2csIHQyKSwgbjIgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJzZm1rcWNyXCJdXG59KSwgaTIgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJocmxkdGlvXCJdXG59KSwgczIgPSBWdSgoe1xuICBjYXN0czogdCxcbiAgY3Vyc29yOiBlXG59KSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3gobjIsIHtcbiAgY2hpbGRyZW46IHQubWFwKChyLCBuKSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKGF0LkZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3goUnMsIHtcbiAgICAgIGlzRW1iZWQ6ICExLFxuICAgICAgLi4uclxuICAgIH0pLCBuIDwgdC5sZW5ndGggLSAxICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChpMiwge30pXVxuICB9LCByLmhhc2gpKVxufSkpO1xuZnVuY3Rpb24gbzIodCkge1xuICByZXR1cm4gdCA/IHQubWFwKChlKSA9PiB7XG4gICAgdmFyIG4sIG8sIGksIGMsIGY7XG4gICAgY29uc3QgciA9IGUgIT0gbnVsbCAmJiBlLnJlcGxpZXMgJiYgdHlwZW9mIGUucmVwbGllcyA9PSBcIm9iamVjdFwiID8gTnVtYmVyKGUucmVwbGllcy5jb3VudCkgfHwgMCA6IE51bWJlcihlID09IG51bGwgPyB2b2lkIDAgOiBlLnJlcGxpZXMpIHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJuYW1lOiAoKG4gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmF1dGhvcikgPT0gbnVsbCA/IHZvaWQgMCA6IG4udXNlcm5hbWUpID8/IFwiXCIsXG4gICAgICBkaXNwbGF5TmFtZTogKChvID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5hdXRob3IpID09IG51bGwgPyB2b2lkIDAgOiBvLmRpc3BsYXlfbmFtZSkgPz8gXCJcIixcbiAgICAgIGF2YXRhckltZ1VybDogKChpID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5hdXRob3IpID09IG51bGwgPyB2b2lkIDAgOiBpLnBmcF91cmwpID8/IFwiXCIsXG4gICAgICB0ZXh0OiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS50ZXh0KSA/PyBcIlwiLFxuICAgICAgaGFzaDogKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaGFzaCkgPz8gXCJcIixcbiAgICAgIHJlYWN0aW9uczogKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucmVhY3Rpb25zKSA/PyBbXSxcbiAgICAgIHJlcGxpZXM6IHIsXG4gICAgICBlbWJlZHM6IChlID09IG51bGwgPyB2b2lkIDAgOiBlLmVtYmVkcykgPz8gW10sXG4gICAgICBmcmFtZXM6IChlID09IG51bGwgPyB2b2lkIDAgOiBlLmZyYW1lcykgPz8gW10sXG4gICAgICByZW5kZXJFbWJlZHM6IChlID09IG51bGwgPyB2b2lkIDAgOiBlLnJlbmRlckVtYmVkcykgPz8gITAsXG4gICAgICBjaGFubmVsOiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5jaGFubmVsKSA/PyBcIlwiLFxuICAgICAgdmlld2VyRmlkOiAyLFxuICAgICAgaGFzUG93ZXJCYWRnZTogKChjID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5hdXRob3IpID09IG51bGwgPyB2b2lkIDAgOiBjLnBvd2VyX2JhZGdlKSA/PyAhMSxcbiAgICAgIGFwcEF2YXRhckltZ1VybDogKChmID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5hcHApID09IG51bGwgPyB2b2lkIDAgOiBmLnBmcF91cmwpID8/IFwiXCIsXG4gICAgICBpc093blByb2ZpbGU6ICExLFxuICAgICAgYWxsb3dSZWFjdGlvbnM6ICEwLFxuICAgICAgcmVuZGVyRnJhbWVzOiAhMSxcbiAgICAgIHRpbWVzdGFtcDogZS50aW1lc3RhbXAgPz8gXCJcIlxuICAgIH07XG4gIH0pIDogW107XG59XG5jb25zdCBhMiA9ICh0KSA9PiB5bih0KS50aGVuKGFzeW5jIChlKSA9PiBhd2FpdCBlLmpzb24oKSksIHUyID0gKHQsIGUsIHIsIG4sIG8pID0+IHtcbiAgaWYgKGUgJiYgKCFlLmNhc3RzIHx8ICFlLmNhc3RzLmxlbmd0aCkpIHJldHVybiBudWxsO1xuICBsZXQgaSA9IGAke2dufS92Mi9mYXJjYXN0ZXIvZmVlZCR7ciA/IFwiXCIgOiBcIj9cIn1gO1xuICBjb25zdCBjID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICByICYmIChpICs9IGAke3J9P2ApLCBvICYmIChpICs9IGBjbGllbnRfaWQ9JHtvfWApLCBlICYmIChpICs9IGAmY3Vyc29yPSR7ZS5uZXh0LmN1cnNvcn1gKTtcbiAgY29uc3QgZiA9ICh2LCB4KSA9PiB7XG4gICAgeCAhPSBudWxsICYmICFpLmluY2x1ZGVzKGAke3Z9PWApICYmIGMuYXBwZW5kKHYsIFN0cmluZyh4KSk7XG4gIH07XG4gIGlmIChuKSB7XG4gICAgT2JqZWN0LmVudHJpZXMobikuZm9yRWFjaCgoW3gsIGJdKSA9PiB7XG4gICAgICBjb25zdCBTID0geC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxXyQyXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmKFMsIGIpO1xuICAgIH0pO1xuICAgIGNvbnN0IHYgPSBjLnRvU3RyaW5nKCk7XG4gICAgdiAmJiAoaSArPSBpLmluY2x1ZGVzKFwiP1wiKSA/IGAmJHt2fWAgOiBgPyR7dn1gKTtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXMobikubGVuZ3RoID4gMSlcbiAgICByZXR1cm4gaTtcbn0sIHV5ID0gKHtcbiAgcGF0aDogdCxcbiAgLi4uZVxufSkgPT4ge1xuICB2YXIgQztcbiAgY29uc3Qge1xuICAgIGNsaWVudF9pZDogclxuICB9ID0gbHIoKSwgbiA9IFJ0KG51bGwpLCBbbywgaV0gPSBydCghMSksIGMgPSBSdChudWxsKSwge1xuICAgIGRhdGE6IGYsXG4gICAgZXJyb3I6IHYsXG4gICAgc2l6ZTogeCxcbiAgICBzZXRTaXplOiBiLFxuICAgIGlzVmFsaWRhdGluZzogU1xuICB9ID0gcjIoKFAsIEIpID0+IHUyKFAsIEIsIHQsIGUsIHIpLCBhMiksIFQgPSBUcigoKSA9PiB7XG4gICAgaWYgKCFmKSByZXR1cm4gW107XG4gICAgY29uc3QgUCA9IGYuZmxhdE1hcCgoUikgPT4gKFIgPT0gbnVsbCA/IHZvaWQgMCA6IFIuY2FzdHMpID8/IFtdKSwgQiA9IEFycmF5LmZyb20obmV3IFNldChQLm1hcCgoUikgPT4gUi5oYXNoKSkpLm1hcCgoUikgPT4gUC5maW5kKCh6KSA9PiB6Lmhhc2ggPT09IFIpKTtcbiAgICByZXR1cm4gbzIoQik7XG4gIH0sIFtmXSk7XG4gIHJldHVybiBtdCgoKSA9PiAoYy5jdXJyZW50ICYmIGMuY3VycmVudC5kaXNjb25uZWN0KCksIGMuY3VycmVudCA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoUCkgPT4ge1xuICAgIHZhciBSLCB6O1xuICAgIGNvbnN0IFtCXSA9IFA7XG4gICAgQi5pc0ludGVyc2VjdGluZyAmJiAhbyAmJiAhUyAmJiBmICYmICgoeiA9IChSID0gZltmLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogUi5uZXh0KSAhPSBudWxsICYmIHouY3Vyc29yKSAmJiAoaSghMCksIGIoeCArIDEpLnRoZW4oKCkgPT4gaSghMSkpKTtcbiAgfSwge1xuICAgIHJvb3RNYXJnaW46IFwiMTAwcHhcIlxuICB9KSwgbi5jdXJyZW50ICYmIGMuY3VycmVudC5vYnNlcnZlKG4uY3VycmVudCksICgpID0+IHtcbiAgICBjLmN1cnJlbnQgJiYgYy5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgfSksIFtuLmN1cnJlbnQsIG8sIFMsIGYsIHhdKSwgdiA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IFwiRXJyb3IgZmV0Y2hpbmcgZmVlZCBkYXRhXCJcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogW1QubGVuZ3RoICE9PSAwID8gLyogQF9fUFVSRV9fICovIFUuanN4KHMyLCB7XG4gICAgICBjYXN0czogVCxcbiAgICAgIGN1cnNvcjogXCJcIlxuICAgIH0pIDogLyogQF9fUFVSRV9fICovIFUuanN4KFwiZGl2XCIsIHtcbiAgICAgIGNoaWxkcmVuOiAoQyA9IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGZbMF0pID09IG51bGwgPyB2b2lkIDAgOiBDLm1lc3NhZ2VcbiAgICB9KSwgUyAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZzogXCIxMHB4XCJcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoXCJzcGFuXCIsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBhbmltYXRpb246IFwiYmxpbmsgMS41cyBpbmZpbml0ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbXCJMb2FkaW5nXCIsIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInNwYW5cIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJkb3RzXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFwiLi4uXCJcbiAgICAgICAgfSldXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4KFwic3R5bGVcIiwge1xuICAgICAgICBjaGlsZHJlbjogYFxuICAgICAgICAgICAgICAgICAgICAgICAgQGtleWZyYW1lcyBibGluayB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCUgeyBvcGFjaXR5OiAxOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNTAlIHsgb3BhY2l0eTogMDsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMCUgeyBvcGFjaXR5OiAxOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgIH0pXVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJkaXZcIiwge1xuICAgICAgcmVmOiBuXG4gICAgfSldXG4gIH0pO1xufSwgYzIgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJidXR0b25cIikoe1xuICBjbGFzc2VzOiBbXCJiMWJxdWc4clwiXVxufSksIGwyID0gLyogQF9fUFVSRV9fICovIHVlKFwiYnV0dG9uXCIpKHtcbiAgY2xhc3NlczogW1wiYjFtcmE0NXdcIl1cbn0pLCB6dSA9IFwiaHR0cHM6Ly9mYXJjYXN0ZXIueHl6XCIsIFdsID0gLyhefFxccylcXC9cXHcrL2csIEdsID0gL0BcXHcrL2csIFlsID0gLygoaHR0cHM/OlxcL1xcLyk/KFthLXpBLVowLTkuLV0rXFwuW2EtekEtWl17Mix9KShcXC9bXlxcc10qKT8pL2csIHF1ID0gbmV3IFJlZ0V4cChgKCR7V2wuc291cmNlfSl8KCR7R2wuc291cmNlfSl8KCR7WWwuc291cmNlfSlgLCBcImdcIiksIGYyID0gKHQpID0+IFdsLnRlc3QodCkgPyBgJHt6dX0vfi9jaGFubmVsJHt0LnRyaW0oKX1gIDogR2wudGVzdCh0KSA/IGAke3p1fS8ke3Quc3Vic3RyaW5nKDEpfWAgOiBZbC50ZXN0KHQpID8gdC5zdGFydHNXaXRoKFwiaHR0cFwiKSA/IHQgOiBgaHR0cDovLyR7dH1gIDogXCJcIiwgaDIgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJhXCIpKHtcbiAgY2xhc3NlczogW1wic2J5OXdhMlwiXVxufSksIGQyID0gKHQpID0+IHtcbiAgaWYgKCF0KSByZXR1cm4gW107XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IHIgPSAwLCBuO1xuICBmb3IgKDsgKG4gPSBxdS5leGVjKHQpKSAhPT0gbnVsbDsgKSB7XG4gICAgY29uc3QgbyA9IG4uaW5kZXg7XG4gICAgciA8IG8gJiYgZS5wdXNoKHQuc2xpY2UociwgbykpO1xuICAgIGNvbnN0IGkgPSBmMihuWzBdKSwgYyA9IG5bMF0udHJpbSgpLnN0YXJ0c1dpdGgoXCIvXCIpO1xuICAgIGUucHVzaCgvKiBAX19QVVJFX18gKi8gVS5qc3goaDIsIHtcbiAgICAgIGhyZWY6IGksXG4gICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICBzdHlsZTogYyA/IHtcbiAgICAgICAgbWFyZ2luTGVmdDogMy41XG4gICAgICB9IDoge30sXG4gICAgICBjaGlsZHJlbjogblswXS50cmltKClcbiAgICB9LCBvKSksIHIgPSBxdS5sYXN0SW5kZXg7XG4gIH1cbiAgcmV0dXJuIHIgPCB0Lmxlbmd0aCAmJiBlLnB1c2godC5zbGljZShyKSksIGU7XG59LCBwMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInNkYWhtNThcIl1cbn0pLCBtMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcIm16aXF5eHBcIl1cbn0pLCBnMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInV6N3RwbWZcIl1cbn0pLCB5MiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInUxcnhsd2FjXCJdXG59KSwgWnUgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJwZ2M2eXFwXCJdXG59KSwgdjIgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ0b3JqZjlhXCJdXG59KSwgdzIgPSBWdSgoe1xuICBmaWQ6IHQsXG4gIHVzZXJuYW1lOiBlLFxuICBkaXNwbGF5TmFtZTogcixcbiAgYXZhdGFySW1nVXJsOiBuLFxuICBiaW86IG8sXG4gIGZvbGxvd2VyczogaSxcbiAgZm9sbG93aW5nOiBjLFxuICBoYXNQb3dlckJhZGdlOiBmLFxuICBpc0ZvbGxvd2luZzogdixcbiAgaXNPd25Qcm9maWxlOiB4LFxuICBvbkNhc3Q6IGIsXG4gIGNvbnRhaW5lclN0eWxlczogU1xufSkgPT4ge1xuICBjb25zdCBUID0gZDIobyksIEMgPSBUcigoKSA9PiBrdShjKSwgW2NdKSwgUCA9IFRyKCgpID0+IGt1KGkpLCBbaV0pLCBCID0gKCkgPT4ge1xuICAgIHdpbmRvdy5vcGVuKFwiaHR0cHM6Ly9mYXJjYXN0ZXIueHl6L34vc2V0dGluZ3NcIiwgXCJfYmxhbmtcIik7XG4gIH0sIFIgPSB7XG4gICAgY29sb3I6IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFMuY29sb3JcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMocDIsIHtcbiAgICBzdHlsZTogUyxcbiAgICBjaGlsZHJlbjogW3ggJiYgYiAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3hzKEh0LCB7XG4gICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLFxuICAgICAgc3BhY2luZ0JvdHRvbTogXCIyMHB4XCIsXG4gICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoeTIsIHtcbiAgICAgICAgc3R5bGU6IFMsXG4gICAgICAgIGNoaWxkcmVuOiBbXCJAXCIsIGVdXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4KGMyLCB7XG4gICAgICAgIG9uQ2xpY2s6IGIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNhc3RcIlxuICAgICAgfSldXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoSHQsIHtcbiAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4KFZ0LCB7XG4gICAgICAgIHNwYWNpbmdSaWdodDogXCIxMHB4XCIsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goQnMsIHtcbiAgICAgICAgICBzcmM6IG4gPz8gTGksXG4gICAgICAgICAgbG9hZGluZzogXCJsYXp5XCIsXG4gICAgICAgICAgYWx0OiBgJHtyID8/IFwiU2tlbGV0b25cIn0gQXZhdGFyYFxuICAgICAgICB9KVxuICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMobTIsIHtcbiAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3hzKEh0LCB7XG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLFxuICAgICAgICAgIGZsZXhHcm93OiAxLFxuICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4cyhPbCwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3goSHQsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInN0cm9uZ1wiLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHIgfHwgYCEke3R9YFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoSHQsIHtcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3hzKGcyLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IFMsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcIkBcIiwgZV1cbiAgICAgICAgICAgICAgfSksIHYgJiYgLyogQF9fUFVSRV9fICovIFUuanN4KHYyLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IFMsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRm9sbG93cyB5b3VcIlxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goSHQsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB4ICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChsMiwge1xuICAgICAgICAgICAgICBzdHlsZTogUyxcbiAgICAgICAgICAgICAgb25DbGljazogQixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRWRpdCBQcm9maWxlXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goVnQsIHtcbiAgICAgICAgICBzcGFjaW5nVmVydGljYWw6IFwiMTVweFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJkaXZcIiwge1xuICAgICAgICAgICAgc3R5bGU6IFMsXG4gICAgICAgICAgICBjaGlsZHJlbjogVFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3hzKEh0LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3hzKFp1LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInN0cm9uZ1wiLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBSLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogQ1xuICAgICAgICAgICAgfSksIFwiIFwiLCBcIkZvbGxvd2luZ1wiXVxuICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFp1LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInN0cm9uZ1wiLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBSLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogUFxuICAgICAgICAgICAgfSksIFwiIFwiLCBcIkZvbGxvd2Vyc1wiXVxuICAgICAgICAgIH0pXVxuICAgICAgICB9KV1cbiAgICAgIH0pXVxuICAgIH0pXVxuICB9KTtcbn0pO1xuYXN5bmMgZnVuY3Rpb24geDIoe1xuICBmaWQ6IHQsXG4gIHZpZXdlckZpZDogZSxcbiAgY2xpZW50SWQ6IHJcbn0pIHtcbiAgdmFyIG47XG4gIHRyeSB7XG4gICAgbGV0IG8gPSBgJHtnbn0vdjIvZmFyY2FzdGVyL3VzZXIvYnVsaz9jbGllbnRfaWQ9JHtyfSZmaWRzPSR7dH1gO1xuICAgIGUgJiYgKG8gKz0gYCZ2aWV3ZXJfZmlkPSR7ZX1gKTtcbiAgICBjb25zdCBjID0gYXdhaXQgKGF3YWl0IHluKG8pKS5qc29uKCk7XG4gICAgcmV0dXJuICgobiA9IGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMudXNlcnMpID09IG51bGwgPyB2b2lkIDAgOiBuWzBdKSA/PyBudWxsO1xuICB9IGNhdGNoIChvKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB1c2VyIGJ5IGZpZFwiLCBvKSwgbnVsbDtcbiAgfVxufVxuY29uc3QgY3kgPSAoe1xuICBmaWQ6IHQsXG4gIHZpZXdlckZpZDogZSxcbiAgY29udGFpbmVyU3R5bGVzOiByXG59KSA9PiB7XG4gIHZhciBUO1xuICBjb25zdCB7XG4gICAgY2xpZW50X2lkOiBuXG4gIH0gPSBscigpLCBbbywgaV0gPSBydChudWxsKSwgW2MsIGZdID0gcnQoITApLCBbdiwgeF0gPSBydChudWxsKSwgYiA9IChvID09IG51bGwgPyB2b2lkIDAgOiBvLmZpZCkgPT09IGU7XG4gIG10KCgpID0+IHtcbiAgICB0ICYmIChmKCEwKSwgeChudWxsKSwgeDIoe1xuICAgICAgZmlkOiB0LFxuICAgICAgdmlld2VyRmlkOiBlLFxuICAgICAgY2xpZW50SWQ6IG5cbiAgICB9KS50aGVuKChDKSA9PiB7XG4gICAgICBpKEMpO1xuICAgIH0pLmNhdGNoKChDKSA9PiB7XG4gICAgICB4KEMpO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgZighMSk7XG4gICAgfSkpO1xuICB9LCBbdCwgZV0pO1xuICBjb25zdCBTID0gX3QoKCkgPT4ge1xuICB9LCBbXSk7XG4gIHJldHVybiBjID8gLyogQF9fUFVSRV9fICovIFUuanN4KFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogXCJMb2FkaW5nLi4uXCJcbiAgfSkgOiAhbyB8fCB2ID8gLyogQF9fUFVSRV9fICovIFUuanN4KFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogXCJFcnJvciBmZXRjaGluZyB1c2VyIGRhdGFcIlxuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBVLmpzeCh3Miwge1xuICAgIGZpZDogdCxcbiAgICB1c2VybmFtZTogby51c2VybmFtZSxcbiAgICBkaXNwbGF5TmFtZTogby5kaXNwbGF5X25hbWUsXG4gICAgYXZhdGFySW1nVXJsOiBvLnBmcF91cmwsXG4gICAgYmlvOiBvLnByb2ZpbGUuYmlvLnRleHQsXG4gICAgZm9sbG93ZXJzOiBvLmZvbGxvd2VyX2NvdW50LFxuICAgIGZvbGxvd2luZzogby5mb2xsb3dpbmdfY291bnQsXG4gICAgaGFzUG93ZXJCYWRnZTogby5wb3dlcl9iYWRnZSxcbiAgICBpc093blByb2ZpbGU6IGIsXG4gICAgaXNGb2xsb3dpbmc6IChUID0gby52aWV3ZXJfY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IFQuZm9sbG93ZWRfYnksXG4gICAgb25DYXN0OiBTLFxuICAgIGNvbnRhaW5lclN0eWxlczogclxuICB9KTtcbn0sIGIyID0gLyogQF9fUFVSRV9fICovIHVlKFwidWxcIikoe1xuICBjbGFzc2VzOiBbXCJkMTJyeDRvbVwiXVxufSksIF8yID0gLyogQF9fUFVSRV9fICovIHVlKFwibGlcIikoe1xuICBjbGFzc2VzOiBbXCJscnBtNmxwXCJdXG59KSwgRTIgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJpbWdcIikoe1xuICBjbGFzc2VzOiBbXCJhMWU5aGczYlwiXVxufSksIE0yID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1widTFhcWF5MWlcIl1cbn0pLCBDMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImQxbTBuanFcIl1cbn0pLCBTMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInUxbHZsYnVvXCJdXG59KSwgQTIgPSAoe1xuICB1c2VyczogdCxcbiAgb25TZWxlY3Q6IGUsXG4gIGN1c3RvbVN0eWxlczogciA9IHt9XG59KSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3goYjIsIHtcbiAgc3R5bGU6IHtcbiAgICAuLi5yID09IG51bGwgPyB2b2lkIDAgOiByLmRyb3Bkb3duXG4gIH0sXG4gIGNoaWxkcmVuOiB0Lm1hcCgobikgPT4gLyogQF9fUFVSRV9fICovIFUuanN4cyhfMiwge1xuICAgIHN0eWxlOiB7XG4gICAgICAuLi5yID09IG51bGwgPyB2b2lkIDAgOiByLmxpc3RJdGVtXG4gICAgfSxcbiAgICBvbkNsaWNrOiAoKSA9PiBlKG4pLFxuICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4KEUyLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICAuLi5yID09IG51bGwgPyB2b2lkIDAgOiByLmF2YXRhclxuICAgICAgfSxcbiAgICAgIHNyYzogbi5wZnBfdXJsLFxuICAgICAgYWx0OiBuLnVzZXJuYW1lXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoTTIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIC4uLnIudXNlckluZm9cbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChDMiwge1xuICAgICAgICBjaGlsZHJlbjogbi5kaXNwbGF5X25hbWVcbiAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3hzKFMyLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJAXCIsIG4udXNlcm5hbWVdXG4gICAgICB9KV1cbiAgICB9KV1cbiAgfSwgbi5maWQpKVxufSksIGsyID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiYzlobTIwdFwiXVxufSksIEkyID0gLyogQF9fUFVSRV9fICovIHVlKFwiaW5wdXRcIikoe1xuICBjbGFzc2VzOiBbXCJpODBzZDhoXCJdXG59KTtcbmFzeW5jIGZ1bmN0aW9uIEIyKHtcbiAgcTogdCxcbiAgdmlld2VyRmlkOiBlLFxuICBjbGllbnRfaWQ6IHJcbn0pIHtcbiAgdmFyIG47XG4gIHRyeSB7XG4gICAgbGV0IG8gPSBgJHtnbn0vdjIvZmFyY2FzdGVyL3VzZXIvc2VhcmNoP3E9JHt0fSZsaW1pdD01JHtlID8gYCZ2aWV3ZXJfZmlkPSR7ZX1gIDogXCJcIn0mY2xpZW50X2lkPSR7cn1gO1xuICAgIGNvbnN0IGMgPSBhd2FpdCAoYXdhaXQgeW4obykpLmpzb24oKTtcbiAgICByZXR1cm4gKChuID0gYyA9PSBudWxsID8gdm9pZCAwIDogYy5yZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBuLnVzZXJzKSB8fCBbXTtcbiAgfSBjYXRjaCAobykge1xuICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVycm9yIGZldGNoaW5nIHVzZXJzIGJ5IHF1ZXJ5XCIsIG8pLCBudWxsO1xuICB9XG59XG5jb25zdCBseSA9ICh7XG4gIHZhbHVlOiB0LFxuICBvbkNoYW5nZTogZSxcbiAgc3R5bGU6IHIgPSB7fSxcbiAgcGxhY2Vob2xkZXI6IG4gPSBcIkVudGVyIHVzZXJuYW1lXCIsXG4gIGRpc2FibGVkOiBvID0gITEsXG4gIHZpZXdlckZpZDogaSxcbiAgY3VzdG9tU3R5bGVzOiBjID0ge30sXG4gIGxpbWl0OiBmID0gbnVsbFxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xpZW50X2lkOiB2XG4gIH0gPSBscigpLCBbeCwgYl0gPSBydChcIlwiKSwgW1MsIFRdID0gcnQoITEpLCBbQywgUF0gPSBydChbXSksIEIgPSBSdChudWxsKTtcbiAgbXQoKCkgPT4ge1xuICAgIGNvbnN0IGogPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC5zcGxpdChcIixcIikpIHx8IFtdO1xuICAgIGlmICghaltqLmxlbmd0aCAtIDFdKSB7XG4gICAgICBiKFwiXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBiKGpbai5sZW5ndGggLSAxXS50cmltKCkpO1xuICB9LCBbdF0pLCBtdCgoKSA9PiB7XG4gICAgeCAhPT0gXCJcIiAmJiAhL15cXGQrJC8udGVzdCh4KSA/IFIoeCkgOiBUKCExKTtcbiAgfSwgW3hdKTtcbiAgY29uc3QgUiA9IGFzeW5jIChqKSA9PiB7XG4gICAgY29uc3QgViA9IGF3YWl0IEIyKHtcbiAgICAgIHE6IGosXG4gICAgICB2aWV3ZXJGaWQ6IGksXG4gICAgICBjbGllbnRfaWQ6IHZcbiAgICB9KTtcbiAgICBWICYmIChQKFYpLCBUKCEwKSk7XG4gIH0sIHogPSAoaikgPT4ge1xuICAgIGNvbnN0IFYgPSBqLnRhcmdldC52YWx1ZTtcbiAgICBlKFYpO1xuICB9LCBLID0gKGopID0+IHtcbiAgICBsZXQgViA9IHQuc3BsaXQoXCIsXCIpO1xuICAgIGYgIT09IG51bGwgJiYgVi5sZW5ndGggPj0gZiA/IFZbVi5sZW5ndGggLSAxXSA9IGouZmlkLnRvU3RyaW5nKCkgOiBWLnB1c2goai5maWQudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgZWUgPSBWLmpvaW4oXCIsXCIpO1xuICAgIGUoZWUpLCBiKFwiXCIpLCBUKCExKTtcbiAgfSwgWiA9ICgpID0+IHtcbiAgICB4ICYmIGlzTmFOKE51bWJlcih4KSkgJiYgVCghMCk7XG4gIH0sIFEgPSAoKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBUKCExKSwgMjAwKTtcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoazIsIHtcbiAgICBzdHlsZTogcixcbiAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChJMiwge1xuICAgICAgcmVmOiBCLFxuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB2YWx1ZTogdCxcbiAgICAgIG9uQ2hhbmdlOiB6LFxuICAgICAgb25Gb2N1czogWixcbiAgICAgIG9uQmx1cjogUSxcbiAgICAgIHBsYWNlaG9sZGVyOiBuLFxuICAgICAgZGlzYWJsZWQ6IG9cbiAgICB9KSwgUyAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3goQTIsIHtcbiAgICAgIHVzZXJzOiBDLFxuICAgICAgb25TZWxlY3Q6IEssXG4gICAgICBjdXN0b21TdHlsZXM6IGNcbiAgICB9KV1cbiAgfSk7XG59LCBSMiA9ICh7XG4gIGNvbG9yOiB0ID0gXCIjODU1RENEXCJcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoXCJzdmdcIiwge1xuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB3aWR0aDogXCIyNFwiLFxuICBoZWlnaHQ6IFwiMjRcIixcbiAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHN0cm9rZTogdCxcbiAgXCJzdHJva2Utd2lkdGhcIjogXCIyXCIsXG4gIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gIGNsYXNzTmFtZTogXCJsdWNpZGUgbHVjaWRlLXNlYXJjaFwiLFxuICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChcImNpcmNsZVwiLCB7XG4gICAgY3g6IFwiMTFcIixcbiAgICBjeTogXCIxMVwiLFxuICAgIHI6IFwiOFwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIm0yMSAyMS00LjMtNC4zXCJcbiAgfSldXG59KSwgVDIgPSAoe1xuICBjb2xvcjogdCA9IFwiIzg1NURDRFwiXG59KSA9PiAvKiBAX19QVVJFX18gKi8gVS5qc3goXCJzdmdcIiwge1xuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB3aWR0aDogXCIyNFwiLFxuICBoZWlnaHQ6IFwiMjRcIixcbiAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHN0cm9rZTogdCxcbiAgXCJzdHJva2Utd2lkdGhcIjogXCIyXCIsXG4gIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gIGNsYXNzTmFtZTogXCJsdWNpZGUgbHVjaWRlLWxvYWRlci1jaXJjbGVcIixcbiAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTIxIDEyYTkgOSAwIDEgMS02LjIxOS04LjU2XCJcbiAgfSlcbn0pLCBMMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImlnN2tjdWNcIl1cbn0pLCBPMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImlucHV0XCIpKHtcbiAgY2xhc3NlczogW1wic2g3ejdrNlwiXVxufSksIE4yID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiczE0YWkyMDNcIl1cbn0pLCBqMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImlmMThuZDZcIl1cbn0pLCBVMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInNkODMzbGJcIl1cbn0pLCBGMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInVnbzU4Nm1cIl1cbn0pLCBQMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInVrd3R5MWRcIl1cbn0pLCBEMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInU3N29sbXlcIl1cbn0pLCAkMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInMxeHZreHd3XCJdXG59KSwgejIgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJzMWY2YjFqYVwiXVxufSksIHEyID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1widWRpdWZkOFwiXVxufSksIFoyID0gLyogQF9fUFVSRV9fICovIHVlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiZjFiOGEyaDBcIl1cbn0pLCBWMiA9IC8qIEBfX1BVUkVfXyAqLyB1ZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImwxeXEyNmowXCJdXG59KSwgSDIgPSAvKiBAX19QVVJFX18gKi8gdWUoXCJsaVwiKSh7XG4gIGNsYXNzZXM6IFtcInMxOG1rNDdrXCJdXG59KSwgZnkgPSAoe1xuICB3aWR0aDogdCxcbiAgaGVpZ2h0OiBlLFxuICBzZWxlY3RlZFVzZXJzOiByLFxuICBvblNlbGVjdFVzZXJzOiBuLFxuICAuLi5vXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGllbnRfaWQ6IGlcbiAgfSA9IGxyKCksIHtcbiAgICB1c2VyOiBjLFxuICAgIGlzQXV0aGVudGljYXRlZDogZlxuICB9ID0ga2woKSwgW3YsIHhdID0gcnQoXCJcIiksIFtiLCBTXSA9IHJ0KFtdKSwgW1QsIENdID0gcnQoITEpLCBQID0gUnQobnVsbCk7XG4gIG10KCgpID0+IHtcbiAgICBmdW5jdGlvbiBqKFYpIHtcbiAgICAgIFAuY3VycmVudCAmJiAhUC5jdXJyZW50LmNvbnRhaW5zKFYudGFyZ2V0KSAmJiAoUyhbXSksIHgoXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBqKSwgKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBqKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHogPSBfdCgoKGosIFYpID0+IHtcbiAgICBsZXQgZWU7XG4gICAgcmV0dXJuICguLi5HKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoZWUpLCBlZSA9IHNldFRpbWVvdXQoKCkgPT4gaiguLi5HKSwgVik7XG4gICAgfTtcbiAgfSkoYXN5bmMgKGosIFYpID0+IHtcbiAgICB2YXIgZWU7XG4gICAgaWYgKCFqKSB7XG4gICAgICBTKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQyghMCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IE4gPSBhd2FpdCAoYXdhaXQgeW4oVikpLmpzb24oKTtcbiAgICAgIFMoKChlZSA9IE4gPT0gbnVsbCA/IHZvaWQgMCA6IE4ucmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogZWUudXNlcnMpIHx8IFtdKTtcbiAgICB9IGNhdGNoIChHKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgZGF0YTpcIiwgRyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEMoITEpO1xuICAgIH1cbiAgfSwgNTAwKSwgW10pLCBLID0gKGopID0+IHtcbiAgICBjb25zdCBWID0gYCR7Z259L3YyL2ZhcmNhc3Rlci91c2VyL3NlYXJjaD9xPSR7ai50YXJnZXQudmFsdWV9JmNsaWVudF9pZD0ke2l9JHtmID8gYCZ2aWV3ZXJfZmlkPSR7YyA9PSBudWxsID8gdm9pZCAwIDogYy5maWR9YCA6IFwiXCJ9KWA7XG4gICAgeChqLnRhcmdldC52YWx1ZSksIHooai50YXJnZXQudmFsdWUsIFYpO1xuICB9LCBaID0gKGopID0+IHtcbiAgICByLnNvbWUoKFYpID0+IFYudXNlcm5hbWUgPT09IGoudXNlcm5hbWUpIHx8IChuKFsuLi5yLCBqXSksIHgoXCJcIiksIFMoW10pKTtcbiAgfSwgUSA9IChqKSA9PiB7XG4gICAgbihyLmZpbHRlcigoVikgPT4gVi51c2VybmFtZSAhPT0gaikpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFUuanN4cyhMMiwge1xuICAgIHJlZjogUCxcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IHRcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4cyhqMiwge1xuICAgICAgY2hpbGRyZW46IFtyLm1hcCgoaikgPT4gLyogQF9fUFVSRV9fICovIFUuanN4cyhVMiwge1xuICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChCcywge1xuICAgICAgICAgIHNyYzogai5wZnBfdXJsID8/IExpLFxuICAgICAgICAgIGFsdDogYCR7ai51c2VybmFtZX0gQXZhdGFyYCxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IFwiMjRweFwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjI0cHhcIixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI1MCVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChcInNwYW5cIiwge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiBcIjhweFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogai5kaXNwbGF5X25hbWVcbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChVbCwge1xuICAgICAgICAgIHNpemU6IDIwLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IFEoai51c2VybmFtZSlcbiAgICAgICAgfSldXG4gICAgICB9LCBqLnVzZXJuYW1lKSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoJDIsIHtcbiAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gVS5qc3goejIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIFUuanN4KFIyLCB7XG4gICAgICAgICAgICBjb2xvcjogXCIjODU1RENEXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIFUuanN4KE8yLCB7XG4gICAgICAgICAgLi4ubyxcbiAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICBvbkNoYW5nZTogSyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogXCJUeXBlIHRvIHNlYXJjaCB1c2Vyc1wiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogdCB8fCBcIjEwMCVcIixcbiAgICAgICAgICAgIGhlaWdodDogZSB8fCBcIjQwcHhcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSldXG4gICAgICB9KV1cbiAgICB9KSwgVCA/IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChWMiwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBVLmpzeChUMiwge1xuICAgICAgICBjb2xvcjogXCIjODU1RENEXCJcbiAgICAgIH0pXG4gICAgfSkgOiBiLmxlbmd0aCAhPT0gMCAmJiAvKiBAX19QVVJFX18gKi8gVS5qc3goTjIsIHtcbiAgICAgIGNoaWxkcmVuOiBiLm1hcCgoaikgPT4gLyogQF9fUFVSRV9fICovIFUuanN4cyhIMiwge1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiBaKGopLFxuICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChCcywge1xuICAgICAgICAgIHNyYzogai5wZnBfdXJsID8/IExpLFxuICAgICAgICAgIGFsdDogYCR7ai51c2VybmFtZX0gQXZhdGFyYCxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IFwiNDBweFwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjQwcHhcIixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI1MCVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMoRjIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBVLmpzeChQMiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGouZGlzcGxheV9uYW1lXG4gICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBVLmpzeHMocTIsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIFUuanN4cyhEMiwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogW1wiQFwiLCBqLnVzZXJuYW1lXVxuICAgICAgICAgICAgfSksIGoudmlld2VyX2NvbnRleHQgJiYgKGoudmlld2VyX2NvbnRleHQuZm9sbG93aW5nIHx8IGoudmlld2VyX2NvbnRleHQuZm9sbG93ZWRfYnkpICYmIC8qIEBfX1BVUkVfXyAqLyBVLmpzeChaMiwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogai52aWV3ZXJfY29udGV4dC5mb2xsb3dpbmcgJiYgai52aWV3ZXJfY29udGV4dC5mb2xsb3dlZF9ieSA/IFwiRm9sbG93aW5nIGVhY2ggb3RoZXJcIiA6IGoudmlld2VyX2NvbnRleHQuZm9sbG93aW5nID8gXCJGb2xsb3dpbmdcIiA6IGoudmlld2VyX2NvbnRleHQuZm9sbG93ZWRfYnkgPyBcIkZvbGxvd3MgeW91XCIgOiBudWxsXG4gICAgICAgICAgICB9KV1cbiAgICAgICAgICB9KV1cbiAgICAgICAgfSldXG4gICAgICB9LCBqLnVzZXJuYW1lKSlcbiAgICB9KV1cbiAgfSk7XG59O1xuZXhwb3J0IHtcbiAgUnMgYXMgQ2FzdENhcmQsXG4gIFhwIGFzIE1pbmlBcHBDb250ZXh0LFxuICBzeSBhcyBNaW5pQXBwUHJvdmlkZXIsXG4gIGZtIGFzIE5leW5hckF1dGhCdXR0b24sXG4gIGZ5IGFzIE5leW5hckF1dG9Db21wbGV0ZVVzZXIsXG4gIF9tIGFzIE5leW5hckNhc3RDYXJkLFxuICBveSBhcyBOZXluYXJDb250ZXh0UHJvdmlkZXIsXG4gIGF5IGFzIE5leW5hckNvbnZlcnNhdGlvbkxpc3QsXG4gIHV5IGFzIE5leW5hckZlZWRMaXN0LFxuICBuZyBhcyBOZXluYXJGcmFtZUNhcmQsXG4gIGN5IGFzIE5leW5hclByb2ZpbGVDYXJkLFxuICBseSBhcyBOZXluYXJVc2VyRHJvcGRvd24sXG4gIHdyIGFzIFNJV05fdmFyaWFudCxcbiAgU2wgYXMgVGhlbWUsXG4gIF9hIGFzIHVzZUxvY2FsU3RvcmFnZSxcbiAgUXAgYXMgdXNlTWluaUFwcCxcbiAgbHIgYXMgdXNlTmV5bmFyQ29udGV4dFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@neynar/react/dist/bundle.es.js\n");

/***/ })

};
;